id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:866,Integrability,depend,dependencies,866,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:186,Modifiability,config,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:678,Modifiability,maintainab,maintainability,678,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:431,Security,inject,injecting,431,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:19,Performance,optimiz,optimize,19,// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:106,Energy Efficiency,schedul,scheduling,106,"// Run register allocation and passes that are tightly coupled with it,; // including phi elimination and scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:44,Energy Efficiency,schedul,scheduling,44,// Expand pseudo instructions before second scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,Energy Efficiency,schedul,scheduler,15,// Second pass scheduler.; // Let Target optionally insert this pass by itself at some other; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:61,Availability,mask,mask,61,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:108,Performance,optimiz,optimize,108,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Deployability,Configurat,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Modifiability,Config,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:294,Performance,optimiz,optimized,294,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:459,Performance,optimiz,optimized,459,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:549,Performance,optimiz,optimized,549,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:99,Performance,optimiz,optimization,99,/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:11,Modifiability,rewrite,rewrite,11,// Finally rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:3,Performance,Perform,Perform,3,// Perform stack slot coloring and post-ra machine LICM.; //; // FIXME: Re-enable coloring with register when it's capable of adding; // kill markers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:118,Energy Efficiency,schedul,scheduling,118,/// Add the minimum set of target-independent passes that are required for; /// register allocation. No coalescing or scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:156,Energy Efficiency,schedul,scheduling,156,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:78,Performance,optimiz,optimized,78,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,Energy Efficiency,schedul,scheduler,15,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:121,Safety,avoid,avoid,121,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Integrability,depend,depending,47,// Allow targets to expand pseudo instructions depending on the choice of; // registers before MachineCopyPropagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:104,Deployability,Configurat,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:104,Modifiability,Config,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:220,Performance,optimiz,optimize,220,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:94,Performance,perform,performance,94,// Tail duplication.; // Note that duplicating tail just increases code size and degrades; // performance for targets that require Structured Control Flow.; // In addition it can also make CFG irreducible. Thus we disable it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,Availability,redundant,redundant,14,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:54,Performance,load,loads,54,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,Safety,redund,redundant,14,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:44,Integrability,Interface,Interface,44,"//===-- CommandFlags.h - Command Line Flags Interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains codegen-specific flags that are shared between different; // command line tools. The tools ""llc"" and ""opt"" both use this file to prevent; // flag duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:275,Integrability,depend,dependant,275,"/// Common utility function tightly tied to the options listed here. Initializes; /// a TargetOptions object with CodeGen flags and returns it.; /// \p TheTriple is used to determine the default value for options if; /// options are not explicitly specified. If those triple dependant options; /// value do not have effect for your component, a default Triple() could be; /// passed in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:26,Modifiability,variab,variable,26,/// Should value-tracking variable locations / instruction referencing be; /// enabled by default for this triple?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:412,Usability,simpl,simple,412,"//===-- CostTable.h - Instruction Cost Table handling -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Cost tables and simple lookup functions; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:46,Availability,failure,failures,46,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:3,Integrability,Wrap,Wrapper,3,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:46,Availability,failure,failures,46,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:3,Integrability,Wrap,Wrapper,3,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:37,Integrability,interface,interface,37,"//===- CSEConfigBase.h - A CSEConfig interface ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:27,Deployability,configurat,configuration,27,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:149,Integrability,depend,depend,149,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:213,Integrability,interface,interface,213,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:27,Modifiability,config,configuration,27,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:18,Modifiability,variab,variable,18,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:78,Modifiability,variab,variable,78,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:106,Modifiability,variab,variables,106,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:90,Security,access,accessible,90,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:28,Modifiability,variab,variable,28,"/// Specifies a change in a variable's debug value history.; ///; /// There exist two types of entries:; ///; /// * Debug value entry:; ///; /// A new debug value becomes live. If the entry's \p EndIndex is \p NoEntry,; /// the value is valid until the end of the function. For other values, the; /// index points to the entry in the entry vector that ends this debug; /// value. The ending entry can either be an overlapping debug value, or; /// an instruction that clobbers the value.; ///; /// * Clobbering entry:; ///; /// This entry's instruction clobbers one or more preceding; /// register-described debug values that have their end index; /// set to this entry's position in the entry vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:4,Testability,Test,Test,4,"/// Test whether a vector of entries features any non-empty locations. It; /// could have no entries, or only DBG_VALUE $noreg entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:59,Modifiability,variab,variable,59,/// Drop location ranges which exist entirely outside each variable's scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:39,Modifiability,variab,variable,39,/// Represents the location at which a variable is stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:23,Performance,load,loads,23,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:42,Performance,load,load,42,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:91,Performance,load,load,91,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:48,Modifiability,variab,variable,48,/// Present if the location is part of a larger variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:14,Modifiability,Variab,VariableLocation,14,"/// Extract a VariableLocation from a MachineInstr.; /// This will only work if Instruction is a debug value instruction; /// and the associated DIExpression is in one of the supported forms.; /// If these requirements are not met, the returned Optional will not; /// have a value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:124,Availability,alive,alive,124,/// Base class for debug information backends. Common functionality related to; /// tracking which variables and scopes are alive at a given PC live here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:99,Modifiability,variab,variables,99,/// Base class for debug information backends. Common functionality related to; /// tracking which variables and scopes are alive at a given PC live here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:69,Modifiability,variab,variable,69,/// History of DBG_VALUE and clobber instructions for each user; /// variable. Variables are listed in order of appearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:79,Modifiability,Variab,Variables,79,/// History of DBG_VALUE and clobber instructions for each user; /// variable. Variables are listed in order of appearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:129,Security,access,accessors,129,"/// Maps instruction with label emitted before instruction.; /// FIXME: Make this private from DwarfDebug, we have the necessary accessors; /// for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:7,Safety,Detect,DetectDeadLanes,7,"//===- DetectDeadLanes.h - SubRegister Lane Usage Analysis --*- C++ -*-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:610,Safety,detect,detect,610,"//===- DetectDeadLanes.h - SubRegister Lane Usage Analysis --*- C++ -*-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:4,Deployability,Update,Update,4,/// Update the \p DefinedLanes and the \p UsedLanes for all virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:45,Availability,mask,mask,45,"/// Given a use regiser operand \p Use and a mask of defined lanes, check; /// if the operand belongs to a lowersToCopies() instruction, transfer the; /// mask to the def and put the instruction into the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:155,Availability,mask,mask,155,"/// Given a use regiser operand \p Use and a mask of defined lanes, check; /// if the operand belongs to a lowersToCopies() instruction, transfer the; /// mask to the def and put the instruction into the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,Availability,mask,mask,12,"/// Given a mask \p DefinedLanes of lanes defined at operand \p OpNum; /// of COPY-like instruction, determine which lanes are defined at the output; /// operand \p Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,Availability,mask,mask,12,/// Given a mask \p UsedLanes used from the output of instruction \p MI; /// determine which lanes are used from operand \p MO of this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:679,Energy Efficiency,Schedul,Schedule,679,"//===- llvm/CodeGen/DFAPacketizer.h - DFA Packetizer for VLIW ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:937,Energy Efficiency,consumption,consumption,937,"//===- llvm/CodeGen/DFAPacketizer.h - DFA Packetizer for VLIW ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:22,Energy Efficiency,Schedul,ScheduleDAGInstrs,22,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:58,Energy Efficiency,schedul,schedule,58,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:91,Integrability,depend,dependence,91,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:14,Modifiability,extend,extends,14,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:10,Energy Efficiency,schedul,scheduling,10,// Actual scheduling work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:86,Safety,redund,redundancy,86,"/// For every itinerary, an ""action"" to apply to the automaton. This removes; /// the redundancy in actions between itinerary classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:49,Availability,avail,available,49,// Reset the current state to make all resources available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:56,Availability,avail,available,56,// Check if the resources occupied by a MCInstrDesc are available in; // the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:64,Availability,avail,available,64,// Check if the resources occupied by a machine instruction are available; // in the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:217,Availability,avail,available,217,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:279,Integrability,depend,depends,279,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:339,Integrability,depend,dependency,339,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:445,Integrability,depend,dependency,445,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:509,Integrability,depend,dependence,509,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:35,Usability,simpl,simple,35,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:12,Energy Efficiency,Schedul,Scheduler,12,// The VLIW Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:139,Performance,perform,perform,139,// End the current packet and reset the state of the packetizer.; // Overriding this function allows the target-specific packetizer; // to perform custom finalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:121,Integrability,depend,dependent,121,// Perform initialization before packetizing an instruction. This; // function is supposed to be overrided by the target dependent packetizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:3,Performance,Perform,Perform,3,// Perform initialization before packetizing an instruction. This; // function is supposed to be overrided by the target dependent packetizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:33,Integrability,depend,dependece,33,// Check if it is legal to prune dependece between SUI and SUJ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:86,Usability,simpl,simple,86,//===--------------------------------------------------------------------===//; /// A simple label difference DIE.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:70,Availability,down,down,70,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:60,Performance,optimiz,optimized,60,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:134,Testability,assert,assert,134,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:67,Availability,down,down,67,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:57,Performance,optimiz,optimized,57,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:77,Usability,simpl,simple,77,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:607,Energy Efficiency,allocate,allocated,607,"/// A list of DIE values.; ///; /// This is a singly-linked list, but instead of reversing the order of; /// insertion, we keep a pointer to the back of the list so we can push in; /// order.; ///; /// There are two main reasons to choose a linked list over a customized; /// vector-like data structure.; ///; /// 1. For teardown efficiency, we want DIEs to be BumpPtrAllocated. Using a; /// linked list here makes this way easier to accomplish.; /// 2. Carrying an extra pointer per \a DIEValue isn't expensive. 45% of DIEs; /// have 2 or fewer values, and 90% have 5 or fewer. A vector would be; /// over-allocated by 50% on average anyway, the same cost as the; /// linked-list node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:130,Testability,test,testing,130,/// Set to true to force a DIE to emit an abbreviation that says it has; /// children even when it doesn't. This is used for unit testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:44,Modifiability,variab,variable,44,"/// The compile unit or type unit DIE. This variable must be an instance of; /// DIE so that we can calculate the DIEUnit from any DIE by traversing the; /// parent backchain and getting the Unit DIE, and then casting itself to a; /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without; /// having to store a pointer to the DIEUnit in each DIE instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:97,Integrability,depend,depending,97,/// The section this unit will be emitted in. This may or may not be set to; /// a valid section depending on the client that is emitting DWARF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:182,Modifiability,variab,variable,182,/// Set the section that this DIEUnit will be emitted into.; ///; /// This function is used by some clients to set the section. Not all clients; /// that emit DWARF use this section variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h:437,Energy Efficiency,adapt,adapted,437,"//===------------------- llvm/CodeGen/DwarfEHPrepare.h ----------*- C++-*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h:437,Modifiability,adapt,adapted,437,"//===------------------- llvm/CodeGen/DwarfEHPrepare.h ----------*- C++-*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:480,Availability,avail,available,480,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:802,Deployability,pipeline,pipelines,802,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:763,Modifiability,config,configured,763,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:639,Performance,latency,latency,639,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:782,Availability,avail,available,782,"/// A DomainValue is a bit like LiveIntervals' ValNo, but it also keeps track; /// of execution domains.; ///; /// An open DomainValue represents a set of instructions that can still switch; /// execution domain. Multiple registers may refer to the same open; /// DomainValue - they will eventually be collapsed to the same execution; /// domain.; ///; /// A collapsed DomainValue represents a single register that has been forced; /// into one of more execution domains. There is a separate collapsed; /// DomainValue for each register, but it may contain multiple execution; /// domains. A register value is initially created in a single execution; /// domain, but if we were forced to pay the penalty of a domain crossing, we; /// keep track of the fact that the register is now available in multiple; /// domains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:15,Availability,avail,available,15,"/// Bitmask of available domains. For an open DomainValue, it is the still; /// possible domains for collapsing. For a collapsed DomainValue it is the; /// domains where the register is available for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:186,Availability,avail,available,186,"/// Bitmask of available domains. For an open DomainValue, it is the still; /// possible domains for collapsing. For a collapsed DomainValue it is the; /// domains where the register is available for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:168,Deployability,update,updated,168,"/// Pointer to the next DomainValue in a chain. When two DomainValues are; /// merged, Victim.Next is set to point to Victor, so old DomainValue; /// references can be updated by following the chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:135,Availability,avail,available,135,/// A collapsed DomainValue has no instructions to twiddle - it simply keeps; /// track of the domains where the registers are already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:64,Usability,simpl,simply,64,/// A collapsed DomainValue has no instructions to twiddle - it simply keeps; /// track of the domains where the registers are already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:14,Availability,avail,available,14,/// Is domain available?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:19,Availability,avail,available,19,/// Mark domain as available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:31,Availability,avail,available,31,// Restrict to a single domain available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:39,Availability,avail,available,39,/// Return bitmask of domains that are available and in mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:56,Availability,mask,mask,56,/// Return bitmask of domains that are available and in mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:17,Availability,avail,available,17,/// First domain available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Usability,Clear,Clear,4,/// Clear this DomainValue and point to next which has all its data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Release,Release,4,"/// Release a reference to DV. When the last reference is released,; /// collapse if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:58,Deployability,release,released,58,"/// Release a reference to DV. When the last reference is released,; /// collapse if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:84,Deployability,Update,Update,84,/// Follow the chain of dead DomainValues until a live DomainValue is reached.; /// Update the referenced pointer when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:65,Deployability,release,released,65,"/// All instructions and registers in B are moved to A, and B is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Update,Update,4,/// Update live-out values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Update,Update,4,"/// Update def-ages for registers defined by MI.; /// If Kill is set, also kill off DomainValues clobbered by the defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:72,Availability,mask,mask,72,/// A soft instruction can be changed to work in other domains given by mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h:45,Performance,load,load,45,"//===--- ExpandMemCmp.h - Expand memcmp() to load/stores --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:78,Performance,perform,perform,78,// IsTailCall Should be modified by implementations of FastLowerCall; // that perform tail call conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:195,Safety,avoid,avoid,195,"/// The position of the last instruction for materializing constants; /// for use in the current block. It resets to EmitStartPt when it makes sense; /// (for example, it's usually profitable to avoid function calls between the; /// definition and the use)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:90,Modifiability,variab,variables,90,"/// The top most instruction in the current block that is allowed for; /// emitting local variables. LastLocalValue resets to EmitStartPt when it; /// makes sense (for example, on function calls)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Deployability,Update,Update,4,/// Update the position of the last instruction emitted for; /// materializing constants for use in the current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:53,Performance,cache,cached,53,/// Look up the value to see if its value is already cached in a; /// register. It may be defined by instructions across blocks or defined; /// locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getRegForValue that also takes care of; /// truncating or sign-extending the given getelementptr index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:92,Modifiability,extend,extending,92,/// This is a wrapper around getRegForValue that also takes care of; /// truncating or sign-extending the given getelementptr index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:229,Performance,load,load,229,"/// We're checking to see if we can fold \p LI into \p FoldInst. Note; /// that we could have a sequence where multiple LLVM IR instructions are; /// folded into the same machineinstr. For example we could have:; ///; /// A: x = load i32 *P; /// B: y = icmp A, 42; /// C: br y, ...; ///; /// In this scenario, \p LI is ""A"", and \p FoldInst is ""C"". We know about ""B""; /// (and any other folded instructions) because it is between A and C.; ///; /// If we succeed folding, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:105,Performance,load,load,105,"/// The specified machine instr operand is a vreg, and that vreg is; /// being provided by the specified load instruction. If possible, try to; /// fold the load as an operand to the instruction, returning true if; /// possible.; ///; /// This method should be implemented by targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:157,Performance,load,load,157,"/// The specified machine instr operand is a vreg, and that vreg is; /// being provided by the specified load instruction. If possible, try to; /// fold the load as an operand to the instruction, returning true if; /// possible.; ///; /// This method should be implemented by targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:21,Integrability,wrap,wrapper,21,"/// This method is a wrapper of fastEmit_ri.; ///; /// It first tries to emit an instruction with an immediate operand using; /// fastEmit_ri. If that fails, it materializes the immediate into a register; /// and try fastEmit_rr instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:115,Deployability,update,update,115,"/// Emit an unconditional branch to the given block, unless it is the; /// immediate (fall-through) successor, and update the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Deployability,Update,Update,4,"/// Update the value map to include the new mapping for this; /// instruction, or insert an extra copy to get the result in a previous; /// determined register.; ///; /// NOTE: This is only necessary because we might select a block that uses a; /// value before we select the block that defines the value. It might be; /// possible to fix this by selecting blocks in reverse postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:38,Usability,usab,usable,38,"/// Try to constrain Op so that it is usable by argument OpNum of the; /// provided MCInstrDesc. If this fails, create a new virtual register in the; /// correct class and COPY the value there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:90,Performance,load,loads,90,"/// Emit a constant in a register using target-specific logic, such as; /// constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:56,Testability,log,logic,56,"/// Emit a constant in a register using target-specific logic, such as; /// constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:63,Testability,log,logic,63,/// Emit an alloca address in a register using target-specific logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:84,Testability,log,logic,84,/// Emit the floating-point constant +0.0 in a register using target-; /// specific logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:42,Safety,safe,safely,42,"/// Check if \c Add is an add that can be safely folded into \c GEP.; ///; /// \c Add can be folded into \c GEP if:; /// - \c Add is an add,; /// - \c Add's size matches \c GEP's,; /// - \c Add is in the same basic block as \c GEP, and; /// - \c Add has a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:88,Availability,avail,available,88,/// Helper for getRegForVale. This function is called when the value; /// isn't already available in a register and must be materialized with new; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:62,Modifiability,variab,variables,62,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:142,Modifiability,variab,variables,142,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:135,Performance,cache,cached,135,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:120,Safety,avoid,avoid,120,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Usability,Clear,Clears,4,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:22,Deployability,patch,patchpoint,22,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:95,Deployability,patch,patchpoint,95,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:55,Modifiability,variab,variable,55,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:7,Availability,Fault,FaultMaps,7,"//===- FaultMaps.h - The ""FaultMaps"" section --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:26,Availability,Fault,FaultMaps,26,"//===- FaultMaps.h - The ""FaultMaps"" section --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:92,Testability,test,testing,92,// We'd like to keep a stable iteration order for FunctionInfos to help; // FileCheck based testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:399,Integrability,rout,routines,399,"//===- FunctionLoweringInfo.h - Lower functions from LLVM IR ---*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements routines for translating functions from LLVM IR into; // Machine IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:79,Energy Efficiency,allocate,allocated,79,"/// DemoteRegister - if CanLowerReturn is false, DemoteRegister is a vreg; /// allocated to hold a pointer to the hidden sret parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:129,Energy Efficiency,efficient,efficiently,129,/// StaticAllocaMap - Keep track of frame indices for fixed sized allocas in; /// the entry block. This allows the allocas to be efficiently referenced; /// anywhere in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:124,Energy Efficiency,schedul,scheduling,124,/// ArgDbgValues - A list of DBG_VALUE instructions created during isel for; /// function arguments that are inserted after scheduling is completed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:25,Modifiability,extend,extend,25,/// Record the preferred extend type (ISD::SIGN_EXTEND or ISD::ZERO_EXTEND); /// for a value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:82,Deployability,update,updated,82,"/// PHINodesToUpdate - A list of phi instructions whose operand list will; /// be updated after processing the current basic block.; /// TODO: This isn't per-function state, it's per-basic-block state. But; /// there's no other convenient place for it to live right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:4,Usability,clear,clear,4,"/// clear - Clear out all the function-specific state. This returns this; /// FunctionLoweringInfo to an empty state, ready to be used for a; /// different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:12,Usability,Clear,Clear,12,"/// clear - Clear out all the function-specific state. This returns this; /// FunctionLoweringInfo to an empty state, ready to be used for a; /// different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:223,Modifiability,extend,extended,223,"/// GetLiveOutRegInfo - Gets LiveOutInfo for a register, returning NULL if the; /// register is a PHI destination and the PHI's LiveOutInfo is not valid. If; /// the register's LiveOutInfo is for a smaller bit width, it is extended to; /// the larger bit width by zero extension. The bit width must be no smaller; /// than the LiveOutInfo's existing bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:8,Deployability,install,install,8,// Only install this information if it tells us something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:567,Integrability,interface,interface,567,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1062,Performance,perform,performed,1062,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:793,Safety,Safe,Safe,793,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1015,Safety,safe,safe,1015,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:691,Testability,log,logs,691,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1151,Usability,simpl,simply,1151,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:39,Safety,safe,safe,39,/// GCPoint - Metadata for a collector-safe point in machine code.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:137,Safety,Safe,SafePoints,137,"// FIXME: Liveness. A 2D BitVector, perhaps?; //; // BitVector Liveness;; //; // bool islive(int point, int root) =; // Liveness[point * SafePoints.size() + root]; //; // The bit vector is the more compact representation where >3.2% of roots; // are live per safe point (1.5% on 64-bit hosts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:259,Safety,safe,safe,259,"// FIXME: Liveness. A 2D BitVector, perhaps?; //; // BitVector Liveness;; //; // bool islive(int point, int root) =; // Liveness[point * SafePoints.size() + root]; //; // The bit vector is the more compact representation where >3.2% of roots; // are live per safe point (1.5% on 64-bit hosts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:44,Safety,safe,safe,44,/// addSafePoint - Notes the existence of a safe point. Num is the ID of the; /// label just prior to the safe point (if the code generator is using; /// MachineModuleInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:106,Safety,safe,safe,106,/// addSafePoint - Notes the existence of a safe point. Num is the ID of the; /// label just prior to the safe point (if the code generator is using; /// MachineModuleInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:30,Safety,safe,safe,30,/// begin/end - Iterators for safe points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:62,Safety,safe,safe,62,/// live_begin/live_end - Iterators for live roots at a given safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the entire Module.; /// Records a cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:86,Performance,cache,cache,86,/// An analysis pass which caches information about the entire Module.; /// Records a cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:142,Integrability,depend,depends,142,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:32,Modifiability,rewrite,rewrites,32,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:126,Performance,load,loads,126,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:187,Performance,perform,performs,187,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:119,Usability,simpl,simple,119,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the entire Module.; /// Records both the function level information used by GCRoots and a; /// cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:147,Performance,cache,cache,147,/// An analysis pass which caches information about the entire Module.; /// Records both the function level information used by GCRoots and a; /// cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:4,Usability,clear,clear,4,"/// clear - Resets the pass. Any pass, which uses GCModuleInfo, should; /// call it in doFinalization().; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:792,Modifiability,plugin,plugins,792,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:571,Safety,avoid,avoid,571,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:782,Testability,log,logically,782,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:44,Integrability,depend,depending,44,"// FIXME: Infer the maximum possible offset depending on the actual users; // (these max offsets are different for the users inside Thumb or ARM; // functions), see the code that passes in the offset in the ARM backend; // for more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:35,Modifiability,variab,variables,35,/// Whether we should merge global variables that have external linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:29,Performance,optimiz,optimize,29,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:89,Usability,simpl,simple,89,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:196,Usability,learn,learn,196,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:434,Integrability,inject,inject,434,"//===---- IndirectThunks.h - Indirect Thunk Base Class ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Contains a base class for Passes that inject an MI thunk.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:434,Security,inject,inject,434,"//===---- IndirectThunks.h - Indirect Thunk Base Class ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Contains a base class for Passes that inject an MI thunk.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:5,Modifiability,variab,variable,5,"// A variable used to track whether (and possible which) thunks have been; // inserted so far. InsertedThunksTy is usually a bool, but can be other types; // to represent more than one type of thunk. Requires an |= operator to; // accumulate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:182,Testability,assert,asserts,182,// A MachineBasicBlock must not be created for the Entry block; code; // generation from an empty naked function in C source code also does not; // generate one. At least GlobalISel asserts if this invariant isn't; // respected.; // Set MF properties. We never use vregs...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:181,Safety,detect,detect,181,"// Only add a thunk if one of the functions has the corresponding feature; // enabled in its subtarget, and doesn't enable external thunks. The target; // can use InsertedThunks to detect whether relevant thunks have already; // been inserted.; // FIXME: Conditionalize on indirect calls so we don't emit a thunk when; // nothing will end up calling it.; // FIXME: It's a little silly to look at every function just to enumerate; // the subtargets, but eventually we'll want to look at them for indirect; // calls, so maybe this is OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h:516,Security,access,access,516,"//===---- llvm/CodeGen/InterleavedAccess.h ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the InterleavedAccessPass class,; /// its corresponding pass name is `interleaved-access`.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:423,Integrability,interface,interface,423,"//===-- IntrinsicLowering.h - Intrinsic Function Lowering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the IntrinsicLowering interface. This interface allows; // addition of domain-specific or front-end specific intrinsics to LLVM without; // having to modify all of the C backend or interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:439,Integrability,interface,interface,439,"//===-- IntrinsicLowering.h - Intrinsic Function Lowering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the IntrinsicLowering interface. This interface allows; // addition of domain-specific or front-end specific intrinsics to LLVM without; // having to modify all of the C backend or interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:182,Integrability,message,message,182,"/// Replace a call to the specified intrinsic function.; /// If an intrinsic function must be implemented by the code generator; /// (such as va_start), this function should print a message and abort.; ///; /// Otherwise, if an intrinsic function call can be lowered, the code to; /// implement it (often a call to a non-intrinsic function) is inserted; /// _after_ the call instruction and the call is deleted. The caller must; /// be capable of handling this kind of change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:194,Safety,abort,abort,194,"/// Replace a call to the specified intrinsic function.; /// If an intrinsic function must be implemented by the code generator; /// (such as va_start), this function should print a message and abort.; ///; /// Otherwise, if an intrinsic function call can be lowered, the code to; /// implement it (often a call to a non-intrinsic function) is inserted; /// _after_ the call instruction and the call is deleted. The caller must; /// be capable of handling this kind of change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:111,Usability,simpl,simple,111,/// Try to replace a call instruction with a call to a bswap intrinsic. Return; /// false if the call is not a simple integer bswap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:222,Integrability,depend,dependent,222,"//===--------------------------------------------------------------------===//; /// ISD::NodeType enum - This enum defines the target-independent operators; /// for a SelectionDAG.; ///; /// Targets may also define target-dependent operator codes for SDNodes. For; /// example, on x86, these are the enum values in the X86ISD namespace.; /// Targets should aim to use target-independent operators to model their; /// instruction sets as much as possible, and only use target-dependent; /// operators when they have special requirements.; ///; /// Finally, during and after selection proper, SNodes may use special; /// operator codes that correspond directly with MachineInstr opcodes. These; /// are used to represent selected instructions. See the isMachineOpcode(); /// and getMachineOpcode() member functions of SDNode.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:475,Integrability,depend,dependent,475,"//===--------------------------------------------------------------------===//; /// ISD::NodeType enum - This enum defines the target-independent operators; /// for a SelectionDAG.; ///; /// Targets may also define target-dependent operator codes for SDNodes. For; /// example, on x86, these are the enum values in the X86ISD namespace.; /// Targets should aim to use target-independent operators to model their; /// instruction sets as much as possible, and only use target-dependent; /// operators when they have special requirements.; ///; /// Finally, during and after selection proper, SNodes may use special; /// operator codes that correspond directly with MachineInstr opcodes. These; /// are used to represent selected instructions. See the isMachineOpcode(); /// and getMachineOpcode() member functions of SDNode.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:71,Availability,error,errors,71,/// DELETED_NODE - This is an illegal value that is used to catch; /// errors. This opcode is not a legal opcode for any node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:119,Modifiability,extend,extended,119,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:235,Modifiability,extend,extended,235,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Testability,Assert,AssertSext,4,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:16,Testability,Assert,AssertZext,16,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:415,Testability,assert,assertion,415,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Testability,Assert,AssertAlign,4,/// AssertAlign - These nodes record if a register contains a value that; /// has a known alignment and the trailing bits are known to be zero.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:234,Testability,assert,assertion,234,/// AssertAlign - These nodes record if a register contains a value that; /// has a known alignment and the trailing bits are known to be zero.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:131,Modifiability,variab,variables,131,"/// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on; /// the DAG, which implements the named register global variables extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:80,Usability,simpl,simplification,80,"/// TargetConstant* - Like Constant*, but the DAG does not do any folding,; /// simplification, or lowering of the constant. They are used for constants; /// which are known to fit in the immediate fields of their users, or for; /// carrying magic numbers which are not values which need to be; /// materialized in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:78,Integrability,depend,dependent,78,"/// TargetIndex - Like a constant pool entry, but with completely; /// target-dependent semantics. Holds target flags, a 32-bit index, and a; /// 64-bit index. Targets can use this however they like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:178,Availability,avail,available,178,/// CopyFromReg - This node indicates that the input value is a virtual or; /// physical register that is defined outside of the scope of this; /// SelectionDAG. The register is available from the RegisterSDNode object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Usability,Simpl,Simple,4,/// Simple integer binary arithmetic operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:541,Testability,log,logic,541,"/// Carry-using nodes for multiple precision addition and subtraction.; /// These nodes take three operands: The first two are the normal lhs and; /// rhs to the add or sub, and the third is a boolean value that is 1 if and; /// only if there is an incoming carry/borrow. These nodes produce two; /// results: the normal result of the add or sub, and a boolean value that is; /// 1 if and only if there is an outgoing carry/borrow.; ///; /// Care must be taken if these opcodes are lowered to hardware instructions; /// that use the inverse logic -- 0 if and only if there is an; /// incoming/outgoing carry/borrow. In such cases, you must preserve the; /// semantics of these opcodes by inverting the incoming carry/borrow, feeding; /// it to the add/sub hardware instruction, and then inverting the outgoing; /// carry/borrow.; ///; /// The use of these opcodes is preferable to adde/sube if the target supports; /// it, as the carry is a regular value rather than a glue, which allows; /// further optimisation.; ///; /// These opcodes are different from [US]{ADD,SUB}O in that; /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas; /// [US]{ADD,SUB}O produce an overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2; /// integers with the same bit width (W). If the true value of LHS + RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2; /// integers with the same bit width (W). If the true value of LHS - RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first; /// operand is the value to be shifted, and the second argument is the amount; /// to shift by. Both must be integers of the same bit width (W). If the true; /// value of LHS << RHS exceeds the largest value that can be represented by; /// W bits, the resulting value is this maximum value, Otherwise, if this; /// value is less than the smallest value that can be represented by W bits,; /// the resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Performance,Perform,Perform,43,"/// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication; /// on 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer. A scale of zero is effectively performing; /// multiplication on 2 integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:286,Performance,perform,performing,286,"/// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication; /// on 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer. A scale of zero is effectively performing; /// multiplication on 2 integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Performance,Perform,Perform,43,"/// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on; /// 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Usability,Simpl,Simple,4,/// Simple binary floating point operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:168,Performance,optimiz,optimizations,168,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:210,Performance,optimiz,optimized,210,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:99,Usability,simpl,simple,99,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:244,Performance,optimiz,optimizations,244,/// Constrained versions of libm-equivalent floating point intrinsics.; /// These will be lowered to the equivalent non-constrained pseudo-op; /// (or expanded to the equivalent library call) before final selection.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:281,Performance,optimiz,optimized,281,/// Constrained versions of libm-equivalent floating point intrinsics.; /// These will be lowered to the equivalent non-constrained pseudo-op; /// (or expanded to the equivalent library call) before final selection.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,Performance,optimiz,optimizations,187,/// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or; /// unsigned integer. These have the same semantics as fptosi and fptoui; /// in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:224,Performance,optimiz,optimized,224,/// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or; /// unsigned integer. These have the same semantics as fptosi and fptoui; /// in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,Performance,optimiz,optimizations,187,/// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to; /// a floating point value. These have the same semantics as sitofp and; /// uitofp in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:224,Performance,optimiz,optimized,224,/// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to; /// a floating point value. These have the same semantics as sitofp and; /// uitofp in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:88,Availability,down,down,88,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:731,Performance,optimiz,optimizations,731,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:768,Performance,optimiz,optimized,768,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:609,Safety,safe,safe,609,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:30,Modifiability,Extend,Extend,30,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,Performance,optimiz,optimizations,108,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:145,Performance,optimiz,optimized,145,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:124,Performance,perform,performs,124,"/// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used; /// for floating-point operands only. STRICT_FSETCC performs a quiet; /// comparison operation, while STRICT_FSETCCS performs a signaling; /// comparison operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:189,Performance,perform,performs,189,"/// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used; /// for floating-point operands only. STRICT_FSETCC performs a quiet; /// comparison operation, while STRICT_FSETCCS performs a signaling; /// comparison operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:10,Performance,Perform,Perform,10,/// FMA - Perform a * b + c with no intermediate rounding step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:11,Performance,Perform,Perform,11,"/// FMAD - Perform a * b + c, while getting the same result as the; /// separately rounded operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,Perform,Performs,4,"/// Performs a check of floating point class property, defined by IEEE-754.; /// The first operand is the floating point value to check. The second operand; /// specifies the checked property and is a TargetConstant which specifies; /// test in the same way as intrinsic 'is_fpclass'.; /// Returns boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:237,Testability,test,test,237,"/// Performs a check of floating point class property, defined by IEEE-754.; /// The first operand is the floating point value to check. The second operand; /// specifies the checked property and is a TargetConstant which specifies; /// test in the same way as intrinsic 'is_fpclass'.; /// Returns boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:109,Modifiability,variab,variable,109,"/// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector; /// with the specified, possibly variable, elements. The types of the; /// operands must match the vector element type, except that integer types; /// are allowed to be larger than the element type, in which case the; /// operands are implicitly truncated. The types of the operands must all; /// be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:235,Performance,scalab,scalable,235,"/// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element; /// at IDX replaced with VAL. If the type of VAL is larger than the vector; /// element type then VAL is truncated before replacement.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:111,Modifiability,variab,variable,111,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:247,Modifiability,extend,extended,247,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:362,Performance,scalab,scalable,362,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:382,Performance,scalab,scalable,382,"/// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of; /// vector type with the same length and element type, this produces a; /// concatenated vector result value, with length equal to the sum of the; /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then; /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0; /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:433,Performance,scalab,scalable,433,"/// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of; /// vector type with the same length and element type, this produces a; /// concatenated vector result value, with length equal to the sum of the; /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then; /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0; /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:310,Performance,scalab,scalable,310,"/// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2; /// inserted into VECTOR1. IDX represents the starting element number at which; /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known; /// minimum vector length. Let the type of VECTOR2 be T, then if T is a; /// scalable vector, IDX is first scaled by the runtime scaling factor of T.; /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.; /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1; /// indices. If this condition cannot be determined statically but is false at; /// runtime, then the result vector is undefined. The IDX parameter must be a; /// vector index constant type, which for most targets will be an integer; /// pointer type.; ///; /// This operation supports inserting a fixed-width vector into a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:859,Performance,scalab,scalable,859,"/// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2; /// inserted into VECTOR1. IDX represents the starting element number at which; /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known; /// minimum vector length. Let the type of VECTOR2 be T, then if T is a; /// scalable vector, IDX is first scaled by the runtime scaling factor of T.; /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.; /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1; /// indices. If this condition cannot be determined statically but is false at; /// runtime, then the result vector is undefined. The IDX parameter must be a; /// vector index constant type, which for most targets will be an integer; /// pointer type.; ///; /// This operation supports inserting a fixed-width vector into a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:284,Performance,scalab,scalable,284,"/// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.; /// Let the result type be T, then IDX represents the starting element number; /// from which a subvector of type T is extracted. IDX must be a constant; /// multiple of T's known minimum vector length. If T is a scalable vector,; /// IDX is first scaled by the runtime scaling factor of T. Elements IDX; /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this; /// condition cannot be determined statically but is false at runtime, then; /// the result vector is undefined. The IDX parameter must be a vector index; /// constant type, which for most targets will be an integer pointer type.; ///; /// This operation supports extracting a fixed-width vector from a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:758,Performance,scalab,scalable,758,"/// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.; /// Let the result type be T, then IDX represents the starting element number; /// from which a subvector of type T is extracted. IDX must be a constant; /// multiple of T's known minimum vector length. If T is a scalable vector,; /// IDX is first scaled by the runtime scaling factor of T. Elements IDX; /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this; /// condition cannot be determined statically but is false at runtime, then; /// the result vector is undefined. The IDX parameter must be a vector index; /// constant type, which for most targets will be an integer pointer type.; ///; /// This operation supports extracting a fixed-width vector from a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:256,Security,access,accessible,256,"/// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as; /// VEC1/VEC2. A VECTOR_SHUFFLE node also contains an array of constant int; /// values that indicate which value (or undef) each result element will; /// get. These constant ints are accessible through the; /// ShuffleVectorSDNode class. This is quite similar to the Altivec; /// 'vperm' instruction, except that the indices must be constants and are; /// in terms of the element size of VEC1/VEC2, not in terms of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:61,Performance,load,loading,61,"/// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a; /// scalar value into element 0 of the resultant vector type. The top; /// elements 1 to N-1 of the N-element vector are undefined. The type; /// of the operand must match the vector element type, except when they; /// are integer types. In this case the operand is allowed to be wider; /// than the vector element type, and is implicitly truncated to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:33,Performance,scalab,scalable,33,"/// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised; /// of a linear sequence of unsigned values starting from 0 with a step of; /// IMM, where IMM must be a TargetConstant with type equal to the vector; /// element type. The arithmetic is performed modulo the bitwidth of the; /// element.; ///; /// The operation does not support returning fixed-width vectors or; /// non-constant operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:263,Performance,perform,performed,263,"/// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised; /// of a linear sequence of unsigned values starting from 0 with a step of; /// IMM, where IMM must be a TargetConstant with type equal to the vector; /// element type. The arithmetic is performed modulo the bitwidth of the; /// element.; ///; /// The operation does not support returning fixed-width vectors or; /// non-constant operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:24,Testability,log,logical,24,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:37,Testability,log,logical,37,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:49,Testability,log,logical,49,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:186,Performance,perform,performed,186,"/// ABS - Determine the unsigned absolute value of a signed integer value of; /// the same bitwidth.; /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow; /// is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:159,Integrability,depend,depending,159,"/// Conversion operators. These are all single input single output; /// operations. For all of these, the result type must be strictly; /// wider or narrower (depending on the operation) than the source; /// type.; /// SIGN_EXTEND - Used for integer types, replicating the sign bit; /// into new bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:82,Integrability,depend,depends,82,/// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign; /// depends on the first letter) to floating point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:86,Modifiability,extend,extend,86,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:151,Modifiability,extend,extending,151,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:49,Performance,perform,performs,49,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:407,Modifiability,extend,extended,407,"/// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register any-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is any-extended into the corresponding,; /// wider result elements with the high bits becoming undef.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:410,Modifiability,extend,extended,410,"/// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register sign-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is sign-extended into the corresponding,; /// wider result elements.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:410,Modifiability,extend,extended,410,"/// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register zero-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is zero-extended into the corresponding,; /// wider result elements.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:740,Modifiability,extend,extended,740,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:787,Modifiability,extend,extends,787,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:824,Modifiability,extend,extends,824,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:81,Availability,down,down,81,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:588,Safety,safe,safe,588,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:218,Integrability,depend,dependent,218,"/// Returns current rounding mode:; /// -1 Undefined; /// 0 Round to 0; /// 1 Round to nearest, ties to even; /// 2 Round to +inf; /// 3 Round to -inf; /// 4 Round to nearest, ties to zero; /// Other values are target dependent.; /// Result is rounding mode and chain. Input is a chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:23,Modifiability,Extend,Extend,23,/// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:711,Integrability,depend,depends,711,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:136,Performance,load,loaded,136,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:180,Integrability,interface,interface,180,"/// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions; /// and truncation for half-precision (16 bit) floating numbers. These nodes; /// form a semi-softened interface for dealing with f16 (as an i16), which; /// is often a storage-only type but has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,Performance,perform,perform,57,"/// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions; /// and truncation for half-precision (16 bit) floating numbers. These nodes; /// form a semi-softened interface for dealing with f16 (as an i16), which; /// is often a storage-only type but has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:143,Integrability,interface,interface,143,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,Performance,perform,perform,57,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,Perform,Perform,4,"/// Perform various unary floating-point operations inspired by libm. For; /// FPOWI, the result is undefined if the integer operand doesn't fit into; /// sizeof(int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:22,Performance,Perform,Perform,22,"/// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two; /// values.; //; /// In the case where a single input is a NaN (either signaling or quiet),; /// the non-NaN input is returned.; ///; /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:32,Performance,Perform,Perform,32,"/// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on; /// two values, following the IEEE-754 2008 definition. This differs from; /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a; /// signaling NaN, returns a quiet NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:149,Performance,load,loaded,149,"/// Sets the current floating point environment. The first operand is a token; /// chain, the second is a pointer to memory, where FP environment is loaded; /// from. The result is a token chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,LOAD,LOAD,4,"/// LOAD and STORE have token chains as their first operand, then the same; /// operands as an LLVM load/store instruction, then an offset node that; /// is added / subtracted from the base pointer to form the address (for; /// indexed memory ops).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:100,Performance,load,load,100,"/// LOAD and STORE have token chains as their first operand, then the same; /// operands as an LLVM load/store instruction, then an offset node that; /// is added / subtracted from the base pointer to form the address (for; /// indexed memory ops).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:25,Energy Efficiency,Allocate,Allocate,25,"/// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned; /// to a specified boundary. This node always has two return values: a new; /// stack pointer value and a chain. The first operand is the token chain,; /// the second is the number of bytes to allocate, and the third is the; /// alignment boundary. The size is guaranteed to be a multiple of the; /// stack alignment, and the alignment is guaranteed to be bigger than the; /// stack alignment (if required) or 0 to get standard stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:270,Energy Efficiency,allocate,allocate,270,"/// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned; /// to a specified boundary. This node always has two return values: a new; /// stack pointer value and a chain. The first operand is the token chain,; /// the second is the number of bytes to allocate, and the third is the; /// alignment boundary. The size is guaranteed to be a multiple of the; /// stack alignment, and the alignment is guaranteed to be bigger than the; /// stack alignment (if required) or 0 to get standard stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:464,Performance,optimiz,optimizations,464,"/// BRCOND - Conditional branch. The first operand is the chain, the; /// second is the condition, the third is the block to branch to if the; /// condition is true. If the type of the condition is not i1, then the; /// high bits must conform to getBooleanContents. If the condition is undef,; /// it nondeterministically jumps to the block.; /// TODO: Its semantics w.r.t undef requires further discussion; we need to; /// make it sure that it is consistent with optimizations in MIR & the; /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:657,Modifiability,variab,variable,657,"/// INLINEASM - Represents an inline asm block. This node always has two; /// return values: a chain and a flag result. The inputs are as follows:; /// Operand #0 : Input chain.; /// Operand #1 : a ExternalSymbolSDNode with a pointer to the asm string.; /// Operand #2 : a MDNodeSDNode with the !srcloc metadata.; /// Operand #3 : HasSideEffect, IsAlignStack bits.; /// After this, it is followed by a list of operands with this format:; /// ConstantSDNode: Flags that encode whether it is a mem or not, the; /// of operands that follow, etc. See InlineAsm.h.; /// ... however many operands ...; /// Operand #last: Optional, an incoming flag.; ///; /// The variable width operands are required to represent target addressing; /// modes as a single ""operand"", even though they may have multiple; /// SDOperands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:191,Performance,load,loads,191,"/// ANNOTATION_LABEL - Represents a mid basic block label used by; /// annotations. This should remain within the basic block and be ordered; /// with respect to other call instructions, but loads and stores may float; /// past it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:268,Performance,optimiz,optimizers,268,"/// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end; /// of a call sequence, and carry arbitrary information that target might; /// want to know. The first operand is a chain, the rest are specified by; /// the target and not touched by the DAG optimizers.; /// Targets that may use stack to pass call arguments define additional; /// operands:; /// - size of the call frame part that must be set up within the; /// CALLSEQ_START..CALLSEQ_END pair,; /// - part of the call frame prepared prior to CALLSEQ_START.; /// Both these parameters must be constants, their sum is the total call; /// frame size.; /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:415,Performance,latency,latency,415,"/// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.; /// It produces a chain and one i64 value. The only operand is a chain.; /// If i64 is not legal, the result will be expanded into smaller values.; /// Still, it returns an i64, so targets should set legality for i64.; /// The result is the content of the architecture-specific cycle; /// counter-like register (or other high accuracy low latency clock source).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:326,Security,access,access,326,"/// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic. It; /// takes as input a token chain, the pointer to the trampoline, the pointer; /// to the nested function, the pointer to pass for the 'nest' parameter, a; /// SRCVALUE for the trampoline and another for the nested function; /// (allowing targets to access the original Function*).; /// It produces a token chain as output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:77,Availability,failure,failure,77,/// UBSANTRAP - Trap with an immediate describing the kind of sanitizer; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:62,Security,sanitiz,sanitizer,62,/// UBSANTRAP - Trap with an immediate describing the kind of sanitizer; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:213,Performance,cache,cache,213,"/// PREFETCH - This corresponds to a prefetch intrinsic. The first operand; /// is the chain. The other operands are the address to prefetch,; /// read / write specifier, locality specifier and instruction / data cache; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:183,Integrability,Synchroniz,SynchronizationScope,183,"/// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope); /// This corresponds to the fence instruction. It takes an input chain, and; /// two integer constants: an AtomicOrdering and a SynchronizationScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:72,Performance,load,load,72,"/// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr); /// This corresponds to ""load atomic"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Availability,Mask,Masked,3,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:92,Availability,mask,mask,92,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:146,Availability,mask,masked-off,146,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:203,Availability,Mask,Mask,203,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:257,Availability,Mask,Mask,257,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:10,Performance,load,load,10,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:46,Performance,load,load,46,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:126,Security,access,accesses,126,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Availability,Mask,Masked,3,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:110,Availability,mask,mask,110,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:164,Availability,mask,masked-off,164,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:232,Availability,Mask,Mask,232,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:300,Availability,Mask,Mask,300,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:31,Performance,load,load,31,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:148,Security,access,accesses,148,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:297,Performance,optimiz,optimizers,297,"/// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the; /// beginning and end of GC transition sequence, and carry arbitrary; /// information that target might need for lowering. The first operand is; /// a chain, the rest are specified by the target and not touched by the DAG; /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be; /// nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:176,Energy Efficiency,Power,PowerPC,176,"/// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of; /// the most recent dynamic alloca. For most targets that would be 0, but; /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time; /// known nonzero constant. The only operand here is the chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,Performance,scalab,scalable,108,/// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the; /// number of elements within a scalable vector. IMM is a constant integer; /// multiplier that is applied to the runtime value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:293,Energy Efficiency,reduce,reduce,293,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:145,Performance,perform,perform,145,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:512,Performance,perform,performing,512,"/// These reductions have relaxed evaluation order semantics, and have a; /// single vector operand. The order of evaluation is unspecified. For; /// pow-of-2 vectors, one valid legalizer expansion is to use a tree; /// reduction, i.e.:; /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC; /// PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]; /// PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]; /// RES = FADD PART_RDX2[0], PART_RDX2[1]; /// For non-pow-2 vectors, this can be computed by extracting each element; /// and performing the operation as if it were scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:114,Performance,perform,performed,114,"/// Integer reductions may have a result type larger than the vector element; /// type. However, the reduction is performed using the vector element type; /// and the value in the top bits is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:90,Availability,mask,mask,90,"// The `llvm.experimental.patchpoint.*` intrinsic.; // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,; // <numArgs>, cc, ...; // Outputs: [rv], output chain, glue",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:26,Deployability,patch,patchpoint,26,"// The `llvm.experimental.patchpoint.*` intrinsic.; // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,; // <numArgs>, cc, ...; // Outputs: [rv], output chain, glue",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:28,Testability,log,logic,28,/// Whether this is bitwise logic opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:39,Availability,mask,mask,39,/// The operand position of the vector mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:269,Availability,avail,available,269,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:128,Performance,load,load,128,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:201,Performance,load,load,201,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:397,Performance,load,load,397,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:441,Performance,load,load,441,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:701,Performance,load,load,701,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:739,Performance,load,load,739,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:797,Performance,perform,performing,797,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:927,Performance,load,load,927,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:972,Performance,load,load,972,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:1355,Performance,load,load,1355,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:1404,Performance,load,load,1404,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:233,Modifiability,extend,extends,233,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:331,Modifiability,extend,extends,331,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:432,Modifiability,extend,extending,432,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:465,Modifiability,extend,extending,465,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:84,Performance,Load,LoadExtType,84,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:143,Performance,LOAD,LOADEXT,143,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:157,Performance,load,load,157,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:198,Performance,load,loads,198,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:296,Performance,load,loads,296,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:442,Performance,load,loads,442,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:475,Performance,load,loads,475,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:20,Usability,Intuit,Intuitive,20,// Opcode N U L G E Intuitive operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs a signed; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an unsigned; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with floating point operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:27,Testability,log,logical,27,/// Return the result of a logical OR between different comparisons of; /// identical values: ((X op1 Y) | (X op2 Y)). This function returns; /// SETCC_INVALID if it is not possible to represent the resultant comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:27,Testability,log,logical,27,/// Return the result of a logical AND between different comparisons of; /// identical values: ((X op1 Y) & (X op2 Y)). This function returns; /// SETCC_INVALID if it is not possible to represent the resultant comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:449,Energy Efficiency,Schedul,SchedulingPriorityQueue,449,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:478,Energy Efficiency,schedul,schedules,478,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:521,Energy Efficiency,reduce,reduce,521,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:10,Performance,Latency,LatencyPriorityQueue,10,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:37,Performance,latency,latency-oriented,37,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:63,Performance,queue,queue,63,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:406,Performance,Latency,LatencyPriorityQueue,406,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:494,Performance,latency,latency,494,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:30,Availability,Avail,Available,30,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:40,Performance,queue,queue,40,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:78,Performance,Queue,Queue,78,"/// NumNodesSolelyBlocking - This vector contains, for every node in the; /// Queue, the number of nodes that the node is the sole unscheduled; /// predecessor for. This is used as a tie-breaker heuristic for better; /// mobility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:4,Performance,Queue,Queue,4,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:16,Performance,queue,queue,16,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:240,Availability,avail,available,240,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:3,Energy Efficiency,schedul,scheduledNode,3,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:32,Energy Efficiency,schedul,scheduled,32,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:203,Energy Efficiency,schedul,scheduling,203,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h:331,Availability,avail,available,331,"/// This is an alternative analysis pass to MachineBlockFrequencyInfo.; /// The difference is that with this pass, the block frequencies are not; /// computed when the analysis pass is executed but rather when the BFI result; /// is explicitly requested by the analysis client.; ///; /// This works by checking querying if MBFI is available and otherwise; /// generating MBFI on the fly. In this case the passes required for (LI, DT); /// are also queried before being computed on the fly.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h:53,Availability,avail,available,53,/// Calculate MBFI and all other analyses that's not available and; /// required by BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:4,Modifiability,extend,extendInsnRange,4,/// extendInsnRange - Extend the current instruction range covered by; /// this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:22,Modifiability,Extend,Extend,22,/// extendInsnRange - Extend the current instruction range covered by; /// this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:122,Integrability,interface,interface,122,//===----------------------------------------------------------------------===//; /// LexicalScopes - This class provides interface to collect and use lexical; /// scoping information from machine instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:4,Deployability,release,releaseMemory,4,/// releaseMemory - release memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:20,Deployability,release,release,20,/// releaseMemory - release memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:66,Availability,avail,available,66,/// empty - Return true if there is any lexical scope information available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:85,Availability,avail,available,85,/// getOrCreateLexicalScope - Find lexical scope for the given Scope/IA. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:70,Performance,cache,cache,70,/// Map a location to the set of basic blocks it dominates. This is a cache; /// for \ref LexicalScopes::getMachineBasicBlocks results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h:25,Modifiability,plug-in,plug-ins,25,"// We must reference the plug-ins in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h:128,Performance,optimiz,optimization,128,"// We must reference the plug-ins in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h:126,Performance,optimiz,optimization,126,"// We must reference the passes in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:135,Integrability,interface,interface,135,"/// Result of a LiveRange query. This class hides the implementation details; /// of live ranges, and it should be used as the primary interface for; /// examining live ranges around instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:22,Availability,alive,alive,22,"/// Returns the value alive at the end of the instruction, if any. This can; /// be a live-through value, a live def or a dead def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:29,Deployability,continuous,continuous,29,"/// This represents a simple continuous liveness interval for a value.; /// The start point is inclusive, the end point exclusive. These intervals; /// are rendered as [start,end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:22,Usability,simpl,simple,22,"/// This represents a simple continuous liveness interval for a value.; /// The start point is inclusive, the end point exclusive. These intervals; /// are rendered as [start,end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:117,Energy Efficiency,allocate,allocate,117,"/// createDeadDef - Make sure the range has a value defined at Def.; /// If one already exists, return it. Otherwise allocate a new value and; /// add liveness for a dead def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:15,Modifiability,extend,extend,15,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:450,Modifiability,extend,extended,450,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:691,Modifiability,extend,extend,691,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:37,Modifiability,extend,extendInBlock,37,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:232,Modifiability,extend,extend,232,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:4,Usability,Simpl,Simplified,4,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:186,Safety,abort,aborts,186,"/// join - Join two live ranges (this, and other) together. This applies; /// mappings to the value numbers in the LHS/RHS ranges as specified. If; /// the ranges are not joinable, this aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:213,Modifiability,extend,extended,213,"/// True iff this segment is a single segment that lies between the; /// specified boundaries, exclusively. Vregs live across a backedge are not; /// considered local. The boundaries are expected to lie within an extended; /// basic block, so vregs that are not live out should contain no holes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:163,Security,access,access,163,/// Stores indexes from the input index sequence R at which this LiveRange; /// is live to the output O iterator.; /// R is a range of _ascending sorted_ _random_ access iterators; /// to the input indexes. Indexes stored at O are ascending sorted so it; /// can be used directly in the subsequent search (for example for; /// subranges). Returns true if found at least one index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:23,Testability,assert,assert,23,/// Walk the range and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:103,Testability,assert,asserts,103,/// Walk the range and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:56,Availability,avail,available,56,/// Returns true if subregister liveness information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,Availability,mask,mask,21,"/// For a given lane mask @p LaneMask, compute indexes at which the; /// lane is marked undefined by subregister <def,read-undef> definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:359,Availability,mask,mask,359,"/// Refines the subranges to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:642,Availability,mask,masks,642,"/// Refines the subranges to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:944,Deployability,update,update,944,"s to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:1847,Deployability,update,update,1847,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:2035,Deployability,update,updated,2035,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:1710,Modifiability,rewrite,rewrite,1710,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:27,Testability,assert,assert,27,/// Walks the interval and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:107,Testability,assert,asserts,107,/// Walks the interval and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:47,Deployability,update,updates,47,/// Helper class for performant LiveRange bulk updates.; ///; /// Calling LiveRange::addSegment() repeatedly can be expensive on large; /// live ranges because segments after the insertion point may need to be; /// shifted. The LiveRangeUpdater class can defer the shifting when adding; /// many segments in order.; ///; /// The LiveRange will be in an invalid state until flush() is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,Performance,perform,performant,21,/// Helper class for performant LiveRange bulk updates.; ///; /// Calling LiveRange::addSegment() repeatedly can be expensive on large; /// live ranges because segments after the insertion point may need to be; /// shifted. The LiveRangeUpdater class can defer the shifting when adding; /// many segments in order.; ///; /// The LiveRange will be in an invalid state until flush() is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:149,Performance,perform,performance,149,"/// Add a segment to LR and coalesce when possible, just like; /// LR.addSegment(). Segments should be added in increasing start order for; /// best performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:14,Deployability,update,updater,14,/// Flush the updater state to LR so it is valid and contains all added; /// segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:411,Energy Efficiency,allocate,allocate,411,"/// ConnectedVNInfoEqClasses - Helper class that can divide VNInfos in a; /// LiveInterval into equivalence clases of connected components. A; /// LiveInterval that has multiple connected components can be broken into; /// multiple LiveIntervals.; ///; /// Given a LiveInterval that may have multiple connected components, run:; ///; /// unsigned numComps = ConEQ.Classify(LI);; /// if (numComps > 1) {; /// // allocate numComps-1 new LiveIntervals into LIS[1..]; /// ConEQ.Distribute(LIS);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:272,Availability,mask,mask,272,"/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// If @p LR is a main range, or if @p LI is null, then all uses must be; /// jointly dominated by the definitions from @p LR. If @p LR is a subrange; /// of the live interval @p LI, corresponding to lane mask @p LaneMask,; /// all uses must be jointly dominated by the definitions from @p LR; /// together with definitions of other lanes where @p LR becomes undefined; /// (via <def,read-undef> operands).; /// If @p LR is a main range, the @p LaneMask should be set to ~0, i.e.; /// LaneBitmask::getAll().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:4,Modifiability,Extend,Extend,4,"/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// If @p LR is a main range, or if @p LI is null, then all uses must be; /// jointly dominated by the definitions from @p LR. If @p LR is a subrange; /// of the live interval @p LI, corresponding to lane mask @p LaneMask,; /// all uses must be jointly dominated by the definitions from @p LR; /// together with definitions of other lanes where @p LR becomes undefined; /// (via <def,read-undef> operands).; /// If @p LR is a main range, the @p LaneMask should be set to ~0, i.e.; /// LaneBitmask::getAll().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:4,Modifiability,Extend,Extend,4,/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// All uses must be jointly dominated by existing liveness. PHI-defs are; /// inserted as needed to preserve SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,Availability,mask,mask,46,"/// Sorted list of instructions with register mask operands. Always use the; /// 'r' slot, RegMasks are normal clobbers, not early clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:99,Availability,mask,mask,99,"/// This vector is parallel to RegMaskSlots, it holds a pointer to the; /// corresponding register mask. This pointer can be recomputed as:; ///; /// MI = Indexes->getInstructionFromIndex(RegMaskSlot[N]);; /// unsigned OpNum = findRegMaskOperand(MI);; /// RegMaskBits[N] = MI->getOperand(OpNum).getRegMask();; ///; /// This is kept in a separate vector partly because some standard; /// libraries don't support lower_bound() with mixed objects, partly to; /// improve locality when searching in RegMaskSlots.; /// Also see the comment in LiveInterval::find().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:246,Availability,mask,mask,246,"/// For each basic block number, keep (begin, size) pairs indexing into the; /// RegMaskSlots and RegMaskBits arrays.; /// Note that basic block numbers may not be layout contiguous, that's why; /// we can't just keep track of the first register mask in each basic; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:191,Availability,mask,mask,191,"/// Specialized version of; /// shrinkToUses(LiveInterval *li, SmallVectorImpl<MachineInstr*> *dead); /// that works on a subregister live range and only looks at uses matching; /// the lane mask of the subregister range.; /// This may leave the subrange empty which needs to be cleaned up with; /// LiveInterval::removeEmptySubranges() afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Modifiability,Extend,Extend,4,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:360,Modifiability,extend,extended,360,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:519,Modifiability,extend,extended,519,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:577,Modifiability,extend,extend,577,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:168,Modifiability,extend,extendToIndices,168,"/// If \p LR has a live value at \p Kill, prune its live range by removing; /// any liveness reachable from Kill. Add live range end points to; /// EndPoints such that extendToIndices(LI, EndPoints) will reconstruct the; /// value's live range.; ///; /// Calling pruneValue() and extendToIndices() can be used to reconstruct; /// SSA form after adding defs to a virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:280,Modifiability,extend,extendToIndices,280,"/// If \p LR has a live value at \p Kill, prune its live range by removing; /// any liveness reachable from Kill. Add live range end points to; /// EndPoints such that extendToIndices(LI, EndPoints) will reconstruct the; /// value's live range.; ///; /// Calling pruneValue() and extendToIndices() can be used to reconstruct; /// SSA form after adding defs to a virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:107,Safety,avoid,avoid,107,/// Returns true if VNI is killed by any PHI-def values in LI.; /// This may conservatively return true to avoid expensive computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:120,Deployability,update,update,120,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:241,Deployability,Update,UpdateFlags,241,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:253,Deployability,Update,Update,253,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Deployability,Update,Update,4,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:132,Deployability,Update,UpdateFlags,132,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:144,Deployability,Update,Update,144,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Deployability,Update,Update,4,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:172,Energy Efficiency,efficient,efficient,172,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:414,Usability,simpl,simple,414,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:12,Availability,mask,mask,12,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:76,Availability,mask,mask,76,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:441,Availability,mask,mask,441,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:539,Availability,mask,mask,539,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:235,Performance,perform,performance,235,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:82,Availability,mask,mask,82,/// Returns a sorted array of slot indices of all instructions with register; /// mask operands in the basic block numbered \p MBBNum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:33,Availability,mask,mask,33,/// Returns an array of register mask pointers corresponding to; /// getRegMaskSlots().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,Availability,mask,mask,24,/// Returns an array of mask pointers corresponding to; /// getRegMaskSlotsInBlock(MBBNum).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,Availability,mask,mask,46,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:88,Availability,mask,mask,88,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:219,Availability,mask,mask,219,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Testability,Test,Test,4,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:420,Energy Efficiency,efficient,efficiently,420,"// Register unit functions.; //; // Fixed interference occurs when MachineInstrs use physregs directly; // instead of virtual registers. This typically happens when passing; // arguments to a function call, or when instructions require operands in; // fixed registers.; //; // Each physreg has one or more register units, see MCRegisterInfo. We; // track liveness per register unit to handle aliasing registers more; // efficiently.; /// Return the live range for register unit \p Unit. It will be computed if; /// it doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,Availability,repair,repairIntervalsInRange,24,"/// Helper function for repairIntervalsInRange(), walks backwards and; /// creates/modifies live segments in \p LR to match the operands found.; /// Only full operands or operands with subregisters matching \p LaneMask; /// are considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:126,Integrability,depend,depending,126,"/// Union of live intervals that are strong candidates for coalescing into a; /// single register (either physical or virtual depending on the context). We; /// expect the constituent live intervals to be disjoint, although we may; /// eventually make exceptions to handle value-based interference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:18,Security,access,access,18,// Provide public access to the underlying map to allow overlap iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:10,Performance,cache,cached,10,"// Retain cached results, e.g. firstInterference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:1181,Availability,alive,alive,1181,"//===- llvm/CodeGen/LivePhysRegs.h - Live Physical Register Set -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the LivePhysRegs utility for tracking liveness of; /// physical registers. This can be used for ad-hoc liveness tracking after; /// register allocation. You can start with the live-ins/live-outs at the; /// beginning/end of a block and update the information while walking the; /// instructions inside the block. This implementation tracks the liveness on a; /// sub-register granularity.; ///; /// We assume that the high bits of a physical super-register are not preserved; /// unless the instruction has an implicit-use operand reading the super-; /// register.; ///; /// X86 Example:; /// %ymm0 = ...; /// %xmm0 = ... (Kills %xmm0, all %xmm0s sub-registers, and %ymm0); ///; /// %ymm0 = ...; /// %xmm0 = ..., implicit %ymm0 (%ymm0 and all its sub-registers are alive); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:652,Deployability,update,update,652,"//===- llvm/CodeGen/LivePhysRegs.h - Live Physical Register Set -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the LivePhysRegs utility for tracking liveness of; /// physical registers. This can be used for ad-hoc liveness tracking after; /// register allocation. You can start with the live-ins/live-outs at the; /// beginning/end of a block and update the information while walking the; /// instructions inside the block. This implementation tracks the liveness on a; /// sub-register granularity.; ///; /// We assume that the high bits of a physical super-register are not preserved; /// unless the instruction has an implicit-use operand reading the super-; /// register.; ///; /// X86 Example:; /// %ymm0 = ...; /// %xmm0 = ... (Kills %xmm0, all %xmm0s sub-registers, and %ymm0); ///; /// %ymm0 = ...; /// %xmm0 = ..., implicit %ymm0 (%ymm0 and all its sub-registers are alive); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:25,Usability,clear,clears,25,/// (re-)initializes and clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:4,Usability,Clear,Clears,4,/// Clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:275,Availability,avail,available,275,"/// Returns true if register \p Reg is contained in the set. This also; /// works if only the super register of \p Reg has been defined, because; /// addReg() always adds all sub-registers to the set as well.; /// Note: Returns false if just some sub registers are live, use available(); /// when searching a free register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:158,Integrability,depend,depends,158,"/// Simulates liveness when stepping forward over an instruction(bundle).; /// Remove killed-uses, add defs. This is the not recommended way, because it; /// depends on accurate kill flags. If possible use stepBackward() instead of; /// this function. The clobbers set will be the list of registers either; /// defined or clobbered by a regmask. The operand will identify whether this; /// is a regmask or register operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:80,Availability,mask,masks,80,"/// Adds live-in registers from basic block \p MBB, taking associated; /// lane masks into consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:755,Availability,avail,available,755,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:906,Availability,down,down,906,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:742,Integrability,interface,interface,742,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:1000,Integrability,interface,interface,1000,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:794,Modifiability,variab,variable,794,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:487,Performance,cache,caches,487,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:594,Performance,cache,cache,594,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,Availability,redundant,redundant,82,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,Safety,redund,redundant,82,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:211,Usability,clear,cleared,211,"/// Bit vector of active entries in LiveOut, also used as a visited set by; /// findReachingDefs. One entry per basic block, indexed by block number.; /// This is kept as a separate bit vector because it can be cleared quickly; /// when switching live ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:117,Deployability,update,updated,117,// DomNode - Dominator tree node for the block.; // Cleared when the final value has been determined and LI has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:52,Usability,Clear,Cleared,52,// DomNode - Dominator tree node for the block.; // Cleared when the final value has been determined and LI has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:30,Deployability,update,updateSSA,30,// Live-in value filled in by updateSSA once it is known.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:174,Deployability,update,updateSSA,174,/// LiveIn - Work list of blocks where the live-in value has yet to be; /// determined. This list is typically computed by findReachingDefs() and; /// used as a work list by updateSSA(). The low-level interface may also be; /// used to add entries directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:201,Integrability,interface,interface,201,/// LiveIn - Work list of blocks where the live-in value has yet to be; /// determined. This list is typically computed by findReachingDefs() and; /// used as a work list by updateSSA(). The low-level interface may also be; /// used to add entries directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:4,Deployability,update,updateSSA,4,/// updateSSA - Compute the values that will be live in to all requested; /// blocks in LiveIn. Create PHI-def values as required to preserve SSA form.; ///; /// Every live-in block must be jointly dominated by the added live-out; /// blocks. No values are read from the live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:71,Deployability,update,update,71,/// Transfer information from the LiveIn vector to the live ranges and update; /// the given @p LiveOuts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:20,Security,expose,expose,20,/// Some getters to expose in a read-only way some private fields to; /// subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:94,Integrability,interface,interface,94,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:254,Performance,cache,caches,254,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:316,Performance,cache,caches,316,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Mid-level interface.; //===--------------------------------------------------------------------===//; //; // Modify existing live ranges.; //; /// Extend the live range of @p LR to reach @p Use.; ///; /// The existing values in @p LR must be live so they jointly dominate @p Use.; /// If @p Use is not dominated by a single existing value, PHI-defs are; /// inserted as required to preserve SSA form.; ///; /// PhysReg, when set, is used to verify live-in lists on basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:230,Modifiability,Extend,Extend,230,"//===--------------------------------------------------------------------===//; // Mid-level interface.; //===--------------------------------------------------------------------===//; //; // Modify existing live ranges.; //; /// Extend the live range of @p LR to reach @p Use.; ///; /// The existing values in @p LR must be live so they jointly dominate @p Use.; /// If @p Use is not dominated by a single existing value, PHI-defs are; /// inserted as required to preserve SSA form.; ///; /// PhysReg, when set, is used to verify live-in lists on basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // These functions can be used to compute live ranges where the live-in and; // live-out blocks are already known, but the SSA value in each block is; // unknown.; //; // After calling reset(), add known live-out values and known live-in blocks.; // Then call calculateValues() to compute the actual value that is; // live-in to each block, and add liveness to the live ranges.; //; /// setLiveOutValue - Indicate that VNI is live out from MBB. The; /// calculateValues() function will not add liveness for MBB, the caller; /// should take care of that.; ///; /// VNI may be null only if MBB is a live-through block also passed to; /// addLiveInBlock().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:86,Performance,load,load,86,"/// foldAsLoad - If LI has a single use and a single def that can be folded as; /// a load, eliminate the register by folding the def into the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:40,Availability,down,down,40,"/// Create a LiveRangeEdit for breaking down parent into smaller pieces.; /// @param parent The register being spilled or split.; /// @param newRegs List to receive any new registers created. This needn't be; /// empty initially, any existing registers are ignored.; /// @param MF The MachineFunction the live range edit is taking place in.; /// @param lis The collection of all live intervals in this function.; /// @param vrm Map of virtual registers to physical registers for this; /// function. If NULL, no virtual register map updates will; /// be done. This could be the case if called before Regalloc.; /// @param deadRemats The collection of all the instructions defining an; /// original reg and are dead after remat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:532,Deployability,update,updates,532,"/// Create a LiveRangeEdit for breaking down parent into smaller pieces.; /// @param parent The register being spilled or split.; /// @param newRegs List to receive any new registers created. This needn't be; /// empty initially, any existing registers are ignored.; /// @param MF The MachineFunction the live range edit is taking place in.; /// @param lis The collection of all live intervals in this function.; /// @param vrm Map of virtual registers to physical registers for this; /// function. If NULL, no virtual register map updates will; /// be done. This could be the case if called before Regalloc.; /// @param deadRemats The collection of all the instructions defining an; /// original reg and are dead after remat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:17,Security,access,accessing,17,/// Iterator for accessing the new registers added by this edit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:445,Energy Efficiency,allocate,allocate,445,"/// pop_back - It allows LiveRangeEdit users to drop new registers.; /// The context is when an original def instruction of a register is; /// dead after rematerialization, we still want to keep it for following; /// rematerializations. We save the def instruction in DeadRemats,; /// and replace the original dst register with a new dummy register so; /// the live range of original dst register can be shrinked normally.; /// We don't want to allocate phys register for the dummy register, so; /// we want to drop it from the NewRegs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:94,Availability,avail,available,94,/// allUsesAvailableAt - Return true if all registers used by OrigMI at; /// OrigIdx are also available with the same value at UseIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:171,Deployability,update,updated,171,"/// rematerializeAt - Rematerialize RM.ParentVNI into DestReg by inserting an; /// instruction into MBB before MI. The new instruction is mapped, but; /// liveness is not updated. If ReplaceIndexMI is not null it will be replaced; /// by new MI in the index map.; /// Return the SlotIndex of the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Performance,Cache,Cached,3,// Cached queries per register unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:19,Availability,mask,mask,19,// Cached register mask interference info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Performance,Cache,Cached,3,// Cached register mask interference info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:94,Integrability,interface,interface,94,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:298,Performance,cache,cached,298,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:438,Performance,cache,caches,438,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:166,Availability,avail,available,166,/// Assign VirtReg to PhysReg.; /// This will mark VirtReg's live range as occupied in the LiveRegMatrix and; /// update VirtRegMap. The live range is expected to be available in PhysReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:114,Deployability,update,update,114,/// Assign VirtReg to PhysReg.; /// This will mark VirtReg's live range as occupied in the LiveRegMatrix and; /// update VirtRegMap. The live range is expected to be available in PhysReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:140,Deployability,update,updates,140,"/// Unassign VirtReg from its PhysReg.; /// Assuming that VirtReg was previously assigned to a PhysReg, this undoes; /// the assignment and updates VirtRegMap accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:109,Usability,undo,undoes,109,"/// Unassign VirtReg from its PhysReg.; /// Assuming that VirtReg was previously assigned to a PhysReg, this undoes; /// the assignment and updates VirtRegMap accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // Provide access to the underlying LiveIntervalUnions.; //; /// Check for regmask interference only.; /// Return true if VirtReg crosses a regmask operand that clobbers PhysReg.; /// If PhysReg is null, check if VirtReg crosses any regmask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:200,Security,access,access,200,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // Provide access to the underlying LiveIntervalUnions.; //; /// Check for regmask interference only.; /// Return true if VirtReg crosses a regmask operand that clobbers PhysReg.; /// If PhysReg is null, check if VirtReg crosses any regmask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:13,Security,access,access,13,/// Directly access the live interval unions per regunit.; /// This returns an array indexed by the regunit number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:19,Usability,clear,clear,19,/// Initialize and clear the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:4,Usability,Clear,Clears,4,/// Clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:98,Availability,Mask,Mask,98,/// Adds register units covered by physical register \p Reg that are; /// part of the lanemask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:4,Deployability,Update,Updates,4,/// Updates liveness when stepping backwards over the instruction \p MI.; /// This removes all register units defined or clobbered in \p MI and then; /// adds the units used (as in use operands) in \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:61,Availability,mask,mask,61,/// Returns an iterator range over all physical register and mask operands for; /// \p MI and bundled instructions. This also skips any debug operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1077,Energy Efficiency,efficient,efficiently,1077,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:44,Modifiability,Variab,Variable,44,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:818,Modifiability,variab,variables,818,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:923,Modifiability,variab,variable,923,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1106,Modifiability,variab,variables,1106,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:498,Availability,Alive,AliveBlocks,498,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:653,Availability,Alive,AliveBlocks,653,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:728,Availability,Alive,AliveBlocks,728,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1274,Availability,Alive,AliveBlocks,1274,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1498,Availability,Alive,AliveBlocks,1498,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:4,Availability,Alive,AliveBlocks,4,/// AliveBlocks - Set of blocks in which this value is alive completely; /// through. This is a bit set which uses the basic block number as an; /// index.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:55,Availability,alive,alive,55,/// AliveBlocks - Set of blocks in which this value is alive completely; /// through. This is a bit set which uses the basic block number as an; /// index.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:78,Modifiability,variab,variable,78,/// VirtRegInfo - This list is a mapping from virtual register number to; /// variable information.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:74,Availability,Mask,Mask,74,/// HandleRegMask - Call HandlePhysRegKill for all registers clobbered by Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:109,Modifiability,variab,variable,109,"/// analyzePHINodes - Gather information about the PHI nodes in here. In; /// particular, we want to map the variable information of a virtual; /// register which is used in a PHI node. We map that to the BB the vreg; /// is coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:90,Deployability,update,update,90,//===--------------------------------------------------------------------===//; // API to update live variable information; /// Recompute liveness from scratch for a virtual register \p Reg that is; /// known to have a single def that dominates all uses. This can be useful; /// after removing some uses of \p Reg. It is not necessary for the whole; /// machine function to be in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:102,Modifiability,variab,variable,102,//===--------------------------------------------------------------------===//; // API to update live variable information; /// Recompute liveness from scratch for a virtual register \p Reg that is; /// known to have a single def that dominates all uses. This can be useful; /// after removing some uses of \p Reg. It is not necessary for the whole; /// machine function to be in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:29,Deployability,Update,Update,29,/// replaceKillInstruction - Update register kill info by replacing a kill; /// instruction with a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:103,Modifiability,variab,variable,103,"/// removeVirtualRegisterKilled - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked as killed by the specified instruction,; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:150,Modifiability,variab,variable,150,"/// removeVirtualRegisterKilled - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked as killed by the specified instruction,; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:101,Modifiability,variab,variable,101,"/// removeVirtualRegisterDead - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked dead at the specified instruction, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:148,Modifiability,variab,variable,148,"/// removeVirtualRegisterDead - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked dead at the specified instruction, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:78,Modifiability,variab,variables,78,/// addNewBlock - Add a new basic block BB between DomBB and SuccBB. All; /// variables that are live out of DomBB and live into SuccBB will be marked; /// as passing live through BB. This method assumes that the machine code is; /// still in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:647,Energy Efficiency,efficient,efficient,647,"//==------ llvm/CodeGen/LoopTraversal.h - Loop Traversal -*- C++ -*---------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Loop Traversal logic.; ///; /// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:405,Testability,log,logic,405,"//==------ llvm/CodeGen/LoopTraversal.h - Loop Traversal -*- C++ -*---------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Loop Traversal logic.; ///; /// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:353,Deployability,update,update,353,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:971,Deployability,update,update,971,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:229,Energy Efficiency,efficient,efficient,229,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:835,Performance,Optimiz,Optimized,835,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1777,Performance,optimiz,optimized,1777,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1799,Safety,avoid,avoid,1799,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:398,Usability,clear,clearance,398,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:443,Usability,clear,clearance,443,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:482,Usability,clear,clearances,482,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1347,Usability,clear,clearances,1347,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1388,Usability,clear,clearance,1388,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:99,Energy Efficiency,efficient,efficient,99,/// Identifies basic blocks that are part of loops and should to be; /// visited twice and returns efficient traversal order for all the blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h:414,Modifiability,variab,variables,414,"//==------ llvm/CodeGen/LowerEmuTLS.h -------------------------*- C++ -*----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Add Add __emutls_[vt].* variables.; ///; /// This file provide declaration of LowerEmuTLSPass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:99,Usability,simpl,simple,99,/// Get a 16-bit IEEE half value.; /// TODO: Add IEEE semantics to type - This currently returns a simple `scalar(16)`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,Performance,scalab,scalable,20,/// Get a low-level scalable vector of some number of elements and element; /// width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,Performance,scalab,scalable,20,/// Get a low-level scalable vector of some number of elements and element; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,Performance,scalab,scalable,33,/// Returns true if the LLT is a scalable vector. Must only be called on; /// vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,Performance,scalab,scalable,33,"/// Returns true if the LLT is a scalable vector. Returns false otherwise,; /// even if the LLT is not a vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:51,Energy Efficiency,Reduce,Reduces,51,"/// Return a type that is \p Factor times smaller. Reduces the number of; /// elements if this is a vector, or the bitwidth for scalar/pointers. Does; /// not attempt to handle cases that aren't evenly divisible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:219,Modifiability,portab,portable,219,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:357,Modifiability,variab,variables,357,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:382,Modifiability,variab,variables,382,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:212,Usability,simpl,simple,212,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:114,Performance,Scalab,Scalable,114,/// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 32;; /// Scalable: 1;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:133,Performance,Scalab,Scalable,133,/// * Vector-of-pointer (isPointer == 1 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 16;; /// AddressSpace: 24;; /// Scalable: 1;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h:118,Testability,assert,assert,118,"/// Get a rough equivalent of an LLT for a given MVT. LLT does not yet support; /// scalarable vector types, and will assert if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:39,Availability,mask,mask,39,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:62,Usability,simpl,simply,62,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:130,Usability,clear,clearly,130,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:154,Performance,optimiz,optimization,154,"/// Keep track of the probabilities to the successors. This vector has the; /// same order as Successors, or it is empty if we don't use it (disable; /// optimization).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:105,Performance,cache,cached,105,"/// since getSymbol is a relatively heavy-weight operation, the symbol; /// is only computed once and is cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Performance,Cache,Cached,4,/// Cached MCSymbol for this block (used if IsEHCatchRetTarget).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:26,Energy Efficiency,allocate,allocated,26,// MachineBasicBlocks are allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,"/// Test whether this block is used as something other than the target; /// of a terminator, exception-handling target, or jump table. This is; /// either the result of an IR-level ""blockaddress"", or some form; /// of target-specific branch lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:191,Performance,load,loaded,191,"/// Test whether this block is used as something other than the target of a; /// terminator, exception-handling target, jump table, or IR blockaddress.; /// For example, its address might be loaded into a register, or; /// stored in some branch table that isn't part of MachineJumpTableInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,"/// Test whether this block is used as something other than the target of a; /// terminator, exception-handling target, jump table, or IR blockaddress.; /// For example, its address might be loaded into a register, or; /// stored in some branch table that isn't part of MachineJumpTableInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,/// Test whether this block is the target of an IR BlockAddress. (There can; /// more than one MBB associated with an IR BB where the address is taken.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,/// Test whether this block must have its label emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:96,Availability,error,error,96,// LiveIn management methods.; /// Adds the specified register as a live in. Note that it is an error to add; /// the same register to the same set more than once unless the intention is; /// to call sortUniqueLiveIns after all registers are added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Usability,Clear,Clear,4,/// Clear live in list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:176,Testability,assert,assert,176,"/// Unlike livein_begin, this method does not check that the liveness; /// information is accurate. Still for debug purposes it may be useful; /// to have iterators that won't assert if the liveness information; /// is not current.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,Availability,mask,mask,20,/// Get the clobber mask for the start of this basic block. Funclets use this; /// to prevent register allocation across funclet transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,Availability,mask,mask,20,/// Get the clobber mask for the end of the basic block.; /// \see getBeginClobberMask(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Deployability,Update,Update,4,"/// Update the terminator instructions in block to account for changes to; /// block layout which may have been made. PreviousLayoutSuccessor should be; /// set to the block which may have been used as fallthrough before the block; /// layout was modified. If the block previously fell through to that block,; /// it may now need a branch. If it previously branched to another block, it; /// may now be able to fallthrough to the current layout successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:132,Deployability,update,updated,132,"// Machine-CFG mutators; /// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. PROB parameter is stored in; /// Probabilities list. The default probability is set as unknown. Mixing; /// known and unknown probabilities in successor list is not allowed. When all; /// successors have unknown probabilities, 1 / N is returned as the; /// probability for each successor, where N is the number of successors.; ///; /// Note that duplicate Machine CFG edges are not allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:172,Availability,avail,available,172,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:107,Deployability,update,updated,107,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:266,Integrability,interface,interface,266,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:126,Deployability,update,update,126,"/// Normalize probabilities of all successors so that the sum of them becomes; /// one. This is usually done when the current update on this MBB is done, and; /// the sum of its successors' probabilities is not guaranteed to be one. The; /// user is responsible for the correct use of this function.; /// MBB::removeSuccessor() has an option to do this automatically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Security,Validat,Validate,4,/// Validate successors' probabilities and check if the sum of them is; /// approximate one. This only works in DEBUG mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:125,Deployability,update,updated,125,"/// Remove successor from the successors list of this MachineBasicBlock. The; /// Predecessors list of Succ is automatically updated.; /// If NormalizeSuccProbs is true, then normalize successors' probabilities; /// after the successor is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:135,Deployability,update,updated,135,"/// Remove specified successor from the successors list of this; /// MachineBasicBlock. The Predecessors list of Succ is automatically updated.; /// If NormalizeSuccProbs is true, then normalize successors' probabilities; /// after the successor is removed.; /// Return the iterator to the element after the one removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:39,Deployability,update,update,39,/// Replace successor OLD with NEW and update probability info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:50,Deployability,update,updates,50,/// Split the old successor into old plus new and updates the probability; /// info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:64,Deployability,update,update,64,"/// Transfers all the successors, as in transferSuccessors, and update PHI; /// operands in the successor blocks which refer to FromMBB to refer to this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:424,Performance,optimiz,optimizing,424,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:547,Performance,optimiz,optimizations,547,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:591,Performance,optimiz,optimizations,591,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:810,Performance,optimiz,optimizations,810,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:898,Performance,optimiz,optimizations,898,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:343,Safety,avoid,avoid,343,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:417,Performance,optimiz,optimizing,417,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:540,Performance,optimiz,optimizations,540,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:584,Performance,optimiz,optimizations,584,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:803,Performance,optimiz,optimizations,803,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:891,Performance,optimiz,optimizations,891,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:336,Safety,avoid,avoid,336,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:275,Deployability,update,updated,275,"/// Split a basic block into 2 pieces at \p SplitPoint. A new block will be; /// inserted after this block, and all instructions after \p SplitInst moved; /// to it (\p SplitInst will be in the original block). If \p LIS is provided,; /// LiveIntervals will be appropriately updated. \return the newly inserted; /// block.; ///; /// If \p UpdateLiveIns is true, this will ensure the live ins list is; /// accurate, including for physreg uses/defs in the original block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:339,Deployability,Update,UpdateLiveIns,339,"/// Split a basic block into 2 pieces at \p SplitPoint. A new block will be; /// inserted after this block, and all instructions after \p SplitInst moved; /// to it (\p SplitInst will be in the original block). If \p LIS is provided,; /// LiveIntervals will be appropriately updated. \return the newly inserted; /// block.; ///; /// If \p UpdateLiveIns is true, this will ensure the live ins list is; /// accurate, including for physreg uses/defs in the original block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:177,Deployability,update,updates,177,"/// Split the critical edge from this block to the given successor block, and; /// return the newly created block, or null if splitting is not possible.; ///; /// This function updates LiveVariables, MachineDominatorTree, and; /// MachineLoopInfo, as applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:354,Availability,reliab,reliable,354,"/// Insert MI into the instruction list before I, possibly inside a bundle.; ///; /// If the insertion point is inside a bundle, MI will be added to the bundle,; /// otherwise MI will not be added to any bundle. That means this function; /// alone can't be used to prepend or append instructions to bundles. See; /// MIBundleBuilder::insert() for a more reliable way of doing that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Deployability,Update,Update,4,/// Update all phi nodes in this basic block to refer to basic block \p New; /// instead of basic block \p Old.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:23,Availability,avail,available,23,///< Add IR name where available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:155,Deployability,update,update,155,"// Machine-CFG mutators; /// Add Pred as a predecessor of this MachineBasicBlock. Don't do this; /// unless you know what you're doing, because it doesn't update Pred's; /// successors list. Use Pred->addSuccessor instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:133,Deployability,update,update,133,"/// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this; /// unless you know what you're doing, because it doesn't update Pred's; /// successors list. Use Pred->removeSuccessor instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:9,Security,access,accessors,9,// These accessors are handy for sharing templated code between IR and MIR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:33,Integrability,interface,interface,33,"/// MachineInstrSpan provides an interface to get an iteration range; /// containing the instruction it was initialized with, along with all; /// those instructions inserted prior to or following that instruction; /// at some point after the MachineInstrSpan is constructed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:399,Usability,simpl,simplified,399,"//===- MachineBlockFrequencyInfo.h - MBB Frequency Analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:281,Safety,avoid,avoid,281,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to 1024. It means; /// that we should not rely on the value itself, but only on the comparison to; /// the other block frequencies. We do this to avoid using of floating points.; /// For example, to get the frequency of a block relative to the entry block,; /// divide the integral value returned by this function (the; /// BlockFrequency::getFrequency() value) by getEntryFreq().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:70,Safety,avoid,avoid,70,"/// incrementally calculate block frequencies when we split edges, to avoid; /// full CFG traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h:407,Modifiability,inherit,inherit,407,"// Default weight value. Used when we don't have information about the edge.; // TODO: DEFAULT_WEIGHT makes sense during static predication, when none of; // the successors have a weight yet. But it doesn't make sense when providing; // weight to an edge that may have siblings with non-zero weights. This can; // be handled various ways, but it's probably fine for an edge with unknown; // weight to just ""inherit"" the non-zero weight of an adjacent successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h:108,Availability,avail,available,108,"// Same as above, but using a const_succ_iterator from Src. This is faster; // when the iterator is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Energy Efficiency,Power,PowerPC,37,// These are patterns matched by the PowerPC to reassociate FMA chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Energy Efficiency,Power,PowerPC,37,// These are patterns matched by the PowerPC to reassociate FMA and FSUB to; // reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:80,Energy Efficiency,reduce,reduce,80,// These are patterns matched by the PowerPC to reassociate FMA and FSUB to; // reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:30,Energy Efficiency,reduce,reduce,30,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:51,Integrability,depend,dependence,51,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h:136,Integrability,wrap,wrapper,136,"/// isMachineConstantPoolEntry - Return true if the MachineConstantPoolEntry; /// is indeed a target specific constantpool entry, not a wrapper over a; /// Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h:445,Integrability,wrap,wrapper,445,"//===- MachineCycleAnalysis.h - Cycle Info for Machine IR -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MachineCycleInfo class, which is a thin wrapper over; // the Machine IR instance of GenericCycleInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:63,Deployability,update,updates,63,/// Apply all the recorded critical edges to the DT.; /// This updates the underlying DT information in a way that uses; /// the fast query path of DT as much as possible.; ///; /// \post CriticalEdgesToSplit.empty().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:50,Performance,perform,performs,50,// dominates - Return true if A dominates B. This performs the; // special checks necessary if A and B are in the same basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:54,Deployability,update,update,54,/// changeImmediateDominator - This method is used to update the dominator; /// tree information when a node's immediate dominator changes.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:59,Deployability,Update,Update,59,/// splitBlock - BB is split and now it has one successor. Update dominator; /// tree to reflect this change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:138,Deployability,update,update,138,"/// Record that the critical edge (FromBB, ToBB) has been; /// split with NewBB.; /// This is best to use this method instead of directly update the; /// underlying information, because this helps mitigating the; /// number of time the DT information is invalidated.; ///; /// \note Do not use this method with regular edges.; ///; /// \note To benefit from the compile time improvement incurred by this; /// method, the users of this method have to limit the queries to the DT; /// interface between two edges splitting. In other words, they have to; /// pack the splitting of critical edges as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:483,Integrability,interface,interface,483,"/// Record that the critical edge (FromBB, ToBB) has been; /// split with NewBB.; /// This is best to use this method instead of directly update the; /// underlying information, because this helps mitigating the; /// number of time the DT information is invalidated.; ///; /// \note Do not use this method with regular edges.; ///; /// \note To benefit from the compile time improvement incurred by this; /// method, the users of this method have to limit the queries to the DT; /// interface between two edges splitting. In other words, they have to; /// pack the splitting of critical edges as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:326,Performance,load,loaded,326,"/// Flag indicating whether the register is actually restored in the epilog.; /// In most cases, if a register is saved, it is also restored. There are; /// some situations, though, when this is not the case. For example, the; /// LR register on ARM is usually saved, but on exit from the function its; /// saved value may be loaded directly into PC. Since liveness tracking of; /// physical registers treats callee-saved registers are live outside of; /// the function, LR would be treated as live-on-exit, even though in these; /// scenarios it is not. This flag is added to indicate that the saved; /// register described by this object is not restored in the epilog.; /// The long-term solution is to model the liveness of callee-saved registers; /// by implicit uses on the return instructions, however, the required; /// changes in the ARM backend would be quite extensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:879,Energy Efficiency,allocate,allocated,879,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:854,Modifiability,variab,variable,854,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1071,Modifiability,variab,variable,1071,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1145,Modifiability,variab,variable,1145,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1227,Modifiability,variab,variable,1227,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1346,Modifiability,variab,variable,1346,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:171,Performance,optimiz,optimizations,171,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:276,Performance,optimiz,optimizations,276,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1004,Performance,optimiz,optimization,1004,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1422,Performance,perform,performed,1422,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1181,Safety,safe,safe,1181,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:39,Security,expose,exposed,39,///< The address of this allocation is exposed and; ///< triggered protection. 3rd closest to the protector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:29,Energy Efficiency,allocate,allocated,29,// Represent a single object allocated on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:114,Modifiability,variab,variable,114,// The offset of this object from the stack pointer on entry to; // the function. This field has no meaning for a variable sized element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:51,Modifiability,variab,variable,51,"// The size of this object on the stack. 0 means a variable sized object,; // ~0ULL means a dead object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:176,Energy Efficiency,Power,PowerPC,176,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:123,Security,access,accessible,123,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Modifiability,extend,extended,38,"/// If true, the object has been zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Modifiability,extend,extended,38,"/// If true, the object has been sign-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:590,Energy Efficiency,allocate,allocate,590,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:696,Performance,optimiz,optimization,696,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:653,Security,access,access,653,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:30,Energy Efficiency,allocate,allocated,30,/// The list of stack objects allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:82,Energy Efficiency,allocate,allocated,82,/// This boolean keeps track of whether any variable; /// sized objects have been allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:44,Modifiability,variab,variable,44,/// This boolean keeps track of whether any variable; /// sized objects have been allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:92,Deployability,patch,patchpoint,92,/// This boolean keeps track of whether there is a call; /// to builtin \@llvm.experimental.patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:157,Deployability,update,updates,157,"/// The prolog/epilog code inserter calculates the final stack; /// offsets for all of the fixed size objects, updating the Objects list; /// above. It then updates StackSize to contain the number of bytes that need; /// to be allocated on entry to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:227,Energy Efficiency,allocate,allocated,227,"/// The prolog/epilog code inserter calculates the final stack; /// offsets for all of the fixed size objects, updating the Objects list; /// above. It then updates StackSize to contain the number of bytes that need; /// to be allocated on entry to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:156,Integrability,depend,dependent,156,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:619,Performance,perform,performed,619,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:273,Security,access,accessed,273,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:20,Energy Efficiency,allocate,allocated,20,/// Size of the pre-allocated local frame block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:46,Energy Efficiency,allocate,allocated,46,"/// Whether the local object blob needs to be allocated together. If not,; /// PEI should ignore the isPreAllocated flags on the stack objects and; /// just allocate them normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:157,Energy Efficiency,allocate,allocate,157,"/// Whether the local object blob needs to be allocated together. If not,; /// PEI should ignore the isPreAllocated flags on the stack objects and; /// just allocate them normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,Availability,down,down,62,/// True if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:24,Integrability,wrap,wrapping,24,"/// Not null, if shrink-wrapping found a better place for the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:24,Integrability,wrap,wrapping,24,"/// Not null, if shrink-wrapping found a better place for the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:16,Safety,Unsafe,UnsafeStack,16,/// Size of the UnsafeStack Frame,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:152,Modifiability,variab,variable,152,/// This method may be called any time after instruction; /// selection is complete to determine if the stack frame for this function; /// contains any variable sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:152,Deployability,patch,patchpoint,152,/// This method may be called any time after instruction; /// selection is complete to determine if there is a call to builtin; /// \@llvm.experimental.patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:485,Availability,error,error,485,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:530,Availability,failure,failures,530,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:547,Availability,error,errors,547,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:33,Energy Efficiency,allocate,allocated,33,/// Return the number of objects allocated into the local object block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:52,Energy Efficiency,allocate,allocated,52,/// Get whether the local allocation blob should be allocated together or; /// let PEI allocate the locals in it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:87,Energy Efficiency,allocate,allocate,87,/// Get whether the local allocation blob should be allocated together or; /// let PEI allocate the locals in it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:91,Energy Efficiency,allocate,allocated,91,/// setUseLocalStackAllocationBlock - Set whether the local allocation blob; /// should be allocated together or let PEI allocate the locals in it; /// directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:121,Energy Efficiency,allocate,allocate,121,/// setUseLocalStackAllocationBlock - Set whether the local allocation blob; /// should be allocated together or let PEI allocate the locals in it; /// directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Energy Efficiency,allocate,allocated,38,/// Return true if the object was pre-allocated into the local block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:49,Performance,scalab,scalable,49,// Only ensure max alignment for the default and scalable vector stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:44,Energy Efficiency,allocate,allocated,44,/// Return the number of bytes that must be allocated to hold; /// all of the fixed size frame objects. This is only valid after; /// Prolog/Epilog code insertion has finalized the stack frame layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:70,Availability,down,down,70,/// Returns true if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:116,Availability,avail,available,116,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,Energy Efficiency,allocate,allocated,62,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:21,Testability,assert,assert,21,"// TODO: Enable this assert when targets are fixed.; //assert(isMaxCallFrameSizeComputed() && ""MaxCallFrameSize not computed yet"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:55,Testability,assert,assert,55,"// TODO: Enable this assert when targets are fixed.; //assert(isMaxCallFrameSizeComputed() && ""MaxCallFrameSize not computed yet"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:104,Deployability,update,updated,104,"// If ID > 0, MaxAlignment may now be overly conservative.; // If ID == 0, MaxAlignment will need to be updated separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:57,Modifiability,variab,variable,57,/// Returns true if the specified index corresponds to a variable sized; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:46,Modifiability,variab,variable,46,"/// Notify the MachineFrameInfo object that a variable sized object has been; /// created. This must be created whenever a variable sized object is; /// created, whether or not the index returned is actually used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:123,Modifiability,variab,variable,123,"/// Notify the MachineFrameInfo object that a variable sized object has been; /// created. This must be created whenever a variable sized object is; /// created, whether or not the index returned is actually used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:177,Security,access,accessed,177,/// MachineFunctionInfo - This class can be derived from and used by targets to; /// hold private target-specific information for each MachineFunction. Objects; /// of type are accessed/created with MF::getInfo and destroyed when the; /// MachineFunction is destroyed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,extend,extend,35,"// Possible TODO: Allow targets to extend this (perhaps by allowing the; // constructor to specify the size of the bit vector); // Possible TODO: Allow requiring the negative (e.g. VRegsAllocated could be; // stated as the negative of ""has vregs""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:969,Availability,reliab,reliable,969,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:2635,Deployability,pipeline,pipeline,2635,"y not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it; // means that tied-def have been rewritten to meet the RegConstraint.; // FailsVerification: Means that the function is not expected to pass machine; // verification. This can be set by passes that introduce known problems that; // have not been fixed yet.; // TracksDebugUserValues: Without this property enabled, debug instructions; // such as DBG_VALUE are allowed to reference virtual registers even if those; // registers do not have a definition. With the property enabled virtual; // registers must only be used if they have a definition. This property; // allows earlier passes in the pipeline to skip updates of `DBG_VALUE`; // instructions to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:2652,Deployability,update,updates,2652,"y not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it; // means that tied-def have been rewritten to meet the RegConstraint.; // FailsVerification: Means that the function is not expected to pass machine; // verification. This can be set by passes that introduce known problems that; // have not been fixed yet.; // TracksDebugUserValues: Without this property enabled, debug instructions; // such as DBG_VALUE are allowed to reference virtual registers even if those; // registers do not have a definition. With the property enabled virtual; // registers must only be used if they have a definition. This property; // allows earlier passes in the pipeline to skip updates of `DBG_VALUE`; // instructions to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:914,Usability,clear,cleared,914,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Availability,recover,recover,24,/// Address of block to recover at. Null for a finally handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Safety,recover,recover,24,/// Address of block to recover at. Null for a finally handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,Energy Efficiency,allocate,allocated,25,// Keep track of objects allocated on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:8,Energy Efficiency,allocate,allocate,8,// Pool-allocate MachineFunction-lifetime and IR objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,Performance,optimiz,optimizations,189,"/// ExposesReturnsTwice - True if the function calls setjmp or related; /// functions with attribute ""returns twice"", but doesn't have; /// the attribute itself.; /// This is used to limit optimizations which cannot reason; /// about the control flow of such functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Security,Expose,ExposesReturnsTwice,4,"/// ExposesReturnsTwice - True if the function calls setjmp or related; /// functions with attribute ""returns twice"", but doesn't have; /// the attribute itself.; /// This is used to limit optimizations which cannot reason; /// about the control flow of such functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:117,Energy Efficiency,allocate,allocated,117,/// Current high-level properties of the IR of the function (e.g. is in SSA; /// form or whether registers have been allocated),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:184,Energy Efficiency,allocate,allocated,184,"/// \}; /// Clear all the members of this MachineFunction, but the ones used; /// to initialize again the MachineFunction.; /// More specifically, this deallocates all the dynamically allocated; /// objects and get rid of all the XXXInfo data structure, but keep; /// unchanged the references to Fn, Target, MMI, and FunctionNumber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:12,Usability,Clear,Clear,12,"/// \}; /// Clear all the members of this MachineFunction, but the ones used; /// to initialize again the MachineFunction.; /// More specifically, this deallocates all the dynamically allocated; /// objects and get rid of all the XXXInfo data structure, but keep; /// unchanged the references to Fn, Target, MMI, and FunctionNumber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate and initialize the different members.; /// In particular, the XXXInfo data structure.; /// \pre Fn, Target, MMI, and FunctionNumber are properly set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:37,Modifiability,variab,variable,37,"/// Description of the location of a variable whose Address is valid and; /// unchanging during function execution. The Address may be:; /// * A stack index, which can be negative for fixed stack objects.; /// * A MCRegister, whose entry value contains the address of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:272,Modifiability,variab,variable,272,"/// Description of the location of a variable whose Address is valid and; /// unchanging during function execution. The Address may be:; /// * A stack index, which can be negative for fixed stack objects.; /// * A MCRegister, whose entry value contains the address of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Modifiability,variab,variable,24,/// Return true if this variable is in a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Modifiability,variab,variable,24,/// Return true if this variable is in the entry value of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Returns the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Returns the MCRegister of this variable, assuming; /// `inEntryValueRegister()` is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Deployability,Update,Updates,4,"/// Updates the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Updates the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:14,Security,access,accessed,14,// Need to be accessed from MachineInstr::setDesc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:49,Safety,Avoid,Avoid,49,/// Set value of DebugInstrNumberingCount field. Avoid using this unless; /// you're deserializing this data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,Availability,recover,recovery,217,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:234,Modifiability,variab,variable,234,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,Safety,recover,recovery,217,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:233,Availability,mainten,maintenance,233,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:60,Modifiability,variab,variable,60,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:122,Performance,Load,Loaded,122,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:131,Performance,optimiz,optimization,131,"/// Create substitutions for any tracked values in \p Old, to point at; /// \p New. Needed when we re-create an instruction during optimization,; /// which has the same signature (i.e., def operands in the same place) but; /// a modified instruction type, flags, or otherwise. An example: X86 moves; /// are sometimes transformed into equivalent LEAs.; /// If the two instructions are not the same opcode, limit which operands to; /// examine for substitutions to the first N operands by setting; /// \p MaxOperand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:673,Performance,cache,cache,673,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:256,Safety,avoid,avoided,256,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:46,Deployability,configurat,configuration,46,"/// Determine whether, in the current machine configuration, we should use; /// instruction referencing or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:46,Modifiability,config,configuration,46,"/// Determine whether, in the current machine configuration, we should use; /// instruction referencing or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,/// Returns true if the function's variable locations are tracked with; /// instruction referencing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:56,Testability,assert,assert,56,/// Reset the currently registered delegate - otherwise assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:126,Energy Efficiency,allocate,allocated,126,/// getFrameInfo - Return the frame info object for the current function.; /// This object contains information about objects allocated on the stack; /// frame of the current function in an abstract way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:103,Energy Efficiency,allocate,allocate,103,"/// getOrCreateJumpTableInfo - Get the JumpTableInfo for this function, if it; /// does already exist, allocate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Security,expose,exposesReturnsTwice,4,"/// exposesReturnsTwice - Returns true if the function calls setjmp or; /// any other similar functions with attribute ""returns twice"" without; /// having the attribute itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:51,Energy Efficiency,allocate,allocated,51,/// getNumBlockIDs - Return the number of MBB ID's allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:262,Integrability,depend,depends,262,"/// viewCFG - This function is meant for use from the debugger. You can just; /// say 'call F->viewCFG()' and a ghostview window should pop up from the; /// program, displaying the CFG of the current function with the code for each; /// basic block inside. This depends on there being a 'dot' and 'gv' program; /// in your path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:11,Security,access,accessors,11,// Provide accessors for the MachineBasicBlock list...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:94,Security,access,accessor,94,//===--------------------------------------------------------------------===//; // BasicBlock accessor functions.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,Energy Efficiency,Allocate,Allocate,25,/// CreateMachineInstr - Allocate a new MachineInstr. Use this instead; /// of `new MachineInstr'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:259,Performance,perform,perform,259,"/// Create a new MachineInstr which is a copy of \p Orig, identical in all; /// ways except the instruction has no parent, prev, or next. Bundling flags; /// are reset.; ///; /// Note: Clones a single instruction, not whole instruction bundles.; /// Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:140,Performance,perform,perform,140,/// Clones instruction or the whole instruction bundle \p Orig and insert; /// into \p MBB before \p InsertBefore.; ///; /// Note: Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Energy Efficiency,Allocate,Allocate,30,/// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this; /// instead of `new MachineBasicBlock'. Sets `MachineBasicBlock::BBID` if; /// basic-block-sections is enabled for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,/// getMachineMemOperand - Allocate a new MachineMemOperand.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,"/// getMachineMemOperand - Allocate a new MachineMemOperand by copying; /// an existing one, adjusting by an offset and using the given size.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,"/// getMachineMemOperand - Allocate a new MachineMemOperand by copying; /// an existing one, replacing only the MachinePointerInfo and size.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing only AliasAnalysis information. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing the flags. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate an array of MachineOperands. This is only intended for use by; /// internal MachineInstr functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,Energy Efficiency,allocate,allocate,189,/// Dellocate an array of MachineOperands and recycle the memory. This is; /// only intended for use by internal MachineInstr functions.; /// Cap must be the same capacity that was used to allocate the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:39,Availability,mask,mask,39,/// Allocate and initialize a register mask with @p NumRegister bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and initialize a register mask with @p NumRegister bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and construct an extra info structure for a `MachineInstr`.; ///; /// This is allocated on the function's allocator and so lives the life of; /// the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:91,Energy Efficiency,allocate,allocated,91,/// Allocate and construct an extra info structure for a `MachineInstr`.; ///; /// This is allocated on the function's allocator and so lives the life of; /// the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a string and populate it with the given external symbol name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:72,Modifiability,variab,variable,72,/// \}; /// Collect information used to emit debugging information of a variable in a; /// stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:64,Modifiability,variab,variable,64,/// Collect information used to emit debugging information of a variable in; /// the entry value of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned an entry value register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Deployability,update,update,24,"/// Following functions update call site info. They should be called before; /// removing, replacing or copying call instruction.; /// Erase the call site info for \p MI. It is used to remove a call; /// instruction from the instruction stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:37,Energy Efficiency,adapt,adapts,37,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:61,Integrability,interface,interface,61,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:37,Modifiability,adapt,adapts,37,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:3,Performance,Cache,Cache,3,// Cache the properties info at module-init time so we don't have to; // construct them for every function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:61,Performance,perform,perform,61,/// runOnMachineFunction - This method must be overloaded to perform the; /// desired machine code transformation or analysis.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:498,Integrability,depend,dependent,498,"//===- llvm/CodeGen/MachineInstr.h - MachineInstr class ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the MachineInstr class, which is the; // basic representation for all target dependent machine instructions used by; // the back end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:38,Integrability,contract,contraction,38,// Instruction supports Fast math; // contraction operations like fma.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:56,Integrability,wrap,wrap,56,// Instruction supports binary operator; // no unsigned wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:54,Integrability,wrap,wrap,54,// Instruction supports binary operator; // no signed wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:55,Energy Efficiency,allocate,allocated,55,// Pointer to the owning basic block.; // Operands are allocated by an ArrayRecycler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:136,Performance,optimiz,optimized,136,"// Description of the extra info, used to interpret the actual optional; // data appended.; //; // Note that this is not terribly space optimized. This leaves a great deal; // of flexibility to fit more in here later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:94,Integrability,rout,routine,94,// Just a boring constructor to allow us to initialize the sizes. Always use; // the `create` routine above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:50,Availability,avail,available,50,/// Enumeration of the kinds of inline extra info available. It is important; /// that the `MachineMemOperand` inline kind has a tag value of zero to make; /// it accessible as an `ArrayRef`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:163,Security,access,accessible,163,/// Enumeration of the kinds of inline extra info available. It is important; /// that the `MachineMemOperand` inline kind has a tag value of zero to make; /// it accessible as an `ArrayRef`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:170,Performance,optimiz,optimize,170,"// We store extra information about the instruction here. The common case is; // expected to be nothing or a single pointer (typically a MMO or a symbol).; // We work to optimize this common case by storing it inline here rather than; // requiring a separate allocation, but we fall back to an allocation when; // multiple pointers are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:26,Energy Efficiency,allocate,allocated,26,// MachineInstrs are pool-allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear the AsmPrinter bitvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear specific AsmPrinter flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,clear,clearFlag,4,/// clearFlag - Clear a MI flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:16,Usability,Clear,Clear,16,/// clearFlag - Clear a MI flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:37,Modifiability,variab,variable,37,/// Return the operand for the debug variable referenced by; /// this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:21,Modifiability,variab,variable,21,/// Return the debug variable referenced by; /// this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:49,Safety,Avoid,Avoid,49,/// Set instruction number of this MachineInstr. Avoid using unless you're; /// deserializing this information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:13,Modifiability,variab,variable,13,/// Drop any variable location debugging information associated with this; /// instruction. Use when an instruction is modified in such a way that it no; /// longer defines the value it used to. Variable locations using that value; /// will be dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:195,Modifiability,Variab,Variable,195,/// Drop any variable location debugging information associated with this; /// instruction. Use when an instruction is modified in such a way that it no; /// longer defines the value it used to. Variable locations using that value; /// will be dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:12,Availability,error,error,12,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:172,Availability,error,errors,172,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:282,Availability,recover,recover,282,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:299,Availability,error,error,299,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:282,Safety,recover,recover,282,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:69,Modifiability,variab,variable,69,/// Returns a range over all operands that are used to determine the variable; /// location for this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction. If there are none, that does; /// not imply anything about whether the function accesses memory. Instead,; /// the caller must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:130,Security,access,accesses,130,"/// Access to memory operands of the instruction. If there are none, that does; /// not imply anything about whether the function accesses memory. Instead,; /// the caller must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:168,Security,access,accesses,168,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:168,Security,access,accesses,168,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:85,Security,access,access,85,"/// Return true if we don't have any memory operands which described the; /// memory access done by this instruction. If this is true, calling code; /// must be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:33,Security,hash,hash,33,/// Helper to extract a CFI type hash if one has been added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:47,Modifiability,variab,variable,47,"/// Return true if this instruction can have a variable number of operands.; /// In this case, the variable operands will be after the normal; /// operands but before the implicit definitions and uses (if any are; /// present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:99,Modifiability,variab,variable,99,"/// Return true if this instruction can have a variable number of operands.; /// In this case, the variable operands will be after the normal; /// operands but before the implicit definitions and uses (if any are; /// present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:190,Availability,error,errors,190,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:46,Safety,safe,safely,46,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:104,Integrability,depend,dependent,104,/// Return true if this instruction is convergent.; /// Convergent instructions can not be made control-dependent on any; /// additional values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:165,Performance,load,loads,165,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:210,Performance,load,loaded,210,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:320,Performance,load,loads,320,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:158,Usability,simpl,simple,158,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:243,Performance,optimiz,optimizers,243,"/// Return true if this instruction behaves; /// the same way as the generic REG_SEQUENCE instructions.; /// E.g., on ARM,; /// dX VMOVDRR rY, rZ; /// is equivalent to; /// dX = REG_SEQUENCE rY, ssub_0, rZ, ssub_1.; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getRegSequenceLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:290,Performance,optimiz,optimizers,290,"/// Return true if this instruction behaves; /// the same way as the generic EXTRACT_SUBREG instructions.; /// E.g., on ARM,; /// rX, rY VMOVRRD dZ; /// is equivalent to two EXTRACT_SUBREG:; /// rX = EXTRACT_SUBREG dZ, ssub_0; /// rY = EXTRACT_SUBREG dZ, ssub_1; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getExtractSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:281,Performance,optimiz,optimizers,281,"/// Return true if this instruction behaves; /// the same way as the generic INSERT_SUBREG instructions.; /// E.g., on ARM,; /// dX = VSETLNi32 dY, rZ, Imm; /// is equivalent to a INSERT_SUBREG:; /// dX = INSERT_SUBREG dY, rZ, translateImmToSubIdx(Imm); ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getInsertSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:313,Performance,load,load,313,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:346,Performance,load,load,346,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:306,Usability,simpl,simple,306,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:123,Usability,simpl,simple,123,"/// Return true if this instruction could possibly modify memory.; /// Instructions with this flag set are not necessarily simple store; /// instructions, they may store a modified value based on their operands, or; /// may not actually modify anything, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:303,Energy Efficiency,efficient,efficient,303,"/// Return true if this is a 2-address instruction; /// which can be changed into a 3-address instruction if needed. Doing this; /// transformation can be profitable in the register allocator, because it; /// means that the instruction can use a 2-address form if possible, but; /// degrade into a less efficient form if the source and dest register cannot; /// be assigned to the same register. For example, this allows the x86; /// backend to turn a ""shl reg, 3"" instruction into an LEA instruction, which; /// is the same speed as the shift but has bigger code size.; ///; /// If this returns true, then the target must implement the; /// TargetInstrInfo::convertToThreeAddress method for this instruction, which; /// is allowed to fail if the transformation isn't valid for this specific; /// instruction (e.g. shl reg, 4 on x86).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:88,Energy Efficiency,schedul,scheduler,88,"/// Return true if this instruction requires; /// custom insertion support when the DAG scheduler is inserting it into a; /// machine basic block. If this is true for the instruction, it basically; /// means that it is a pseudo instruction used at SelectionDAG time that is; /// expanded out into magic code by the target when MachineInstrs are formed.; ///; /// If this is true, the TargetLoweringInfo::InsertAtEndOfBasicBlock method; /// is used to insert this into the MachineBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:188,Integrability,depend,depending,188,"/// Return true if this instruction requires *adjustment*; /// after instruction selection by calling a target hook. For example, this; /// can be used to fill in ARM 's' optional operand depending on whether; /// the conditional flag register is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:134,Performance,optimiz,optimizations,134,"/// Returns true if this instruction has the same cost (or less) than a move; /// instruction. This is useful during certain types of optimizations; /// (e.g., remat during two-address conversion or machine licm); /// where we would like to remat or hoist the instruction, but not if it costs; /// more than moving the instruction into the appropriate register. Note, we; /// are not marking copies from and to the same register class with this flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:212,Modifiability,variab,variables,212,"/// Returns true if this instruction is a debug instruction that represents an; /// identical debug value to \p Other.; /// This function considers these debug instructions equivalent if they have; /// identical variables, debug locations, and debug operands, and if the; /// DIExpressions combined with the directness flags are equivalent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:85,Modifiability,variab,variable,85,/// Return true if the instruction is a debug value which describes a part of; /// a variable as unavailable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:62,Performance,load,load,62,/// Returns true if the register operand can be folded with a load or store; /// into a frame index. Does so by checking the InlineAsm::Flag immediate; /// operand at OpId - 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper for findRegisterUseOperandIdx, it returns; /// a pointer to the MachineOperand rather than an index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:394,Availability,mask,mask,394,"/// Returns the operand index that is a def of the specified register or; /// -1 if it is not found. If isDead is true, defs that are not dead are; /// skipped. If Overlap is true, then it also looks for defs that merely; /// overlap the specified register. If TargetRegisterInfo is non-null,; /// then it also checks if there is a def of a super-register.; /// This may also return a register mask operand when Overlap is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper for findRegisterDefOperandIdx, it returns; /// a pointer to the MachineOperand rather than an index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clears,4,/// Clears kill flags on all operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,"/// Clear all kill flags affecting Reg. If RegInfo is provided, this includes; /// all aliasing registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear all dead flags on operands defining register @p Reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:136,Availability,mask,mask,136,"/// Mark every physreg used by this instruction as; /// dead except those in the UsedRegs list.; ///; /// On instructions with register mask operands, also add implicit-def; /// operands for all registers in UsedRegs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:25,Safety,safe,safe,25,"/// Return true if it is safe to move this instruction. If; /// SawStore is set to true, it means that there is a store (or call) between; /// the instruction's location and its intended destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:46,Security,access,access,46,"/// Returns true if this instruction's memory access aliases the memory; /// access of Other.; //; /// Assumes any physical registers used to compute addresses; /// have the same value for both instructions. Returns false if neither; /// instruction writes to memory.; ///; /// @param AA Optional alias analysis, used to compare memory operands.; /// @param Other MachineInstr to check aliasing against.; /// @param UseTBAA Whether to pass TBAA information to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:77,Security,access,access,77,"/// Returns true if this instruction's memory access aliases the memory; /// access of Other.; //; /// Assumes any physical registers used to compute addresses; /// have the same value for both instructions. Returns false if neither; /// instruction writes to memory.; ///; /// @param AA Optional alias analysis, used to compare memory operands.; /// @param Other MachineInstr to check aliasing against.; /// @param UseTBAA Whether to pass TBAA information to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:157,Availability,avail,available,157,"/// Return true if this instruction may have an ordered; /// or volatile memory reference, or if the information describing the memory; /// reference is not available. Return false if it is known to have no; /// ordered or volatile memory references.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:24,Performance,load,load,24,"/// Return true if this load instruction never traps and points to a memory; /// location whose value doesn't change during the execution of this function.; ///; /// Examples include loading a value from the constant pool or from the; /// argument area of a function (if it does not change). If the instruction; /// does multiple loads, this returns true only if all of the loads are; /// dereferenceable and invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:183,Performance,load,loading,183,"/// Return true if this load instruction never traps and points to a memory; /// location whose value doesn't change during the execution of this function.; ///; /// Examples include loading a value from the constant pool or from the; /// argument area of a function (if it does not change). If the instruction; /// does multiple loads, this returns true only if all of the loads are; /// dereferenceable and invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:330,Performance,load,loads,330,"/// Return true if this load instruction never traps and points to a memory; /// location whose value doesn't change during the execution of this function.; ///; /// Examples include loading a value from the constant pool or from the; /// argument area of a function (if it does not change). If the instruction; /// does multiple loads, this returns true only if all of the loads are; /// dereferenceable and invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:374,Performance,load,loads,374,"/// Return true if this load instruction never traps and points to a memory; /// location whose value doesn't change during the execution of this function.; ///; /// Examples include loading a value from the constant pool or from the; /// argument area of a function (if it does not change). If the instruction; /// does multiple loads, this returns true only if all of the loads are; /// dereferenceable and invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:44,Performance,load,load,44,/// Returns true if it is illegal to fold a load across this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:457,Energy Efficiency,allocate,allocate,457,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:546,Integrability,interface,interface,546,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:91,Security,Access,Accessors,91,"/// @}; //===--------------------------------------------------------------------===//; // Accessors used to build up machine instructions.; /// Add the specified operand to the instruction. If it is an implicit; /// operand, it is added to the end of the operand list. If it is an; /// explicit operand it is added at the end of the explicit operand list; /// (before the first implicit operand).; ///; /// MF must be the machine function that was used to allocate this; /// instruction.; ///; /// MachineInstrBuilder provides a more convenient interface for creating; /// instructions and adding operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:59,Safety,Avoid,Avoid,59,"/// Replace current source information with new such.; /// Avoid using this, the constructor argument is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:242,Performance,perform,performed,242,/// Clear this MachineInstr's memory reference descriptor list. This resets; /// the memrefs to their most conservative state. This should be used only; /// as a last resort since it greatly pessimizes our knowledge of the memory; /// access performed by the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:235,Security,access,access,235,/// Clear this MachineInstr's memory reference descriptor list. This resets; /// the memrefs to their most conservative state. This should be used only; /// as a last resort since it greatly pessimizes our knowledge of the memory; /// access performed by the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear this MachineInstr's memory reference descriptor list. This resets; /// the memrefs to their most conservative state. This should be used only; /// as a last resort since it greatly pessimizes our knowledge of the memory; /// access performed by the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:109,Energy Efficiency,allocate,allocate,109,"/// Assign this MachineInstr's memory reference descriptor list.; ///; /// Unlike other methods, this *will* allocate them into a new array; /// associated with the provided `MachineFunction`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:203,Safety,avoid,avoid,203,/// Clone another MachineInstr's memory reference descriptor list and replace; /// ours with it.; ///; /// Note that `*this` may be the incoming MI!; ///; /// Prefer this API whenever possible as it can avoid allocations in common; /// cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:226,Safety,avoid,avoid,226,/// Clone the merge of multiple MachineInstrs' memory reference descriptors; /// list and replace ours with it.; ///; /// Note that `*this` may be one of the incoming MIs!; ///; /// Prefer this API whenever possible as it can avoid allocations in common; /// cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:161,Performance,optimiz,optimizations,161,"/// Set a marker on instructions that denotes where we should create and emit; /// heap alloc site labels. This waits until after instruction selection and; /// optimizations to create the label, so it should still work if the; /// instruction is removed or duplicated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:130,Integrability,rout,routine,130,/// Return the MIFlags which represent both MachineInstrs. This; /// should be used when merging two MachineInstrs into one. This routine does; /// not modify the MIFlags of this MachineInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:19,Testability,log,logic,19,"/// Implements the logic of getRegClassConstraintEffectForVReg for the; /// this MI and the given operand index \p OpIdx.; /// If the related operand does not constrained Reg, this returns CurRC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:51,Energy Efficiency,allocate,allocates,51,/// Stores extra instruction information inline or allocates as ExtraInfo; /// based on the number of pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:131,Security,hash,hashing,131,"/// Special DenseMapInfo traits to compare MachineInstr* by *value* of the; /// instruction rather than by pointer value.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:152,Testability,test,testing,152,"/// Special DenseMapInfo traits to compare MachineInstr* by *value* of the; /// instruction rather than by pointer value.; /// The hashing and equality testing functions ignore definitions so this is; /// useful for CSE, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:394,Security,expose,exposes,394,"//===- CodeGen/MachineInstrBuilder.h - Simplify creation of MIs --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes a function named BuildMI, which is useful for dramatically; // simplifying how MachineInstr's are created. It allows use of code like this:; //; // MIMetadata MIMD(MI); // Propagates DebugLoc and other metadata; // M = BuildMI(MBB, MI, MIMD, TII.get(X86::ADD8rr), Dst); // .addReg(argVal1); // .addReg(argVal2);; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:39,Usability,Simpl,Simplify,39,"//===- CodeGen/MachineInstrBuilder.h - Simplify creation of MIs --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes a function named BuildMI, which is useful for dramatically; // simplifying how MachineInstr's are created. It allows use of code like this:; //; // MIMetadata MIMD(MI); // Propagates DebugLoc and other metadata; // M = BuildMI(MBB, MI, MIMD, TII.get(X86::ADD8rr), Dst); // .addReg(argVal1); // .addReg(argVal2);; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:465,Usability,simpl,simplifying,465,"//===- CodeGen/MachineInstrBuilder.h - Simplify creation of MIs --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes a function named BuildMI, which is useful for dramatically; // simplifying how MachineInstr's are created. It allows use of code like this:; //; // MIMetadata MIMD(MI); // Propagates DebugLoc and other metadata; // M = BuildMI(MBB, MI, MIMD, TII.get(X86::ADD8rr), Dst); // .addReg(argVal1); // .addReg(argVal2);; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:128,Energy Efficiency,allocate,allocate,128,/// Create a MachineInstrBuilder for manipulating an existing instruction.; /// F must be the machine function that was used to allocate I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:96,Testability,assert,asserted,96,/// Get the register for the operand index.; /// The operand at the index should be a register (asserted by; /// MachineOperand).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:49,Availability,error,error,49,/// Add a virtual register use operand. It is an error for Flags to contain; /// `RegState::Define` when calling this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:187,Usability,clear,clear,187,"// If caller specifies new TargetFlags then use it, otherwise the; // default behavior is to copy the target flags from the existing; // MachineOperand. This means if the caller wants to clear the; // target flags it needs to do so explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:12,Integrability,interface,interface,12,/// Builder interface. Specify how to create the initial instruction itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:97,Availability,avail,available,97,"// Calling the overload for instr_iterator is always correct. However, the; // definition is not available in headers, so inline the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:97,Availability,avail,available,97,"// Calling the overload for instr_iterator is always correct. However, the; // definition is not available in headers, so inline the check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:4,Deployability,Update,Update,4,/// Update a DBG_VALUE whose value has been spilled to FrameIndex. Useful when; /// modifying an instruction in place while iterating over a basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h:94,Deployability,Update,Update,94,"// MI was inserted in the middle of the bundle, so its neighbors' flags are; // already fine. Update MI's bundle flags manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h:161,Integrability,rout,routine,161,"/// finalizeBundle - Finalize a machine instruction bundle which includes; /// a sequence of instructions starting from FirstMI to LastMI (exclusive).; /// This routine adds a BUNDLE instruction to represent the bundle, it adds; /// IsInternalRead markers to MachineOperands which are defined inside the; /// bundle, and it copies externally visible defs and uses to the BUNDLE; /// instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h:26,Availability,mask,masks,26,"/// Return a pair of lane masks (reads, writes) indicating which lanes this; /// instruction uses with Reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundle.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of R.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:3,Safety,Avoid,Avoid,3,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h:9,Testability,assert,assertion,9,// Avoid assertion about validity of L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstrBundleIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h:70,Deployability,update,update,70,"/// ReplaceMBBInJumpTables - If Old is the target of any jump tables, update; /// the jump tables to branch to New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h:67,Deployability,update,update,67,"/// ReplaceMBBInJumpTable - If Old is a target of the jump tables, update; /// the jump table to branch to New instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineJumpTableInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h:50,Modifiability,variab,variable,50,"/// Find the block that contains the loop control variable and the; /// loop test. This will return the latch block if it's one of the exiting; /// blocks. Otherwise, return the exiting block. Return 'null' when; /// multiple exiting blocks are present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h:77,Testability,test,test,77,"/// Find the block that contains the loop control variable and the; /// loop test. This will return the latch block if it's one of the exiting; /// blocks. Otherwise, return the exiting block. Return 'null' when; /// multiple exiting blocks are present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h:160,Security,access,accessed,160,"/// Returns true if the instruction is loop invariant.; /// I.e., all virtual register operands are defined outside of the loop,; /// physical registers aren't accessed explicitly, and there are no side; /// effects that aren't captured by the operands or other flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h:17,Integrability,interface,interface,17,/// The iterator interface to the top-level loops in the current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h:394,Deployability,update,updated,394,"/// Peels a single block loop. Loop must have two successors, one of which; /// must be itself. Similarly it must have two predecessors, one of which must; /// be itself.; ///; /// The loop block is copied and inserted into the CFG such that two copies of; /// the loop follow on from each other. The copy is inserted either before or; /// after the loop based on Direction.; ///; /// Phis are updated and an unconditional branch inserted at the end of the; /// clone so as to execute a single iteration.; ///; /// The trip count of Loop is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h:545,Deployability,update,updated,545,"/// Peels a single block loop. Loop must have two successors, one of which; /// must be itself. Similarly it must have two predecessors, one of which must; /// be itself.; ///; /// The loop block is copied and inserted into the CFG such that two copies of; /// the loop follow on from each other. The copy is inserted either before or; /// after the loop based on Direction.; ///; /// Phis are updated and an unconditional branch inserted at the end of the; /// clone so as to execute a single iteration.; ///; /// The trip count of Loop is not updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineLoopUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:525,Integrability,depend,dependencies,525,"//==- llvm/CodeGen/MachineMemOperand.h - MachineMemOperand class -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the MachineMemOperand class, which is a; // description of a memory reference. It is used to help track dependencies; // in the backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:193,Security,expose,exposed,193,"/// This class contains a discriminated union of information about pointers in; /// memory operands, relating them back to LLVM IR or to virtual locations (such; /// as frame indices) that are exposed during codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:41,Security,access,access,41,"/// This is the IR pointer value for the access, or it is null if unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:27,Security,access,access,27,/// Stack pointer relative access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:182,Performance,Load,LoadInst,182,"//===----------------------------------------------------------------------===//; /// A description of a memory reference used in the backend.; /// Instead of holding a StoreInst or LoadInst, this class holds the address; /// Value of the reference along with a byte size and offset. This allows it; /// to describe lowered loads and stores. Also, the special PseudoSourceValue; /// objects can be used to represent loads and stores to memory locations; /// that aren't explicit in the regular LLVM IR.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:324,Performance,load,loads,324,"//===----------------------------------------------------------------------===//; /// A description of a memory reference used in the backend.; /// Instead of holding a StoreInst or LoadInst, this class holds the address; /// Value of the reference along with a byte size and offset. This allows it; /// to describe lowered loads and stores. Also, the special PseudoSourceValue; /// objects can be used to represent loads and stores to memory locations; /// that aren't explicit in the regular LLVM IR.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:416,Performance,load,loads,416,"//===----------------------------------------------------------------------===//; /// A description of a memory reference used in the backend.; /// Instead of holding a StoreInst or LoadInst, this class holds the address; /// Value of the reference along with a byte size and offset. This allows it; /// to describe lowered loads and stores. Also, the special PseudoSourceValue; /// objects can be used to represent loads and stores to memory locations; /// that aren't explicit in the regular LLVM IR.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,/// The memory access reads data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,/// The memory access writes data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,/// The memory access is volatile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,/// The memory access is non-temporal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,"/// The memory access is dereferenceable (i.e., doesn't trap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:15,Security,access,access,15,/// The memory access always returns the same value (or traps).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:258,Deployability,update,updated,258,"// Reserved for use by target-specific passes.; // Targets may override getSerializableMachineMemOperandTargetFlags() to; // enable MIR serialization/parsing of these flags. If more of these flags; // are added, the MIR printing/parsing code will need to be updated as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:4,Integrability,Synchroniz,Synchronization,4,/// Synchronization scope ID for this memory operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:33,Security,access,access,33,/// Track the memory type of the access. An access size which is unknown or; /// too large to be represented by LLT should use the invalid LLT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:44,Security,access,access,44,/// Track the memory type of the access. An access size which is unknown or; /// too large to be represented by LLT should use the invalid LLT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:133,Integrability,synchroniz,synchronization,133,"/// Construct a MachineMemOperand object with the specified PtrInfo, flags,; /// size, and base alignment. For atomic operations the synchronization scope; /// and atomic ordering requirements must also be specified. For cmpxchg; /// atomic operations the atomic ordering requirements when store does not; /// occur must also be specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:42,Security,access,access,42,"/// Return the base address of the memory access. This may either be a normal; /// LLVM IR Value, or one of the special values used in CodeGen.; /// Special values are those obtained via; /// PseudoSourceValue::getFixedStack(int), PseudoSourceValue::getStack, and; /// other PseudoSourceValue member functions which return objects which stand; /// for frame/stack pointer relative references and other special references; /// which are not representable in the high-level IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:16,Integrability,synchroniz,synchronization,16,/// Returns the synchronization scope ID for this memory operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:92,Availability,failure,failure,92,"/// Return a single atomic ordering that is at least as strong as both the; /// success and failure orderings for an atomic operation. (For operations; /// other than cmpxchg, this is equivalent to getSuccessOrdering().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:4,Deployability,Update,Update,4,"/// Update this MachineMemOperand to reflect the alignment of MMO, if it has a; /// greater alignment. This must only be used when the new alignment applies; /// to all users of this MachineMemOperand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:159,Deployability,update,updated,159,/// Change the SourceValue for this MachineMemOperand. This should only be; /// used when an object is being relocated and all references to it are being; /// updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:228,Security,access,accessed,228,//===----------------------------------------------------------------------===//; /// This class can be derived from and used by targets to hold private; /// target-specific information for each Module. Objects of type are; /// accessed/created with MachineModuleInfo::getObjFileInfo and destroyed when; /// the MachineModuleInfo is destroyed.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:76,Usability,Clear,Clears,76,/// Return the entries from a DenseMap in a deterministic sorted orer.; /// Clears the map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:413,Availability,avail,available,413,"/// \}; // TODO: Ideally, what we'd like is to have a switch that allows emitting; // synchronous (precise at call-sites only) CFA into .eh_frame. However,; // even under this switch, we'd like .debug_frame to be precise when using; // -g. At this moment, there's no way to specify that some CFI directives; // go into .eh_frame only, while others go into .debug_frame only.; /// True if debugging information is available in this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:23,Availability,avail,available,23,/// Next unique number available for a MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:23,Performance,cache,cache,23,///< Used for shortcut/cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:23,Performance,cache,cache,23,///< Used for shortcut/cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:37,Testability,stub,stubs,37,"/// GVStubs - Darwin '$non_lazy_ptr' stubs. The key is something like; /// ""Lfoo$non_lazy_ptr"", the value is something like ""_foo"". The extra bit; /// is true if this GV is external.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:48,Testability,stub,stubs,48,"/// ThreadLocalGVStubs - Darwin '$non_lazy_ptr' stubs. The key is something; /// like ""Lfoo$non_lazy_ptr"", the value is something like ""_foo"". The extra; /// bit is true if this GV is external.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:4,Security,Access,Accessor,4,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:42,Testability,stub,stubs,42,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:20,Testability,stub,stubs,20,/// GVStubs - These stubs are used to materialize global addresses in PIC; /// mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:4,Security,Access,Accessor,4,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:42,Testability,stub,stubs,42,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:20,Testability,stub,stubs,20,/// GVStubs - These stubs are used to materialize global addresses in PIC; /// mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:4,Security,Access,Accessor,4,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h:42,Testability,stub,stubs,42,/// Accessor methods to return the set of stubs in sorted order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfoImpls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:310,Integrability,depend,depend,310,"/// MachineOperand class - Representation of each machine instruction operand.; ///; /// This class isn't a POD type because it has a private constructor, but its; /// destructor must be trivial. Functions like MachineInstr::addOperand(),; /// MachineRegisterInfo::moveOperands(), and MF::DeleteMachineInstr() depend on; /// not having to call the MachineOperand destructor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:12,Integrability,depend,dependent,12,///< Target-dependent index+offset operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:5,Availability,Mask,Mask,5,///< Mask of preserved registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:5,Availability,Mask,Mask,5,///< Mask of live-out registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:41,Availability,mask,masks,41,///< Other IR Constant for ISel (shuffle masks),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:510,Integrability,depend,depend,510,"/// IsUndef - True if this register operand reads an ""undef"" value, i.e. the; /// read value doesn't matter. This flag can be set on both use and def; /// operands. On a sub-register def operand, it refers to the part of the; /// register that isn't written. On a full-register def operand, it is a; /// noop. See readsReg().; ///; /// This is only valid on registers.; ///; /// Note that an instruction may have multiple <undef> operands referring to; /// the same register. In that case, the instruction may depend on those; /// operands reading the same dont-care value. For example:; ///; /// %1 = XOR undef %2, undef %2; ///; /// Any register can be used for %2, and its value doesn't matter, but; /// the two operands must be the same register.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:3,Security,Access,Access,3,// Access list for register. See MRI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:3,Testability,Assert,Assert,3,// Assert that the layout is what we expect. It's easy to grow this object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:4,Usability,clear,clearParent,4,"/// clearParent - Reset the parent pointer.; ///; /// The MachineOperand copy constructor also copies ParentMI, expecting the; /// original to be deleted. If a MachineOperand is ever stored outside a; /// MachineInstr, the parent pointer must be cleared.; ///; /// Never call clearParent() on an operand in a MachineInstr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:246,Usability,clear,cleared,246,"/// clearParent - Reset the parent pointer.; ///; /// The MachineOperand copy constructor also copies ParentMI, expecting the; /// original to be deleted. If a MachineOperand is ever stored outside a; /// MachineInstr, the parent pointer must be cleared.; ///; /// Never call clearParent() on an operand in a MachineInstr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:276,Usability,clear,clearParent,276,"/// clearParent - Reset the parent pointer.; ///; /// The MachineOperand copy constructor also copies ParentMI, expecting the; /// original to be deleted. If a MachineOperand is ever stored outside a; /// MachineInstr, the parent pointer must be cleared.; ///; /// Never call clearParent() on an operand in a MachineInstr.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:308,Integrability,depend,dependent,308,"/// More complex way of printing a MachineOperand.; /// \param TypeToPrint specifies the generic type to be printed on uses and; /// defs. It can be determined using MachineInstr::getTypeToPrint.; /// \param OpIdx - specifies the index of the operand in machine instruction.; /// This will be used by target dependent MIR formatter. Could be std::nullopt; /// if the index is unknown, e.g. called by dump().; /// \param PrintDef - whether we want to print `def` on an operand which; /// isDef. Sometimes, if the operand is printed before '=', we don't print; /// `def`.; /// \param IsStandalone - whether we want a verbose output of the MO. This; /// prints extra information that can be easily inferred when printing the; /// whole function, but not when printing only a fragment of it.; /// \param ShouldPrintRegisterTies - whether we want to print register ties.; /// Sometimes they are easily determined by the instruction's descriptor; /// (MachineInstr::hasComplexRegiterTies can determine if it's needed).; /// \param TiedOperandIdx - if we need to print register ties this needs to; /// provide the index of the tied register. If not, it will be ignored.; /// \param TRI - provide more target-specific information to the printer.; /// Unlike the previous function, this one will not try and get the; /// information from it's parent.; /// \param IntrinsicInfo - same as \p TRI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:83,Security,Access,Accessors,83,//===--------------------------------------------------------------------===//; // Accessors that tell you what kind of MachineOperand you're looking at.; //===--------------------------------------------------------------------===//; /// isReg - Tests if this is a MO_Register operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:247,Testability,Test,Tests,247,//===--------------------------------------------------------------------===//; // Accessors that tell you what kind of MachineOperand you're looking at.; //===--------------------------------------------------------------------===//; /// isReg - Tests if this is a MO_Register operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:12,Testability,Test,Tests,12,/// isImm - Tests if this is a MO_Immediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:13,Testability,Test,Test,13,/// isCImm - Test if this is a MO_CImmediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:14,Testability,Test,Tests,14,/// isFPImm - Tests if this is a MO_FPImmediate operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:12,Testability,Test,Tests,12,/// isMBB - Tests if this is a MO_MachineBasicBlock operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:11,Testability,Test,Tests,11,/// isFI - Tests if this is a MO_FrameIndex operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:12,Testability,Test,Tests,12,/// isCPI - Tests if this is a MO_ConstantPoolIndex operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:20,Testability,Test,Tests,20,/// isTargetIndex - Tests if this is a MO_TargetIndex operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:12,Testability,Test,Tests,12,/// isJTI - Tests if this is a MO_JumpTableIndex operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:15,Testability,Test,Tests,15,/// isGlobal - Tests if this is a MO_GlobalAddress operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:15,Testability,Test,Tests,15,/// isSymbol - Tests if this is a MO_ExternalSymbol operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:21,Testability,Test,Tests,21,/// isBlockAddress - Tests if this is a MO_BlockAddress operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:16,Testability,Test,Tests,16,/// isRegMask - Tests if this is a MO_RegisterMask operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:19,Testability,Test,Tests,19,/// isRegLiveOut - Tests if this is a MO_RegisterLiveOut operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:17,Testability,Test,Tests,17,/// isMetadata - Tests if this is a MO_Metadata operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:83,Security,Access,Accessors,83,//===--------------------------------------------------------------------===//; // Accessors for Register Operands; //===--------------------------------------------------------------------===//; /// getReg - Returns the register number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:1185,Integrability,depend,depend,1185,"/// isRenamable - Returns true if this register may be renamed, i.e. it does; /// not generate a value that is somehow read in a way that is not represented; /// by the Machine IR (e.g. to meet an ABI or ISA requirement). This is only; /// valid on physical register operands. Virtual registers are assumed to; /// always be renamable regardless of the value of this field.; ///; /// Operands that are renamable can freely be changed to any other register; /// that is a member of the register class returned by; /// MI->getRegClassConstraint().; ///; /// isRenamable can return false for several different reasons:; ///; /// - ABI constraints (since liveness is not always precisely modeled). We; /// conservatively handle these cases by setting all physical register; /// operands that didnt start out as virtual regs to not be renamable.; /// Also any physical register operands created after register allocation or; /// whose register is changed after register allocation will not be; /// renamable. This state is tracked in the MachineOperand::IsRenamable; /// bit.; ///; /// - Opcode/target constraints: for opcodes that have complex register class; /// requirements (e.g. that depend on other operands/instructions), we set; /// hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq in the machine opcode; /// description. Operands belonging to instructions with opcodes that are; /// marked hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq return false from; /// isRenamable(). Additionally, the AllowRegisterRenaming target property; /// prevents any operands from being marked renamable for targets that don't; /// have detailed opcode hasExtraSrcRegAllocReq/hasExtraDstRegAllocReq; /// values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:83,Security,Access,Accessors,83,//===--------------------------------------------------------------------===//; // Accessors for various operand types.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:123,Availability,mask,mask,123,/// clobbersPhysReg - Returns true if this RegMask clobbers PhysReg.; /// It is sometimes necessary to detach the register mask pointer from its; /// machine operand. This static method can be used for such detached bit; /// mask pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:225,Availability,mask,mask,225,/// clobbersPhysReg - Returns true if this RegMask clobbers PhysReg.; /// It is sometimes necessary to detach the register mask pointer from its; /// machine operand. This static method can be used for such detached bit; /// mask pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:31,Availability,mask,mask,31,/// getRegMask - Returns a bit mask of registers preserved by this RegMask; /// operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:34,Availability,mask,mask,34,/// getRegLiveOut - Returns a bit mask of live-out registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:27,Availability,mask,mask,27,"/// Sets value of register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it must; /// remain valid for the lifetime of the operand. See CreateRegMask().; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:52,Availability,Mask,Mask,52,"/// Sets value of register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it must; /// remain valid for the lifetime of the operand. See CreateRegMask().; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:127,Availability,Mask,Mask,127,"/// Sets value of register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it must; /// remain valid for the lifetime of the operand. See CreateRegMask().; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:250,Availability,mask,mask,250,"/// Sets value of register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it must; /// remain valid for the lifetime of the operand. See CreateRegMask().; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:102,Security,hash,hash,102,/// MachineOperand hash_value overload.; ///; /// Note that this includes the same information in the hash that; /// isIdenticalTo uses for comparison. It is thus suited for use in hash; /// tables which use that function for equality comparisons only. This must; /// stay exactly in sync with isIdenticalTo above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:181,Security,hash,hash,181,/// MachineOperand hash_value overload.; ///; /// Note that this includes the same information in the hash that; /// isIdenticalTo uses for comparison. It is thus suited for use in hash; /// tables which use that function for equality comparisons only. This must; /// stay exactly in sync with isIdenticalTo above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:174,Testability,Assert,Asserts,174,"/// getTargetIndexName - If this MachineOperand is a TargetIndex that has a; /// name, attempt to get the name. Returns nullptr if the TargetIndex does not; /// have a name. Asserts if MO is not a TargetIndex.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:39,Availability,mask,mask,39,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:64,Availability,Mask,Mask,64,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:139,Availability,Mask,Mask,139,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:369,Availability,mask,mask,369,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h:578,Availability,mask,mask,578,"/// CreateRegMask - Creates a register mask operand referencing Mask. The; /// operand does not take ownership of the memory referenced by Mask, it; /// must remain valid for the lifetime of the operand.; ///; /// A RegMask operand represents a set of non-clobbered physical registers; /// on an instruction that clobbers many registers, typically a call. The; /// bit mask has a bit set for each physreg that is preserved by this; /// instruction, as described in the documentation for; /// TargetRegisterInfo::getCallPreservedMask().; ///; /// Any physreg with a 0 bit in the mask is clobbered by the instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOperand.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:420,Integrability,interface,interfaces,420,"///===- MachineOptimizationRemarkEmitter.h - Opt Diagnostics -*- C++ -*----===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:534,Integrability,depend,dependent,534,"///===- MachineOptimizationRemarkEmitter.h - Opt Diagnostics -*- C++ -*----===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:622,Integrability,message,message,622,"///===- MachineOptimizationRemarkEmitter.h - Opt Diagnostics -*- C++ -*----===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:396,Performance,Optimiz,Optimization,396,"///===- MachineOptimizationRemarkEmitter.h - Opt Diagnostics -*- C++ -*----===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:49,Performance,optimiz,optimization,49,/// Common features for diagnostics dealing with optimization remarks; /// that are used by machine passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:39,Performance,optimiz,optimization,39,/// Diagnostic information for applied optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:296,Performance,optimiz,optimization,296,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass=, then the diagnostic will; /// be emitted. \p RemarkName is a textual identifier for the remark. \p; /// Loc is the debug location and \p MBB is the block that the optimization; /// operates in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:38,Performance,optimiz,optimization,38,/// Diagnostic information for missed-optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:308,Performance,optimiz,optimization,308,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-missed=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark. \p Loc is the debug location and \p MBB is the block that the; /// optimization operates in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:31,Performance,optimiz,optimization,31,/// Diagnostic information for optimization analysis remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:310,Performance,optimiz,optimization,310,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-analysis=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark. \p Loc is the debug location and \p MBB is the block that the; /// optimization operates in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:4,Modifiability,Extend,Extend,4,/// Extend llvm::ore:: with MI-specific helper names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:32,Integrability,interface,interface,32,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:8,Performance,optimiz,optimization,8,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:78,Performance,optimiz,optimizations,78,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:96,Performance,perform,performed,96,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:12,Performance,optimiz,optimization,12,/// Emit an optimization remark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:54,Performance,perform,perform,54,"/// Whether we allow for extra compile-time budget to perform more; /// analysis to be more informative.; ///; /// This is useful to enable additional missed optimizations to be reported; /// that are normally too noisy. In this mode, we can use the extra analysis; /// (1) to filter trivial false positives or (2) to provide more context so; /// that non-trivial false positives can be quickly detected by the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:158,Performance,optimiz,optimizations,158,"/// Whether we allow for extra compile-time budget to perform more; /// analysis to be more informative.; ///; /// This is useful to enable additional missed optimizations to be reported; /// that are normally too noisy. In this mode, we can use the extra analysis; /// (1) to filter trivial false positives or (2) to provide more context so; /// that non-trivial false positives can be quickly detected by the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:395,Safety,detect,detected,395,"/// Whether we allow for extra compile-time budget to perform more; /// analysis to be more informative.; ///; /// This is useful to enable additional missed optimizations to be reported; /// that are normally too noisy. In this mode, we can use the extra analysis; /// (1) to filter trivial false positives or (2) to provide more context so; /// that non-trivial false positives can be quickly detected by the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:3,Safety,Avoid,Avoid,3,// Avoid building the remark unless we know there are at least *some*; // remarks enabled. We can't currently check whether remarks are requested; // for the calling pass since that requires actually building the remark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:83,Availability,avail,available,83,/// Compute hotness from IR value (currently assumed to be a block) if PGO is; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:46,Deployability,update,update,46,/// Similar but use value from \p OptDiag and update hotness there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:23,Integrability,message,messages,23,/// Only allow verbose messages if we know we're filtering by hotness; /// (BFI is only set in this case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:115,Safety,safe,safe,115,"/// Represents how an instruction should be mapped by the outliner.; /// \p Legal instructions are those which are safe to outline.; /// \p LegalTerminator instructions are safe to outline, but only as the; /// last instruction in a sequence.; /// \p Illegal instructions are those which cannot be outlined.; /// \p Invisible instructions are instructions which can be outlined, but; /// shouldn't actually impact the outlining result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:173,Safety,safe,safe,173,"/// Represents how an instruction should be mapped by the outliner.; /// \p Legal instructions are those which are safe to outline.; /// \p LegalTerminator instructions are safe to outline, but only as the; /// last instruction in a sequence.; /// \p Illegal instructions are those which cannot be outlined.; /// \p Invisible instructions are instructions which can be outlined, but; /// shouldn't actually impact the outlining result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:183,Performance,tune,tune,183,"/// Liveness information for this Candidate. Tracks from the end of the; /// block containing this Candidate to the beginning of its sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:212,Performance,tune,tune,212,"/// Liveness information for this Candidate. Tracks from the end of the; /// block containing this Candidate to the beginning of its sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:118,Performance,tune,tune,118,"/// Liveness information restricted to this Candidate's instruction sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:147,Performance,tune,tune,147,"/// Liveness information restricted to this Candidate's instruction sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:31,Availability,avail,available,31,/// \returns True if \p Reg is available from the end of the block to the; /// beginning of the sequence.; ///; /// This query considers the following range:; ///; /// in_seq_1; /// in_seq_2; /// ...; /// in_seq_n; /// not_in_seq_1; /// ...; /// <end of block>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:31,Availability,avail,available,31,/// \returns True if \p Reg is available within the sequence itself.; ///; /// This query considers the following range:; ///; /// in_seq_1; /// in_seq_2; /// ...; /// in_seq_n,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:144,Deployability,update,updated,144,/// The number of instructions that would be saved by outlining every; /// candidate of this type.; ///; /// This is a fixed value which is not updated during the candidate pruning; /// process. It is only used for deciding which candidate to keep if two; /// candidates overlap. The true benefit is stored in the OutlinedFunction; /// for some given candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:459,Deployability,pipeline,pipeline,459,"//===- PassManager.h --- Pass management for CodeGen ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the pass manager interface for codegen. The codegen; // pipeline consists of only machine function passes. There is no container; // relationship between IR module/function and machine function in terms of pass; // manager organization. So there is no need for adaptor classes (for example; // ModuleToMachineFunctionAdaptor). Since invalidation could only happen among; // machine function passes, there is no proxy classes to handle cross-IR-unit; // invalidation. IR analysis results are provided for machine function passes by; // their respective analysis managers such as ModuleAnalysisManager and; // FunctionAnalysisManager.; //; // TODO: Add MachineFunctionProperties support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:664,Energy Efficiency,adapt,adaptor,664,"//===- PassManager.h --- Pass management for CodeGen ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the pass manager interface for codegen. The codegen; // pipeline consists of only machine function passes. There is no container; // relationship between IR module/function and machine function in terms of pass; // manager organization. So there is no need for adaptor classes (for example; // ModuleToMachineFunctionAdaptor). Since invalidation could only happen among; // machine function passes, there is no proxy classes to handle cross-IR-unit; // invalidation. IR analysis results are provided for machine function passes by; // their respective analysis managers such as ModuleAnalysisManager and; // FunctionAnalysisManager.; //; // TODO: Add MachineFunctionProperties support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:420,Integrability,interface,interface,420,"//===- PassManager.h --- Pass management for CodeGen ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the pass manager interface for codegen. The codegen; // pipeline consists of only machine function passes. There is no container; // relationship between IR module/function and machine function in terms of pass; // manager organization. So there is no need for adaptor classes (for example; // ModuleToMachineFunctionAdaptor). Since invalidation could only happen among; // machine function passes, there is no proxy classes to handle cross-IR-unit; // invalidation. IR analysis results are provided for machine function passes by; // their respective analysis managers such as ModuleAnalysisManager and; // FunctionAnalysisManager.; //; // TODO: Add MachineFunctionProperties support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:664,Modifiability,adapt,adaptor,664,"//===- PassManager.h --- Pass management for CodeGen ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the pass manager interface for codegen. The codegen; // pipeline consists of only machine function passes. There is no container; // relationship between IR module/function and machine function in terms of pass; // manager organization. So there is no need for adaptor classes (for example; // ModuleToMachineFunctionAdaptor). Since invalidation could only happen among; // machine function passes, there is no proxy classes to handle cross-IR-unit; // invalidation. IR analysis results are provided for machine function passes by; // their respective analysis managers such as ModuleAnalysisManager and; // FunctionAnalysisManager.; //; // TODO: Add MachineFunctionProperties support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:50,Security,expose,exposes,50,/// An AnalysisManager<MachineFunction> that also exposes IR analysis results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:109,Availability,avail,available,109,/// Get the result of an analysis pass for a Function.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:88,Performance,cache,cached,88,/// Get the result of an analysis pass for a Function.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,Performance,cache,cached,12,/// Get the cached result of an analysis pass for a Function.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:148,Performance,cache,cached,148,/// Get the cached result of an analysis pass for a Function.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:107,Availability,avail,available,107,/// Get the result of an analysis pass for a Module.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:86,Performance,cache,cached,86,/// Get the result of an analysis pass for a Module.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,Performance,cache,cached,12,/// Get the cached result of an analysis pass for a Module.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:146,Performance,cache,cached,146,/// Get the cached result of an analysis pass for a Module.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:116,Availability,avail,available,116,/// Get the result of an analysis pass for a MachineFunction.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:95,Performance,cache,cached,95,/// Get the result of an analysis pass for a MachineFunction.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,Performance,cache,cached,12,/// Get the cached result of an analysis pass for a MachineFunction.; ///; /// This method never runs the analysis.; ///; /// returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:154,Performance,cache,cached,154,/// Get the cached result of an analysis pass for a MachineFunction.; ///; /// This method never runs the analysis.; ///; /// returns null if there is no cached result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:470,Availability,Error,Error,470,"/// MachineFunctionPassManager adds/removes below features to/from the base; /// PassManager template instantiation.; ///; /// - Support passes that implement doInitialization/doFinalization. This is for; /// machine function passes to work on module level constructs. One such pass; /// is AsmPrinter.; ///; /// - Support machine module pass which runs over the module (for example,; /// MachineOutliner). A machine module pass needs to define the method:; ///; /// ```Error run(Module &, MachineFunctionAnalysisManager &)```; ///; /// FIXME: machine module passes still need to define the usual machine; /// function pass interface, namely,; /// `PreservedAnalyses run(MachineFunction &,; /// MachineFunctionAnalysisManager &)`; /// But this interface wouldn't be executed. It is just a placeholder; /// to satisfy the pass manager type-erased inteface. This; /// special-casing of machine module pass is due to its limited use; /// cases and the unnecessary complexity it may bring to the machine; /// pass manager.; ///; /// - The base class `run` method is replaced by an alternative `run` method.; /// See details below.; ///; /// - Support codegening in the SCC order. Users include interprocedural; /// register allocation (IPRA).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:624,Integrability,interface,interface,624,"/// MachineFunctionPassManager adds/removes below features to/from the base; /// PassManager template instantiation.; ///; /// - Support passes that implement doInitialization/doFinalization. This is for; /// machine function passes to work on module level constructs. One such pass; /// is AsmPrinter.; ///; /// - Support machine module pass which runs over the module (for example,; /// MachineOutliner). A machine module pass needs to define the method:; ///; /// ```Error run(Module &, MachineFunctionAnalysisManager &)```; ///; /// FIXME: machine module passes still need to define the usual machine; /// function pass interface, namely,; /// `PreservedAnalyses run(MachineFunction &,; /// MachineFunctionAnalysisManager &)`; /// But this interface wouldn't be executed. It is just a placeholder; /// to satisfy the pass manager type-erased inteface. This; /// special-casing of machine module pass is due to its limited use; /// cases and the unnecessary complexity it may bring to the machine; /// pass manager.; ///; /// - The base class `run` method is replaced by an alternative `run` method.; /// See details below.; ///; /// - Support codegening in the SCC order. Users include interprocedural; /// register allocation (IPRA).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:744,Integrability,interface,interface,744,"/// MachineFunctionPassManager adds/removes below features to/from the base; /// PassManager template instantiation.; ///; /// - Support passes that implement doInitialization/doFinalization. This is for; /// machine function passes to work on module level constructs. One such pass; /// is AsmPrinter.; ///; /// - Support machine module pass which runs over the module (for example,; /// MachineOutliner). A machine module pass needs to define the method:; ///; /// ```Error run(Module &, MachineFunctionAnalysisManager &)```; ///; /// FIXME: machine module passes still need to define the usual machine; /// function pass interface, namely,; /// `PreservedAnalyses run(MachineFunction &,; /// MachineFunctionAnalysisManager &)`; /// But this interface wouldn't be executed. It is just a placeholder; /// to satisfy the pass manager type-erased inteface. This; /// special-casing of machine module pass is due to its limited use; /// cases and the unnecessary complexity it may bring to the machine; /// pass manager.; ///; /// - The base class `run` method is replaced by an alternative `run` method.; /// See details below.; ///; /// - Support codegening in the SCC order. Users include interprocedural; /// register allocation (IPRA).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:88,Deployability,pipeline,pipeline,88,"/// Run machine passes for a Module.; ///; /// The intended use is to start the codegen pipeline for a Module. The base; /// class's `run` method is deliberately hidden by this due to the observation; /// that we don't yet have the use cases of compositing two instances of; /// machine pass managers, or compositing machine pass managers with other; /// types of pass managers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h:749,Deployability,update,updated,749,"//===- llvm/CodeGen/MachinePassRegistry.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the mechanics for machine function pass registries. A; // function pass registry (MachinePassRegistry) is auto filled by the static; // constructors of MachinePassRegistryNode. Further there is a command line; // parser (RegisterPassParser) which listens to each registry for additions; // and deletions, so that the appropriate command option is updated.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h:3,Security,Access,Accessors,3,// Accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h:97,Security,Access,Accessors,97,// NO CONSTRUCTOR - we don't want static constructor ordering to mess; // with the registry.; // Accessors.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:45,Deployability,Pipeline,Pipeliner,45,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:445,Deployability,pipeline,pipeliner,445,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:419,Energy Efficiency,Schedul,Scheduling,419,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:508,Energy Efficiency,schedul,scheduling,508,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:641,Energy Efficiency,Schedul,Scheduling,641,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:715,Energy Efficiency,schedul,schedules,715,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:862,Energy Efficiency,Schedul,Scheduling,862,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:1104,Energy Efficiency,Schedul,Scheduling,1104,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:1319,Energy Efficiency,Schedul,Scheduling,1319,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:1799,Energy Efficiency,schedul,schedule,1799,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:1591,Integrability,depend,dependence,1591,"//===- MachinePipeliner.h - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlap loop iterations and exploits ILP via a compiler transformation.; //; // Swing Modulo Scheduling is an implementation of software pipelining; // that generates schedules that are near optimal in terms of initiation; // interval, register requirements, and stage count. See the papers:; //; // ""Swing Modulo Scheduling: A Lifetime-Sensitive Approach"", by J. Llosa,; // A. Gonzalez, E. Ayguade, and M. Valero. In PACT '96 Proceedings of the 1996; // Conference on Parallel Architectures and Compilation Techiniques.; //; // ""Lifetime-Sensitive Modulo Scheduling in a Production Environment"", by J.; // Llosa, E. Ayguade, A. Gonzalez, M. Valero, and J. Eckhardt. In IEEE; // Transactions on Computers, Vol. 50, No. 3, 2001.; //; // ""An Implementation of Swing Modulo Scheduling With Extensions for; // Superblocks"", by T. Lattner, Master's Thesis, University of Illinois at; // Urbana-Champaign, 2005.; //; //; // The SMS algorithm consists of three main steps after computing the minimal; // initiation interval (MII).; // 1) Analyze the dependence graph and compute information about each; // instruction in the graph.; // 2) Order the nodes (instructions) by priority based upon the heuristics; // described in the algorithm.; // 3) Attempt to schedule the nodes in the specified order using the MII.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:81,Deployability,pipeline,pipeliner,81,/// The main class in the implementation of the target independent; /// software pipeliner pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:4,Performance,Cache,Cache,4,/// Cache the target analysis information about the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:96,Energy Efficiency,schedul,schedule,96,"/// This class builds the dependence graph for the instructions in a loop,; /// and attempts to schedule the instructions using the SMS algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:26,Integrability,depend,dependence,26,"/// This class builds the dependence graph for the instructions in a loop,; /// and attempts to schedule the instructions using the SMS algorithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:64,Energy Efficiency,schedul,schedule,64,/// The minimum initiation interval between iterations for this schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:64,Energy Efficiency,schedul,schedule,64,/// The maximum initiation interval between iterations for this schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:27,Deployability,pipeline,pipelined,27,/// Set to true if a valid pipelined schedule is found for the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:37,Energy Efficiency,schedul,schedule,37,/// Set to true if a valid pipelined schedule is found for the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:75,Integrability,depend,dependences,75,"/// A toplogical ordering of the SUnits, which is needed for changing; /// dependences and iterating over the SUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:31,Energy Efficiency,schedul,scheduling,31,/// Computed node ordering for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,Energy Efficiency,schedul,schedule,51,/// Instructions to change when emitting the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:22,Energy Efficiency,Schedul,ScheduleDAGTopologicalSort,22,// Node to Index from ScheduleDAGTopologicalSort,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:44,Energy Efficiency,schedul,scheduled,44,/// Return true if the loop kernel has been scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,Energy Efficiency,schedul,scheduled,51,/// Return the earliest time an instruction may be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:48,Energy Efficiency,schedul,scheduled,48,/// Return the latest time an instruction my be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:89,Energy Efficiency,schedul,scheduled,89,"/// The mobility function, which the number of slots in which; /// an instruction may be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:22,Integrability,depend,dependence,22,"/// The depth, in the dependence graph, for a node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:113,Performance,latency,latency,113,/// The maximum unweighted length of a path from an arbitrary node to the; /// given node in which each edge has latency 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:23,Integrability,depend,dependence,23,"/// The height, in the dependence graph, for a node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:113,Performance,latency,latency,113,/// The maximum unweighted length of a path from the given node to an; /// arbitrary node in which each edge has latency 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:23,Integrability,depend,dependence,23,"/// Return true if the dependence is a back-edge in the data dependence graph.; /// Since the DAG doesn't contain cycles, we represent a cycle in the graph; /// using an anti dependence from a Phi to an instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:61,Integrability,depend,dependence,61,"/// Return true if the dependence is a back-edge in the data dependence graph.; /// Since the DAG doesn't contain cycles, we represent a cycle in the graph; /// using an anti dependence from a Phi to an instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:175,Integrability,depend,dependence,175,"/// Return true if the dependence is a back-edge in the data dependence graph.; /// Since the DAG doesn't contain cycles, we represent a cycle in the graph; /// using an anti dependence from a Phi to an instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:80,Integrability,depend,depends,80,"/// The distance function, which indicates that operation V of iteration I; /// depends on operations U of iteration I-distance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:107,Integrability,depend,dependence,107,// Instructions that feed a Phi have a distance of 1. Computing larger; // values for arrays requires data dependence information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:49,Energy Efficiency,schedul,schedule,49,/// Set the Minimum Initiation Interval for this schedule attempt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:49,Energy Efficiency,schedul,schedule,49,/// Set the Maximum Initiation Interval for this schedule attempt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:18,Energy Efficiency,schedul,scheduled,18,"/// The number of scheduled micro operations for each slot. Micro operations; /// are assumed to be scheduled one per cycle, starting with the cycle in; /// which the instruction is scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:100,Energy Efficiency,schedul,scheduled,100,"/// The number of scheduled micro operations for each slot. Micro operations; /// are assumed to be scheduled one per cycle, starting with the cycle in; /// which the instruction is scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:182,Energy Efficiency,schedul,scheduled,182,"/// The number of scheduled micro operations for each slot. Micro operations; /// are assumed to be scheduled one per cycle, starting with the cycle in; /// which the instruction is scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:83,Availability,mask,mask,83,/// Each processor resource is associated with a so-called processor resource; /// mask. This vector allows to correlate processor resource IDs with; /// processor resource masks. There is exactly one element per each processor; /// resource declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:173,Availability,mask,masks,173,/// Each processor resource is associated with a so-called processor resource; /// mask. This vector allows to correlate processor resource IDs with; /// processor resource masks. There is exactly one element per each processor; /// resource declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:258,Energy Efficiency,schedul,scheduling,258,/// Each processor resource is associated with a so-called processor resource; /// mask. This vector allows to correlate processor resource IDs with; /// processor resource masks. There is exactly one element per each processor; /// resource declared by the scheduling model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:47,Energy Efficiency,schedul,scheduled,47,/// The number of micro operations that can be scheduled at a cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:65,Availability,avail,available,65,/// Check if the resources occupied by a machine instruction are available; /// in the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:30,Energy Efficiency,schedul,scheduled,30,"/// This class represents the scheduled code. The main data structure is a; /// map from scheduled cycle to instructions. During scheduling, the; /// data structure explicitly represents all stages/iterations. When; /// the algorithm finshes, the schedule is collapsed into a single stage,; /// which represents instructions from different loop iterations.; ///; /// The SMS algorithm allows negative values for cycles, so the first cycle; /// in the schedule is the smallest cycle value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:89,Energy Efficiency,schedul,scheduled,89,"/// This class represents the scheduled code. The main data structure is a; /// map from scheduled cycle to instructions. During scheduling, the; /// data structure explicitly represents all stages/iterations. When; /// the algorithm finshes, the schedule is collapsed into a single stage,; /// which represents instructions from different loop iterations.; ///; /// The SMS algorithm allows negative values for cycles, so the first cycle; /// in the schedule is the smallest cycle value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:129,Energy Efficiency,schedul,scheduling,129,"/// This class represents the scheduled code. The main data structure is a; /// map from scheduled cycle to instructions. During scheduling, the; /// data structure explicitly represents all stages/iterations. When; /// the algorithm finshes, the schedule is collapsed into a single stage,; /// which represents instructions from different loop iterations.; ///; /// The SMS algorithm allows negative values for cycles, so the first cycle; /// in the schedule is the smallest cycle value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:247,Energy Efficiency,schedul,schedule,247,"/// This class represents the scheduled code. The main data structure is a; /// map from scheduled cycle to instructions. During scheduling, the; /// data structure explicitly represents all stages/iterations. When; /// the algorithm finshes, the schedule is collapsed into a single stage,; /// which represents instructions from different loop iterations.; ///; /// The SMS algorithm allows negative values for cycles, so the first cycle; /// in the schedule is the smallest cycle value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:451,Energy Efficiency,schedul,schedule,451,"/// This class represents the scheduled code. The main data structure is a; /// map from scheduled cycle to instructions. During scheduling, the; /// data structure explicitly represents all stages/iterations. When; /// the algorithm finshes, the schedule is collapsed into a single stage,; /// which represents instructions from different loop iterations.; ///; /// The SMS algorithm allows negative values for cycles, so the first cycle; /// in the schedule is the smallest cycle value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:47,Energy Efficiency,schedul,schedule,47,"/// Keep track of the first cycle value in the schedule. It starts; /// as zero, but the algorithm allows negative values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:46,Energy Efficiency,schedul,schedule,46,/// Keep track of the last cycle value in the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:41,Energy Efficiency,schedul,schedule,41,/// The initiation interval (II) for the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:41,Energy Efficiency,schedul,schedule,41,/// Set the initiation interval for this schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:44,Energy Efficiency,schedul,schedule,44,/// Return the initiation interval for this schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:44,Energy Efficiency,schedul,schedule,44,/// Return the first cycle in the completed schedule. This; /// can be a negative value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:43,Energy Efficiency,schedul,schedule,43,/// Return the last cycle in the finalized schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:37,Energy Efficiency,schedul,scheduled,37,/// Return the cycle of the earliest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:66,Integrability,depend,dependence,66,/// Return the cycle of the earliest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:35,Energy Efficiency,schedul,scheduled,35,/// Return the cycle of the latest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:64,Integrability,depend,dependence,64,/// Return the cycle of the latest scheduled instruction in the dependence; /// chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:38,Energy Efficiency,schedul,scheduled,38,/// Return true if the instruction is scheduled at the specified stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:27,Energy Efficiency,schedul,scheduled,27,/// Return the stage for a scheduled instruction. Return -1 if; /// the instruction has not been scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:97,Energy Efficiency,schedul,scheduled,97,/// Return the stage for a scheduled instruction. Return -1 if; /// the instruction has not been scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:27,Energy Efficiency,schedul,scheduled,27,/// Return the cycle for a scheduled instruction. This function normalizes; /// the first cycle to be 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:51,Energy Efficiency,schedul,schedule,51,/// Return the maximum stage count needed for this schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:37,Energy Efficiency,schedul,scheduled,37,/// Return the instructions that are scheduled at the specified cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h:401,Integrability,interface,interfaces,401,"//===- llvm/CodeGen/MachinePostDominators.h ----------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information for; // target-specific code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h:393,Security,expose,exposes,393,"//===- llvm/CodeGen/MachinePostDominators.h ----------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information for; // target-specific code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h:53,Integrability,wrap,wrapper,53,///; /// MachinePostDominatorTree - an analysis pass wrapper for DominatorTree; /// used to compute the post-dominator tree for MachineFunctions.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h:3,Deployability,update,updateStatistics,3,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h:22,Deployability,Update,Update,22,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h:30,Integrability,interface,interface,30,/// @name MachineFunctionPass interface; //@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:12,Availability,recover,recovering,12,/// Map for recovering vreg name from vreg number.; /// This map is used by the MIR Printer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:12,Safety,recover,recovering,12,/// Map for recovering vreg name from vreg number.; /// This map is used by the MIR Printer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:29,Deployability,Update,UpdatedCSRs,29,/// The flag is true upon \p UpdatedCSRs initialization; /// and false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:17,Deployability,update,updated,17,"/// Contains the updated callee saved register list.; /// As opposed to the static list defined in register info,; /// all registers that were disabled are removed from the list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:445,Energy Efficiency,allocate,allocated,445,"/// RegAllocHints - This vector records register allocation hints for; /// virtual registers. For each virtual register, it keeps a pair of hint; /// type and hints vector making up the allocation hints. Only the first; /// hint may be target specific, and in that case this is reflected by the; /// first member of the pair being non-zero. If the hinted register is; /// virtual, it means the allocator should prefer the physical register; /// allocated to it if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:202,Deployability,update,updated,202,//===--------------------------------------------------------------------===//; // Register Info; //===--------------------------------------------------------------------===//; /// Returns true if the updated CSR list was initialized and false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:107,Availability,mask,mask,107,/// Disables the register from the list of CSRs.; /// I.e. the register will not appear as part of the CSR mask.; /// \see UpdatedCalleeSavedRegs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:123,Deployability,Update,UpdatedCalleeSavedRegs,123,/// Disables the register from the list of CSRs.; /// I.e. the register will not appear as part of the CSR mask.; /// \see UpdatedCalleeSavedRegs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:74,Deployability,update,updated,74,/// Returns list of callee saved registers.; /// The function returns the updated CSR list (after taking into account; /// registers that are disabled from the CSR list).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:13,Deployability,update,updated,13,/// Sets the updated Callee Saved Registers list.; /// Notice that it will override ant previously disabled/saved CSRs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:30,Security,access,access,30,// Make it a friend so it can access getNextOperandForReg().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:179,Modifiability,extend,extend,179,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:153,Performance,optimiz,optimization,153,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:4,Usability,clear,clearKillFlags,4,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:78,Usability,clear,clear,78,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:535,Safety,safe,safe,535,"/// Return the register class of \p Reg, or null if Reg has not been assigned; /// a register class yet.; ///; /// \note A null register class can only happen when these two; /// conditions are met:; /// 1. Generic virtual registers are created.; /// 2. The machine function has not completely been through the; /// instruction selection process.; /// None of this condition is possible without GlobalISel for now.; /// In other words, if GlobalISel is not used or if the query happens after; /// the select pass, using getRegClass is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:184,Deployability,upgrade,upgraded,184,"/// recomputeRegClass - Try to find a legal super-class of Reg's register; /// class that still satisfies the constraints from the instructions using; /// Reg. Returns true if Reg was upgraded.; ///; /// This method can be used after constraints have been removed from a; /// virtual register, for example after removing instructions or splitting; /// the live range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:4,Usability,clear,clearVirtRegs,4,/// clearVirtRegs - Remove all virtual registers (after physreg assignment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:4,Deployability,update,updateDbgUsersToReg,4,/// updateDbgUsersToReg - Update a collection of debug instructions; /// to refer to the designated register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:26,Deployability,Update,Update,26,/// updateDbgUsersToReg - Update a collection of debug instructions; /// to refer to the designated register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:65,Deployability,update,update,65,"// Iterate through (possibly several) operands to DBG_VALUEs and update; // each. For DBG_PHIs, only one operand will be present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:109,Availability,mask,mask,109,/// addPhysRegsUsedFromRegMask - Mark any registers not in RegMask as used.; /// This corresponds to the bit mask attached to register mask operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:135,Availability,mask,mask,135,/// addPhysRegsUsedFromRegMask - Mark any registers not in RegMask as used.; /// This corresponds to the bit mask attached to register mask operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:512,Safety,avoid,avoid,512,"//===--------------------------------------------------------------------===//; // Reserved Register Info; //===--------------------------------------------------------------------===//; //; // The set of reserved registers must be invariant during register; // allocation. For example, the target cannot suddenly decide it needs a; // frame pointer when the register allocator has already used the frame; // pointer register for something else.; //; // These methods can be used by target hooks like hasFP() to avoid changing; // the reserved register set during register allocation.; /// freezeReservedRegs - Called by the register allocator to freeze the set; /// of reserved registers before allocation begins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:200,Availability,avail,available,200,"/// reserveReg -- Mark a register as reserved so checks like isAllocatable ; /// will not suggest using it. This should not be used during the middle; /// of a function walk, or when liveness info is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:281,Availability,avail,availability,281,"/// isAllocatable - Returns true when PhysReg belongs to an allocatable; /// register class and it hasn't been reserved.; ///; /// Allocatable registers may show up in the allocation order of some virtual; /// register, so a register allocator needs to track its liveness and; /// availability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:263,Availability,error,error,263,//===--------------------------------------------------------------------===//; // LiveIn Management; //===--------------------------------------------------------------------===//; /// addLiveIn - Add the specified register as a live-in. Note that it; /// is an error to add the same register to the same set more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:14,Availability,mask,mask,14,/// Returns a mask covering all bits that can appear in lane masks of; /// subregisters of the virtual register @p Reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:61,Availability,mask,masks,61,/// Returns a mask covering all bits that can appear in lane masks of; /// subregisters of the virtual register @p Reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:41,Energy Efficiency,Schedul,Scheduling,41,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:762,Energy Efficiency,schedul,scheduled,762,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:814,Energy Efficiency,schedul,scheduler,814,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:875,Energy Efficiency,Schedul,ScheduleDAGInstrs,875,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1036,Energy Efficiency,schedul,scheduler,1036,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1047,Energy Efficiency,Schedul,ScheduleDAGMILive,1047,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1101,Energy Efficiency,schedul,scheduling,1101,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1259,Energy Efficiency,schedul,scheduler,1259,"tion; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the fol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1305,Energy Efficiency,schedul,scheduling,1305,"tion; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the fol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1472,Energy Efficiency,Schedul,ScheduleDAGInstrs,1472,"assManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1580,Energy Efficiency,Schedul,ScheduleDAGMILive,1580,"assManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1762,Energy Efficiency,schedul,scheduling,1762,"assManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1900,Energy Efficiency,Schedul,ScheduleDAGInstrs,1900,"eScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsign",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1997,Energy Efficiency,Schedul,ScheduleDAGMI,1997,"eScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsign",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2160,Energy Efficiency,schedul,schedulers,2160," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2320,Energy Efficiency,Schedul,ScheduleDAGInstrs,2320," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2528,Energy Efficiency,schedul,scheduler,2528," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2724,Energy Efficiency,schedul,scheduler,2724," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2756,Energy Efficiency,schedul,scheduling,2756," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:405,Integrability,interface,interface,405,"//===- MachineScheduler.h - MachineInstr Scheduling Pass --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // Sche",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1803,Integrability,depend,dependencies,1803,"eScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsign",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1335,Modifiability,plugin,plugin,1335,"tion; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface for customizing the standard MachineScheduler; // pass. Note that the entire pass may be replaced as follows:; //; // <Target>TargetMachine::createPassConfig(PassManagerBase &PM) {; // PM.substitutePass(&MachineSchedulerID, &CustomSchedulerPassID);; // ...}; //; // The MachineScheduler pass is only responsible for choosing the regions to be; // scheduled. Targets can override the DAG builder and scheduler without; // replacing the pass as follows:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; //; // The default scheduler, ScheduleDAGMILive, builds the DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the fol",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2672,Modifiability,config,configure,2672," DAG and drives list; // scheduling while updating the instruction stream, register pressure, and live; // intervals. Most targets don't need to override the DAG builder and list; // scheduler, but subtargets that require custom scheduling heuristics may; // plugin an alternate MachineSchedStrategy. The strategy is responsible for; // selecting the highest priority node from the list:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // return new ScheduleDAGMILive(C, CustomStrategy(C));; // }; //; // The DAG builder can also be customized in a sense by adding DAG mutations; // that will run after DAG building and before list scheduling. DAG mutations; // can adjust dependencies based on target-specific knowledge or add weak edges; // to aid heuristics:; //; // ScheduleDAGInstrs *<Target>PassConfig::; // createMachineScheduler(MachineSchedContext *C) {; // ScheduleDAGMI *DAG = createGenericSchedLive(C);; // DAG->addMutation(new CustomDAGMutation(...));; // return DAG;; // }; //; // A target that supports alternative schedulers can use the; // MachineSchedRegistry to allow command line selection. This can be done by; // implementing the following boilerplate:; //; // static ScheduleDAGInstrs *createCustomMachineSched(MachineSchedContext *C) {; // return new CustomMachineScheduler(C);; // }; // static MachineSchedRegistry; // SchedCustomRegistry(""custom"", ""Run my target's custom scheduler"",; // createCustomMachineSched);; //; //; // Finally, subtargets that don't need to implement custom heuristics but would; // like to configure the GenericScheduler's policy for a given scheduler region,; // including scheduling direction and register pressure tracking policy, can do; // this:; //; // void <SubTarget>Subtarget::; // overrideSchedPolicy(MachineSchedPolicy &Policy,; // unsigned NumRegionInstrs) const {; // Policy.<Flag> = true;; // }; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:116,Energy Efficiency,schedul,scheduler,116,/// MachineSchedContext provides enough context from the MachineScheduler pass; /// for the target to instantiate a scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,Availability,avail,available,49,/// MachineSchedRegistry provides a selection of available machine instruction; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:84,Energy Efficiency,schedul,schedulers,84,/// MachineSchedRegistry provides a selection of available machine instruction; /// schedulers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:3,Security,Access,Accessors,3,// Accessors.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,Energy Efficiency,schedul,scheduling,21,/// Define a generic scheduling policy for targets that don't provide their own; /// MachineSchedStrategy. This can be overriden for each scheduling region; /// before building the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:138,Energy Efficiency,schedul,scheduling,138,/// Define a generic scheduling policy for targets that don't provide their own; /// MachineSchedStrategy. This can be overriden for each scheduling region; /// before building the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:13,Energy Efficiency,schedul,scheduler,13,// Allow the scheduler to disable register pressure tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,Availability,down,down,36,"// Allow the scheduler to force top-down or bottom-up scheduling. If neither; // is true, the scheduler runs in both directions and converges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:13,Energy Efficiency,schedul,scheduler,13,"// Allow the scheduler to force top-down or bottom-up scheduling. If neither; // is true, the scheduler runs in both directions and converges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:54,Energy Efficiency,schedul,scheduling,54,"// Allow the scheduler to force top-down or bottom-up scheduling. If neither; // is true, the scheduler runs in both directions and converges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:94,Energy Efficiency,schedul,scheduler,94,"// Allow the scheduler to force top-down or bottom-up scheduling. If neither; // is true, the scheduler runs in both directions and converges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:57,Integrability,depend,dependency,57,// Disable heuristic that tries to fetch nodes from long dependency chains; // first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:32,Energy Efficiency,schedul,scheduling,32,// Compute DFSResult for use in scheduling heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:44,Energy Efficiency,schedul,scheduling,44,/// MachineSchedStrategy - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Initialization sequence:; /// initPolicy -> shouldTrackPressure -> initialize(DAG) -> registerRoots,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,Schedul,ScheduleDAGMI,78,/// MachineSchedStrategy - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Initialization sequence:; /// initPolicy -> shouldTrackPressure -> initialize(DAG) -> registerRoots,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:27,Integrability,Interface,Interface,27,/// MachineSchedStrategy - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Initialization sequence:; /// initPolicy -> shouldTrackPressure -> initialize(DAG) -> registerRoots,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:39,Energy Efficiency,schedul,scheduling,39,/// Optionally override the per-region scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,Energy Efficiency,schedul,scheduling,48,"// If this method returns true, handling of the scheduling regions; // themselves (in case of a scheduling boundary in MBB) will be done; // beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:96,Energy Efficiency,schedul,scheduling,96,"// If this method returns true, handling of the scheduling regions; // themselves (in case of a scheduling boundary in MBB) will be done; // beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:50,Deployability,release,released,50,/// Notify this strategy that all roots have been released (including those; /// that depend on EntrySU or ExitSU).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:86,Integrability,depend,depend,86,/// Notify this strategy that all roots have been released (including those; /// that depend on EntrySU or ExitSU).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:26,Energy Efficiency,schedul,schedule,26,"/// Pick the next node to schedule, or return NULL. Set IsTopNode to true to; /// schedule the node at the top of the unscheduled region. Otherwise it will; /// be scheduled at the bottom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:82,Energy Efficiency,schedul,schedule,82,"/// Pick the next node to schedule, or return NULL. Set IsTopNode to true to; /// schedule the node at the top of the unscheduled region. Otherwise it will; /// be scheduled at the bottom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:164,Energy Efficiency,schedul,scheduled,164,"/// Pick the next node to schedule, or return NULL. Set IsTopNode to true to; /// schedule the node at the top of the unscheduled region. Otherwise it will; /// be scheduled at the bottom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Energy Efficiency,Schedul,Scheduler,4,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:55,Energy Efficiency,schedul,scheduled,55,/// Scheduler callback to notify that a new subtree is scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:89,Deployability,update,updated,89,/// Notify MachineSchedStrategy that ScheduleDAGMI has scheduled an; /// instruction and updated scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:37,Energy Efficiency,Schedul,ScheduleDAGMI,37,/// Notify MachineSchedStrategy that ScheduleDAGMI has scheduled an; /// instruction and updated scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:55,Energy Efficiency,schedul,scheduled,55,/// Notify MachineSchedStrategy that ScheduleDAGMI has scheduled an; /// instruction and updated scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:97,Energy Efficiency,schedul,scheduled,97,/// Notify MachineSchedStrategy that ScheduleDAGMI has scheduled an; /// instruction and updated scheduled/remaining flags in the DAG nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:86,Availability,down,down,86,"/// When all predecessor dependencies have been resolved, free this node for; /// top-down scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:91,Energy Efficiency,schedul,scheduling,91,"/// When all predecessor dependencies have been resolved, free this node for; /// top-down scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:25,Integrability,depend,dependencies,25,"/// When all predecessor dependencies have been resolved, free this node for; /// top-down scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:90,Energy Efficiency,schedul,scheduling,90,"/// When all successor dependencies have been resolved, free this node for; /// bottom-up scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:23,Integrability,depend,dependencies,23,"/// When all successor dependencies have been resolved, free this node for; /// bottom-up scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Energy Efficiency,Schedul,ScheduleDAGMI,4,/// ScheduleDAGMI is an implementation of ScheduleDAGInstrs that simply; /// schedules machine instructions according to the given MachineSchedStrategy; /// without much extra book-keeping. This is the common functionality between; /// PreRA and PostRA MachineScheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,Energy Efficiency,Schedul,ScheduleDAGInstrs,42,/// ScheduleDAGMI is an implementation of ScheduleDAGInstrs that simply; /// schedules machine instructions according to the given MachineSchedStrategy; /// without much extra book-keeping. This is the common functionality between; /// PreRA and PostRA MachineScheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:77,Energy Efficiency,schedul,schedules,77,/// ScheduleDAGMI is an implementation of ScheduleDAGInstrs that simply; /// schedules machine instructions according to the given MachineSchedStrategy; /// without much extra book-keeping. This is the common functionality between; /// PreRA and PostRA MachineScheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:65,Usability,simpl,simply,65,/// ScheduleDAGMI is an implementation of ScheduleDAGInstrs that simply; /// schedules machine instructions according to the given MachineSchedStrategy; /// without much extra book-keeping. This is the common functionality between; /// PreRA and PostRA MachineScheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:30,Energy Efficiency,schedul,scheduled,30,/// Record the next node in a scheduled cluster.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:31,Energy Efficiency,schedul,scheduled,31,/// The number of instructions scheduled so far. Used to cut off the; /// scheduler at the point determined by misched-cutoff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:74,Energy Efficiency,schedul,scheduler,74,/// The number of instructions scheduled so far. Used to cut off the; /// scheduler at the point determined by misched-cutoff.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,Energy Efficiency,schedul,scheduling,49,"/// If this method returns true, handling of the scheduling regions; /// themselves (in case of a scheduling boundary in MBB) will be done; /// beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:98,Energy Efficiency,schedul,scheduling,98,"/// If this method returns true, handling of the scheduling regions; /// themselves (in case of a scheduling boundary in MBB) will be done; /// beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:199,Energy Efficiency,Schedul,ScheduleDAGMI,199,/// Add a postprocessing step to the DAG builder.; /// Mutations are applied in the order that they are added after normal DAG; /// building and before MachineSchedStrategy initialization.; ///; /// ScheduleDAGMI takes ownership of the Mutation object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:68,Energy Efficiency,schedul,scheduling,68,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:139,Energy Efficiency,schedul,schedule,139,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,Integrability,interface,interface,36,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:14,Energy Efficiency,Schedul,ScheduleDAGInstrs,14,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,Energy Efficiency,schedul,scheduling,46,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:32,Integrability,interface,interface,32,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:69,Deployability,update,update,69,/// Change the position of an instruction within the basic block and update; /// live ranges and region boundary iterators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:34,Energy Efficiency,schedul,schedule,34,// Top-Level entry points for the schedule() driver...; /// Apply each ScheduleDAGMutation step in order. This allows different; /// instances of ScheduleDAGMI to perform custom DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:71,Energy Efficiency,Schedul,ScheduleDAGMutation,71,// Top-Level entry points for the schedule() driver...; /// Apply each ScheduleDAGMutation step in order. This allows different; /// instances of ScheduleDAGMI to perform custom DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:146,Energy Efficiency,Schedul,ScheduleDAGMI,146,// Top-Level entry points for the schedule() driver...; /// Apply each ScheduleDAGMutation step in order. This allows different; /// instances of ScheduleDAGMI to perform custom DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:163,Performance,perform,perform,163,// Top-Level entry points for the schedule() driver...; /// Apply each ScheduleDAGMutation step in order. This allows different; /// instances of ScheduleDAGMI to perform custom DAG postprocessing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Deployability,Release,Release,4,/// Release ExitSU predecessors and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,Energy Efficiency,schedul,scheduler,42,/// Release ExitSU predecessors and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:52,Performance,queue,queues,52,/// Release ExitSU predecessors and setup scheduler queues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Deployability,Update,Update,4,/// Update scheduler DAG and queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:11,Energy Efficiency,schedul,scheduler,11,/// Update scheduler DAG and queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,Energy Efficiency,schedul,scheduling,42,/// Update scheduler DAG and queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:29,Performance,queue,queues,29,/// Update scheduler DAG and queues after scheduling an instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:38,Energy Efficiency,Schedul,ScheduleDAGInstrs,38,/// Reinsert debug_values recorded in ScheduleDAGInstrs::DbgValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:13,Energy Efficiency,schedul,scheduled,13,/// dump the scheduled Sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,Availability,down,down,46,/// Print execution trace of the schedule top-down or bottom-up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:33,Energy Efficiency,schedul,schedule,33,/// Print execution trace of the schedule top-down or bottom-up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Energy Efficiency,Schedul,ScheduleDAGMILive,4,/// ScheduleDAGMILive is an implementation of ScheduleDAGInstrs that schedules; /// machine instructions while updating LiveIntervals and tracking regpressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,Energy Efficiency,Schedul,ScheduleDAGInstrs,46,/// ScheduleDAGMILive is an implementation of ScheduleDAGInstrs that schedules; /// machine instructions while updating LiveIntervals and tracking regpressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:69,Energy Efficiency,schedul,schedules,69,/// ScheduleDAGMILive is an implementation of ScheduleDAGInstrs that schedules; /// machine instructions while updating LiveIntervals and tracking regpressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:63,Energy Efficiency,Schedul,SchedulerTrees,63,"/// Information about DAG subtrees. If DFSResult is NULL, then SchedulerTrees; /// will be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:58,Energy Efficiency,schedul,scheduling,58,/// Maps vregs to the SUnits of their uses in the current scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:123,Availability,down,down,123,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:65,Deployability,update,updated,65,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:107,Energy Efficiency,schedul,scheduling,107,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:128,Energy Efficiency,schedul,scheduling,128,// Map each SU to its summary of pressure changes. This array is updated for; // liveness during bottom-up scheduling. Top-down scheduling may proceed but; // has no affect on the pressure diffs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,schedul,scheduling,78,"/// List of pressure sets that exceed the target's pressure limit before; /// scheduling, listed in increasing set ID order. Each pressure set is paired; /// with its max pressure in the currently scheduled regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:197,Energy Efficiency,schedul,scheduled,197,"/// List of pressure sets that exceed the target's pressure limit before; /// scheduling, listed in increasing set ID order. Each pressure set is paired; /// with its max pressure in the currently scheduled regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,Energy Efficiency,schedul,scheduled,46,/// Get current register pressure for the top scheduled instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,Energy Efficiency,schedul,scheduled,49,/// Get current register pressure for the bottom scheduled instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:41,Energy Efficiency,schedul,scheduling,41,/// Get register pressure for the entire scheduling region before scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:66,Energy Efficiency,schedul,scheduling,66,/// Get register pressure for the entire scheduling region before scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:76,Performance,queue,queue,76,"/// Compute a DFSResult after DAG building is complete, and before any; /// queue comparisons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:40,Energy Efficiency,schedul,scheduling,40,/// Return a non-null DFS result if the scheduling strategy initialized it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,Energy Efficiency,Schedul,ScheduleDAGInstrs,18,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:68,Energy Efficiency,schedul,scheduling,68,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:139,Energy Efficiency,schedul,schedule,139,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,Integrability,interface,interface,36,"/// Implement the ScheduleDAGInstrs interface for handling the next scheduling; /// region. This covers all instructions in a block, while schedule() may only; /// cover a subset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:14,Energy Efficiency,Schedul,ScheduleDAGInstrs,14,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:46,Energy Efficiency,schedul,scheduling,46,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:32,Integrability,interface,interface,32,/// Implement ScheduleDAGInstrs interface for scheduling a sequence of; /// reorderable instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:34,Energy Efficiency,schedul,schedule,34,"// Top-Level entry points for the schedule() driver...; /// Call ScheduleDAGInstrs::buildSchedGraph with register pressure tracking; /// enabled. This sets up three trackers. RPTracker will cover the entire DAG; /// region, TopTracker and BottomTracker will be initialized to the top and; /// bottom of the DAG region without covereing any unscheduled instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:65,Energy Efficiency,Schedul,ScheduleDAGInstrs,65,"// Top-Level entry points for the schedule() driver...; /// Call ScheduleDAGInstrs::buildSchedGraph with register pressure tracking; /// enabled. This sets up three trackers. RPTracker will cover the entire DAG; /// region, TopTracker and BottomTracker will be initialized to the top and; /// bottom of the DAG region without covereing any unscheduled instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Deployability,Release,Release,4,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:42,Energy Efficiency,schedul,scheduler,42,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:52,Performance,queue,queues,52,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:28,Deployability,update,update,28,/// Move an instruction and update register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:523,Availability,mask,mask,523,"//===----------------------------------------------------------------------===//; ///; /// Helpers for implementing custom MachineSchedStrategy classes. These take; /// care of the book-keeping associated with list scheduling heuristics.; ///; //===----------------------------------------------------------------------===//; /// ReadyQueue encapsulates vector of ""ready"" SUnits with basic convenience; /// methods for pushing and removing nodes. ReadyQueue's are uniquely identified; /// by an ID. SUnit::NodeQueueId is a mask of the ReadyQueues the SUnit is in.; ///; /// This is a convenience class that may be used by implementations of; /// MachineSchedStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:215,Energy Efficiency,schedul,scheduling,215,"//===----------------------------------------------------------------------===//; ///; /// Helpers for implementing custom MachineSchedStrategy classes. These take; /// care of the book-keeping associated with list scheduling heuristics.; ///; //===----------------------------------------------------------------------===//; /// ReadyQueue encapsulates vector of ""ready"" SUnits with basic convenience; /// methods for pushing and removing nodes. ReadyQueue's are uniquely identified; /// by an ID. SUnit::NodeQueueId is a mask of the ReadyQueues the SUnit is in.; ///; /// This is a convenience class that may be used by implementations of; /// MachineSchedStrategy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:17,Performance,queue,queue,17,// SU is in this queue if it's NodeQueueID is a superset of this ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:45,Performance,latency,latency,45,// Critical path through the DAG in expected latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:37,Energy Efficiency,schedul,schedule,37,// Scaled count of micro-ops left to schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:345,Testability,assert,assertion,345,"/// Adds an interval [a, b) to the collection of the instance.; ///; /// When adding [a, b[ to the collection, the operation merges the; /// adjacent intervals. For example; ///; /// 0 1 2 3 4 5 6 7 8 9 10; /// [-----) [--) [--); /// + [--); /// = [-----------) [--); ///; /// To be able to debug duplicate resource usage, the function has; /// assertion that checks that no interval should be added if it; /// overlaps any of the intervals in the collection. We can; /// require this because by definition a \ref ResourceSegments is; /// attached only to an individual resource instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:659,Availability,DOWN,DOWN,659,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1071,Availability,down,down,1071," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:265,Deployability,Release,ReleaseAtCycle,265,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1127,Deployability,Release,ReleaseAtCycle,1127," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1884,Deployability,Release,ReleaseAtCycle,1884,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:2020,Deployability,Release,ReleaseAtCycle,2020,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:81,Energy Efficiency,schedul,scheduling,81,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:541,Energy Efficiency,schedul,schedule,541,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:664,Energy Efficiency,SCHEDUL,SCHEDULING,664,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:692,Energy Efficiency,schedul,scheduling,692,"/// These function return the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resou",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1043,Energy Efficiency,schedul,scheduled,1043," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1081,Energy Efficiency,schedul,scheduling,1081," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1170,Energy Efficiency,SCHEDUL,SCHEDULING,1170," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1198,Energy Efficiency,schedul,scheduling,1198," the interval used by a resource in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (Releas",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1289,Energy Efficiency,schedul,scheduling,1289,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1305,Energy Efficiency,schedul,scheduling,1305,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1431,Energy Efficiency,schedul,scheduled,1431,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1478,Energy Efficiency,allocate,allocated,1478,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1817,Energy Efficiency,schedul,scheduled,1817,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1856,Energy Efficiency,schedul,scheduling,1856,"urce in bottom and top; /// scheduling.; ///; /// Consider an instruction that uses resources X0, X1 and X2 as follows:; ///; /// X0 X1 X1 X2 +--------+-------------+--------------+; /// |Resource|AcquireAtCycle|ReleaseAtCycle|; /// +--------+-------------+--------------+; /// | X0 | 0 | 1 |; /// +--------+-------------+--------------+; /// | X1 | 1 | 3 |; /// +--------+-------------+--------------+; /// | X2 | 3 | 4 |; /// +--------+-------------+--------------+; ///; /// If we can schedule the instruction at cycle C, we need to; /// compute the interval of the resource as follows:; ///; /// # TOP DOWN SCHEDULING; ///; /// Cycles scheduling flows to the _right_, in the same direction; /// of time.; ///; /// C 1 2 3 4 5 ...; /// ------|------|------|------|------|------|----->; /// X0 X1 X1 X2 ---> direction of time; /// X0 [C, C+1); /// X1 [C+1, C+3); /// X2 [C+3, C+4); ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in top-down; /// scheduling is:; ///; /// [C+AcquireAtCycle, C+ReleaseAtCycle); ///; ///; /// # BOTTOM UP SCHEDULING; ///; /// Cycles scheduling flows to the _left_, in opposite direction; /// of time.; ///; /// In bottom up scheduling, the scheduling happens in opposite; /// direction to the execution of the cycles of the; /// instruction. When the instruction is scheduled at cycle `C`,; /// the resources are allocated in the past relative to `C`:; ///; /// 2 1 C -1 -2 -3 -4 -5 ...; /// <-----|------|------|------|------|------|------|------|---; /// X0 X1 X1 X2 ---> direction of time; /// X0 (C+1, C]; /// X1 (C, C-2]; /// X2 (C-2, C-3]; ///; /// Therefore, the formula to compute the interval for a resource; /// of an instruction that can be scheduled at cycle C in bottom-up; /// scheduling is:; ///; /// [C-ReleaseAtCycle+1, C-AcquireAtCycle+1); ///; ///; /// NOTE: In both cases, the number of cycles booked by a; /// resources is the value (ReleaseAtCycle - AcquireAtCycle).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1440,Availability,down,down,1440,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1695,Availability,down,down,1695,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:247,Deployability,Release,ReleaseAtCycle,247,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:860,Deployability,Release,ReleaseAtCycle,860,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:53,Energy Efficiency,allocate,allocated,53,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:660,Energy Efficiency,allocate,allocated,660,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1036,Energy Efficiency,schedul,scheduling,1036,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1266,Energy Efficiency,schedul,scheduling,1266,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1551,Energy Efficiency,schedul,scheduling,1551,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:1700,Energy Efficiency,schedul,scheduling,1700,"/// Finds the first cycle in which a resource can be allocated.; ///; /// The function uses the \param IntervalBuider [*] to build a; /// resource interval [a, b[ out of the input parameters \param; /// CurrCycle, \param AcquireAtCycle and \param ReleaseAtCycle.; ///; /// The function then loops through the intervals in the ResourceSegments; /// and shifts the interval [a, b[ and the ReturnCycle to the; /// right until there is no intersection between the intervals of; /// the \ref ResourceSegments instance and the new shifted [a, b[. When; /// this condition is met, the ReturnCycle (which; /// correspond to the cycle in which the resource can be; /// allocated) is returned.; ///; /// c = CurrCycle in input; /// c 1 2 3 4 5 6 7 8 9 10 ... ---> (time; /// flow); /// ResourceSegments... [---) [-------) [-----------); /// c [1 3[ -> AcquireAtCycle=1, ReleaseAtCycle=3; /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3); /// ++c [1 3) ---> returns c; /// incremented by 5 (c+5); ///; ///; /// Notice that for bottom-up scheduling the diagram is slightly; /// different because the current cycle c is always on the right; /// of the interval [a, b) (see \ref; /// `getResourceIntervalBottom`). This is because the cycle; /// increments for bottom-up scheduling moved in the direction; /// opposite to the direction of time:; ///; /// --------> direction of time.; /// XXYZZZ (resource usage); /// --------> direction of top-down execution cycles.; /// <-------- direction of bottom-up execution cycles.; ///; /// Even though bottom-up scheduling moves against the flow of; /// time, the algorithm used to find the first free slot in between; /// intervals is the same as for top-down scheduling.; ///; /// [*] See \ref `getResourceIntervalTop` and; /// \ref `getResourceIntervalBottom` to see how such resource intervals; /// are built.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:98,Performance,perform,performs,98,"/// Merge all adjacent intervals in the collection. For all pairs; /// of adjacient intervals, it performs [a, b) + [b, c) -> [a, c).; ///; /// Before performing the merge operation, the intervals are; /// sorted with \ref sort_predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:151,Performance,perform,performing,151,"/// Merge all adjacent intervals in the collection. For all pairs; /// of adjacient intervals, it performs [a, b) + [b, c) -> [a, c).; ///; /// Before performing the merge operation, the intervals are; /// sorted with \ref sort_predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:9,Energy Efficiency,Schedul,Scheduling,9,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:54,Performance,queue,queues,54,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:158,Safety,hazard,hazards,158,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:177,Safety,interlock,interlocks,177,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:177,Security,interlock,interlocks,177,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:44,Deployability,update,updated,44,/// True if the pending Q should be checked/updated before scheduling another; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:59,Energy Efficiency,schedul,scheduling,59,/// True if the pending Q should be checked/updated before scheduling another; /// instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:56,Energy Efficiency,schedul,scheduled,56,/// Number of cycles it takes to issue the instructions scheduled in this; /// zone. It is defined as: scheduled-micro-ops / issue-width + stalls.; /// See getStalls().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:103,Energy Efficiency,schedul,scheduled-micro-ops,103,/// Number of cycles it takes to issue the instructions scheduled in this; /// zone. It is defined as: scheduled-micro-ops / issue-width + stalls.; /// See getStalls().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:41,Availability,avail,available,41,/// MinReadyCycle - Cycle of the soonest available instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:53,Energy Efficiency,schedul,scheduled,53,// The expected latency of the critical path in this scheduled zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:16,Performance,latency,latency,16,// The expected latency of the critical path in this scheduled zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,schedul,scheduled,78,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:144,Energy Efficiency,schedul,scheduled,144,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,Integrability,depend,dependence,18,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:7,Performance,latency,latency,7,"// The latency of dependence chains leading into this zone.; // For each node scheduled bottom-up: DLat = max DLat, N.Depth.; // For each cycle scheduled: DLat -= 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:14,Energy Efficiency,schedul,scheduled,14,/// Count the scheduled (issued) micro-ops that can be retired by; /// time=CurrCycle assuming the first scheduled instr is retired at time=0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:105,Energy Efficiency,schedul,scheduled,105,/// Count the scheduled (issued) micro-ops that can be retired by; /// time=CurrCycle assuming the first scheduled instr is retired at time=0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:9,Energy Efficiency,schedul,scheduled,9,// Count scheduled resources that have been executed. Resources are; // considered executed if they become ready in the time that it takes to; // saturate any resource including the one in question. Counts are scaled; // for direct comparison with other resources. Counts can be compared with; // MOps * getMicroOpFactor and Latency * getLatencyFactor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:325,Performance,Latency,Latency,325,// Count scheduled resources that have been executed. Resources are; // considered executed if they become ready in the time that it takes to; // saturate any resource including the one in question. Counts are scaled; // for direct comparison with other resources. Counts can be compared with; // MOps * getMicroOpFactor and Latency * getLatencyFactor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Performance,Cache,Cache,4,/// Cache the max count for a single resource.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:43,Energy Efficiency,schedul,scheduled,43,// Cache the critical resources ID in this scheduled zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:3,Performance,Cache,Cache,3,// Cache the critical resources ID in this scheduled zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:10,Energy Efficiency,schedul,scheduled,10,// Is the scheduled region resource limited vs. latency limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,Performance,latency,latency,48,// Is the scheduled region resource limited vs. latency limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:35,Energy Efficiency,allocate,allocated,35,/// Record how resources have been allocated across the cycles of; /// the execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:113,Performance,queue,queue,113,// Remember the greatest possible stall as an upper bound on the number of; // times we should retry the pending queue because of a hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:132,Safety,hazard,hazard,132,// Remember the greatest possible stall as an upper bound on the number of; // times we should retry the pending queue because of a hazard.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:19,Modifiability,extend,extend,19,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:12,Performance,queue,queues,12,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,Performance,queue,queues,36,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:47,Energy Efficiency,schedul,scheduled,47,/// Number of cycles to issue the instructions scheduled in this zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:18,Integrability,depend,dependence,18,// The latency of dependence chains leading into this zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:7,Performance,latency,latency,7,// The latency of dependence chains leading into this zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:54,Energy Efficiency,schedul,scheduled,54,"/// Get the number of latency cycles ""covered"" by the scheduled; /// instructions. This is the larger of the critical path within the zone; /// and the number of cycles required to issue the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:22,Performance,latency,latency,22,"/// Get the number of latency cycles ""covered"" by the scheduled; /// instructions. This is the larger of the critical path within the zone; /// and the number of cycles required to issue the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:28,Energy Efficiency,schedul,scheduled,28,"/// Get the scaled count of scheduled micro-ops and resources, including; /// executed resources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:61,Energy Efficiency,schedul,scheduled,61,/// Get a scaled count for the minimum execution time of the scheduled; /// micro-ops that are ready to execute by getExecutedCount. Notice the; /// feedback loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:149,Usability,feedback,feedback,149,/// Get a scaled count for the minimum execution time of the scheduled; /// micro-ops that are ready to execute by getExecutedCount. Notice the; /// feedback loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:10,Energy Efficiency,schedul,scheduled,10,// Is the scheduled region resource limited vs. latency limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,Performance,latency,latency,48,// Is the scheduled region resource limited vs. latency limited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:120,Availability,avail,available,120,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Deployability,Release,Release,4,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:220,Deployability,release,released,220,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:84,Performance,queue,queue,84,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:130,Performance,queue,queue,130,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:178,Performance,queue,queue,178,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:344,Performance,queue,queue,344,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:394,Performance,queue,queue,394,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,Safety,hazard,hazard,48,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:58,Availability,Avail,Available,58,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:92,Availability,Avail,Available,92,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:155,Availability,avail,available,155,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:80,Deployability,Update,Updates,80,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:68,Performance,queue,queue,68,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:81,Energy Efficiency,schedul,scheduling,81,/// Base class for GenericScheduler. This class maintains information about; /// scheduling candidates based on TargetSchedModel making it easy to implement; /// heuristics for either preRA or postRA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:200,Energy Efficiency,schedul,scheduling,200,/// Base class for GenericScheduler. This class maintains information about; /// scheduling candidates based on TargetSchedModel making it easy to implement; /// heuristics for either preRA or postRA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:97,Integrability,depend,depends,97,/// Represent the type of SchedCandidate found within a single queue.; /// pickNodeBidirectional depends on these listed by decreasing priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:63,Performance,queue,queue,63,/// Represent the type of SchedCandidate found within a single queue.; /// pickNodeBidirectional depends on these listed by decreasing priority.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:15,Energy Efficiency,schedul,scheduling,15,/// Policy for scheduling the next instruction in the candidate's zone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:49,Energy Efficiency,consumption,consumption,49,/// Status of an instruction's critical resource consumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:35,Energy Efficiency,schedul,scheduled,35,// Count critical resources in the scheduled region required by SU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:36,Energy Efficiency,schedul,scheduled,36,// Whether this candidate should be scheduled at top/bottom.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,Energy Efficiency,consumption,consumption,21,// Critical resource consumption of the best candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:87,Energy Efficiency,schedul,schedule,87,/// GenericScheduler shrinks the unscheduled zone using heuristics to balance; /// the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:31,Energy Efficiency,schedul,scheduled,31,// State of the top and bottom scheduled instruction boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:44,Energy Efficiency,schedul,scheduling,44,/// PostGenericScheduler - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Callbacks from ScheduleDAGMI:; /// initPolicy -> initialize(DAG) -> registerRoots -> pickNode ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,Schedul,ScheduleDAGMI,78,/// PostGenericScheduler - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Callbacks from ScheduleDAGMI:; /// initPolicy -> initialize(DAG) -> registerRoots -> pickNode ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:118,Energy Efficiency,Schedul,ScheduleDAGMI,118,/// PostGenericScheduler - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Callbacks from ScheduleDAGMI:; /// initPolicy -> initialize(DAG) -> registerRoots -> pickNode ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:27,Integrability,Interface,Interface,27,/// PostGenericScheduler - Interface to the scheduling algorithm used by; /// ScheduleDAGMI.; ///; /// Callbacks from ScheduleDAGMI:; /// initPolicy -> initialize(DAG) -> registerRoots -> pickNode ...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:6,Modifiability,config,configurable,6,/* no configurable policy */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:11,Energy Efficiency,schedul,scheduling,11,/// PostRA scheduling does not track pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:43,Energy Efficiency,schedul,scheduler,43,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.; /// Adds default DAG mutations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:92,Energy Efficiency,schedul,scheduler,92,/// Create the standard converging machine scheduler. This will be used as the; /// default scheduler if the target does not set a default.; /// Adds default DAG mutations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:21,Energy Efficiency,schedul,scheduler,21,/// Create a generic scheduler with no vreg liveness or DAG mutation passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,reduce,reduce,78,"/// If ReorderWhileClustering is set to true, no attempt will be made to; /// reduce reordering due to store clustering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:78,Energy Efficiency,reduce,reduce,78,"/// If ReorderWhileClustering is set to true, no attempt will be made to; /// reduce reordering due to store clustering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:40,Performance,optimiz,optimization,40,"//===- MachineSizeOpts.h - machine size optimization ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:435,Performance,optimiz,optimization,435,"//===- MachineSizeOpts.h - machine size optimization ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:67,Performance,optimiz,optimized,67,/// Returns true if machine function \p MF is suggested to be size-optimized; /// based on the profile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:71,Performance,optimiz,optimized,71,/// Returns true if machine basic block \p MBB is suggested to be size-optimized; /// based on the profile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:71,Performance,optimiz,optimized,71,/// Returns true if machine basic block \p MBB is suggested to be size-optimized; /// based on the profile.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:46,Deployability,Update,Update,46,"//===- MachineSSAUpdater.h - Unstructured SSA Update Tool -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the MachineSSAUpdater class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:35,Deployability,update,updates,35,/// MachineSSAUpdater - This class updates SSA form for a set of virtual; /// registers defined in multiple blocks. This is used when code duplication; /// or another unstructured transformation wants to rewrite a set of uses of one; /// vreg with uses of a set of vregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:204,Modifiability,rewrite,rewrite,204,/// MachineSSAUpdater - This class updates SSA form for a set of virtual; /// registers defined in multiple blocks. This is used when code duplication; /// or another unstructured transformation wants to rewrite a set of uses of one; /// vreg with uses of a set of vregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:4,Availability,Avail,AvailableVals,4,"/// AvailableVals - This keeps track of which value to use on a per-block; /// basis. When we insert PHI nodes, we keep track of them here.; //typedef DenseMap<MachineBasicBlock*, Register> AvailableValsTy;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:190,Availability,Avail,AvailableValsTy,190,"/// AvailableVals - This keeps track of which value to use on a per-block; /// basis. When we insert PHI nodes, we keep track of them here.; //typedef DenseMap<MachineBasicBlock*, Register> AvailableValsTy;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:74,Deployability,update,updates,74,/// Initialize - Reset this object to get ready for a new set of SSA; /// updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:59,Availability,avail,available,59,/// AddAvailableValue - Indicate that a rewritten value is available at the; /// end of the specified block with the specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:652,Availability,Avail,AvailableVals,652,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:696,Modifiability,rewrite,rewriter,696,"/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that; /// is live in the middle of the specified block. If ExistingValueOnly is; /// true then this will only return an existing value or $noreg; otherwise new; /// instructions may be inserted to materialize a value.; ///; /// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one; /// important case: if there is a definition of the rewritten value after the; /// 'use' in BB. Consider code like this:; ///; /// X1 = ...; /// SomeBB:; /// use(X); /// X2 = ...; /// br Cond, SomeBB, OutBB; ///; /// In this case, there are two values (X1 and X2) added to the AvailableVals; /// set by the client of the rewriter, and those values are both live out of; /// their respective blocks. However, the use of X happens in the *middle* of; /// a block. Because of this, we need to insert a new PHI node in SomeBB to; /// merge the appropriate values, and this value isn't live out of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:4,Modifiability,Rewrite,RewriteUse,4,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor. Note that this; /// will not work if the use is supposed to be rewritten to a value defined in; /// the same block as the use, but above it. Any 'AddAvailableValue's added; /// for the use's block will be considered to be below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h:17,Modifiability,Rewrite,Rewrite,17,"/// RewriteUse - Rewrite a use of the symbolic value. This handles PHI nodes,; /// which use their value in the corresponding predecessor. Note that this; /// will not work if the use is supposed to be rewritten to a value defined in; /// the same block as the use, but above it. Any 'AddAvailableValue's added; /// for the use's block will be considered to be below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h:51,Security,Hash,Hashing,51,"//===------------ MachineStableHash.h - MIR Stable Hashing Utilities ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h:390,Security,hash,hashing,390,"//===------------ MachineStableHash.h - MIR Stable Hashing Utilities ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h:459,Security,hash,hash,459,"//===------------ MachineStableHash.h - MIR Stable Hashing Utilities ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stable hashing for MachineInstr and MachineOperand. Useful or getting a; // hash across runs, modules, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineStableHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:405,Integrability,interface,interface,405,"//===- lib/CodeGen/MachineTraceMetrics.h - Super-scalar metrics -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the MachineTraceMetrics analysis pass; // that estimates CPU resource usage and critical data dependency paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:513,Integrability,depend,dependency,513,"//===- lib/CodeGen/MachineTraceMetrics.h - Super-scalar metrics -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the MachineTraceMetrics analysis pass; // that estimates CPU resource usage and critical data dependency paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:651,Integrability,depend,dependencies,651,"//===- lib/CodeGen/MachineTraceMetrics.h - Super-scalar metrics -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the MachineTraceMetrics analysis pass; // that estimates CPU resource usage and critical data dependency paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:2091,Integrability,depend,dependencies,2091,"paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the number of; // cycles required to execute the trace when execution is limited by data; // dependencies only. We also compute the resource height, which is the number; // of cycles required to execute all instructions in the trace when ignoring; // data dependencies.; //; // Every instruction in the current block has a slack - the number of cycles; // execution of the instruction can be delayed without extending the critical; // path.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:2254,Integrability,depend,dependencies,2254,"paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the number of; // cycles required to execute the trace when execution is limited by data; // dependencies only. We also compute the resource height, which is the number; // of cycles required to execute all instructions in the trace when ignoring; // data dependencies.; //; // Every instruction in the current block has a slack - the number of cycles; // execution of the instruction can be delayed without extending the critical; // path.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:2406,Modifiability,extend,extending,2406,"paths through; // preferred traces. This is useful for super-scalar CPUs where execution speed; // can be limited both by data dependencies and by limited execution resources.; //; // Out-of-order CPUs will often be executing instructions from multiple basic; // blocks at the same time. This makes it difficult to estimate the resource; // usage accurately in a single basic block. Resources can be estimated better; // by looking at a trace through the current basic block.; //; // For every block, the MachineTraceMetrics pass will pick a preferred trace; // that passes through the block. The trace is chosen based on loop structure,; // branch probabilities, and resource usage. The intention is to pick likely; // traces that would be the most affected by code transformations.; //; // It is expensive to compute a full arbitrary trace for every block, so to; // save some computations, traces are chosen to be convergent. This means that; // if the traces through basic blocks A and B ever cross when moving away from; // A and B, they never diverge again. This applies in both directions - If the; // traces meet above A and B, they won't diverge when going further back.; //; // Traces tend to align with loops. The trace through a block in an inner loop; // will begin at the loop entry block and end at a back edge. If there are; // nested loops, the trace may begin and end at those instead.; //; // For each trace, we compute the critical path length, which is the number of; // cycles required to execute the trace when execution is limited by data; // dependencies only. We also compute the resource height, which is the number; // of cycles required to execute all instructions in the trace when ignoring; // data dependencies.; //; // Every instruction in the current block has a slack - the number of cycles; // execution of the instruction can be delayed without extending the critical; // path.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:30,Integrability,depend,dependencies,30,"// Keep track of physreg data dependencies by recording each live register unit.; // Associate each regunit with an instruction operand. Depending on the; // direction instructions are scanned, it could be the operand that defined the; // regunit, or the highest operand to read the regunit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:137,Integrability,Depend,Depending,137,"// Keep track of physreg data dependencies by recording each live register unit.; // Associate each regunit with an instruction operand. Depending on the; // direction instructions are scanned, it could be the operand that defined the; // regunit, or the highest operand to read the regunit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:45,Integrability,depend,depend,45,/// Per-basic block information that doesn't depend on the trace through the; /// block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:172,Integrability,depend,dependencies,172,"/// Assuming that this is a dominator of TBI, determine if it contains; /// useful instruction depths. A dominating block can be above the current; /// trace head, and any dependencies from such a far away dominator are not; /// expected to affect the critical path.; ///; /// Also returns true when TBI == this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:8,Integrability,depend,dependency-related,8,"// Data-dependency-related information. Per-instruction depth and height; // are computed from data dependencies in the current trace, using; // itinerary data.; /// Instruction depths have been computed. This implies hasValidDepth().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:100,Integrability,depend,dependencies,100,"// Data-dependency-related information. Per-instruction depth and height; // are computed from data dependencies in the current trace, using; // itinerary data.; /// Instruction depths have been computed. This implies hasValidDepth().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:80,Integrability,depend,dependency,80,/// Critical path length. This is the number of cycles in the longest data; /// dependency chain through the trace. This is only valid when both; /// HasValidInstrDepths and HasValidInstrHeights are set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:47,Integrability,depend,dependencies,47,/// Earliest issue cycle as determined by data dependencies and instruction; /// latencies from the beginning of the trace. Data dependencies from; /// before the trace are not included.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:129,Integrability,depend,dependencies,129,/// Earliest issue cycle as determined by data dependencies and instruction; /// latencies from the beginning of the trace. Data dependencies from; /// before the trace are not included.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:109,Integrability,depend,dependencies,109,"/// Minimum number of cycles from this instruction is issued to the of the; /// trace, as determined by data dependencies and instruction latencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:175,Performance,cache,cached,175,/// A trace represents a plausible sequence of executed basic blocks that; /// passes through the current basic block one. The Trace class serves as a; /// handle to internal cached data structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:274,Integrability,depend,dependencies,274,"/// Return the resource depth of the top/bottom of the trace center block.; /// This is the number of cycles required to execute all instructions from; /// the trace head to the trace center block. The resource depth only; /// considers execution resources, it ignores data dependencies.; /// When Bottom is set, instructions in the trace center block are included.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:357,Energy Efficiency,schedul,scheduling,357,"/// Return the resource length of the trace. This is the number of cycles; /// required to execute the instructions in the trace if they were all; /// independent, exposing the maximum instruction-level parallelism.; ///; /// Any blocks in Extrablocks are included as if they were part of the; /// trace. Likewise, extra resources required by the specified scheduling; /// classes are included. For the caller to account for extra machine; /// instructions, it must first resolve each instruction's scheduling class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:499,Energy Efficiency,schedul,scheduling,499,"/// Return the resource length of the trace. This is the number of cycles; /// required to execute the instructions in the trace if they were all; /// independent, exposing the maximum instruction-level parallelism.; ///; /// Any blocks in Extrablocks are included as if they were part of the; /// trace. Likewise, extra resources required by the specified scheduling; /// classes are included. For the caller to account for extra machine; /// instructions, it must first resolve each instruction's scheduling class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:35,Integrability,depend,dependency,35,/// Return the length of the (data dependency) critical path through the; /// trace.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:6,Integrability,depend,dependence,6,/// A dependence is useful if the basic block of the defining instruction; /// is part of the trace of the user instruction. It is assumed that DefMI; /// dominates UseMI (see also isUsefulDominator).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:4,Deployability,Update,Updates,4,"/// Updates the depth of an machine instruction, given RegUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:4,Deployability,Update,Updates,4,/// Updates the depth of the instructions from Start to End.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:346,Deployability,update,update,346,"/// Invalidate cached information about MBB. This must be called *before* MBB; /// is erased, or the CFG is otherwise changed.; ///; /// This invalidates per-block information about resource usage for MBB only,; /// and it invalidates per-trace information for any trace that passes; /// through MBB.; ///; /// Call Ensemble::getTrace() again to update any trace handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:15,Performance,cache,cached,15,"/// Invalidate cached information about MBB. This must be called *before* MBB; /// is erased, or the CFG is otherwise changed.; ///; /// This invalidates per-block information about resource usage for MBB only,; /// and it invalidates per-trace information for any trace that passes; /// through MBB.; ///; /// Call Ensemble::getTrace() again to update any trace handles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:89,Modifiability,extend,extended,89,// Simple value types that aren't explicitly part of this enumeration; // are considered extended value types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:3,Usability,Simpl,Simple,3,// Simple value types that aren't explicitly part of this enumeration; // are considered extended value types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:94,Testability,assert,asserts,94,// This is the current maximum for LAST_VALUETYPE.; // MVT::MAX_ALLOWED_VALUETYPE is used for asserts and to size bit vectors; // This value must be a multiple of 32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:35,Usability,simpl,simple,35,/// Return true if this is a valid simple valuetype.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:88,Integrability,depend,dependent,88,/// Return true if this is a vector value type where the; /// runtime length is machine dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:59,Performance,scalab,scalable,59,/// Return true if this is a custom target type that has a scalable size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:33,Performance,scalab,scalable,33,/// Return true if the type is a scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:42,Energy Efficiency,power,power,42,/// Returns true if the given vector is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:64,Energy Efficiency,power,power,64,/// Widens the length of the given vector MVT up to the nearest power of 2; /// and returns that type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:84,Performance,scalab,scalable,84,"/// Returns the size of the specified MVT in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:110,Performance,scalab,scalable,110,"/// Returns the size of the specified MVT in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:114,Performance,scalab,scalable,114,/// Return the size of the specified fixed width value type in bits. The; /// function will assert if the type is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:92,Testability,assert,assert,92,/// Return the size of the specified fixed width value type in bits. The; /// function will assert if the type is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:121,Performance,scalab,scalable,121,"/// Return the number of bytes overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:147,Performance,scalab,scalable,147,"/// Return the number of bytes overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:120,Performance,scalab,scalable,120,"/// Return the number of bits overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:146,Performance,scalab,scalable,146,"/// Return the number of bits overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:4,Usability,Simpl,SimpleValueType,4,/// SimpleValueType Iteration; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:435,Energy Efficiency,schedul,scheduling,435,"//===- MacroFusion.h - Macro Fusion -----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains the definition of the DAG scheduling mutation to; /// pair instructions back to back.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:168,Energy Efficiency,schedul,scheduled,168,/// Create an artificial edge between FirstSU and SecondSU.; /// Make data dependencies from the FirstSU also dependent on the SecondSU to; /// prevent them from being scheduled between the FirstSU and the SecondSU; /// and vice-versa.; /// Fusing more than 2 instructions is not currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:75,Integrability,depend,dependencies,75,/// Create an artificial edge between FirstSU and SecondSU.; /// Make data dependencies from the FirstSU also dependent on the SecondSU to; /// prevent them from being scheduled between the FirstSU and the SecondSU; /// and vice-versa.; /// Fusing more than 2 instructions is not currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:110,Integrability,depend,dependent,110,/// Create an artificial edge between FirstSU and SecondSU.; /// Make data dependencies from the FirstSU also dependent on the SecondSU to; /// prevent them from being scheduled between the FirstSU and the SecondSU; /// and vice-versa.; /// Fusing more than 2 instructions is not currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h:17,Energy Efficiency,schedul,scheduling,17,"/// Create a DAG scheduling mutation to pair instructions back to back; /// for instructions that benefit according to the target-specific; /// predicate functions. shouldScheduleAdjacent will be true if any of the; /// provided predicates are true.; /// If BranchOnly is true, only branch instructions with one of their; /// predecessors will be fused.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MacroFusion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRFormatter.h:18,Integrability,Interface,Interface,18,/// MIRFormater - Interface to format MIR operand based on target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRFormatter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRFormatter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h:460,Performance,load,loader,460,"//===----- MIRSampleProfile.h: SampleFDO Support in MIR ---*- c++ -*-------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the supoorting functions for machine level Sample FDO; // loader. This is used in Flow Sensitive SampelFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h:46,Availability,Mask,Mask,46,/// FS bits will only use the '1' bits in the Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:6,Integrability,wrap,wrapper,6,/// A wrapper around std::string which contains a source range that's being; /// set during parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:6,Integrability,wrap,wrapper,6,/// A wrapper around unsigned which contains a source range that's being set; /// during parsing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:83,Modifiability,Variab,VariableDbgInfo,83,/// Serializable representation of the MCRegister variant of; /// MachineFunction::VariableDbgInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h:40,Availability,mask,masks,40,// TODO: Serialize the various register masks.; // Frame information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRYamlMapping.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:35,Deployability,pipeline,pipeline,35,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1516,Deployability,pipeline,pipelined,1516," iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===-------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1565,Deployability,pipeline,pipeline,1565,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:2382,Deployability,pipeline,pipeline,2382,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:44,Energy Efficiency,schedul,schedule,44,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:427,Energy Efficiency,schedul,scheduling,427,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:610,Energy Efficiency,schedul,schedule,610,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:661,Energy Efficiency,Schedul,Scheduling,661,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:736,Energy Efficiency,schedul,schedule,736,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:837,Energy Efficiency,schedul,schedule,837,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:891,Energy Efficiency,schedul,schedule,891,"//===- ModuloSchedule.h - Software pipeline schedule expansion ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Software pipelining (SWP) is an instruction scheduling technique for loops; // that overlaps loop iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1769,Energy Efficiency,schedul,schedule,1769,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1830,Energy Efficiency,schedul,scheduled,1830,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:2160,Energy Efficiency,schedul,schedule,2160,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:1484,Testability,log,logical,1484," iterations and exploits ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===-------------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:2078,Usability,simpl,simple,2078,"its ILP via compiler transformations.; //; // There are multiple methods for analyzing a loop and creating a schedule.; // An example algorithm is Swing Modulo Scheduling (implemented by the; // MachinePipeliner). The details of how a schedule is arrived at are irrelevant; // for the task of actually rewriting a loop to adhere to the schedule, which; // is what this file does.; //; // A schedule is, for every instruction in a block, a Cycle and a Stage. Note; // that we only support single-block loops, so ""block"" and ""loop"" can be used; // interchangably.; //; // The Cycle of an instruction defines a partial order of the instructions in; // the remapped loop. Instructions within a cycle must not consume the output; // of any instruction in the same cycle. Cycle information is assumed to have; // been calculated such that the processor will execute instructions in; // lock-step (for example in a VLIW ISA).; //; // The Stage of an instruction defines the mapping between logical loop; // iterations and pipelined loop iterations. An example (unrolled) pipeline; // may look something like:; //; // I0[0] Execute instruction I0 of iteration 0; // I1[0], I0[1] Execute I0 of iteration 1 and I1 of iteration 1; // I1[1], I0[2]; // I1[2], I0[3]; //; // In the schedule for this unrolled sequence we would say that I0 was scheduled; // in stage 0 and I1 in stage 1:; //; // loop:; // [stage 0] x = I0; // [stage 1] I1 x (from stage 0); //; // And to actually generate valid code we must insert a phi:; //; // loop:; // x' = phi(x); // x = I0; // I1 x'; //; // This is a simple example; the rules for how to generate correct code given; // an arbitrary schedule containing loop-carried values are complex.; //; // Note that these examples only mention the steady-state kernel of the; // generated loop; prologs and epilogs must be generated also that prime and; // flush the pipeline. Doing so is nontrivial.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:17,Energy Efficiency,schedul,schedule,17,/// Represents a schedule for a single-block loop. For every instruction we; /// maintain a Cycle and Stage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:145,Energy Efficiency,schedul,schedule,145,"/// The instructions to be generated, in total order. Cycle provides a partial; /// order; the total order within cycles has been decided by the schedule; /// producer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:33,Energy Efficiency,schedul,schedule,33,/// The number of stages in this schedule (Max(Stage) + 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:43,Energy Efficiency,Schedul,ScheduledInstrs,43,"/// Create a new ModuloSchedule.; /// \arg ScheduledInstrs The new loop instructions, in total resequenced; /// order.; /// \arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does; /// not need to start at zero. ScheduledInstrs must be partially ordered by; /// Cycle.; /// \arg Stage Stage index for all instructions in ScheduleInstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:171,Energy Efficiency,Schedul,ScheduledInstrs,171,"/// Create a new ModuloSchedule.; /// \arg ScheduledInstrs The new loop instructions, in total resequenced; /// order.; /// \arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does; /// not need to start at zero. ScheduledInstrs must be partially ordered by; /// Cycle.; /// \arg Stage Stage index for all instructions in ScheduleInstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:231,Energy Efficiency,Schedul,ScheduledInstrs,231,"/// Create a new ModuloSchedule.; /// \arg ScheduledInstrs The new loop instructions, in total resequenced; /// order.; /// \arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does; /// not need to start at zero. ScheduledInstrs must be partially ordered by; /// Cycle.; /// \arg Stage Stage index for all instructions in ScheduleInstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:340,Energy Efficiency,Schedul,ScheduleInstrs,340,"/// Create a new ModuloSchedule.; /// \arg ScheduledInstrs The new loop instructions, in total resequenced; /// order.; /// \arg Cycle Cycle index for all instructions in ScheduledInstrs. Cycle does; /// not need to start at zero. ScheduledInstrs must be partially ordered by; /// Cycle.; /// \arg Stage Stage index for all instructions in ScheduleInstrs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:39,Energy Efficiency,schedul,scheduled,39,/// Return the single-block loop being scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:50,Energy Efficiency,schedul,schedule,50,"/// Return the number of stages contained in this schedule, which is the; /// largest stage index + 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:34,Energy Efficiency,schedul,schedule,34,"/// Return the first cycle in the schedule, which is the cycle index of the; /// first instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:34,Energy Efficiency,schedul,schedule,34,"/// Return the final cycle in the schedule, which is the cycle index of the; /// last instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:32,Energy Efficiency,schedul,scheduled,32,"/// Return the stage that MI is scheduled in, or -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:32,Energy Efficiency,schedul,scheduled,32,"/// Return the cycle that MI is scheduled at, or -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:226,Energy Efficiency,schedul,scheduled,226,/// Map for each register and the max difference between its uses and def.; /// The first element in the pair is the max difference in stages. The; /// second is true if the register defines a Phi value and loop value is; /// scheduled before the Phi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:51,Energy Efficiency,schedul,schedule,51,/// Instructions to change when emitting the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:251,Energy Efficiency,schedul,scheduled,251,/// The number of stages for a Phi is a little different than other; /// instructions. The minimum value computed in RegToStageDiff is 1; /// because we assume the Phi is needed for at least 1 iteration.; /// This is not the case if the loop value is scheduled prior to the; /// Phi in the same stage. This function returns the number of stages; /// or iterations needed between the Phi definition and any uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:207,Performance,optimiz,optimization,207,/// Create a new ModuloScheduleExpander.; /// \arg InstrChanges Modifications to make to instructions with memory; /// operands.; /// FIXME: InstrChanges is opaque and is an implementation detail of an; /// optimization in MachinePipeliner that crosses abstraction boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Performance,Perform,Performs,4,/// Performs the actual expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Performance,Perform,Performs,4,/// Performs final cleanup after expansion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:74,Performance,optimiz,optimized,74,"/// Returns the newly rewritten kernel block, or nullptr if this was; /// optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:67,Security,validat,validate,67,/// Runs ModuloScheduleExpander and treats it as a golden input to validate; /// aspects of the code generated by PeelingModuloScheduleExpander.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:41,Availability,avail,available,41,"/// For every block, the stages that are available. A stage can be available; /// but not produced (in the epilog) or produced but not available (in the; /// prolog).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:67,Availability,avail,available,67,"/// For every block, the stages that are available. A stage can be available; /// but not produced (in the epilog) or produced but not available (in the; /// prolog).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:135,Availability,avail,available,135,"/// For every block, the stages that are available. A stage can be available; /// but not produced (in the epilog) or produced but not available (in the; /// prolog).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:62,Deployability,pipeline,pipelined,62,"/// Converts BB from the original loop body to the rewritten, pipelined; /// steady-state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:53,Energy Efficiency,schedul,schedule,53,/// Helper to get the stage of an instruction in the schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:40,Energy Efficiency,schedul,scheduled,40,"/// Expander that simply annotates each scheduled instruction with a post-instr; /// symbol that can be consumed by the ModuloScheduleTest pass.; ///; /// The post-instr symbol is a way of annotating an instruction that can be; /// roundtripped in MIR. The syntax is:; /// MYINST %0, post-instr-symbol <mcsymbol Stage-1_Cycle-5>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:18,Usability,simpl,simply,18,"/// Expander that simply annotates each scheduled instruction with a post-instr; /// symbol that can be consumed by the ModuloScheduleTest pass.; ///; /// The post-instr symbol is a way of annotating an instruction that can be; /// roundtripped in MIR. The syntax is:; /// MYINST %0, post-instr-symbol <mcsymbol Stage-1_Cycle-5>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Performance,Perform,Performs,4,/// Performs the annotation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h:44,Energy Efficiency,Schedul,Scheduling,44,"//=- llvm/CodeGen/MultiHazardRecognizer.h - Scheduling Support ----*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h:473,Energy Efficiency,Schedul,ScheduleHazardRecognizer,473,"//=- llvm/CodeGen/MultiHazardRecognizer.h - Scheduling Support ----*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h:448,Integrability,wrap,wrapper,448,"//=- llvm/CodeGen/MultiHazardRecognizer.h - Scheduling Support ----*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the MultiHazardRecognizer class, which is a wrapper; // for a set of ScheduleHazardRecognizer instances; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MultiHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h:46,Usability,simpl,simply,46,/// Entries are stored into the StringMap and simply linked together through; /// the second element of this pair in order to keep track of insertion; /// order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h:102,Integrability,interface,interface,102,/// It's very easy to introduce bugs by passing the wrong string pool.; /// By using strong types the interface enforces that the right; /// kind of pool is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/NonRelocatableStringpool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:401,Integrability,interface,interfaces,401,"//===-- Passes.h - Target independent code generation passes ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code generation; // passes provided by the LLVM backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:415,Security,access,access,415,"//===-- Passes.h - Target independent code generation passes ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines interfaces to access the target independent code generation; // passes provided by the LLVM backend.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:116,Performance,optimiz,optimization,116,"/// createGCEmptyBasicblocksPass - Empty basic blocks (basic blocks without; /// real code) appear as the result of optimization passes removing; /// instructions. These blocks confuscate profile analysis (e.g., basic block; /// sections) since they will share the address of their fallthrough blocks.; /// This pass garbage-collects such basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:239,Safety,Abort,AbortOnFailedISel,239,"/// This pass resets a MachineFunction when it has the FailedISel property; /// as if it was just created.; /// If EmitFallbackDiag is true, the pass will emit a; /// DiagnosticInfoISelFallback for every MachineFunction it resets.; /// If AbortOnFailedISel is true, abort compilation instead of resetting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:266,Safety,abort,abort,266,"/// This pass resets a MachineFunction when it has the FailedISel property; /// as if it was just created.; /// If EmitFallbackDiag is true, the pass will emit a; /// DiagnosticInfoISelFallback for every MachineFunction it resets.; /// If AbortOnFailedISel is true, abort compilation instead of resetting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:59,Security,expose,expose,59,/// createCodeGenPrepareLegacyPass - Transform the code to expose more pattern; /// matching during instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:79,Performance,load,load-linked,79,/// AtomicExpandID -- Lowers atomic operations in terms of either cmpxchg; /// load-linked/store-conditional loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:81,Modifiability,variab,variable,81,/// LiveVariables pass - This pass computes the set of blocks in which each; /// variable is life and sets machine operand kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:38,Energy Efficiency,reduce,reduces,38,/// TwoAddressInstruction - This pass reduces two-address instructions to; /// use two operands. This destroys SSA information but it is desired by; /// register allocators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,Energy Efficiency,schedul,schedules,33,/// MachineScheduler - This pass schedules machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:37,Energy Efficiency,schedul,schedules,37,/// PostMachineScheduler - This pass schedules machine instructions postRA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:92,Deployability,update,update,92,/// ShrinkWrap pass. Look for the best place to insert save and restore; // instruction and update the MachineFunctionInfo with that information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:26,Modifiability,Rewrite,Rewrite,26,/// VirtRegRewriter pass. Rewrite virtual registers to physical registers as; /// assigned in VirtRegMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,perform,14,/// This pass perform post-ra machine sink for COPY instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:53,Energy Efficiency,allocate,allocates,53,/// FastRegisterAllocation Pass - This pass register allocates as fast as; /// possible. It is best suited for debug code where live ranges are short.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:96,Performance,optimiz,optimized,96,/// Greedy register allocation pass - This pass implements a global register; /// allocator for optimized builds.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:56,Safety,hazard,hazard,56,/// PostRAHazardRecognizer - This pass runs the post-ra hazard; /// recognizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:71,Energy Efficiency,schedul,scheduling,71,/// PostRAScheduler - This pass performs post register allocation; /// scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:32,Performance,perform,performs,32,/// PostRAScheduler - This pass performs post register allocation; /// scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:30,Performance,perform,performs,30,"/// BranchFolding - This pass performs machine code CFG based; /// optimizations to delete branches to branches, eliminate branches to; /// successor blocks (creating fall throughs), and eliminating branches over; /// branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:67,Performance,optimiz,optimizations,67,"/// BranchFolding - This pass performs machine code CFG based; /// optimizations to delete branches to branches, eliminate branches to; /// successor blocks (creating fall throughs), and eliminating branches over; /// branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,Performance,perform,performs,33,/// EarlyIfConverter - This pass performs if-conversion on SSA form by; /// inserting cmov instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,Performance,perform,performs,34,/// EarlyIfPredicator - This pass performs if-conversion on SSA form by; /// predicating if/else block and insert select at the join point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,performs,14,/// This pass performs instruction combining using trace metrics to estimate; /// critical-path and resource depth.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:106,Energy Efficiency,reduce,reduce,106,/// StackSlotColoring - This pass performs stack coloring and merging.; /// It merges disjoint allocas to reduce the stack size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,Performance,perform,performs,34,/// StackSlotColoring - This pass performs stack coloring and merging.; /// It merges disjoint allocas to reduce the stack size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:68,Modifiability,variab,variable,68,/// StackFramePrinter - This pass prints the stack frame layout and variable; /// mappings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:28,Performance,perform,performs,28,/// IfConverter - This pass performs machine code if conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:41,Performance,perform,perform,41,/// GCLowering Pass - Used by gc.root to perform its default lowering; /// operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:41,Performance,perform,perform,41,/// GCLowering Pass - Used by gc.root to perform its default lowering; /// operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:60,Safety,safe,safe,60,"/// GCMachineCodeAnalysis - Target-independent pass to mark safe points; /// in machine code. Must be added very late during code generation, just; /// prior to output, and importantly after all CFG transformations (such as; /// branch folding).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:27,Performance,perform,performs,27,/// MachineCSE - This pass performs global CSE on machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,performs,14,/// This pass performs loop invariant code motion on machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,performs,14,/// This pass performs loop invariant code motion on machine instructions.; /// This variant works before register allocation. \see MachineLICMID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:31,Performance,perform,performs,31,/// MachineSinking - This pass performs sinking on machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:39,Performance,perform,performs,39,/// MachineCopyPropagation - This pass performs copy propagation on; /// machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:49,Availability,redundant,redundant,49,/// MachineLateInstrsCleanup - This pass removes redundant identical; /// instructions after register allocation and rematerialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:49,Safety,redund,redundant,49,/// MachineLateInstrsCleanup - This pass removes redundant identical; /// instructions after register allocation and rematerialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,Performance,perform,performs,34,/// PeepholeOptimizer - This pass performs peephole optimizations -; /// like extension and comparison eliminations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:52,Performance,optimiz,optimizations,52,/// PeepholeOptimizer - This pass performs peephole optimizations -; /// like extension and comparison eliminations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:4,Performance,Optimiz,OptimizePHIs,4,/// OptimizePHIs - This pass optimizes machine instruction PHIs; /// to take advantage of opportunities created during DAG legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:29,Performance,optimiz,optimizes,29,/// OptimizePHIs - This pass optimizes machine instruction PHIs; /// to take advantage of opportunities created during DAG legalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,Performance,perform,performs,34,/// StackSlotColoring - This pass performs stack slot coloring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:30,Deployability,patch,patchable-function,30,"/// This pass implements the ""patchable-function"" attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:83,Energy Efficiency,adapt,adapted,83,/// createDwarfEHPass - This pass mulches exception handling code into a form; /// adapted to code generation. Required if using dwarf exception handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:83,Modifiability,adapt,adapted,83,/// createDwarfEHPass - This pass mulches exception handling code into a form; /// adapted to code generation. Required if using dwarf exception handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:40,Energy Efficiency,adapt,adapts,40,/// createSjLjEHPreparePass - This pass adapts exception handling code to use; /// the GCC-style builtin setjmp/longjmp (sjlj) to handling EH control flow.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:40,Modifiability,adapt,adapts,40,/// createSjLjEHPreparePass - This pass adapts exception handling code to use; /// the GCC-style builtin setjmp/longjmp (sjlj) to handling EH control flow.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,Energy Efficiency,adapt,adapts,33,/// createWasmEHPass - This pass adapts exception handling code to use; /// WebAssembly's exception handling scheme.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,Modifiability,adapt,adapts,33,/// createWasmEHPass - This pass adapts exception handling code to use; /// WebAssembly's exception handling scheme.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:117,Energy Efficiency,allocate,allocates,117,/// LocalStackSlotAllocation - This pass assigns local frame indices to stack; /// slots relative to one another and allocates base registers to access them; /// when it is estimated by the target to be out of range of normal frame; /// pointer or stack pointer index addressing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:145,Security,access,access,145,/// LocalStackSlotAllocation - This pass assigns local frame indices to stack; /// slots relative to one another and allocates base registers to access them; /// when it is estimated by the target to be out of range of normal frame; /// pointer or stack pointer index addressing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:118,Energy Efficiency,schedul,scheduling,118,"/// FinalizeMachineBundles - This pass finalize machine instruction; /// bundles (created earlier, e.g. during pre-RA scheduling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:85,Deployability,patch,patchpoint,85,/// StackMapLiveness - This pass analyses the register live-out set of; /// stackmap/patchpoint intrinsics and attaches the calculated information to; /// the intrinsic for later emission to the StackMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:54,Security,sanitiz,sanitizer,54,// MachineSanitizerBinaryMetadata - appends/finalizes sanitizer binary; // metadata after llvm SanitizerBinaryMetadata pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:95,Security,Sanitiz,SanitizerBinaryMetadata,95,// MachineSanitizerBinaryMetadata - appends/finalizes sanitizer binary; // metadata after llvm SanitizerBinaryMetadata pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:86,Security,access,accesses,86,/// InterleavedAccess Pass - This pass identifies and matches interleaved; /// memory accesses to target specific intrinsics.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:68,Performance,load,loads,68,/// InterleavedLoadCombines Pass - This pass identifies interleaved loads and; /// combines them into wide loads detectable by InterleavedAccessPass; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:107,Performance,load,loads,107,/// InterleavedLoadCombines Pass - This pass identifies interleaved loads and; /// combines them into wide loads detectable by InterleavedAccessPass; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:113,Safety,detect,detectable,113,/// InterleavedLoadCombines Pass - This pass identifies interleaved loads and; /// combines them into wide loads detectable by InterleavedAccessPass; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:56,Modifiability,variab,variables,56,/// LowerEmuTLS - This pass generates __emutls_[vt].xyz variables for all; /// TLS variables for the emulated TLS model.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:83,Modifiability,variab,variables,83,/// LowerEmuTLS - This pass generates __emutls_[vt].xyz variables for all; /// TLS variables for the emulated TLS model.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:32,Performance,load,load,32,"/// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to; /// instructions. This is unsafe to do earlier because a pass may combine the; /// constant initializer into the load, which may result in an overflowing; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:192,Performance,load,load,192,"/// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to; /// instructions. This is unsafe to do earlier because a pass may combine the; /// constant initializer into the load, which may result in an overflowing; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:105,Safety,unsafe,unsafe,105,"/// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to; /// instructions. This is unsafe to do earlier because a pass may combine the; /// constant initializer into the load, which may result in an overflowing; /// evaluation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:166,Modifiability,config,configured,166,/// GlobalMerge - This pass merges internal (by default) globals into structs; /// to enable reuse of a base pointer by indexed addressing modes.; /// It can also be configured to focus on size optimizations only.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:194,Performance,optimiz,optimizations,194,/// GlobalMerge - This pass merges internal (by default) globals into structs; /// to enable reuse of a base pointer by indexed addressing modes.; /// It can also be configured to focus on size optimizations only.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:38,Safety,safe,safe,38,/// This pass splits the stack into a safe stack and an unsafe stack to; /// protect against stack-based overflow vulnerabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:56,Safety,unsafe,unsafe,56,/// This pass splits the stack into a safe stack and an unsafe stack to; /// protect against stack-based overflow vulnerabilities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Safety,detect,detects,14,/// This pass detects subregister lanes in a virtual register that are used; /// independently of other lanes and splits them into separate virtual; /// registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:136,Availability,avail,available,136,/// Return a MachineFunction pass that identifies call sites; /// and propagates register usage information of callee to caller; /// if available with PysicalRegisterUsageInfo pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,performs,14,/// This pass performs software pipelining on machine instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,Performance,perform,performs,14,/// This pass performs outlining on machine instructions directly before; /// printing assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:164,Availability,mask,mask,164,/// This pass expands the vector predication intrinsics into unpredicated; /// instructions with selects or just the explicit vector length into the; /// predicate mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,Performance,load,load,33,// This pass expands memcmp() to load/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:24,Integrability,Depend,Dependencies,24,/// Creates Break False Dependencies pass. \see BreakFalseDeps.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:24,Performance,load,load,24,/// The pass transforms load/store <256 x i32> to AMX load/store intrinsics; /// or split the data to two <128 x i32>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:54,Performance,load,load,54,/// The pass transforms load/store <256 x i32> to AMX load/store intrinsics; /// or split the data to two <128 x i32>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:9,Usability,learn,learning,9,"/// When learning an eviction policy, extract score(reward) information,; /// otherwise this does nothing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h:417,Integrability,interface,interface,417,"//===- llvm/CodeGen/PBQPRAConstraint.h --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PBQPBuilder interface, for classes which build PBQP; // instances to represent register allocation problems, and the RegAllocPBQP; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h:539,Integrability,interface,interface,539,"//===- llvm/CodeGen/PBQPRAConstraint.h --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PBQPBuilder interface, for classes which build PBQP; // instances to represent register allocation problems, and the RegAllocPBQP; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQPRAConstraint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h:429,Performance,load,load,429,"//===- PreISelIntrinsicLowering.h - Pre-ISel intrinsic lowering pass ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR lowering for the llvm.load.relative and llvm.objc.*; // intrinsics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h:93,Security,access,access,93,"/// Special value supplied for machine level alias analysis. It indicates that; /// a memory access references the functions stack frame (e.g., a spill slot),; /// below the stack frame (e.g., argument space), or constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h:4,Testability,Test,Test,4,/// Test whether the memory pointed to by this PseudoSourceValue has a; /// constant value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h:4,Testability,Test,Test,4,/// Test whether the memory pointed to by this PseudoSourceValue may also be; /// pointed to by an LLVM IR Value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PseudoSourceValue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:1465,Energy Efficiency,consumption,consumption,1465,"r data flow (RDF); // for a non-SSA program representation (e.g. post-RA machine code).; //; //; // *** Introduction; //; // The RDF graph is a collection of nodes, each of which denotes some element; // of the program. There are two main types of such elements: code and refe-; // rences. Conceptually, ""code"" is something that represents the structure; // of the program, e.g. basic block or a statement, while ""reference"" is an; // instance of accessing a register, e.g. a definition or a use. Nodes are; // connected with each other based on the structure of the program (such as; // blocks, instructions, etc.), and based on the data flow (e.g. reaching; // definitions, reached uses, etc.). The single-reaching-definition principle; // of SSA is generally observed, although, due to the non-SSA representation; // of the program, there are some differences between the graph and a ""pure""; // SSA representation.; //; //; // *** Implementation remarks; //; // Since the graph can contain a large number of nodes, memory consumption; // was one of the major design considerations. As a result, there is a single; // base class NodeBase which defines all members used by all possible derived; // classes. The members are arranged in a union, and a derived class cannot; // add any data members of its own. Each derived class only defines the; // functional interface, i.e. member functions. NodeBase must be a POD,; // which implies that all of its members must also be PODs.; // Since nodes need to be connected with other nodes, pointers have been; // replaced with 32-bit identifiers: each node has an id of type NodeId.; // There are mapping functions in the graph that translate between actual; // memory addresses and the corresponding identifiers.; // A node id of 0 is equivalent to nullptr.; //; //; // *** Structure of the graph; //; // A code node is always a collection of other nodes. For example, a code; // node corresponding to a basic block will contain code nodes corresponding; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:1800,Integrability,interface,interface,1800,"the structure; // of the program, e.g. basic block or a statement, while ""reference"" is an; // instance of accessing a register, e.g. a definition or a use. Nodes are; // connected with each other based on the structure of the program (such as; // blocks, instructions, etc.), and based on the data flow (e.g. reaching; // definitions, reached uses, etc.). The single-reaching-definition principle; // of SSA is generally observed, although, due to the non-SSA representation; // of the program, there are some differences between the graph and a ""pure""; // SSA representation.; //; //; // *** Implementation remarks; //; // Since the graph can contain a large number of nodes, memory consumption; // was one of the major design considerations. As a result, there is a single; // base class NodeBase which defines all members used by all possible derived; // classes. The members are arranged in a union, and a derived class cannot; // add any data members of its own. Each derived class only defines the; // functional interface, i.e. member functions. NodeBase must be a POD,; // which implies that all of its members must also be PODs.; // Since nodes need to be connected with other nodes, pointers have been; // replaced with 32-bit identifiers: each node has an id of type NodeId.; // There are mapping functions in the graph that translate between actual; // memory addresses and the corresponding identifiers.; // A node id of 0 is equivalent to nullptr.; //; //; // *** Structure of the graph; //; // A code node is always a collection of other nodes. For example, a code; // node corresponding to a basic block will contain code nodes corresponding; // to instructions. In turn, a code node corresponding to an instruction will; // contain a list of reference nodes that correspond to the definitions and; // uses of registers in that instruction. The members are arranged into a; // circular list, which is yet another consequence of the effort to save; // memory: for each member node it s",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:887,Security,access,accessing,887,"//===- RDFGraph.h -----------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Target-independent, SSA-based data flow graph for register data flow (RDF); // for a non-SSA program representation (e.g. post-RA machine code).; //; //; // *** Introduction; //; // The RDF graph is a collection of nodes, each of which denotes some element; // of the program. There are two main types of such elements: code and refe-; // rences. Conceptually, ""code"" is something that represents the structure; // of the program, e.g. basic block or a statement, while ""reference"" is an; // instance of accessing a register, e.g. a definition or a use. Nodes are; // connected with each other based on the structure of the program (such as; // blocks, instructions, etc.), and based on the data flow (e.g. reaching; // definitions, reached uses, etc.). The single-reaching-definition principle; // of SSA is generally observed, although, due to the non-SSA representation; // of the program, there are some differences between the graph and a ""pure""; // SSA representation.; //; //; // *** Implementation remarks; //; // Since the graph can contain a large number of nodes, memory consumption; // was one of the major design considerations. As a result, there is a single; // base class NodeBase which defines all members used by all possible derived; // classes. The members are arranged in a union, and a derived class cannot; // add any data members of its own. Each derived class only defines the; // functional interface, i.e. member functions. NodeBase must be a POD,; // which implies that all of its members must also be PODs.; // Since nodes need to be connected with other nodes, pointers have been; // repl",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:2853,Security,access,access,2853,"ived class only defines the; // functional interface, i.e. member functions. NodeBase must be a POD,; // which implies that all of its members must also be PODs.; // Since nodes need to be connected with other nodes, pointers have been; // replaced with 32-bit identifiers: each node has an id of type NodeId.; // There are mapping functions in the graph that translate between actual; // memory addresses and the corresponding identifiers.; // A node id of 0 is equivalent to nullptr.; //; //; // *** Structure of the graph; //; // A code node is always a collection of other nodes. For example, a code; // node corresponding to a basic block will contain code nodes corresponding; // to instructions. In turn, a code node corresponding to an instruction will; // contain a list of reference nodes that correspond to the definitions and; // uses of registers in that instruction. The members are arranged into a; // circular list, which is yet another consequence of the effort to save; // memory: for each member node it should be possible to obtain its owner,; // and it should be possible to access all other members. There are other; // ways to accomplish that, but the circular list seemed the most natural.; //; // +- CodeNode -+; // | | <---------------------------------------------------+; // +-+--------+-+ |; // |FirstM |LastM |; // | +-------------------------------------+ |; // | | |; // V V |; // +----------+ Next +----------+ Next Next +----------+ Next |; // | |----->| |-----> ... ----->| |----->-+; // +- Member -+ +- Member -+ +- Member -+; //; // The order of members is such that related reference nodes (see below); // should be contiguous on the member list.; //; // A reference node is a node that encapsulates an access to a register,; // in other words, data flowing into or out of a register. There are two; // major kinds of reference nodes: defs and uses. A def node will contain; // the id of the first reached use, and the id of the first reached def.; // Each def an",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:3498,Security,access,access,3498,"on will; // contain a list of reference nodes that correspond to the definitions and; // uses of registers in that instruction. The members are arranged into a; // circular list, which is yet another consequence of the effort to save; // memory: for each member node it should be possible to obtain its owner,; // and it should be possible to access all other members. There are other; // ways to accomplish that, but the circular list seemed the most natural.; //; // +- CodeNode -+; // | | <---------------------------------------------------+; // +-+--------+-+ |; // |FirstM |LastM |; // | +-------------------------------------+ |; // | | |; // V V |; // +----------+ Next +----------+ Next Next +----------+ Next |; // | |----->| |-----> ... ----->| |----->-+; // +- Member -+ +- Member -+ +- Member -+; //; // The order of members is such that related reference nodes (see below); // should be contiguous on the member list.; //; // A reference node is a node that encapsulates an access to a register,; // in other words, data flowing into or out of a register. There are two; // major kinds of reference nodes: defs and uses. A def node will contain; // the id of the first reached use, and the id of the first reached def.; // Each def and use will contain the id of the reaching def, and also the; // id of the next reached def (for def nodes) or use (for use nodes).; // The ""next node sharing the same reaching def"" is denoted as ""sibling"".; // In summary:; // - Def node contains: reaching def, sibling, first reached def, and first; // reached use.; // - Use node contains: reaching def and sibling.; //; // +-- DefNode --+; // | R2 = ... | <---+--------------------+; // ++---------+--+ | |; // |Reached |Reached | |; // |Def |Use | |; // | | |Reaching |Reaching; // | V |Def |Def; // | +-- UseNode --+ Sib +-- UseNode --+ Sib Sib; // | | ... = R2 |----->| ... = R2 |----> ... ----> 0; // | +-------------+ +-------------+; // V; // +-- DefNode --+ Sib; // | R2 = ... |----> ...; // +",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:3,Testability,Test,Test,3,// Test if A contains B.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:53,Safety,avoid,avoid,53,// Use these short names with rdf:: qualification to avoid conflicts with; // preexisting names. Do not use 'using namespace rdf'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:294,Energy Efficiency,allocate,allocated,294,"// Fast memory allocation and translation between node id and node address.; // This is really the same idea as the one underlying the ""bump pointer; // allocator"", the difference being in the translation. A node id is; // composed of two components: the index of the block in which it was; // allocated, and the index within the block. With the default settings,; // where the number of nodes per block is 4096, the node id (minus 1) is:; //; // bit position: 11 0; // +----------------------------+--------------+; // | Index of the block |Index in block|; // +----------------------------+--------------+; //; // The actual node id is the above plus 1, to avoid creating a node id of 0.; //; // This method significantly improved the build time, compared to using maps; // (std::unordered_map or DenseMap) to translate between pointers and ids.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:659,Safety,avoid,avoid,659,"// Fast memory allocation and translation between node id and node address.; // This is really the same idea as the one underlying the ""bump pointer; // allocator"", the difference being in the translation. A node id is; // composed of two components: the index of the block in which it was; // allocated, and the index within the block. With the default settings,; // where the number of nodes per block is 4096, the node id (minus 1) is:; //; // bit position: 11 0; // +----------------------------+--------------+; // | Index of the block |Index in block|; // +----------------------------+--------------+; //; // The actual node id is the above plus 1, to avoid creating a node id of 0.; //; // This method significantly improved the build time, compared to using maps; // (std::unordered_map or DenseMap) to translate between pointers and ids.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:23,Safety,avoid,avoid,23,"// Add 1 to the id, to avoid the id of 0, which is treated as ""null"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:147,Usability,clear,clearer,147,"// Id of the next node in the circular chain.; // Definitions of nested types. Using anonymous nested structs would make; // this class definition clearer, but unnamed structs are not a part of; // the standard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:17,Energy Efficiency,allocate,allocates,17,// The allocator allocates chunks of 32 bytes for each node. The fact that; // each node takes 32 bytes in memory is used for fast translation between; // the node id and the node address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:45,Security,access,accessing,45,// Make this std::unordered_map for speed of accessing elements.; // Map: Register (physical or virtual) -> DefStack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:8,Availability,mask,mask,8,// Lane mask map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h:126,Energy Efficiency,reduce,reduces,126,// Cache of mapping from node ids (for RefNodes) to the containing; // basic blocks. Not computing it each time for each node reduces; // the liveness calculation time by a large fraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h:3,Performance,Cache,Cache,3,// Cache of mapping from node ids (for RefNodes) to the containing; // basic blocks. Not computing it each time for each node reduces; // the liveness calculation time by a large fraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFLiveness.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:247,Energy Efficiency,allocate,allocated,247,"// Template class for a map translating uint32_t into arbitrary types.; // The map will act like an indexed set: upon insertion of a new object,; // it will automatically assign a new index to it. Index of 0 is treated; // as invalid and is never allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:13,Availability,Mask,MaskId,13,// RegId and MaskId are unchanged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:107,Security,access,accessed,107,"// This is really a std::map, except that it provides a non-trivial; // default constructor to the element accessed via [].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h:18,Availability,mask,mask,18,// Print the lane mask in a short form (or not at all if all bits are set).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFRegisters.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:566,Usability,clear,clearance,566,"//==--- llvm/CodeGen/ReachingDefAnalysis.h - Reaching Def Analysis -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Reaching Defs Analysis pass.; ///; /// This pass tracks for each instruction what is the ""closest"" reaching def of; /// a given register. It is used by BreakFalseDeps (for clearance calculation); /// and ExecutionDomainFix (for arbitrating conflicting domains).; ///; /// Note that this is different from the usual definition notion of liveness.; /// The CPU doesn't care whether or not we consider a register killed.; ///; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:9,Integrability,wrap,wrapper,9,"/// Thin wrapper around ""int"" used to store reaching definitions,; /// using an encoding that makes it compatible with TinyPtrVector.; /// The 0th LSB is forced zero (and will be used for pointer union tagging),; /// The 1st LSB is forced one (to make sure the value is non-zero).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:10,Usability,clear,clearance,10,/// Keeps clearance information for all registers. Note that this; /// is different from the usual definition notion of liveness. The CPU; /// doesn't care whether or not we consider a register killed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:17,Usability,clear,clearance,17,/// Provides the clearance - the number of instructions since the closest; /// reaching def instuction of PhysReg that reaches MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:100,Availability,redundant,redundant,100,"/// Return whether removing this instruction will have no effect on the; /// program, returning the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:100,Safety,redund,redundant,100,"/// Return whether removing this instruction will have no effect on the; /// program, returning the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,Availability,redundant,redundant,157,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,Safety,redund,redundant,157,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:62,Safety,safe,safely,62,/// Return whether a MachineInstr could be inserted at MI and safely define; /// the given register without affecting the program.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:62,Safety,safe,safely,62,"/// Return whether a MachineInstr could be inserted at MI and safely define; /// the given register without affecting the program, ignoring any effects; /// on the provided instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:4,Deployability,Update,Update,4,/// Update live-out values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:4,Deployability,Update,Update,4,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:65,Integrability,depend,dependencies,65,/// Update def-ages for registers defined by MI.; /// Also break dependencies on partial defs and undef uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,Availability,redundant,redundant,157,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,Safety,redund,redundant,157,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h:105,Energy Efficiency,allocate,allocated,105,/// Default register class filter function for register allocation. All virtual; /// registers should be allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocCommon.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:417,Integrability,interface,interface,417,"//===- RegAllocPBQP.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PBQPBuilder interface, for classes which build PBQP; // instances to represent register allocation problems, and the RegAllocPBQP; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:539,Integrability,interface,interface,539,"//===- RegAllocPBQP.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PBQPBuilder interface, for classes which build PBQP; // instances to represent register allocation problems, and the RegAllocPBQP; // interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:37,Testability,test,test,37,/// Metadata to speed allocatability test.; ///; /// Keeps track of the number of infinities in each row and column.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:83,Availability,avail,available,83,// Remember this state to assert later that a non-infinite register; // option was available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:26,Testability,assert,assert,26,// Remember this state to assert later that a non-infinite register; // option was available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:47,Deployability,update,update,47,"// Metadata are computed incrementally. First, update them; // by removing the old cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:7,Deployability,update,update,7,// And update now the metadata with the new cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:45,Deployability,update,update,45,"// As the metadata may have changed with the update, the nodes may have; // become ConservativelyAllocatable or OptimallyReducible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:245,Energy Efficiency,reduce,reduced,245,"// Compute a reduction order for the graph by iteratively applying PBQP; // reduction rules. Locally optimal rules are applied whenever possible (R0,; // R1, R2). If no locally-optimal rules apply then any conservatively; // allocatable node is reduced. Finally, if no conservatively allocatable; // node exists then the node with the lowest spill-cost:degree ratio is; // selected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h:146,Performance,optimiz,optimizing,146,"// Conservatively allocatable nodes will never spill. For now just; // take the first node in the set and push it on the stack. When we; // start optimizing more heavily for register preferencing, it may; // would be better to push nodes with lower 'expected' or worst-case; // register costs first (since early nodes are the most; // constrained).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocPBQP.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocRegistry.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegAllocRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper class representing virtual and physical registers. Should be passed; /// by value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h:406,Energy Efficiency,allocate,allocated,406,"// Register numbers can represent physical registers, virtual registers, and; // sometimes stack slots. The unsigned values are divided into these ranges:; //; // 0 Not a register, can be used as a sentinel.; // [1;2^30) Physical registers assigned by TableGen.; // [2^30;2^31) Stack slots. (Rarely used.); // [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.; //; // Further sentinels can be allocated from the small negative integers.; // DenseMapInfo<unsigned> uses -1u and -2u.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h:99,Modifiability,variab,variable,99,/// isStackSlot - Sometimes it is useful the be able to store a non-negative; /// frame index in a variable that normally holds a register. isStackSlot(); /// returns true if Reg is in the range used for stack slots.; ///; /// FIXME: remove in favor of member.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h:101,Security,validat,validated,101,"/// Utility to check-convert this value to a MCRegister. The caller is; /// expected to have already validated that this Register is, indeed,; /// physical.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Register.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h:157,Testability,assert,assertions,157,"/// Check if this register bank is valid. In other words,; /// if it has been properly constructed.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h:22,Availability,mask,mask,22,/// Dump the register mask on dbgs() stream.; /// The dump is verbose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h:23,Availability,mask,mask,23,"/// Print the register mask on OS.; /// If IsForDebug is false, then only the name of the register bank; /// is printed. Otherwise, all the fields are printing.; /// TRI is then used to print the name of the register classes that; /// this register bank covers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBank.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:228,Availability,Mask,Mask,228,/// Helper struct that represents how a value is partially mapped; /// into a register.; /// The StartIdx and Length represent what region of the orginal; /// value this partial mapping covers.; /// This can be represented as a Mask of contiguous bit starting; /// at StartIdx bit and spanning Length bits.; /// StartIdx is the number of bits from the less significant bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:19,Availability,Mask,Mask,19,"/// Check that the Mask is compatible with the RegBank.; /// Indeed, if the RegBank cannot accomadate the ""active bits"" of the mask,; /// there is no way this mapping is valid.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:127,Availability,mask,mask,127,"/// Check that the Mask is compatible with the RegBank.; /// Indeed, if the RegBank cannot accomadate the ""active bits"" of the mask,; /// there is no way this mapping is valid.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:234,Testability,assert,assertions,234,"/// Check that the Mask is compatible with the RegBank.; /// Indeed, if the RegBank cannot accomadate the ""active bits"" of the mask,; /// there is no way this mapping is valid.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:28,Availability,down,down,28,/// How the value is broken down between the different register banks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:39,Availability,down,down,39,/// Number of partial mapping to break down this value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:136,Testability,assert,assertions,136,/// Verify that this mapping makes sense for a value of; /// \p MeaningfulBitWidth.; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:91,Performance,optimiz,optimizers,91,/// Identifier of the mapping.; /// This is used to communicate between the target and the optimizers; /// which mapping should be realized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:186,Energy Efficiency,efficient,efficient,186,/// Constructor for the mapping of an instruction.; /// \p NumOperands must be equal to number of all the operands of; /// the related instruction.; /// The rationale is that it is more efficient for the optimizers; /// to be able to assume that the mapping of the ith operand is; /// at the index i.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:204,Performance,optimiz,optimizers,204,/// Constructor for the mapping of an instruction.; /// \p NumOperands must be equal to number of all the operands of; /// the related instruction.; /// The rationale is that it is more efficient for the optimizers; /// to be able to assume that the mapping of the ith operand is; /// at the index i.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:166,Testability,assert,assertions,166,/// Verifiy that this mapping makes sense for \p MI.; /// \pre \p MI must be connected to a MachineFunction.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:183,Safety,avoid,avoid,183,/// The OpIdx-th cell contains the index in NewVRegs where the VRegs of the; /// OpIdx-th operand starts. -1 means we do not have such mapping yet.; /// Note: We use a SmallVector to avoid heap allocation for most cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,Energy Efficiency,allocate,allocated,21,/// Keep dynamically allocated PartialMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,Energy Efficiency,allocate,allocated,21,/// Keep dynamically allocated ValueMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,Energy Efficiency,allocate,allocated,21,/// Keep dynamically allocated array of ValueMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:21,Energy Efficiency,allocate,allocated,21,/// Keep dynamically allocated InstructionMapping in a separate map.; /// This shouldn't be needed when everything gets TableGen'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:71,Performance,Cache,Cache,71,/// Getting the minimal register class of a physreg is expensive.; /// Cache this information as we get it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:257,Availability,failure,failures,257,"/// This constructor is meaningless.; /// It just provides a default constructor that can be used at link time; /// when GlobalISel is not built.; /// That way, targets can still inherit from this class without doing; /// crazy gymnastic to avoid link time failures.; /// \note That works because the constructor is inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:179,Modifiability,inherit,inherit,179,"/// This constructor is meaningless.; /// It just provides a default constructor that can be used at link time; /// when GlobalISel is not built.; /// That way, targets can still inherit from this class without doing; /// crazy gymnastic to avoid link time failures.; /// \note That works because the constructor is inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:241,Safety,avoid,avoid,241,"/// This constructor is meaningless.; /// It just provides a default constructor that can be used at link time; /// when GlobalISel is not built.; /// That way, targets can still inherit from this class without doing; /// crazy gymnastic to avoid link time failures.; /// \note That works because the constructor is inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:583,Safety,abort,abort,583,"/// Helper method to apply something that is like the default mapping.; /// Basically, that means that \p OpdMapper.getMI() is left untouched; /// aside from the reassignment of the register operand that have been; /// remapped.; ///; /// The type of all the new registers that have been created by the; /// mapper are properly remapped to the type of the original registers; /// they replace. In other words, the semantic of the instruction does; /// not change, only the register banks.; ///; /// If the mapping of one of the operand spans several registers, this; /// method will abort as this is not like a default mapping anymore.; ///; /// \pre For OpIdx in {0..\p OpdMapper.getMI().getNumOperands()); /// the range OpdMapper.getVRegs(OpIdx) is empty or of size 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:157,Safety,avoid,avoid,157,/// Identifier used when the related instruction mapping instance; /// is generated by target independent code.; /// Make sure not to use that identifier to avoid possible collision.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:277,Deployability,update,updated,277,"/// Get the mapping of the different operands of \p MI; /// on the register bank.; /// This mapping should be the direct translation of \p MI.; /// In other words, when \p MI is mapped with the returned mapping,; /// only the register banks of the operands of \p MI need to be updated.; /// In particular, neither the opcode nor the type of \p MI needs to be; /// updated for this direct mapping.; ///; /// The target independent implementation gives a mapping based on; /// the register classes for the target specific opcode.; /// It uses the ID RegisterBankInfo::DefaultMappingID for that mapping.; /// Make sure you do not use that ID for the alternative mapping; /// for MI. See getInstrAlternativeMappings for the alternative; /// mappings.; ///; /// For instance, if \p MI is a vector add, the mapping should; /// not be a scalarization of the add.; ///; /// \post returnedVal.verify(MI).; ///; /// \note If returnedVal does not verify MI, this would probably mean; /// that the target does not support that instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:364,Deployability,update,updated,364,"/// Get the mapping of the different operands of \p MI; /// on the register bank.; /// This mapping should be the direct translation of \p MI.; /// In other words, when \p MI is mapped with the returned mapping,; /// only the register banks of the operands of \p MI need to be updated.; /// In particular, neither the opcode nor the type of \p MI needs to be; /// updated for this direct mapping.; ///; /// The target independent implementation gives a mapping based on; /// the register classes for the target specific opcode.; /// It uses the ID RegisterBankInfo::DefaultMappingID for that mapping.; /// Make sure you do not use that ID for the alternative mapping; /// for MI. See getInstrAlternativeMappings for the alternative; /// mappings.; ///; /// For instance, if \p MI is a vector add, the mapping should; /// not be a scalarization of the add.; ///; /// \post returnedVal.verify(MI).; ///; /// \note If returnedVal does not verify MI, this would probably mean; /// that the target does not support that instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:144,Testability,assert,assertions,144,/// Check that information hold by this instance make sense for the; /// given \p TRI.; ///; /// \note This method does not check anything when assertions are disabled.; ///; /// \return True is the check was successful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:4,Security,Hash,Hashing,4,/// Hashing function for PartialMapping.; /// It is required for the hashing of ValueMapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:69,Security,hash,hashing,69,/// Hashing function for PartialMapping.; /// It is required for the hashing of ValueMapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h:542,Integrability,depend,depends,542,"//===- RegisterClassInfo.h - Dynamic Register Class Info --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the RegisterClassInfo class which provides dynamic; // information about target register classes. Callee saved and reserved; // registers depends on calling conventions and other dynamic information, so; // some things cannot be determined statically.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h:9,Performance,cache,cached,9,// Brief cached information for each register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h:24,Performance,cache,cached,24,// Tag changes whenever cached information needs to be recomputed. An RCInfo; // entry is valid when its tag matches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h:71,Deployability,update,update,71,// Callee saved registers of last MF.; // Used only to determine if an update for CalleeSavedAliases is necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterClassInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:365,Availability,avail,available,365,"/// RegisterPressure computed within a region of instructions delimited by; /// TopIdx and BottomIdx. During pressure computation, the maximum pressure per; /// register pressure set is increased. Once pressure within a region is fully; /// computed, the live-in and live-out sets are recorded.; ///; /// This is preferable to RegionPressure when LiveIntervals are available,; /// because delimiting regions by SlotIndex is more robust and convenient than; /// holding block iterators. The block contents can change without invalidating; /// the pressure result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:429,Availability,robust,robust,429,"/// RegisterPressure computed within a region of instructions delimited by; /// TopIdx and BottomIdx. During pressure computation, the maximum pressure per; /// register pressure set is increased. Once pressure within a region is fully; /// computed, the live-in and live-out sets are recorded.; ///; /// This is preferable to RegionPressure when LiveIntervals are available,; /// because delimiting regions by SlotIndex is more robust and convenient than; /// holding block iterators. The block contents can change without invalidating; /// the pressure result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:112,Availability,down,downward,112,"/// Capture a change in pressure for a single pressure set. UnitInc may be; /// expressed in terms of upward or downward pressure depending on the client; /// and will be dynamically adjusted for current liveness.; ///; /// Pressure increments are tiny, typically 1-2 units, and this is only for; /// heuristics, so we don't check UnitInc overflow. Instead, we may have a; /// higher level assert that pressure is consistent within a region. We also; /// effectively ignore dead defs which don't affect heuristics much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:130,Integrability,depend,depending,130,"/// Capture a change in pressure for a single pressure set. UnitInc may be; /// expressed in terms of upward or downward pressure depending on the client; /// and will be dynamically adjusted for current liveness.; ///; /// Pressure increments are tiny, typically 1-2 units, and this is only for; /// heuristics, so we don't check UnitInc overflow. Instead, we may have a; /// higher level assert that pressure is consistent within a region. We also; /// effectively ignore dead defs which don't affect heuristics much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:390,Testability,assert,assert,390,"/// Capture a change in pressure for a single pressure set. UnitInc may be; /// expressed in terms of upward or downward pressure depending on the client; /// and will be dynamically adjusted for current liveness.; ///; /// Pressure increments are tiny, typically 1-2 units, and this is only for; /// heuristics, so we don't check UnitInc overflow. Instead, we may have a; /// higher level assert that pressure is consistent within a region. We also; /// effectively ignore dead defs which don't affect heuristics much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:208,Energy Efficiency,schedul,scheduling,208,"// The initial design was for MaxPSets=4, but that requires PSet partitions,; // which are not yet implemented. (PSet partitions are equivalent PSets given; // the register classes actually in use within the scheduling region.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:64,Energy Efficiency,schedul,scheduler,64,"/// Store the effects of a change in pressure on things that MI scheduler cares; /// about.; ///; /// Excess records the value of the largest difference in register units beyond; /// the target's pressure limits across the affected pressure sets, where; /// largest is defined as the absolute value of the difference. Negative; /// ExcessUnits indicates a reduction in pressure that had already exceeded the; /// target's limits.; ///; /// CriticalMax records the largest increase in the tracker's max pressure that; /// exceeds the critical limit for some pressure set determined by the client.; ///; /// CurrentMax records the largest increase in the tracker's max pressure that; /// exceeds the current limit for some pressure set determined by the client.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:85,Integrability,wrap,wrapper,85,/// A set of live virtual registers and physical register units.; ///; /// This is a wrapper around a SparseSet which deals with mapping register unit; /// and virtual register indexes to an index usable by the sparse set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:197,Usability,usab,usable,197,/// A set of live virtual registers and physical register units.; ///; /// This is a wrapper around a SparseSet which deals with mapping register unit; /// and virtual register indexes to an index usable by the sparse set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:4,Usability,Clear,Clears,4,/// Clears the \p Pair.LaneMask lanes of \p Pair.Reg (mark them as dead).; /// Returns the previously live lanes of \p Pair.Reg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:682,Availability,down,downward,682,"/// Track the current register pressure at some position in the instruction; /// stream, and remember the high water mark within the region traversed. This; /// does not automatically consider live-through ranges. The client may; /// independently adjust for global liveness.; ///; /// Each RegPressureTracker only works within a MachineBasicBlock. Pressure can; /// be tracked across a larger region by storing a RegisterPressure result at; /// each block boundary and explicitly adjusting pressure to account for block; /// live-in and live-out register sets.; ///; /// RegPressureTracker holds a reference to a RegisterPressure result that it; /// computes incrementally. During downward tracking, P.BottomIdx or P.BottomPos; /// is invalid until it reaches the end of the block or closeRegion() is; /// explicitly called. Similarly, P.TopIdx is invalid during upward; /// tracking. Changing direction has the side effect of closing region, and; /// traversing past TopIdx or BottomIdx reopens it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:21,Integrability,depend,dependending,21,"/// Run in two modes dependending on whether constructed with IntervalPressure; /// or RegisterPressure. If requireIntervals is false, LIS are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:81,Energy Efficiency,schedul,schedulers,81,"// Reset the MI position corresponding to the register pressure. This allows; // schedulers to move instructions above the RegPressureTracker's; // CurrPos. Since the pressure is computed before CurrPos, the iterator; // position changes while pressure does not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:82,Availability,down,down,82,"/// Consider the pressure increase caused by traversing this instruction; /// top-down. Find the pressure set with the most change beyond its pressure; /// limit based on the tracker's current pressure, and record the number of; /// excess register units of that pressure set introduced by this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:129,Availability,down,downward,129,/// Find the pressure set with the most change beyond its pressure limit after; /// traversing this instruction either upward or downward depending on the; /// closed end of the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:138,Integrability,depend,depending,138,/// Find the pressure set with the most change beyond its pressure limit after; /// traversing this instruction either upward or downward depending on the; /// closed end of the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h:72,Availability,down,down,72,/// Get the pressure of each PSet after traversing this instruction top-down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterPressure.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:599,Availability,avail,available,599,"//===- RegisterScavenging.h - Machine register scavenging -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file declares the machine register scavenger class. It can provide; /// information such as unused register at any point in a machine basic block.; /// It also provides a mechanism to make registers available by evicting them; /// to spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:154,Deployability,update,update,154,"/// Record that \p Reg is in use at scavenging index \p FI. This is for; /// targets which need to directly manage the spilling process, and need to; /// update the scavenger's internal state. It's expected this be called a; /// second time with \p Restore set to a non-null value, so that the; /// externally inserted restore instruction resets the scavenged slot; /// liveness when encountered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:4,Deployability,Update,Update,4,/// Update internal register state and move MBB iterator backwards. This; /// method gives precise results even in the absence of kill flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:23,Deployability,update,update,23,/// Call backward() to update internal register state to just before \p *I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:15,Availability,avail,available,15,/// Return all available registers in the register class in Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:60,Availability,Mask,Mask,60,/// Return all available registers in the register class in Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:51,Availability,avail,available,51,"/// Make a register of the specific register class available from the current; /// position backwards to the place before \p To. If \p RestoreAfter is true; /// this includes the instruction following the current position.; /// SPAdj is the stack adjustment due to call frame, it's passed along to; /// eliminateFrameIndex().; /// Returns the scavenged register.; ///; /// If \p AllowSpill is false, fail if a spill is required to make the; /// register available, and return NoRegister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h:454,Availability,avail,available,454,"/// Make a register of the specific register class available from the current; /// position backwards to the place before \p To. If \p RestoreAfter is true; /// this includes the instruction following the current position.; /// SPAdj is the stack adjustment due to call frame, it's passed along to; /// eliminateFrameIndex().; /// Returns the scavenged register.; ///; /// If \p AllowSpill is false, fail if a spill is required to make the; /// register available, and return NoRegister.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterScavenging.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h:518,Usability,simpl,simple,518,"//==- RegisterUsageInfo.h - Register Usage Informartion Storage --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass is simple immutable pass which keeps RegMasks (calculated based on; /// actual register allocation) for functions in a module and provides simple; /// API to query this information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h:654,Usability,simpl,simple,654,"//==- RegisterUsageInfo.h - Register Usage Informartion Storage --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass is required to take advantage of the interprocedural register; /// allocation infrastructure.; ///; /// This pass is simple immutable pass which keeps RegMasks (calculated based on; /// actual register allocation) for functions in a module and provides simple; /// API to query this information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterUsageInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:451,Energy Efficiency,Schedul,SchedulingPriorityQueue,451,"//===----- ResourcePriorityQueue.h - A DFA-oriented priority queue -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:480,Energy Efficiency,schedul,schedules,480,"//===----- ResourcePriorityQueue.h - A DFA-oriented priority queue -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:513,Energy Efficiency,reduce,reduce,513,"//===----- ResourcePriorityQueue.h - A DFA-oriented priority queue -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:61,Performance,queue,queue,61,"//===----- ResourcePriorityQueue.h - A DFA-oriented priority queue -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:30,Availability,Avail,Available,30,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:40,Performance,queue,queue,40,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:78,Performance,Queue,Queue,78,"/// NumNodesSolelyBlocking - This vector contains, for every node in the; /// Queue, the number of nodes that the node is the sole unscheduled; /// predecessor for. This is used as a tie-breaker heuristic for better; /// mobility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:4,Performance,Queue,Queue,4,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:16,Performance,queue,queue,16,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:47,Energy Efficiency,schedul,scheduling,47,/// Single cost function reflecting benefit of scheduling SU; /// in the current cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:4,Energy Efficiency,schedul,scheduledNode,4,/// scheduledNode - Main resource tracking point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RuntimeLibcalls.h:68,Security,access,access,68,"/// Return the outline atomics value for the given atomic ordering, access; /// size and set of libcalls for a given atomic, or UNKNOWN_LIBCALL if there; /// is none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/RuntimeLibcalls.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RuntimeLibcalls.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SafeStack.h:40,Safety,Safe,SafeStack,40,"//===--------------------- llvm/CodeGen/SafeStack.h -------------*- C++-*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SafeStack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SafeStack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:20,Energy Efficiency,Schedul,ScheduleDAG,20,"//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is used as the common base; /// class for instruction schedulers. This encapsulates the scheduling DAG,; /// which is shared between SelectionDAG and MachineInstr scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:405,Energy Efficiency,Schedul,ScheduleDAG,405,"//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is used as the common base; /// class for instruction schedulers. This encapsulates the scheduling DAG,; /// which is shared between SelectionDAG and MachineInstr scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:484,Energy Efficiency,schedul,schedulers,484,"//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is used as the common base; /// class for instruction schedulers. This encapsulates the scheduling DAG,; /// which is shared between SelectionDAG and MachineInstr scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:518,Energy Efficiency,schedul,scheduling,518,"//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is used as the common base; /// class for instruction schedulers. This encapsulates the scheduling DAG,; /// which is shared between SelectionDAG and MachineInstr scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:593,Energy Efficiency,schedul,scheduling,593,"//===- llvm/CodeGen/ScheduleDAG.h - Common Base Class -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAG class, which is used as the common base; /// class for instruction schedulers. This encapsulates the scheduling DAG,; /// which is shared between SelectionDAG and MachineInstr scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Energy Efficiency,Schedul,Scheduling,4,/// Scheduling dependency. This represents one direction of an edge in the; /// scheduling DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:80,Energy Efficiency,schedul,scheduling,80,/// Scheduling dependency. This represents one direction of an edge in the; /// scheduling DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:15,Integrability,depend,dependency,15,/// Scheduling dependency. This represents one direction of an edge in the; /// scheduling DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:37,Energy Efficiency,schedul,scheduling,37,/// These are the different kinds of scheduling dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:48,Integrability,depend,dependencies,48,/// These are the different kinds of scheduling dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:18,Integrability,depend,dependence,18,///< Regular data dependence (aka true-dependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:39,Integrability,depend,dependence,39,///< Regular data dependence (aka true-dependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:21,Integrability,depend,dependence,21,///< A register anti-dependence (aka WAR).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:23,Integrability,depend,dependence,23,///< A register output-dependence (aka WAW).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:24,Integrability,depend,dependency,24,///< Any other ordering dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:119,Availability,redundant,redundant,119,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:48,Energy Efficiency,schedul,scheduler,48,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:214,Energy Efficiency,schedul,scheduling,214,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:10,Integrability,depend,dependencies,10,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:74,Integrability,depend,dependencies,74,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:153,Integrability,depend,dependence,153,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:178,Integrability,depend,dependencies,178,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:119,Safety,redund,redundant,119,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:16,Energy Efficiency,schedul,scheduling,16,///< An unknown scheduling barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:17,Performance,load,load,17,///< Nonvolatile load/Store instructions that may alias.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:17,Performance,load,load,17,///< Nonvolatile load/Store instructions that must alias.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:40,Integrability,depend,dependence,40,///< Arbitrary strong DAG edge (no real dependence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:21,Integrability,depend,depending,21,"/// A pointer to the depending/depended-on SUnit, and an enum; /// indicating the kind of the dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:31,Integrability,depend,depended-on,31,"/// A pointer to the depending/depended-on SUnit, and an enum; /// indicating the kind of the dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:94,Integrability,depend,dependency,94,"/// A pointer to the depending/depended-on SUnit, and an enum; /// indicating the kind of the dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:33,Integrability,depend,dependence,33,/// A union discriminated by the dependence kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:31,Integrability,depend,dependencies,31,"/// For Data, Anti, and Output dependencies, the associated register. For; /// Data dependencies that don't currently have a register/ assigned, this; /// is set to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:84,Integrability,depend,dependencies,84,"/// For Data, Anti, and Output dependencies, the associated register. For; /// Data dependencies that don't currently have a register/ assigned, this; /// is set to zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:39,Integrability,depend,dependencies,39,/// Additional information about Order dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:81,Performance,Latency,Latency,81,"/// The time associated with this edge. Often this is just the value of the; /// Latency field of the predecessor, however advanced models may provide; /// additional information about specific edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,Performance,latency,latency,64,/// Returns true if the specified SDep is equivalent except for latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:16,Performance,latency,latency,16,"/// Returns the latency value for this edge, which roughly means the; /// minimum number of cycles that must elapse between the predecessor and; /// the successor, given that they have this edge between them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:13,Performance,latency,latency,13,/// Sets the latency for this edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:55,Integrability,depend,dependence,55,/// Returns an enum value representing the kind of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:30,Integrability,depend,dependence,30,/// Tests if this is an Order dependence between two memory accesses; /// where both sides of the dependence access memory in non-volatile and; /// fully modeled ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:98,Integrability,depend,dependence,98,/// Tests if this is an Order dependence between two memory accesses; /// where both sides of the dependence access memory in non-volatile and; /// fully modeled ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:60,Security,access,accesses,60,/// Tests if this is an Order dependence between two memory accesses; /// where both sides of the dependence access memory in non-volatile and; /// fully modeled ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:109,Security,access,access,109,/// Tests if this is an Order dependence between two memory accesses; /// where both sides of the dependence access memory in non-volatile and; /// fully modeled ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if this is an Order dependence between two memory accesses; /// where both sides of the dependence access memory in non-volatile and; /// fully modeled ways.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:30,Integrability,depend,dependence,30,/// Tests if this is an Order dependence that is marked as a barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if this is an Order dependence that is marked as a barrier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:49,Integrability,depend,dependence,49,/// Tests if this is could be any kind of memory dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if this is could be any kind of memory dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:30,Integrability,depend,dependence,30,"/// Tests if this is an Order dependence that is marked as; /// ""must alias"", meaning that the SUnits at either end of the edge have a; /// memory dependence on a known memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:147,Integrability,depend,dependence,147,"/// Tests if this is an Order dependence that is marked as; /// ""must alias"", meaning that the SUnits at either end of the edge have a; /// memory dependence on a known memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,"/// Tests if this is an Order dependence that is marked as; /// ""must alias"", meaning that the SUnits at either end of the edge have a; /// memory dependence on a known memory location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:199,Energy Efficiency,schedul,scheduler,199,"/// Tests if this a weak dependence. Weak dependencies are considered DAG; /// edges for height computation and other heuristics, but do not force; /// ordering. Breaking a weak edge may require the scheduler to compensate,; /// for example by inserting a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:25,Integrability,depend,dependence,25,"/// Tests if this a weak dependence. Weak dependencies are considered DAG; /// edges for height computation and other heuristics, but do not force; /// ordering. Breaking a weak edge may require the scheduler to compensate,; /// for example by inserting a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:42,Integrability,depend,dependencies,42,"/// Tests if this a weak dependence. Weak dependencies are considered DAG; /// edges for height computation and other heuristics, but do not force; /// ordering. Breaking a weak edge may require the scheduler to compensate,; /// for example by inserting a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,"/// Tests if this a weak dependence. Weak dependencies are considered DAG; /// edges for height computation and other heuristics, but do not force; /// ordering. Breaking a weak edge may require the scheduler to compensate,; /// for example by inserting a copy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:30,Integrability,depend,dependence,30,"/// Tests if this is an Order dependence that is marked as; /// ""artificial"", meaning it isn't necessary for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,"/// Tests if this is an Order dependence that is marked as; /// ""artificial"", meaning it isn't necessary for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:30,Integrability,depend,dependence,30,"/// Tests if this is an Order dependence that is marked as ""cluster"",; /// meaning it is artificial and wants to be adjacent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,"/// Tests if this is an Order dependence that is marked as ""cluster"",; /// meaning it is artificial and wants to be adjacent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:28,Integrability,depend,dependence,28,/// Tests if this is a Data dependence that is associated with a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if this is a Data dependence that is associated with a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Energy Efficiency,Schedul,Scheduling,4,/// Scheduling unit. This is a node in the scheduling DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:43,Energy Efficiency,schedul,scheduling,43,/// Scheduling unit. This is a node in the scheduling DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:69,Energy Efficiency,schedul,scheduling,69,"///< If not this, the node from which this node; /// was cloned. (SD scheduling only)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:5,Performance,Queue,Queue,5,///< Queue id of node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:20,Energy Efficiency,schedul,scheduled,20,///< # of preds not scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:20,Energy Efficiency,schedul,scheduled,20,///< # of succs not scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:25,Energy Efficiency,schedul,scheduled,25,///< # of weak preds not scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:25,Energy Efficiency,schedul,scheduled,25,///< # of weak succs not scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:27,Energy Efficiency,schedul,scheduled,27,///< # of reg defs with no scheduled use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:10,Performance,latency,latency,10,///< Node latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:15,Availability,avail,available,15,///< True once available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:15,Energy Efficiency,schedul,scheduled,15,///< True once scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:27,Energy Efficiency,schedul,schedule,27,///< True if preferable to schedule high.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:27,Energy Efficiency,schedul,schedule,27,///< True if preferable to schedule low.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:5,Energy Efficiency,Schedul,Scheduling,5,///< Scheduling preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:41,Energy Efficiency,schedul,scheduling,41,/// Constructs an SUnit for pre-regalloc scheduling to represent an; /// SDNode and any nodes flagged to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:42,Energy Efficiency,schedul,scheduling,42,/// Constructs an SUnit for post-regalloc scheduling to represent a; /// MachineInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:65,Energy Efficiency,schedul,scheduling,65,"/// Boundary nodes are placeholders for the boundary of the; /// scheduling region.; ///; /// BoundaryNodes can have DAG edges, including Data edges, but they do not; /// correspond to schedulable entities (e.g. instructions) and do not have a; /// valid ID. Consequently, always check for boundary nodes before accessing; /// an associative data structure keyed on node ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:185,Energy Efficiency,schedul,schedulable,185,"/// Boundary nodes are placeholders for the boundary of the; /// scheduling region.; ///; /// BoundaryNodes can have DAG edges, including Data edges, but they do not; /// correspond to schedulable entities (e.g. instructions) and do not have a; /// valid ID. Consequently, always check for boundary nodes before accessing; /// an associative data structure keyed on node ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:312,Security,access,accessing,312,"/// Boundary nodes are placeholders for the boundary of the; /// scheduling region.; ///; /// BoundaryNodes can have DAG edges, including Data edges, but they do not; /// correspond to schedulable entities (e.g. instructions) and do not have a; /// valid ID. Consequently, always check for boundary nodes before accessing; /// an associative data structure keyed on node ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:96,Energy Efficiency,schedul,scheduling,96,/// Assigns the representative SDNode for this SUnit. This may be used; /// during pre-regalloc scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:96,Energy Efficiency,schedul,scheduling,96,/// Returns the representative SDNode for this SUnit. This may be used; /// during pre-regalloc scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:86,Energy Efficiency,schedul,scheduling,86,/// Assigns the instruction for the SUnit. This may be used during; /// post-regalloc scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:103,Energy Efficiency,schedul,scheduling,103,/// Returns the representative MachineInstr for this SUnit. This may be used; /// during post-regalloc scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:57,Performance,latency,latency,57,"/// Adds a barrier edge to SU by calling addPred(), with latency 0; /// generally or latency 1 for a store followed by a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:85,Performance,latency,latency,85,"/// Adds a barrier edge to SU by calling addPred(), with latency 0; /// generally or latency 1 for a store followed by a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:121,Performance,load,load,121,"/// Adds a barrier edge to SU by calling addPred(), with latency 0; /// generally or latency 1 for a store followed by a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:82,Availability,down,down,82,"/// Returns the height of this node, which is the length of the; /// maximum path down to any node which has no successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if node N is a predecessor of this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if node N is a successor of this node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,Performance,latency,latency,64,/// Returns true if the specified SDep is equivalent except for latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:55,Integrability,depend,dependence,55,/// Returns an enum value representing the kind of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:178,Energy Efficiency,schedul,scheduler,178,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:89,Integrability,interface,interface,89,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:207,Integrability,interface,interface,207,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:245,Performance,queue,queue,245,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:400,Performance,queue,queue,400,"//===--------------------------------------------------------------------===//; /// This interface is used to plug different priorities computation; /// algorithms into the list scheduler. It implements the interface of a; /// standard priority queue, where nodes are inserted in arbitrary order and; /// returned in priority order. The computation of the priority and the; /// representation of the queue are totally up to the implementation to; /// decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:20,Energy Efficiency,schedul,scheduled,20,"/// As each node is scheduled, this method is invoked. This allows the; /// priority function to adjust the priority of related unscheduled nodes,; /// for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:9,Energy Efficiency,schedul,scheduling,9,///< The scheduling units.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Usability,Clear,Clears,4,/// Clears the DAG state (between regions).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:42,Energy Efficiency,Schedul,ScheduleDAG,42,/// Pops up a GraphViz/gv window with the ScheduleDAG rendered using 'dot'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,Energy Efficiency,Schedul,ScheduleDAG,64,/// Returns a label for an SUnit node in a visualization of the ScheduleDAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:52,Energy Efficiency,Schedul,ScheduleDAG,52,/// Adds custom features for a visualization of the ScheduleDAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:34,Energy Efficiency,schedul,scheduled,34,/// Verifies that all SUnits were scheduled and that their state is; /// consistent. Returns the number of scheduled SUnits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:107,Energy Efficiency,schedul,scheduled,107,/// Verifies that all SUnits were scheduled and that their state is; /// consistent. Returns the number of scheduled SUnits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:39,Integrability,depend,dependence,39,/// Tests if this is not an SDep::Data dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Testability,Test,Tests,4,/// Tests if this is not an SDep::Data dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:23,Energy Efficiency,Schedul,ScheduleDAG,23,/// A reference to the ScheduleDAG's SUnits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:93,Deployability,update,updates,93,"/// Fix the ordering, by either recomputing from scratch or by applying; /// any outstanding updates. Uses a heuristic to estimate what will be; /// cheaper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,Energy Efficiency,schedul,scheduled,64,/// Creates the initial topological ordering from the DAG to be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Deployability,Update,Updates,4,/// Updates the topological ordering to accommodate an edge to be; /// added from SUnit \p X to SUnit \p Y.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:14,Deployability,update,update,14,/// Queues an update to the topological ordering to accommodate an edge to; /// be added from SUnit \p X to SUnit \p Y.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Performance,Queue,Queues,4,/// Queues an update to the topological ordering to accommodate an edge to; /// be added from SUnit \p X to SUnit \p Y.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Deployability,Update,Updates,4,/// Updates the topological ordering to accommodate an edge to be; /// removed from the specified node \p N from the predecessors of the; /// current node \p M.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:7,Energy Efficiency,Schedul,ScheduleDAGInstrs,7,"//===- ScheduleDAGInstrs.h - MachineInstr Scheduling ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAGInstrs class, which implements scheduling; /// for a MachineInstr-based dependency graph.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:42,Energy Efficiency,Schedul,Scheduling,42,"//===- ScheduleDAGInstrs.h - MachineInstr Scheduling ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAGInstrs class, which implements scheduling; /// for a MachineInstr-based dependency graph.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:405,Energy Efficiency,Schedul,ScheduleDAGInstrs,405,"//===- ScheduleDAGInstrs.h - MachineInstr Scheduling ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAGInstrs class, which implements scheduling; /// for a MachineInstr-based dependency graph.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:447,Energy Efficiency,schedul,scheduling,447,"//===- ScheduleDAGInstrs.h - MachineInstr Scheduling ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAGInstrs class, which implements scheduling; /// for a MachineInstr-based dependency graph.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:488,Integrability,depend,dependency,488,"//===- ScheduleDAGInstrs.h - MachineInstr Scheduling ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Implements the ScheduleDAGInstrs class, which implements scheduling; /// for a MachineInstr-based dependency graph.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:57,Integrability,depend,dependent,57,"/// Record a physical register access.; /// For non-data-dependent uses, OpIdx == -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:31,Security,access,access,31,"/// Record a physical register access.; /// For non-data-dependent uses, OpIdx == -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:75,Energy Efficiency,allocate,allocated,75,/// Use a SparseMultiSet to track physical registers. Storage is only; /// allocated once for the pass. It can be cleared in constant time and reused; /// without any frees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:114,Usability,clear,cleared,114,/// Use a SparseMultiSet to track physical registers. Storage is only; /// allocated once for the pass. It can be cleared in constant time and reused; /// without any frees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:161,Energy Efficiency,schedul,scheduling,161,"/// Use SparseSet as a SparseMap by relying on the fact that it never; /// compares ValueT's, only unsigned keys. This allows the set to be cleared; /// between scheduling regions in constant time as long as ValueT does not; /// require a destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:140,Usability,clear,cleared,140,"/// Use SparseSet as a SparseMap by relying on the fact that it never; /// compares ValueT's, only unsigned keys. This allows the set to be cleared; /// between scheduling regions in constant time as long as ValueT does not; /// require a destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:119,Energy Efficiency,schedul,scheduler,119,/// Track local uses of virtual registers. These uses are gathered by the DAG; /// builder and may be consulted by the scheduler to avoid iterating an entire; /// vreg use list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:132,Safety,avoid,avoid,132,/// Track local uses of virtual registers. These uses are gathered by the DAG; /// builder and may be consulted by the scheduler to avoid iterating an entire; /// vreg use list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:6,Energy Efficiency,Schedul,ScheduleDAG,6,/// A ScheduleDAG for scheduling lists of MachineInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:22,Energy Efficiency,schedul,scheduling,22,/// A ScheduleDAG for scheduling lists of MachineInstr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:33,Integrability,interface,interface,33,/// TargetSchedModel provides an interface to the machine model.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:181,Energy Efficiency,schedul,scheduler,181,/// The standard DAG builder does not normally include terminators as DAG; /// nodes because it does not create the necessary dependencies to prevent; /// reordering. A specialized scheduler can override; /// TargetInstrInfo::isSchedulingBoundary then enable this flag to indicate; /// it has taken responsibility for scheduling the terminator correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:318,Energy Efficiency,schedul,scheduling,318,/// The standard DAG builder does not normally include terminators as DAG; /// nodes because it does not create the necessary dependencies to prevent; /// reordering. A specialized scheduler can override; /// TargetInstrInfo::isSchedulingBoundary then enable this flag to indicate; /// it has taken responsibility for scheduling the terminator correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:126,Integrability,depend,dependencies,126,/// The standard DAG builder does not normally include terminators as DAG; /// nodes because it does not create the necessary dependencies to prevent; /// reordering. A specialized scheduler can override; /// TargetInstrInfo::isSchedulingBoundary then enable this flag to indicate; /// it has taken responsibility for scheduling the terminator correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:17,Availability,mask,masks,17,/// Whether lane masks should get tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:33,Energy Efficiency,schedul,scheduling,33,// State specific to the current scheduling region.; // ------------------------------------------------; /// The block in which to insert instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:37,Energy Efficiency,schedul,scheduled,37,/// The beginning of the range to be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:31,Energy Efficiency,schedul,scheduled,31,/// The end of the range to be scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:80,Energy Efficiency,schedul,scheduling,80,"/// After calling BuildSchedGraph, each machine instruction in the current; /// scheduling region is mapped to an SUnit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:199,Energy Efficiency,allocate,allocated,199,"// State internal to DAG building.; // -------------------------------; /// Defs, Uses - Remember where defs and uses of each register are as we; /// iterate upward through the instructions. This is allocated here instead; /// of inside BuildSchedGraph to avoid the need for it to be initialized and; /// destructed for each block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:256,Safety,avoid,avoid,256,"// State internal to DAG building.; // -------------------------------; /// Defs, Uses - Remember where defs and uses of each register are as we; /// iterate upward through the instructions. This is allocated here instead; /// of inside BuildSchedGraph to avoid the need for it to be initialized and; /// destructed for each block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:92,Energy Efficiency,schedul,scheduled,92,/// Remember a generic side-effecting instruction as we proceed.; /// No other SU ever gets scheduled around it (except in the special; /// case of a huge region that gets reduced).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:172,Energy Efficiency,reduce,reduced,172,/// Remember a generic side-effecting instruction as we proceed.; /// No other SU ever gets scheduled around it (except in the special; /// case of a huge region that gets reduced).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:129,Performance,optimiz,optimized,129,"/// A list of SUnits, used in Value2SUsMap, during DAG construction.; /// Note: to gain speed it might be worth investigating an optimized; /// implementation of this data structure, such as a singly linked list; /// with a memory pool (SmallVector was tried but slow and SparseSet is not; /// applicable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:107,Integrability,depend,depend,107,"/// A map from ValueType to SUList, used during DAG construction, as; /// a means of remembering which SUs depend on which memory locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:4,Energy Efficiency,Reduce,Reduces,4,"/// Reduces maps in FIFO order, by N SUs. This is better than turning; /// every Nth memory SU into BarrierChain in buildSchedGraph(), since; /// it avoids unnecessary edges between seen SUs above the new BarrierChain,; /// and those below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:149,Safety,avoid,avoids,149,"/// Reduces maps in FIFO order, by N SUs. This is better than turning; /// every Nth memory SU into BarrierChain in buildSchedGraph(), since; /// it avoids unnecessary edges between seen SUs above the new BarrierChain,; /// and those below it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:103,Integrability,depend,dependency,103,"/// Adds a chain edge between SUa and SUb, but only if both; /// AAResults and Target fail to deny the dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,Integrability,depend,dependencies,9,/// Adds dependencies as needed from all SUs in list to SU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,Integrability,depend,dependencies,9,"/// Adds dependencies as needed from all SUs in map, to SU.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,Integrability,depend,dependencies,9,"/// Adds dependencies as needed to SU, from all SUs mapped to V.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:127,Performance,optimiz,optimized,127,"/// Adds barrier chain edges from all SUs in map, and then clear the map.; /// This is equivalent to insertBarrierChain(), but optimized for the common; /// case where the new BarrierChain (a global memory object) has a higher; /// NodeNum than all SUs in map. It is assumed BarrierChain has been set; /// before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:59,Usability,clear,clear,59,"/// Adds barrier chain edges from all SUs in map, and then clear the map.; /// This is equivalent to insertBarrierChain(), but optimized for the common; /// case where the new BarrierChain (a global memory object) has a higher; /// NodeNum than all SUs in map. It is assumed BarrierChain has been set; /// before calling this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:31,Security,access,access,31,"/// For an unanalyzable memory access, this Value is used in maps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:161,Energy Efficiency,schedul,schedule,161,/// Remember instruction that precedes DBG_VALUE.; /// These are generated by buildSchedGraph but persist so they can be; /// referenced when emitting the final schedule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:43,Energy Efficiency,schedul,scheduling,43,/// Gets the machine model for instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:34,Energy Efficiency,schedul,scheduling,34,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:17,Performance,cache,cache,17,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:50,Energy Efficiency,schedul,scheduling,50,/// Returns an iterator to the top of the current scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:53,Energy Efficiency,schedul,scheduling,53,/// Returns an iterator to the bottom of the current scheduling region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:49,Energy Efficiency,schedul,scheduling,49,"/// If this method returns true, handling of the scheduling regions; /// themselves (in case of a scheduling boundary in MBB) will be done; /// beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:98,Energy Efficiency,schedul,scheduling,98,"/// If this method returns true, handling of the scheduling regions; /// themselves (in case of a scheduling boundary in MBB) will be done; /// beginning with the topmost region of MBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:24,Energy Efficiency,schedul,scheduling,24,/// Prepares to perform scheduling in the given block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:16,Performance,perform,perform,16,/// Prepares to perform scheduling in the given block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:20,Energy Efficiency,schedul,scheduling,20,/// Cleans up after scheduling in the given block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:34,Energy Efficiency,schedul,scheduler,34,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:65,Energy Efficiency,schedul,scheduling,65,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:148,Energy Efficiency,schedul,scheduling,148,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:215,Energy Efficiency,schedul,scheduling,215,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:128,Usability,clear,clears,128,"/// Initialize the DAG and common scheduler state for a new; /// scheduling region. This does not actually create the DAG, only clears; /// it. The scheduling driver may call BuildSchedGraph multiple times per; /// scheduling region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:20,Energy Efficiency,schedul,scheduler,20,/// Called when the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:43,Energy Efficiency,schedul,scheduling,43,/// Called when the scheduler has finished scheduling the current region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:147,Energy Efficiency,efficient,efficient,147,"/// Builds SUnits for the current region.; /// If \p RPTracker is non-null, compute register pressure as a side effect.; /// The DAG builder is an efficient place to do it because it already visits; /// operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:87,Energy Efficiency,schedul,scheduled,87,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:100,Energy Efficiency,schedul,scheduling,100,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:255,Energy Efficiency,schedul,scheduled,255,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:9,Integrability,depend,dependencies,9,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:320,Performance,latency,latency,320,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:69,Energy Efficiency,schedul,scheduling,69,"/// Orders nodes according to selected style.; ///; /// Typically, a scheduling algorithm will implement schedule() without; /// overriding enterRegion() or exitRegion().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:105,Energy Efficiency,schedul,schedule,105,"/// Orders nodes according to selected style.; ///; /// Typically, a scheduling algorithm will implement schedule() without; /// overriding enterRegion() or exitRegion().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:35,Energy Efficiency,schedul,scheduling,35,/// Allow targets to perform final scheduling actions at the level of the; /// whole MachineFunction. By default does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:21,Performance,perform,perform,21,/// Allow targets to perform final scheduling actions at the level of the; /// whole MachineFunction. By default does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:35,Energy Efficiency,schedul,scheduling,35,/// Fixes register kill flags that scheduling has made invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:221,Availability,failure,failure,221,/// Add a DAG edge to the given SU with the given predecessor; /// dependence data.; ///; /// \returns true if the edge may be added without creating a cycle OR if an; /// equivalent edge already existed (false indicates failure).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:67,Integrability,depend,dependence,67,/// Add a DAG edge to the given SU with the given predecessor; /// dependence data.; ///; /// \returns true if the edge may be added without creating a cycle OR if an; /// equivalent edge already existed (false indicates failure).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:14,Availability,mask,mask,14,/// Returns a mask for which lanes get read/written by the given (register); /// machine operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h:7,Energy Efficiency,Schedul,ScheduleDAGMutation,7,"//===- ScheduleDAGMutation.h - MachineInstr Scheduling ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleDAGMutation class, which represents; // a target-specific mutation of the dependency graph for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h:44,Energy Efficiency,Schedul,Scheduling,44,"//===- ScheduleDAGMutation.h - MachineInstr Scheduling ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleDAGMutation class, which represents; // a target-specific mutation of the dependency graph for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h:408,Energy Efficiency,Schedul,ScheduleDAGMutation,408,"//===- ScheduleDAGMutation.h - MachineInstr Scheduling ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleDAGMutation class, which represents; // a target-specific mutation of the dependency graph for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h:511,Energy Efficiency,schedul,scheduling,511,"//===- ScheduleDAGMutation.h - MachineInstr Scheduling ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleDAGMutation class, which represents; // a target-specific mutation of the dependency graph for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h:490,Integrability,depend,dependency,490,"//===- ScheduleDAGMutation.h - MachineInstr Scheduling ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleDAGMutation class, which represents; // a target-specific mutation of the dependency graph for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGMutation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:7,Energy Efficiency,Schedul,ScheduleDFS,7,"//===- ScheduleDFS.h - ILP metric for ScheduleDAGInstrs ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Definition of an ILP metric for machine level instruction scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:38,Energy Efficiency,Schedul,ScheduleDAGInstrs,38,"//===- ScheduleDFS.h - ILP metric for ScheduleDAGInstrs ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Definition of an ILP metric for machine level instruction scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:441,Energy Efficiency,schedul,scheduling,441,"//===- ScheduleDFS.h - ILP metric for ScheduleDAGInstrs ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Definition of an ILP metric for machine level instruction scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:340,Energy Efficiency,schedul,schedule,340,"/// Represent the ILP of the subDAG rooted at a DAG node.; ///; /// ILPValues summarize the DAG subtree rooted at each node. ILPValues are; /// valid for all nodes regardless of their subtree membership.; ///; /// When computed using bottom-up DFS, this metric assumes that the DAG is a; /// forest of trees with roots at the bottom of the schedule branching upward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:53,Integrability,depend,depending,53,"/// Length may either correspond to depth or height, depending on direction,; /// and cycles or nodes depending on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:102,Integrability,depend,depending,102,"/// Length may either correspond to depth or height, depending on direction,; /// and cycles or nodes depending on context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:83,Deployability,update,updated,83,/// Cache the current connection level of each subtree.; /// This mutable array is updated during scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:98,Energy Efficiency,schedul,scheduling,98,/// Cache the current connection level of each subtree.; /// This mutable array is updated during scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:4,Performance,Cache,Cache,4,/// Cache the current connection level of each subtree.; /// This mutable array is updated during scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:4,Usability,Clear,Clear,4,/// Clear the results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:27,Safety,detect,detected,27,/// The number of subtrees detected in this DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:102,Performance,latency,latency,102,"/// Get the connection level of a subtree.; ///; /// For bottom-up trees, the connection level is the latency depth (in cycles); /// of the deepest connection to another subtree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:26,Deployability,update,update,26,/// Scheduler callback to update SubtreeConnectLevels when a tree is; /// initially scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:4,Energy Efficiency,Schedul,Scheduler,4,/// Scheduler callback to update SubtreeConnectLevels when a tree is; /// initially scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:84,Energy Efficiency,schedul,scheduled,84,/// Scheduler callback to update SubtreeConnectLevels when a tree is; /// initially scheduled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:18,Energy Efficiency,Schedul,ScheduleHazardRecognizer,18,"//=- llvm/CodeGen/ScheduleHazardRecognizer.h - Scheduling Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleHazardRecognizer class, which implements; // hazard-avoidance heuristics for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:47,Energy Efficiency,Schedul,Scheduling,47,"//=- llvm/CodeGen/ScheduleHazardRecognizer.h - Scheduling Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleHazardRecognizer class, which implements; // hazard-avoidance heuristics for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:408,Energy Efficiency,Schedul,ScheduleHazardRecognizer,408,"//=- llvm/CodeGen/ScheduleHazardRecognizer.h - Scheduling Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleHazardRecognizer class, which implements; // hazard-avoidance heuristics for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:493,Energy Efficiency,schedul,scheduling,493,"//=- llvm/CodeGen/ScheduleHazardRecognizer.h - Scheduling Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleHazardRecognizer class, which implements; // hazard-avoidance heuristics for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:461,Safety,hazard,hazard-avoidance,461,"//=- llvm/CodeGen/ScheduleHazardRecognizer.h - Scheduling Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ScheduleHazardRecognizer class, which implements; // hazard-avoidance heuristics for scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:4,Safety,Hazard,HazardRecognizer,4,"/// HazardRecognizer - This determines whether or not an instruction can be; /// issued this cycle, and whether or not a noop needs to be inserted to handle; /// the hazard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:166,Safety,hazard,hazard,166,"/// HazardRecognizer - This determines whether or not an instruction can be; /// issued this cycle, and whether or not a noop needs to be inserted to handle; /// the hazard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:265,Energy Efficiency,schedul,scheduler,265,"/// MaxLookAhead - Indicate the number of cycles in the scoreboard; /// state. Important to restore the state after backtracking. Additionally,; /// MaxLookAhead=0 identifies a fake recognizer, allowing the client to; /// bypass virtual calls. Currently the PostRA scheduler ignores it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:282,Availability,avail,available,282,"/// getHazardType - Return the hazard type of emitting this node. There are; /// three possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.; /// * NoopHazard: issuing this instruction would break the program. If; /// some other instruction can be issued, do so, otherwise issue a noop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:31,Safety,hazard,hazard,31,"/// getHazardType - Return the hazard type of emitting this node. There are; /// three possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.; /// * NoopHazard: issuing this instruction would break the program. If; /// some other instruction can be issued, do so, otherwise issue a noop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:190,Safety,Hazard,Hazard,190,"/// getHazardType - Return the hazard type of emitting this node. There are; /// three possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.; /// * NoopHazard: issuing this instruction would break the program. If; /// some other instruction can be issued, do so, otherwise issue a noop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:90,Energy Efficiency,schedul,schedule,90,/// Reset - This callback is invoked when a new block of; /// instructions is about to be schedule. The hazard state should be; /// set to an initialized state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:104,Safety,hazard,hazard,104,/// Reset - This callback is invoked when a new block of; /// instructions is about to be schedule. The hazard state should be; /// set to an initialized state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:99,Safety,hazard,hazard,99,"/// EmitInstruction - This callback is invoked when an instruction is; /// emitted, to advance the hazard state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:86,Energy Efficiency,schedul,scheduling,86,"/// This overload will be used when the hazard recognizer is being used; /// by a non-scheduling pass, which does not use SUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:40,Safety,hazard,hazard,40,"/// This overload will be used when the hazard recognizer is being used; /// by a non-scheduling pass, which does not use SUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:211,Energy Efficiency,schedul,scheduling,211,/// PreEmitNoops - This callback is invoked prior to emitting an instruction.; /// It should return the number of noops to emit prior to the provided; /// instruction.; /// Note: This is only used during PostRA scheduling. EmitNoop is not called; /// for these noops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:86,Energy Efficiency,schedul,scheduling,86,"/// This overload will be used when the hazard recognizer is being used; /// by a non-scheduling pass, which does not use SUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:40,Safety,hazard,hazard,40,"/// This overload will be used when the hazard recognizer is being used; /// by a non-scheduling pass, which does not use SUnits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:175,Availability,avail,available,175,"/// ShouldPreferAnother - This callback may be invoked if getHazardType; /// returns NoHazard. If, even though there is no hazard, it would be better to; /// schedule another available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:158,Energy Efficiency,schedul,schedule,158,"/// ShouldPreferAnother - This callback may be invoked if getHazardType; /// returns NoHazard. If, even though there is no hazard, it would be better to; /// schedule another available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:123,Safety,hazard,hazard,123,"/// ShouldPreferAnother - This callback may be invoked if getHazardType; /// returns NoHazard. If, even though there is no hazard, it would be better to; /// schedule another available instruction, this callback should return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:66,Availability,down,down,66,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:94,Energy Efficiency,schedul,scheduled,94,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:162,Performance,latency,latency,162,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:246,Safety,hazard,hazard,246,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:284,Safety,Hazard,Hazard,284,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:326,Safety,hazard,hazards,326,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:94,Energy Efficiency,schedul,scheduled,94,"/// RecedeCycle - This callback is invoked whenever the next bottom-up; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:162,Performance,latency,latency,162,"/// RecedeCycle - This callback is invoked whenever the next bottom-up; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:20,Energy Efficiency,Schedul,SchedulerRegistry,20,"//===- llvm/CodeGen/SchedulerRegistry.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation for instruction scheduler function; // pass registry (RegisterScheduler).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:437,Energy Efficiency,schedul,scheduler,437,"//===- llvm/CodeGen/SchedulerRegistry.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation for instruction scheduler function; // pass registry (RegisterScheduler).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:155,Energy Efficiency,schedul,schedulers,155,//===----------------------------------------------------------------------===//; ///; /// RegisterScheduler class - Track the registration of instruction schedulers.; ///; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:93,Energy Efficiency,schedul,scheduler,93,/// createBURRListDAGScheduler - This creates a bottom up register usage; /// reduction list scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:65,Energy Efficiency,schedul,scheduler,65,/// createSourceListDAGScheduler - This creates a bottom up list scheduler that; /// schedules nodes in source code order when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:85,Energy Efficiency,schedul,schedules,85,/// createSourceListDAGScheduler - This creates a bottom up list scheduler that; /// schedules nodes in source code order when possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:94,Energy Efficiency,schedul,scheduler,94,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:262,Energy Efficiency,schedul,schedules,262,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:275,Energy Efficiency,reduce,reduce,275,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:121,Performance,latency,latency,121,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:171,Performance,latency,latency,171,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:144,Safety,avoid,avoid,144,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:91,Energy Efficiency,schedul,scheduler,91,/// createILPListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that tries to increase instruction level parallelism; /// in low register pressure mode. In high register pressure mode it schedules; /// to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:224,Energy Efficiency,schedul,schedules,224,/// createILPListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that tries to increase instruction level parallelism; /// in low register pressure mode. In high register pressure mode it schedules; /// to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:242,Energy Efficiency,reduce,reduce,242,/// createILPListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that tries to increase instruction level parallelism; /// in low register pressure mode. In high register pressure mode it schedules; /// to reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:51,Energy Efficiency,schedul,scheduler,51,"/// createFastDAGScheduler - This creates a ""fast"" scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:74,Availability,down,down,74,/// createVLIWDAGScheduler - Scheduler for VLIW targets. This creates top down; /// DFA driven list scheduler with clustering heuristic to control; /// register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:29,Energy Efficiency,Schedul,Scheduler,29,/// createVLIWDAGScheduler - Scheduler for VLIW targets. This creates top down; /// DFA driven list scheduler with clustering heuristic to control; /// register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:100,Energy Efficiency,schedul,scheduler,100,/// createVLIWDAGScheduler - Scheduler for VLIW targets. This creates top down; /// DFA driven list scheduler with clustering heuristic to control; /// register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:57,Energy Efficiency,schedul,scheduler,57,/// createDefaultScheduler - This creates an instruction scheduler appropriate; /// for the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:45,Energy Efficiency,schedul,scheduling,45,"/// createDAGLinearizer - This creates a ""no-scheduling"" scheduler which; /// linearize the DAG using topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:57,Energy Efficiency,schedul,scheduler,57,"/// createDAGLinearizer - This creates a ""no-scheduling"" scheduler which; /// linearize the DAG using topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:49,Energy Efficiency,Schedul,Schedule,49,"//=- llvm/CodeGen/ScoreboardHazardRecognizer.h - Schedule Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScoreboardHazardRecognizer class, which; // encapsulates hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:494,Energy Efficiency,schedul,scheduling,494,"//=- llvm/CodeGen/ScoreboardHazardRecognizer.h - Schedule Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScoreboardHazardRecognizer class, which; // encapsulates hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:523,Energy Efficiency,schedul,scheduling,523,"//=- llvm/CodeGen/ScoreboardHazardRecognizer.h - Schedule Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScoreboardHazardRecognizer class, which; // encapsulates hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:462,Safety,hazard,hazard-avoidance,462,"//=- llvm/CodeGen/ScoreboardHazardRecognizer.h - Schedule Support -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScoreboardHazardRecognizer class, which; // encapsulates hazard-avoidance heuristics for scheduling, based on the; // scheduling itineraries specified for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:67,Availability,mask,mask,67,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:152,Availability,mask,mask,152,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:123,Energy Efficiency,schedul,schedule,123,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:366,Energy Efficiency,schedul,scheduler,366,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:431,Energy Efficiency,schedul,scheduler,431,"// Scoreboard to track function unit usage. Scoreboard[0] is a; // mask of the FUs in use in the cycle currently being; // schedule. Scoreboard[1] is a mask for the next cycle. The; // Scoreboard is used as a circular buffer with the current cycle; // indicated by Head.; //; // Scoreboard always counts cycles in forward execution order. If used by a; // bottom-up scheduler, then the scoreboard cycles are the inverse of the; // scheduler's cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:32,Energy Efficiency,monitor,monitored,32,// The maximum number of cycles monitored by the Scoreboard. This; // value is determined based on the target itineraries to ensure; // that all hazards can be tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:145,Safety,hazard,hazards,145,// The maximum number of cycles monitored by the Scoreboard. This; // value is determined based on the target itineraries to ensure; // that all hazards can be tracked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:29,Energy Efficiency,power,power-of-,29,// Depth is expected to be a power-of-2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:55,Energy Efficiency,schedul,scheduled,55,// Stalls provides an cycle offset at which SU will be scheduled. It will be; // negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:104,Energy Efficiency,schedul,scheduling,104,// Stalls provides an cycle offset at which SU will be scheduled. It will be; // negative for bottom-up scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:168,Security,access,accessed,168,/// A reference to an Interned FoldingSetNodeID for this node.; /// The Allocator in SelectionDAG holds the data.; /// SDVTList contains all types which are frequently accessed in SelectionDAG.; /// The size of this list is not expected to be big so it won't introduce; /// a memory penalty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:45,Performance,cache,cache,45,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:57,Safety,avoid,avoid,57,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:8,Security,hash,hash,8,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:68,Security,hash,hash,68,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:56,Safety,avoid,avoid,56,/// Specialize FoldingSetTrait for SDVTListNode; /// to avoid computing temp FoldingSetNodeID and hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:98,Security,hash,hash,98,/// Specialize FoldingSetTrait for SDVTListNode; /// to avoid computing temp FoldingSetNodeID and hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:523,Energy Efficiency,power,powerful,523,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:85,Integrability,Depend,Dependence,85,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:281,Performance,optimiz,optimizations,281,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:309,Usability,simpl,simplifications,309,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:515,Usability,simpl,simple,515,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:23,Performance,optimiz,optimization,23,/// The function-level optimization remark emitter. Used to emit remarks; /// whenever manipulating the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:59,Performance,perform,performing,59,"/// This structure is used to memoize nodes, automatically performing; /// CSE with existing nodes when a duplicate is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:171,Deployability,update,updates,171,"/// Clients of various APIs that cause global effects on; /// the DAG can optionally implement this interface. This allows the clients; /// to handle the various sorts of updates that happen.; ///; /// A DAGUpdateListener automatically registers itself with DAG when it is; /// constructed, and removes itself when destroyed in RAII fashion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:100,Integrability,interface,interface,100,"/// Clients of various APIs that cause global effects on; /// the DAG can optionally implement this interface. This allows the clients; /// to handle the various sorts of updates that happen.; ///; /// A DAGUpdateListener automatically registers itself with DAG when it is; /// constructed, and removes itself when destroyed in RAII fashion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:24,Deployability,update,updated,24,/// The node N that was updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:88,Usability,resume,resume,88,/// Help to insert SDNodeFlags automatically in transforming. Use; /// RAII to save and resume flags in current scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:20,Energy Efficiency,reduce,reduce,20,"// The compiler can reduce this expression to a constant iff we pass an; // empty DebugLoc. Thankfully, the debug location doesn't have any bearing; // on the subclass data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Usability,Clear,Clear,4,/// Clear state and free memory necessary to make this; /// SelectionDAG ready to process a new block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:75,Availability,avail,available,75,"/// Returns the result of the AssignmentTrackingAnalysis pass if it's; /// available, otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:314,Availability,Error,Error,314,/// Just dump dot graph to a user-provided path and title.; /// This doesn't open the dot viewer program and; /// helps visualization when outside debugging session.; /// FileName expects absolute path. If provided; /// without any path separators then the file; /// will be created in the current directory.; /// Error will be emitted if the path is insane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Usability,Clear,Clear,4,/// Clear all previously defined node graph attributes.; /// Intended to be used from a debugging tool (eg. gdb).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:558,Deployability,Update,UpdatedNodes,558,"/// Transforms a SelectionDAG node and any operands to it into a node; /// that is compatible with the target instruction selector, as indicated by; /// the TargetLowering object.; ///; /// \returns true if \c N is a valid, legal node after calling this.; ///; /// This essentially runs a single recursive walk of the \c Legalize process; /// over the given node (and its operands). This can be used to incrementally; /// legalize the DAG. All of the nodes which are directly replaced,; /// potentially including N, are added to the output parameter \c; /// UpdatedNodes so that the delta to the DAG can be understood by the; /// caller.; ///; /// When this returns false, N has been legalized in a way that make the; /// pointer passed in no longer valid. It may have even been deleted from the; /// DAG, and so it shouldn't be used further. When this returns true, the; /// N passed in is a legal node, and can be immediately processed as such.; /// This may still have done some work on the DAG, and will still populate; /// UpdatedNodes with any new nodes replacing those originally in the DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:1028,Deployability,Update,UpdatedNodes,1028,"/// Transforms a SelectionDAG node and any operands to it into a node; /// that is compatible with the target instruction selector, as indicated by; /// the TargetLowering object.; ///; /// \returns true if \c N is a valid, legal node after calling this.; ///; /// This essentially runs a single recursive walk of the \c Legalize process; /// over the given node (and its operands). This can be used to incrementally; /// legalize the DAG. All of the nodes which are directly replaced,; /// potentially including N, are added to the output parameter \c; /// UpdatedNodes so that the delta to the DAG can be understood by the; /// caller.; ///; /// When this returns false, N has been legalized in a way that make the; /// pointer passed in no longer valid. It may have even been deleted from the; /// DAG, and so it shouldn't be used further. When this returns true, the; /// N passed in is a legal node, and can be immediately processed as such.; /// This may still have done some work on the DAG, and will still populate; /// UpdatedNodes with any new nodes replacing those originally in the DAG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:135,Integrability,wrap,wrapping,135,"//===--------------------------------------------------------------------===//; // Node creation methods.; /// Create a ConstantSDNode wrapping a constant value.; /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.; ///; /// If only legal types can be produced, this does the necessary; /// transformations (e.g., if the vector element type is illegal).; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:38,Integrability,wrap,wrapping,38,"/// @}; /// Create a ConstantFPSDNode wrapping a constant value.; /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.; ///; /// If only legal types can be produced, this does the necessary; /// transformations (e.g., if the vector element type is illegal).; /// The forms that take a double should only be used for simple constants; /// that can be exactly represented in VT. No checks are made.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:337,Usability,simpl,simple,337,"/// @}; /// Create a ConstantFPSDNode wrapping a constant value.; /// If VT is a vector type, the constant is splatted into a BUILD_VECTOR.; ///; /// If only legal types can be produced, this does the necessary; /// transformations (e.g., if the vector element type is illegal).; /// The forms that take a double should only be used for simple constants; /// that can be exactly represented in VT. No checks are made.; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:129,Availability,mask,mask,129,"/// Return an ISD::VECTOR_SHUFFLE node. The number of elements in VT,; /// which must be a vector type, must match the number of mask elements; /// NumElts. An integer mask element equal to -1 is treated as undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:168,Availability,mask,mask,168,"/// Return an ISD::VECTOR_SHUFFLE node. The number of elements in VT,; /// which must be a vector type, must match the number of mask elements; /// NumElts. An integer mask element equal to -1 is treated as undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:177,Integrability,depend,depending,177,/// Returns a node representing a splat of one value into all lanes; /// of the provided vector type. This is a utility which returns; /// either a BUILD_VECTOR or SPLAT_VECTOR depending on the; /// scalability of the desired vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:199,Performance,scalab,scalability,199,/// Returns a node representing a splat of one value into all lanes; /// of the provided vector type. This is a utility which returns; /// either a BUILD_VECTOR or SPLAT_VECTOR depending on the; /// scalability of the desired vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:82,Modifiability,extend,extending,82,"/// Convert Op, which must be of float type, to the; /// float type VT, by either extending or rounding (by truncation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:101,Modifiability,extend,extending,101,"/// Convert Op, which must be a STRICT operation of float type, to the; /// float type VT, by either extending or rounding (by truncation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:90,Modifiability,extend,extending,90,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either any-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:91,Modifiability,extend,extending,91,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either sign-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:91,Modifiability,extend,extending,91,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either zero-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:111,Integrability,depend,depending,111,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either any/sign/zero-extending (depending on IsAny /; /// IsSigned) or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:100,Modifiability,extend,extending,100,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either any/sign/zero-extending (depending on IsAny /; /// IsSigned) or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:107,Integrability,depend,depending,107,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either sign/zero-extending (depending on IsSigned) or; /// truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:96,Modifiability,extend,extending,96,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by either sign/zero-extending (depending on IsSigned) or; /// truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:170,Modifiability,extend,extending,170,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by first bitcasting (from potential vector) to; /// corresponding scalar type then either any-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:171,Modifiability,extend,extending,171,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by first bitcasting (from potential vector) to; /// corresponding scalar type then either sign-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:171,Modifiability,extend,extending,171,"/// Convert Op, which must be of integer type, to the; /// integer type VT, by first bitcasting (from potential vector) to; /// corresponding scalar type then either zero-extending or truncating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:43,Modifiability,extend,extend,43,/// Return the expression required to zero extend the Op; /// value assuming it was the smaller SrcTy value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:103,Performance,perform,performing,103,"/// Convert Op, which must be of integer type, to the integer type VT, by; /// either truncating it or performing either zero or sign extension as; /// appropriate extension for the pointer's semantics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:38,Modifiability,extend,extend,38,/// Return the expression required to extend the Op as a pointer value; /// assuming it was the smaller SrcTy value. This may be either a zero extend; /// or a sign extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:143,Modifiability,extend,extend,143,/// Return the expression required to extend the Op as a pointer value; /// assuming it was the smaller SrcTy value. This may be either a zero extend; /// or a sign extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:165,Modifiability,extend,extend,165,/// Return the expression required to extend the Op as a pointer value; /// assuming it was the smaller SrcTy value. This may be either a zero extend; /// or a sign extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:13,Testability,log,logical,13,"/// Create a logical NOT operation as (XOR Val, BooleanOne).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:86,Availability,Mask,Mask,86,"/// Create a vector-predicated logical NOT operation as (VP_XOR Val,; /// BooleanOne, Mask, EVL).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:31,Testability,log,logical,31,"/// Create a vector-predicated logical NOT operation as (VP_XOR Val,; /// BooleanOne, Mask, EVL).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:100,Performance,perform,performing,100,"/// Convert a vector-predicated Op, which must be an integer vector, to the; /// vector-type VT, by performing either vector-predicated zext or truncating; /// it. The Op will be returned as-is if Op and VT are vectors containing; /// integer with same width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:135,Performance,perform,performing,135,"/// Convert a vector-predicated Op, which must be of integer type, to the; /// vector-type integer type VT, by either truncating it or performing either; /// vector-predicated zero or sign extension as appropriate extension for the; /// pointer's semantics. This function just redirects to getVPZExtOrTrunc; /// right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:119,Performance,load,load,119,"/// Create an add instruction with appropriate flags when used for; /// addressing some offset of an object. i.e. if a load is split into multiple; /// components, create an add nuw from the base pointer to the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:27,Integrability,wrap,wrap,27,"// The object itself can't wrap around the address space, so it shouldn't be; // possible for the adds of the offsets to the split parts to overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:79,Performance,load,loaded,79,/// Compute a TokenFactor to force all the incoming stack arguments to be; /// loaded from the stack. This is used in tail call lowering to protect; /// stack arguments from being clobbered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:11,Usability,simpl,simplify,11,/// Try to simplify a select/vselect into 1 of its operands or a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:11,Usability,simpl,simplify,11,/// Try to simplify a shift into 1 of its operands or a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:11,Usability,simpl,simplify,11,/// Try to simplify a floating-point binary operation into 1 of its operands; /// or a constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:116,Performance,load,loaded,116,"/// Gets a node for an atomic cmpxchg op. There are two; /// valid Opcodes. ISD::ATOMIC_CMO_SWAP produces the value loaded and a; /// chain result. ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS produces the value loaded,; /// a success flag (initially i1), and a chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:201,Performance,load,loaded,201,"/// Gets a node for an atomic cmpxchg op. There are two; /// valid Opcodes. ISD::ATOMIC_CMO_SWAP produces the value loaded and a; /// chain result. ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS produces the value loaded,; /// a success flag (initially i1), and a chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:46,Usability,GUID,GUID,46,"/// Creates a PseudoProbeSDNode with function GUID `Guid` and; /// the index of the block `Index` it is probing, as well as the attributes; /// `attr` of the probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:52,Usability,Guid,Guid,52,"/// Creates a PseudoProbeSDNode with function GUID `Guid` and; /// the index of the block `Index` it is probing, as well as the attributes; /// `attr` of the probe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Performance,Load,Loads,4,"/// Loads are not normal binary operators: their result type is not; /// determined by their operands, and they produce a value AND a token chain.; ///; /// This function will set the MOLoad flag on MMOFlags, but you can set it if; /// you want. The MOStore flag must not be set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:14,Testability,Assert,AssertAlignSDNode,14,/// Return an AssertAlignSDNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:43,Availability,avail,available,43,"/// Get the specified node if it's already available, or else return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:122,Deployability,Update,UpdateListener,122,"/// Remove the specified node from the system. If any of its; /// operands then becomes dead, remove them as well. Inform UpdateListener; /// for each node deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:378,Deployability,Update,UpdateListener,378,"/// Modify anything using 'From' to use 'To' instead.; /// This can cause recursive merging of nodes in the DAG. Use the first; /// version if 'From' is known to have a single result, use the second; /// if you have two nodes with identical results (or if 'To' has a superset; /// of the results of 'From'), use the third otherwise.; ///; /// These methods all take an optional UpdateListener, which (if not null) is; /// informed about nodes that are deleted and modified due to recursive; /// changes in the dag.; ///; /// These functions only replace all existing uses. It's possible that as; /// these replacements are being performed, CSE may cause the From node; /// to be given new uses. These new uses of From are left in place, and; /// not automatically transferred to To.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:629,Performance,perform,performed,629,"/// Modify anything using 'From' to use 'To' instead.; /// This can cause recursive merging of nodes in the DAG. Use the first; /// version if 'From' is known to have a single result, use the second; /// if you have two nodes with identical results (or if 'To' has a superset; /// of the results of 'From'), use the third otherwise.; ///; /// These methods all take an optional UpdateListener, which (if not null) is; /// informed about nodes that are deleted and modified due to recursive; /// changes in the dag.; ///; /// These functions only replace all existing uses. It's possible that as; /// these replacements are being performed, CSE may cause the From node; /// to be given new uses. These new uses of From are left in place, and; /// not automatically transferred to To.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:131,Deployability,update,update,131,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:265,Integrability,depend,dependency,265,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:19,Performance,load,load,19,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:296,Performance,load,load,296,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:330,Performance,load,load,330,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:131,Deployability,update,update,131,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:265,Integrability,depend,dependency,265,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:19,Performance,load,load,19,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:296,Performance,load,load,296,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:330,Performance,load,load,330,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:116,Deployability,update,update,116,/// Move node N in the AllNodes list to be immediately; /// before the given iterator Position. This may be used to update the; /// topological ordering when the list of nodes is modified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:210,Availability,down,down,210,"/// In most cases this function returns the ABI alignment for a given type,; /// except for illegal vector types where the alignment exceeds that of the; /// stack. In such cases we attempt to break the vector down to a legal type; /// and return the ABI alignment for that instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:109,Availability,down,downstream,109,/// Return true if the sign bit of Op is known to be zero.; /// We use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:89,Usability,simpl,simplify,89,/// Return true if the sign bit of Op is known to be zero.; /// We use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,Availability,Mask,Mask,25,/// Return true if 'Op & Mask' is known to be zero. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:102,Availability,down,downstream,102,/// Return true if 'Op & Mask' is known to be zero. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:121,Availability,Mask,Mask,121,/// Return true if 'Op & Mask' is known to be zero. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:82,Usability,simpl,simplify,82,/// Return true if 'Op & Mask' is known to be zero. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,Availability,Mask,Mask,25,/// Return true if 'Op & Mask' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:118,Availability,down,downstream,118,/// Return true if 'Op & Mask' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:137,Availability,Mask,Mask,137,/// Return true if 'Op & Mask' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:98,Usability,simpl,simplify,98,/// Return true if 'Op & Mask' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream. Op and Mask are; /// known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:111,Availability,down,downstream,111,/// Return true if 'Op' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:91,Usability,simpl,simplify,91,/// Return true if 'Op' is known to be zero in DemandedElts. We; /// use this predicate to simplify operations downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:26,Availability,Mask,Mask,26,/// Return true if '(Op & Mask) == Mask'.; /// Op and Mask are known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:35,Availability,Mask,Mask,35,/// Return true if '(Op & Mask) == Mask'.; /// Op and Mask are known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:54,Availability,Mask,Mask,54,/// Return true if '(Op & Mask) == Mask'.; /// Op and Mask are known to be the same type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test if the given value is known to have exactly one bit set. This differs; /// from computeKnownBits in that it doesn't necessarily determine which bit; /// is set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:209,Integrability,wrap,wrapper,209,/// Get the upper bound on bit size for this Value \p Op as a signed integer.; /// i.e. x == sext(trunc(x to MaxSignedBits) to bitwidth(x)).; /// Similar to the APInt::getSignificantBits function.; /// Helper wrapper to ComputeNumSignBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:209,Integrability,wrap,wrapper,209,/// Get the upper bound on bit size for this Value \p Op as a signed integer.; /// i.e. x == sext(trunc(x to MaxSignedBits) to bitwidth(x)).; /// Similar to the APInt::getSignificantBits function.; /// Helper wrapper to ComputeNumSignBits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,"/// Test whether the given SDValue (or all elements of it, if it is a; /// vector) is known to never be NaN. If \p SNaN is true, returns if \p Op is; /// known to never be a signaling NaN (it may still be a qNaN).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test whether the given floating point SDValue is known to never be; /// positive or negative zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test whether the given SDValue is known to contain non-zero value(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,"/// Test whether two SDValues are known to compare equal. This; /// is true if they are the same value, or if one is negative zero and the; /// other positive zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,"/// Test whether \p V has a splatted value for all the demanded elements.; ///; /// On success \p UndefElts will indicate the elements that have UNDEF; /// values instead of the splat value, this is only guaranteed to be correct; /// for \p DemandedElts.; ///; /// NOTE: The function will return true for a demanded splat of UNDEF values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test whether \p V has a splatted value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:341,Energy Efficiency,reduce,reduced,341,"/// Match a binop + shuffle pyramid that represents a horizontal reduction; /// over the elements of a vector starting from the EXTRACT_VECTOR_ELT node /p; /// Extract. The reduction must use one of the opcodes listed in /p; /// CandidateBinOps and on success /p BinOp will contain the matching opcode.; /// Returns the vector that is being reduced on, or SDValue() if a reduction; /// was not matched. If \p AllowPartials is set then in the case of a; /// reduction pattern that only matches the first few stages, the extracted; /// subvector of the start of the reduction is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:19,Performance,load,loads,19,/// Return true if loads are next to each other and can be; /// merged. Check that both are nonvolatile and if LD is loading; /// 'Bytes' bytes from a location that is 'Dist' units away from the; /// location that the 'Base' load is loading from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:117,Performance,load,loading,117,/// Return true if loads are next to each other and can be; /// merged. Check that both are nonvolatile and if LD is loading; /// 'Bytes' bytes from a location that is 'Dist' units away from the; /// location that the 'Base' load is loading from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:225,Performance,load,load,225,/// Return true if loads are next to each other and can be; /// merged. Check that both are nonvolatile and if LD is loading; /// 'Bytes' bytes from a location that is 'Dist' units away from the; /// location that the 'Base' load is loading from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:233,Performance,load,loading,233,/// Return true if loads are next to each other and can be; /// merged. Check that both are nonvolatile and if LD is loading; /// 'Bytes' bytes from a location that is 'Dist' units away from the; /// location that the 'Base' load is loading from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,Performance,load,load,25,/// Infer alignment of a load / store address. Return std::nullopt if it; /// cannot be inferred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:59,Integrability,depend,dependent,59,"/// Compute the VTs needed for the low/hi parts of a type, dependent on an; /// enveloping VT that has been split into two identical pieces. Sets the; /// HisIsEmpty flag when hi type has zero storage size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:36,Energy Efficiency,power,power,36,/// Widen the vector up to the next power of two using INSERT_SUBVECTOR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test whether the given value is a constant int or similar node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Testability,Test,Test,4,/// Test whether the given value is a constant FP or similar node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:180,Safety,safe,safe,180,"/// Some opcodes may create immediate undefined behavior when used with some; /// values (integer division-by-zero for example). Therefore, these operations; /// are not generally safe to move around or change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:134,Safety,safe,safe,134,"/// Check if the provided node is save to speculatively executed given its; /// current arguments. So, while `udiv` the opcode is not safe to; /// speculatively execute, a given `udiv` node may be if the denominator is; /// known nonzero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:146,Performance,Perform,Performs,146,"/// Look up the node specified by ID in CSEMap. If it exists, return it. If; /// not, return the insertion token that will make insertion faster. Performs; /// additional processing for constant nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:312,Performance,load,load,312,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:377,Performance,load,load,377,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:424,Performance,load,load,424,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:509,Performance,load,load,509,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:122,Safety,safe,safe,122,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:95,Availability,failure,failures,95,/// Current optimization remark emitter.; /// Used to report things like combines and FastISel failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:12,Performance,optimiz,optimization,12,/// Current optimization remark emitter.; /// Used to report things like combines and FastISel failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode VT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode integer VT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode integer VT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode number of result VTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode EmitNodeInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode number of result VTs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:9,Performance,optimiz,optimized,9,// Space-optimized forms that implicitly encode EmitNodeInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:4,Performance,Perform,Perform,4,/// Perform instruction selection on all basic blocks in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:4,Performance,Perform,Perform,4,"/// Perform instruction selection on a single basic block, for; /// instructions between \p Begin and \p End. \p HadTailCall will be set; /// to true if a call in the block was translated as a tail call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:15,Energy Efficiency,schedul,scheduler,15,"/// Create the scheduler. If a specific scheduler was specified; /// via the SchedulerRegistry, use it, otherwise select the; /// one preferred by the target.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:40,Energy Efficiency,schedul,scheduler,40,"/// Create the scheduler. If a specific scheduler was specified; /// via the SchedulerRegistry, use it, otherwise select the; /// one preferred by the target.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:77,Energy Efficiency,Schedul,SchedulerRegistry,77,"/// Create the scheduler. If a specific scheduler was specified; /// via the SchedulerRegistry, use it, otherwise select the; /// one preferred by the target.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:52,Energy Efficiency,efficient,efficiently,52,/// OpcodeOffset - This is a cache used to dispatch efficiently into isel; /// state machines that start with a OPC_SwitchOpcode node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:29,Performance,cache,cache,29,/// OpcodeOffset - This is a cache used to dispatch efficiently into isel; /// state machines that start with a OPC_SwitchOpcode node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:107,Usability,simpl,simple,107,/// This represents a list of ValueType's that has been intern'd by; /// a SelectionDAG. Instances of this simple value class are returned by; /// SelectionDAG::getVTList(...).; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:257,Performance,load,loads,257,"// end namespace ISD; //===----------------------------------------------------------------------===//; /// Unlike LLVM values, Selection DAG nodes may return multiple; /// values as the result of a computation. Many nodes return multiple values,; /// from loads (which define a token and a return value) to ADDC (which returns; /// a result and a carry value), to calls (which may return an arbitrary number; /// of values).; ///; /// As such, each use of a SelectionDAG computation must indicate the node that; /// computes it as well as which return value to use from that node. This pair; /// of information is represented with the SDValue value type.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:15,Usability,simpl,simple,15,/// Return the simple ValueType of the referenced return value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:76,Performance,scalab,scalable,76,"/// Returns the size of the value in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:102,Performance,scalab,scalable,102,"/// Returns the size of the value in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:240,Energy Efficiency,efficient,efficient,240,"/// Return true if this operand (which must be a chain) reaches the; /// specified operand without crossing any side-effecting instructions.; /// In practice, this looks through token factors and non-volatile loads.; /// In order to remain efficient, this only; /// looks a couple of nodes in, it does not do an exhaustive search.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:209,Performance,load,loads,209,"/// Return true if this operand (which must be a chain) reaches the; /// specified operand without crossing any side-effecting instructions.; /// In practice, this looks through token factors and non-volatile loads.; /// In order to remain efficient, this only; /// looks a couple of nodes in, it does not do an exhaustive search.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:53,Energy Efficiency,allocate,allocated,53,"/// Like set, but only supports initializing a newly-allocated; /// SDUse with a non-null value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:23,Performance,optimiz,optimization,23,/// These are IR-level optimization flags that may be propagated to SDNodes.; /// TODO: This data structure should be shared by the IR optimizer and the; /// the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:135,Performance,optimiz,optimizer,135,/// These are IR-level optimization flags that may be propagated to SDNodes.; /// TODO: This data structure should be shared by the IR optimizer and the; /// the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:294,Testability,log,logic,294,"// We assume instructions do not raise floating-point exceptions by default,; // and only those marked explicitly may do so. We could choose to represent; // this via a positive ""FPExcept"" flags like on the MI level, but having a; // negative ""NoFPExcept"" flag here makes the flag intersection logic more; // straightforward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:38,Performance,optimiz,optimization,38,/// Default constructor turns off all optimization flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:13,Security,access,accessors,13,// These are accessors for each flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Usability,Clear,Clear,4,/// Clear any flags in this flag set that aren't also set in Flags. All; /// flags will be cleared if Flags are undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:91,Usability,clear,cleared,91,/// Clear any flags in this flag set that aren't also set in Flags. All; /// flags will be cleared if Flags are undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:33,Performance,perform,performs,33,/// The operation that this node performs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:232,Availability,Mask,MaskedLoadStoreBaseSDNode,232,// This storage is shared between disparate class hierarchies to hold an; // enumeration specific to the class hierarchy in use.; // LSBaseSDNode => enum ISD::MemIndexedMode; // VPLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // MaskedLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // VPGatherScatterSDNode => enum ISD::MemIndexType; // MaskedGatherScatterSDNode => enum ISD::MemIndexType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:342,Availability,Mask,MaskedGatherScatterSDNode,342,// This storage is shared between disparate class hierarchies to hold an; // enumeration specific to the class hierarchy in use.; // LSBaseSDNode => enum ISD::MemIndexedMode; // VPLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // MaskedLoadStoreBaseSDNode => enum ISD::MemIndexedMode; // VPGatherScatterSDNode => enum ISD::MemIndexType; // MaskedGatherScatterSDNode => enum ISD::MemIndexType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:13,Performance,Load,LoadExtType,13,// enum ISD::LoadExtType,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:143,Energy Efficiency,schedul,scheduling,143,"// The ordering of the SDNodes. It roughly corresponds to the ordering of the; // original LLVM instructions.; // This is used for turning off scheduling, because we'll forgo; // the normal scheduling algorithms and output the instructions according to; // this ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:190,Energy Efficiency,schedul,scheduling,190,"// The ordering of the SDNodes. It roughly corresponds to the ordering of the; // original LLVM instructions.; // This is used for turning off scheduling, because we'll forgo; // the normal scheduling algorithms and output the instructions according to; // this ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:83,Security,Access,Accessors,83,"//===--------------------------------------------------------------------===//; // Accessors; //; /// Return the SelectionDAG opcode value for this node. For; /// pre-isel nodes (those for which isMachineOpcode returns false), these; /// are the opcode values in the ISD and <target>ISD namespaces. For; /// post-isel opcodes, see getMachineOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,/// Test if this node has a target-specific opcode (in the; /// \<target\>ISD namespace).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,/// Test if this node has a target-specific opcode that may raise; /// FP exceptions (in the \<target\>ISD namespace and greater than; /// FIRST_TARGET_STRICTFP_OPCODE). Note that all target memory; /// opcode are currently automatically considered to possibly raise; /// FP exceptions as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,/// Test if this node has a target-specific; /// memory-referencing opcode (in the \<target\>ISD namespace and; /// greater than FIRST_TARGET_MEMORY_OPCODE).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,"/// Test if this node is a memory intrinsic (with valid pointer information).; /// INTRINSIC_W_CHAIN and INTRINSIC_VOID nodes are sometimes created for; /// non-memory intrinsics (with chains) that are not really instances of; /// MemSDNode. For such nodes, we need some extra state to determine the; /// proper classof relationship.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,/// Test if this node is a strict floating point pseudo-op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,/// Test if this node is a vector predication operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Testability,Test,Test,4,"/// Test if this node has a post-isel opcode, directly; /// corresponding to a MachineInstr opcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,Safety,avoid,avoid,37,"/// Set source location info. Try to avoid this, putting; /// it in the constructor is preferable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:160,Performance,perform,performed,160,"/// Returns true if N is a predecessor of any node in Worklist. This; /// helper keeps Visited and Worklist sets externally to allow unions; /// searches to be performed in parallel, caching of results across; /// queries and incremental addition to Worklist. Stops early if N is; /// found but will resume. Remember to clear Visited and Worklists; /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before; /// giving up. The TopologicalPrune flag signals that positive NodeIds are; /// topologically ordered (Operands have strictly smaller node id) and search; /// can be pruned leveraging this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:300,Usability,resume,resume,300,"/// Returns true if N is a predecessor of any node in Worklist. This; /// helper keeps Visited and Worklist sets externally to allow unions; /// searches to be performed in parallel, caching of results across; /// queries and incremental addition to Worklist. Stops early if N is; /// found but will resume. Remember to clear Visited and Worklists; /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before; /// giving up. The TopologicalPrune flag signals that positive NodeIds are; /// topologically ordered (Operands have strictly smaller node id) and search; /// can be pruned leveraging this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:320,Usability,clear,clear,320,"/// Returns true if N is a predecessor of any node in Worklist. This; /// helper keeps Visited and Worklist sets externally to allow unions; /// searches to be performed in parallel, caching of results across; /// queries and incremental addition to Worklist. Stops early if N is; /// found but will resume. Remember to clear Visited and Worklists; /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before; /// giving up. The TopologicalPrune flag signals that positive NodeIds are; /// topologically ordered (Operands have strictly smaller node id) and search; /// can be pruned leveraging this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:35,Modifiability,extend,extended,35,/// Helper method returns the zero-extended integer value of a ConstantSDNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Usability,Clear,Clear,4,/// Clear any flags in this node that aren't also set in Flags.; /// If Flags is not in a defined state then this has no effect.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:47,Usability,simpl,simple,47,/// Return the type of a specified result as a simple type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:86,Performance,scalab,scalable,86,"/// Returns MVT::getSizeInBits(getValueType(ResNo)).; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:112,Performance,scalab,scalable,112,"/// Returns MVT::getSizeInBits(getValueType(ResNo)).; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:47,Availability,down,down,47,"/// Print a SelectionDAG node and all children down to; /// the leaves. The given SelectionDAG allows target-specific nodes; /// to be printed in human-readable form. Unlike printr, this will; /// print the whole DAG, including children that appear multiple; /// times.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Deployability,Release,Release,4,/// Release the operands and set this node to have zero operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Integrability,Wrap,Wrapper,4,"/// Wrapper class for IR location info (IR ordering and DebugLoc) to be passed; /// into SDNode creation functions.; /// When an SDNode is created from the DAGBuilder, the DebugLoc is extracted; /// from the original Instruction, and IROrder is the ordinal position of; /// the instruction.; /// When an SDNode is created after the DAG is being built, both DebugLoc and; /// the IROrder are propagated from the original SDNode.; /// So SDLoc class provides two constructors besides the default one, one to; /// be used by the DAGBuilder, the other to be used by others.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:34,Safety,avoid,avoid,34,"// Explicitly check for !ResNo to avoid use-after-free, because there are; // callers that use SDValue(N, 0) with a deleted N to indicate successful; // combines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:91,Deployability,update,updated,91,/// This class is used to form a handle around another node that; /// is persistent and is updated across invocations of replaceAllUsesWith on its; /// operand. This node should be directly created by end-users and not added to; /// the AllNodes list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:93,Energy Efficiency,allocate,allocated,93,"// Manually set up the operand list. This node type is special in that it's; // always stack allocated and SelectionDAG does not manage its operands.; // TODO: This should either (a) not be in the SDNode hierarchy, or (b) not; // be so special.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:51,Security,access,access,51,/// Returns alignment and volatility of the memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:253,Availability,mask,masked,253,"/// Return the SubclassData value, without HasDebugValue. This contains an; /// encoding of the volatile flag, as well as bits used by subclasses. This; /// function should only be used to compute a FoldingSetNodeID value.; /// The HasDebugValue bit is masked out because CSE map needs to match; /// nodes with debug info with nodes without debug info. Same is about; /// isDivergent bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:47,Security,access,access,47,// Returns the offset from the location of the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:16,Integrability,synchroniz,synchronization,16,/// Returns the synchronization scope ID for this memory operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:92,Availability,failure,failure,92,"/// Return a single atomic ordering that is at least as strong as both the; /// success and failure orderings for an atomic operation. (For operations; /// other than cmpxchg, this is equivalent to getSuccessOrdering().)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:75,Performance,perform,performed,75,/// Return a MachineMemOperand object describing the memory; /// reference performed by operation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Deployability,Update,Update,4,"/// Update this MemSDNode's MachineMemOperand information; /// to reflect the alignment of NewMMO, if it has a greater alignment.; /// This must only be used when the new alignment applies to all users of; /// this MachineMemOperand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:303,Availability,mask,mask,303,"/// This SDNode is used to implement the code generator; /// support for the llvm IR shufflevector instruction. It combines elements; /// from two input vectors into a new input vector, with the selection and; /// ordering of elements determined by an array of integers, referred to as; /// the shuffle mask. For input vectors of width N, mask indices of 0..N-1; /// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.; /// An index of -1 is treated as undef, such that the code generator may put; /// any value in the corresponding element of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:339,Availability,mask,mask,339,"/// This SDNode is used to implement the code generator; /// support for the llvm IR shufflevector instruction. It combines elements; /// from two input vectors into a new input vector, with the selection and; /// ordering of elements determined by an array of integers, referred to as; /// the shuffle mask. For input vectors of width N, mask indices of 0..N-1; /// refer to elements from the LHS input, and indices from N to 2N-1 the RHS.; /// An index of -1 is treated as undef, such that the code generator may put; /// any value in the corresponding element of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:18,Availability,Mask,Mask,18,"// The memory for Mask is owned by the SelectionDAG's OperandAllocator, and; // is freed when the SelectionDAG object is destroyed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:138,Usability,simpl,simplify,138,// We can choose any index value here and be correct because all elements; // are undefined. Return 0 for better potential for callers to simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:39,Availability,mask,mask,39,/// Change values in a shuffle permute mask assuming; /// the two vector operands have swapped position.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:427,Testability,log,logic,427,"/// We don't rely on operator== working on double values, as; /// it returns true for things that are clearly not equal, like -0.0 and 0.0.; /// As such, this method can be used to do an exact bit-for-bit comparison of; /// two floating point values.; /// We leave the version with the double argument here because it's just so; /// convenient to write ""2.0"" and the like. Without this function we'd; /// have to duplicate its logic everywhere it's called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:102,Usability,clear,clearly,102,"/// We don't rely on operator== working on double values, as; /// it returns true for things that are clearly not equal, like -0.0 and 0.0.; /// As such, this method can be used to do an exact bit-for-bit comparison of; /// two floating point values.; /// We leave the version with the double argument here because it's just so; /// convenient to write ""2.0"" and the like. Without this function we'd; /// have to duplicate its logic everywhere it's called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:121,Availability,Mask,Mask,121,"/// If \p V is a bitwise not, returns the inverted operand. Otherwise returns; /// an empty SDValue. Only bits set in \p Mask are required to be inverted,; /// other bits may be arbitrary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:72,Usability,guid,guid,72,"/// This SDNode is used for PSEUDO_PROBE values, which are the function guid and; /// the index of the basic block being probed. A pseudo probe serves as a place; /// holder and will be removed at the end of compilation. It does not have any; /// operand because we do not want the instruction selection to deal with any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:22,Integrability,depend,dependent,22,/// Completely target-dependent object reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:422,Availability,mask,mask,422,"/// Check if this is a constant splat, and if so, find the; /// smallest element size that splats the vector. If MinSplatBits is; /// nonzero, the element size must be at least that large. Note that the; /// splat element may be the entire vector (i.e., a one element vector).; /// Returns the splat element value in SplatValue. Any undefined bits in; /// that value are zero, and the corresponding bits in the SplatUndef mask; /// are set. The SplatBitSize value is set to the splat element size in; /// bits. HasAnyUndefs is set to true if any bits in the vector are; /// undefined. isBigEndian describes the endianness of the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:112,Availability,mask,mask,112,"/// Returns the demanded splatted value or a null value if this is not a; /// splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:249,Availability,mask,mask,249,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// The DemandedElts mask indicates the elements that must be present,; /// undemanded elements in Sequence may be null (SDValue()). If passed a; /// non-null UndefElements bitvector, it will resize it to match the original; /// vector width and set the bits where elements are undef. If result is; /// false, Sequence will be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:202,Energy Efficiency,power,power-of-,202,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// The DemandedElts mask indicates the elements that must be present,; /// undemanded elements in Sequence may be null (SDValue()). If passed a; /// non-null UndefElements bitvector, it will resize it to match the original; /// vector width and set the bits where elements are undef. If result is; /// false, Sequence will be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:202,Energy Efficiency,power,power-of-,202,"/// Find the shortest repeating sequence of values in the build vector.; ///; /// e.g. { u, X, u, X, u, u, X, u } -> { X }; /// { X, Y, u, Y, u, u, X, u } -> { X, Y }; ///; /// Currently this must be a power-of-2 build vector.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the original vector width and set the bits where elements are undef.; /// If result is false, Sequence will be empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:116,Availability,mask,mask,116,"/// Returns the demanded splatted constant or null if this is not a constant; /// splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:122,Availability,mask,mask,122,"/// Returns the demanded splatted constant FP or null if this is not a; /// constant FP splat.; ///; /// The DemandedElts mask indicates the elements that must be in the splat.; /// If passed a non-null UndefElements bitvector, it will resize it to match; /// the vector width and set the bits where elements are undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:81,Energy Efficiency,power,power,81,"/// If this is a constant FP splat and the splatted constant FP is an; /// exact power or 2, return the log base 2 integer value. Otherwise,; /// return -1.; ///; /// The BitWidth specifies the necessary bit precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:104,Testability,log,log,104,"/// If this is a constant FP splat and the splatted constant FP is an; /// exact power or 2, return the log base 2 integer value. Otherwise,; /// return -1.; ///; /// The BitWidth specifies the necessary bit precision.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:109,Usability,simpl,simple,109,/// An SDNode that holds an arbitrary LLVM IR Value. This is; /// used when the SelectionDAG needs to make a simple reference to something; /// in the LLVM IR representation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:66,Modifiability,parameteriz,parameterize,66,"/// This class is used to represent EVT's, which are used; /// to parameterize some operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:19,Performance,Load,LoadSDNode,19,/// Base class for LoadSDNode and StoreSDNode,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:40,Performance,load,load,40,"/// Return the addressing mode for this load or store:; /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:46,Performance,load,load,46,/// Return true if this is a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:50,Performance,load,load,50,/// Return true if this is NOT a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:41,Performance,LOAD,LOAD,41,/// This class is used to represent ISD::LOAD nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:79,Modifiability,extend,extending,79,"/// Return whether this is a plain node,; /// or one of the varieties of value-extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:89,Performance,load,loads,89,"/// Return whether this is a plain node,; /// or one of the varieties of value-extending loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:59,Availability,Mask,Mask,59,"// VPStridedStoreSDNode (Chain, Data, Ptr, Offset, Stride, Mask, EVL); // VPStoreSDNode (Chain, Data, Ptr, Offset, Mask, EVL); // VPStridedLoadSDNode (Chain, Ptr, Offset, Stride, Mask, EVL); // VPLoadSDNode (Chain, Ptr, Offset, Mask, EVL); // Mask is a vector of i1 elements;; // the type of EVL is TLI.getVPExplicitVectorLengthTy().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:115,Availability,Mask,Mask,115,"// VPStridedStoreSDNode (Chain, Data, Ptr, Offset, Stride, Mask, EVL); // VPStoreSDNode (Chain, Data, Ptr, Offset, Mask, EVL); // VPStridedLoadSDNode (Chain, Ptr, Offset, Stride, Mask, EVL); // VPLoadSDNode (Chain, Ptr, Offset, Mask, EVL); // Mask is a vector of i1 elements;; // the type of EVL is TLI.getVPExplicitVectorLengthTy().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:179,Availability,Mask,Mask,179,"// VPStridedStoreSDNode (Chain, Data, Ptr, Offset, Stride, Mask, EVL); // VPStoreSDNode (Chain, Data, Ptr, Offset, Mask, EVL); // VPStridedLoadSDNode (Chain, Ptr, Offset, Stride, Mask, EVL); // VPLoadSDNode (Chain, Ptr, Offset, Mask, EVL); // Mask is a vector of i1 elements;; // the type of EVL is TLI.getVPExplicitVectorLengthTy().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:228,Availability,Mask,Mask,228,"// VPStridedStoreSDNode (Chain, Data, Ptr, Offset, Stride, Mask, EVL); // VPStoreSDNode (Chain, Data, Ptr, Offset, Mask, EVL); // VPStridedLoadSDNode (Chain, Ptr, Offset, Stride, Mask, EVL); // VPLoadSDNode (Chain, Ptr, Offset, Mask, EVL); // Mask is a vector of i1 elements;; // the type of EVL is TLI.getVPExplicitVectorLengthTy().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:243,Availability,Mask,Mask,243,"// VPStridedStoreSDNode (Chain, Data, Ptr, Offset, Stride, Mask, EVL); // VPStoreSDNode (Chain, Data, Ptr, Offset, Mask, EVL); // VPStridedLoadSDNode (Chain, Ptr, Offset, Stride, Mask, EVL); // VPLoadSDNode (Chain, Ptr, Offset, Mask, EVL); // Mask is a vector of i1 elements;; // the type of EVL is TLI.getVPExplicitVectorLengthTy().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:40,Performance,load,load,40,"/// Return the addressing mode for this load or store:; /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:46,Performance,load,load,46,/// Return true if this is a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:50,Performance,load,load,50,/// Return true if this is NOT a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:3,Availability,Mask,MaskedLoadSDNode,3,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:41,Availability,mask,mask,41,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:61,Availability,Mask,MaskedStoreSDNode,61,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:106,Availability,mask,mask,106,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:116,Availability,Mask,Mask,116,"// MaskedLoadSDNode (Chain, ptr, offset, mask, passthru); // MaskedStoreSDNode (Chain, data, ptr, offset, mask); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:40,Performance,load,load,40,"/// Return the addressing mode for this load or store:; /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:46,Performance,load,load,46,/// Return true if this is a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:50,Performance,load,load,50,/// Return true if this is NOT a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,Availability,mask,mask,37,"// In the both nodes address is Op1, mask is Op2:; // VPGatherSDNode (Chain, base, index, scale, mask, vlen); // VPScatterSDNode (Chain, value, base, index, scale, mask, vlen); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:97,Availability,mask,mask,97,"// In the both nodes address is Op1, mask is Op2:; // VPGatherSDNode (Chain, base, index, scale, mask, vlen); // VPScatterSDNode (Chain, value, base, index, scale, mask, vlen); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:164,Availability,mask,mask,164,"// In the both nodes address is Op1, mask is Op2:; // VPGatherSDNode (Chain, base, index, scale, mask, vlen); // VPScatterSDNode (Chain, value, base, index, scale, mask, vlen); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:180,Availability,Mask,Mask,180,"// In the both nodes address is Op1, mask is Op2:; // VPGatherSDNode (Chain, base, index, scale, mask, vlen); // VPScatterSDNode (Chain, value, base, index, scale, mask, vlen); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,Availability,mask,mask,37,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:54,Availability,Mask,MaskedGatherSDNode,54,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:91,Availability,mask,mask,91,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:121,Availability,Mask,MaskedScatterSDNode,121,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:156,Availability,mask,mask,156,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:186,Availability,Mask,Mask,186,"// In the both nodes address is Op1, mask is Op2:; // MaskedGatherSDNode (Chain, passthru, mask, base, index, scale); // MaskedScatterSDNode (Chain, value, mask, base, index, scale); // Mask is a vector of i1 elements",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:308,Energy Efficiency,allocate,allocated,308,"// We use a pointer union between a single `MachineMemOperand` pointer and; // a pointer to an array of `MachineMemOperand` pointers. This is null when; // the number of these is zero, the single pointer variant used when the; // number is one, and the array is used for larger numbers.; //; // The array is allocated via the `SelectionDAG`'s allocator and so will; // always live until the DAG is cleaned up and doesn't require ownership here.; //; // We can't use something simpler like `TinyPtrVector` here because `SDNode`; // subclasses aren't managed in a conforming C++ manner. See the comments on; // `SelectionDAG::MorphNodeTo` which details what all goes on, but the; // constraint here is that these don't manage memory with their constructor or; // destructor and can be initialized to a good state even if they start off; // uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:476,Usability,simpl,simpler,476,"// We use a pointer union between a single `MachineMemOperand` pointer and; // a pointer to an array of `MachineMemOperand` pointers. This is null when; // the number of these is zero, the single pointer variant used when the; // number is one, and the array is used for larger numbers.; //; // The array is allocated via the `SelectionDAG`'s allocator and so will; // always live until the DAG is cleaned up and doesn't require ownership here.; //; // We can't use something simpler like `TinyPtrVector` here because `SDNode`; // subclasses aren't managed in a conforming C++ manner. See the comments on; // `SelectionDAG::MorphNodeTo` which details what all goes on, but the; // constraint here is that these don't manage memory with their constructor or; // destructor and can be initialized to a good state even if they start off; // uninitialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:270,Usability,simpl,simpler,270,"// Note that this could be folded into the above `MemRefs` member if doing so; // is advantageous at some point. We don't need to store this in most cases.; // However, at the moment this doesn't appear to make the allocation any; // smaller and makes the code somewhat simpler to read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:4,Usability,Clear,Clear,4,/// Clear out the memory reference descriptor list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:48,Modifiability,extend,extending,48,/// Returns true if the specified node is a non-extending and unindexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:72,Performance,load,load,72,/// Returns true if the specified node is a non-extending and unindexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:48,Modifiability,extend,extending,48,/// Returns true if the specified node is a non-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:58,Performance,load,load,58,/// Returns true if the specified node is a non-extending load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:55,Performance,load,load,55,/// Returns true if the specified node is an unindexed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:470,Modifiability,parameteriz,parameterize,470,"//==- llvm/CodeGen/SelectionDAGTargetInfo.h - SelectionDAG Info --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the SelectionDAGTargetInfo class, which targets can; // subclass to parameterize the SelectionDAG lowering and instruction; // selection process.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:115,Modifiability,parameteriz,parameterize,115,//===----------------------------------------------------------------------===//; /// Targets can subclass this to parameterize the; /// SelectionDAG lowering and instruction selection process.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:212,Energy Efficiency,efficient,efficient,212,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:178,Performance,load,loads,178,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:838,Performance,load,loads,838,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:171,Usability,simpl,simple,171,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:831,Usability,simpl,simple,831,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:213,Energy Efficiency,efficient,efficient,213,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:179,Performance,load,loads,179,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:172,Usability,simpl,simple,172,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:206,Energy Efficiency,efficient,efficient,206,/// Emit target-specific code that performs a memset.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple stores and can be more; /// efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used. Note that if AlwaysInline is true the; /// function has to return a valid SDValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,/// Emit target-specific code that performs a memset.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple stores and can be more; /// efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used. Note that if AlwaysInline is true the; /// function has to return a valid SDValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:171,Usability,simpl,simple,171,/// Emit target-specific code that performs a memset.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple stores and can be more; /// efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used. Note that if AlwaysInline is true the; /// function has to return a valid SDValue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,"/// Emit target-specific code that performs a memcmp/bcmp, in cases where that is; /// faster than a libcall. The first returned SDValue is the result of the; /// memcmp and the second is the chain. Both SDValues can be null if a normal; /// libcall should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,"/// Emit target-specific code that performs a memchr, in cases where that is; /// faster than a libcall. The first returned SDValue is the result of the; /// memchr and the second is the chain. Both SDValues can be null if a normal; /// libcall should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,"/// Emit target-specific code that performs a strcpy or stpcpy, in cases; /// where that is faster than a libcall.; /// The first returned SDValue is the result of the copy (the start; /// of the destination string for strcpy, a pointer to the null terminator; /// for stpcpy) and the second is the chain. Both SDValues can be null; /// if a normal libcall should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,Performance,perform,performs,35,"/// Emit target-specific code that performs a strcmp, in cases where that is; /// faster than a libcall.; /// The first returned SDValue is the result of the strcmp and the second is; /// the chain. Both SDValues can be null if a normal libcall should be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h:508,Performance,optimiz,optimize,508,"//===--- llvm/CodeGen/SelectOptimize.h ---------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the SelectOptimizePass class,; /// its corresponding pass name is `select-optimize`.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:731,Performance,perform,perform,731,"//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements SlotIndex and related classes. The purpose of SlotIndex; // is to describe a position at which a register can become live, or cease to; // be live.; //; // SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which; // is held is LiveIntervals and provides the real numbering. This allows; // LiveIntervals to perform largely transparent renumbering.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:185,Integrability,interface,interface,185,/// This class represents an entry in the slot index list held in the; /// SlotIndexes pass. It should not be used directly. See the; /// SlotIndex & SlotIndexes classes for the public interface to this; /// information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:26,Integrability,wrap,wrapper,26,/// SlotIndex - An opaque wrapper around machine indexes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:158,Testability,test,tests,158,// Creates a SlotIndex from an IndexListEntry and a slot. Generally should; // not be used. This method is only public to facilitate writing certain; // unit tests.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:4,Availability,Repair,Repair,4,/// Repair indexes after adding and removing instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Spiller.h:12,Integrability,interface,interface,12,/// Spiller interface.; ///; /// Implementations are utility classes which insert spill or remat code on; /// demand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Spiller.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Spiller.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:25,Deployability,patch,patchable,25,/// Return the number of patchable bytes the given stackmap should emit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:33,Modifiability,variab,variable,33,"/// Get the operand index of the variable list of non-argument operands.; /// These hold the ""live state"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:13,Deployability,patch,patchpoint,13,"/// MI-level patchpoint operands.; ///; /// MI patchpoint operations take the form:; /// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...; ///; /// IR patchpoint intrinsics do not have the <cc> operand because calling; /// convention is part of the subclass data.; ///; /// SD patchpoint nodes do not have a def operand because it is part of the; /// SDValue.; ///; /// Patchpoints following the anyregcc convention are handled specially. For; /// these, the stack map also records the location of the return value and; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:47,Deployability,patch,patchpoint,47,"/// MI-level patchpoint operands.; ///; /// MI patchpoint operations take the form:; /// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...; ///; /// IR patchpoint intrinsics do not have the <cc> operand because calling; /// convention is part of the subclass data.; ///; /// SD patchpoint nodes do not have a def operand because it is part of the; /// SDValue.; ///; /// Patchpoints following the anyregcc convention are handled specially. For; /// these, the stack map also records the location of the return value and; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:160,Deployability,patch,patchpoint,160,"/// MI-level patchpoint operands.; ///; /// MI patchpoint operations take the form:; /// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...; ///; /// IR patchpoint intrinsics do not have the <cc> operand because calling; /// convention is part of the subclass data.; ///; /// SD patchpoint nodes do not have a def operand because it is part of the; /// SDValue.; ///; /// Patchpoints following the anyregcc convention are handled specially. For; /// these, the stack map also records the location of the return value and; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:286,Deployability,patch,patchpoint,286,"/// MI-level patchpoint operands.; ///; /// MI patchpoint operations take the form:; /// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...; ///; /// IR patchpoint intrinsics do not have the <cc> operand because calling; /// convention is part of the subclass data.; ///; /// SD patchpoint nodes do not have a def operand because it is part of the; /// SDValue.; ///; /// Patchpoints following the anyregcc convention are handled specially. For; /// these, the stack map also records the location of the return value and; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:379,Deployability,Patch,Patchpoints,379,"/// MI-level patchpoint operands.; ///; /// MI patchpoint operations take the form:; /// [<def>], <id>, <numBytes>, <target>, <numArgs>, <cc>, ...; ///; /// IR patchpoint intrinsics do not have the <cc> operand because calling; /// convention is part of the subclass data.; ///; /// SD patchpoint nodes do not have a def operand because it is part of the; /// SDValue.; ///; /// Patchpoints following the anyregcc convention are handled specially. For; /// these, the stack map also records the location of the return value and; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:32,Deployability,patch,patchpoint,32,/// Return the ID for the given patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:25,Deployability,patch,patchable,25,/// Return the number of patchable bytes the given patchpoint should emit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:51,Deployability,patch,patchpoint,51,/// Return the number of patchable bytes the given patchpoint should emit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:33,Modifiability,variab,variable,33,"/// Get the operand index of the variable list of non-argument operands.; /// These hold the ""live state"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:94,Deployability,patch,patch,94,"/// MI-level Statepoint operands; ///; /// Statepoint operands take the form:; /// <id>, <num patch bytes >, <num call arguments>, <call target>,; /// [call arguments...],; /// <StackMaps::ConstantOp>, <calling convention>,; /// <StackMaps::ConstantOp>, <statepoint flags>,; /// <StackMaps::ConstantOp>, <num deopt args>, [deopt args...],; /// <StackMaps::ConstantOp>, <num gc pointer args>, [gc pointer args...],; /// <StackMaps::ConstantOp>, <num gc allocas>, [gc allocas args...],; /// <StackMaps::ConstantOp>, <num entries in gc map>, [base/derived pairs]; /// base/derived pairs in gc map are logical indices into <gc pointer args>; /// section.; /// All gc pointers assigned to VRegs produce new value (in form of MI Def; /// operand) and are tied to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:598,Testability,log,logical,598,"/// MI-level Statepoint operands; ///; /// Statepoint operands take the form:; /// <id>, <num patch bytes >, <num call arguments>, <call target>,; /// [call arguments...],; /// <StackMaps::ConstantOp>, <calling convention>,; /// <StackMaps::ConstantOp>, <statepoint flags>,; /// <StackMaps::ConstantOp>, <num deopt args>, [deopt args...],; /// <StackMaps::ConstantOp>, <num gc pointer args>, [gc pointer args...],; /// <StackMaps::ConstantOp>, <num gc allocas>, [gc allocas args...],; /// <StackMaps::ConstantOp>, <num entries in gc map>, [base/derived pairs]; /// base/derived pairs in gc map are logical indices into <gc pointer args>; /// section.; /// All gc pointers assigned to VRegs produce new value (in form of MI Def; /// operand) and are tied to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:21,Deployability,Patch,Patch,21,/// Get index of Num Patch Bytes operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:25,Deployability,patch,patchable,25,/// Return the number of patchable bytes the given statepoint should emit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:110,Testability,log,logical,110,/// Get vector of base/derived pairs from statepoint.; /// Elements are indices into GC Pointer operand list (logical).; /// Returns number of elements in GCMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:62,Testability,log,logical,62,// OpTypes are used to encode information about the following logical; // operand (which may consist of several MachineOperands) for the; // OpParser.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:102,Deployability,PATCH,PATCHPOINT,102,"/// Generate a stackmap record for a stackmap instruction.; ///; /// MI must be a raw STACKMAP, not a PATCHPOINT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:37,Deployability,patch,patchpoint,37,/// Generate a stackmap record for a patchpoint instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:109,Usability,clear,clears,109,"/// If there is any stack map data, create a stack map section and serialize; /// the map info into it. This clears the stack map data structures; /// afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:32,Availability,mask,mask,32,/// Parse the register live-out mask and return a vector of live-out; /// registers that need to be recorded in the stackmap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:239,Deployability,PATCH,PATCHPOINT,239,"/// Record the locations of the operands of the provided instruction in a; /// record keyed by the provided label. For instructions w/AnyReg calling; /// convention the return register is also recorded if requested. For; /// STACKMAP, and PATCHPOINT the label is expected to immediately *preceed*; /// lowering of the MI to MCInsts. For STATEPOINT, it expected to; /// immediately *follow*. It's not clear this difference was intentional,; /// but it exists today. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:400,Usability,clear,clear,400,"/// Record the locations of the operands of the provided instruction in a; /// record keyed by the provided label. For instructions w/AnyReg calling; /// convention the return register is also recorded if requested. For; /// STACKMAP, and PATCHPOINT the label is expected to immediately *preceed*; /// lowering of the MI to MCInsts. For STATEPOINT, it expected to; /// immediately *follow*. It's not clear this difference was intentional,; /// but it exists today. ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h:45,Deployability,patch,patchpoint,45,/// Emit the callsite info for each stackmap/patchpoint intrinsic call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h:551,Energy Efficiency,allocate,allocated,551,"//===- StackProtector.h - Stack Protector Insertion -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h:452,Modifiability,variab,variable,452,"//===- StackProtector.h - Stack Protector Insertion -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h:533,Modifiability,variab,variables,533,"//===- StackProtector.h - Stack Protector Insertion -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h:690,Safety,abort,aborts,690,"//===- StackProtector.h - Stack Protector Insertion -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts stack protectors into functions which need them. A variable; // with a random value in it is stored onto the stack before the local variables; // are allocated. Upon exiting the block, the stored value is checked. If it's; // changed, then there was some sort of violation and the program aborts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h:101,Deployability,update,update,101,/// Layout - Mapping of allocations to the required SSPLayoutKind.; /// StackProtector analysis will update this map when determining if an; /// AllocaInst triggers a stack protector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/StackProtector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h:26,Energy Efficiency,reduce,reduce,26,// Some useful objects to reduce the number of function arguments needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h:21,Security,expose,exposed,21,/// A list of upward exposed vreg uses that need to be satisfied by either a; /// copy def or a phi node at the beginning of the basic block representing; /// the predecessor(s) swifterror value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwiftErrorValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h:40,Testability,test,test,40,/// A cluster of cases suitable for bit test lowering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h:17,Integrability,interface,interface,17,// For the GISel interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h:16,Testability,test,test,16,/// Build a bit test cluster from Clusters[First..Last]. Returns false if it; /// decides it's not a good idea.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SwitchLoweringUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h:21,Performance,perform,perform,21,/// Utility class to perform tail duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h:44,Deployability,update,update,44,// A list of virtual registers for which to update SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h:137,Deployability,update,updated,137,"/// Tail duplicate a single basic block into its predecessors, and then clean; /// up.; /// If \p DuplicatePreds is not null, it will be updated to contain the list; /// of predecessors that received a copy of \p MBB.; /// If \p RemovalCallback is non-null. It will be called before MBB is; /// deleted.; /// If \p CandidatePtr is not null, duplicate into these blocks only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h:10,Modifiability,extend,extended,10,///< Zero extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h:10,Modifiability,extend,extended,10,///< Sign extended,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h:11,Availability,error,error,11,///< Swift error parameter,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h:5,Testability,Log,Log,5,///< Log 2 of alignment when arg is passed in memory; ///< (including byval/byref). The max alignment is; ///< verified in IR verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h:5,Testability,Log,Log,5,///< Log 2 of original alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetCallingConv.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:383,Integrability,Interface,Interface,383,"//===-- llvm/CodeGen/TargetFrameLowering.h ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Interface to describe the layout of a stack frame on the target machine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:342,Modifiability,variab,variables,342,"/// Information about stack frame layout on the target. It holds the direction; /// of stack growth, the known stack alignment on entry to each function, and; /// the offset to the locals area.; ///; /// The offset to the local area is the offset from the stack pointer on; /// function entry to the first location where function data (local variables,; /// spill locations) can be stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:45,Safety,safe,safe,45,/// This method returns whether or not it is safe for an object with the; /// given stack id to be bundled into the local area.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:193,Energy Efficiency,allocate,allocated,193,"/// Control the placement of special register scavenging spill slots when; /// allocating a stack frame.; ///; /// If this returns true, the frame indexes used by the RegScavenger will be; /// allocated closest to the incoming stack pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:87,Testability,log,logic,87,"/// assignCalleeSavedSpillSlots - Allows target to override spill slot; /// assignment logic. If implemented, assignCalleeSavedSpillSlots() should; /// assign frame slots to all CSI entries and return true. If this method; /// returns false, spill slots will be assigned using generic implementation.; /// assignCalleeSavedSpillSlots() may add, delete or rearrange elements of; /// CSI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:60,Integrability,wrap,wrapping,60,/// Returns true if the target will correctly handle shrink wrapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:142,Energy Efficiency,reduce,reduce,142,/// Returns true if the stack slot holes in the fixed and callee-save stack; /// area should be used when allocating other stack locations to reduce stack; /// size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:35,Safety,safe,safely,35,/// Returns true if the target can safely skip saving callee-saved registers; /// for noreturn nounwind functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:25,Testability,stub,stub,25,/// Replace a StackProbe stub (if any) with the actual probe code inline,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:187,Performance,load,load,187,"/// restoreCalleeSavedRegisters - Issues instruction(s) to restore all callee; /// saved registers and returns true if it isn't possible / profitable to do; /// so by issuing a series of load instructions via loadRegToStackSlot().; /// If it returns true, and any of the registers in CSI is not restored,; /// it sets the corresponding Restored flag in CSI to false.; /// Returns false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:209,Performance,load,loadRegToStackSlot,209,"/// restoreCalleeSavedRegisters - Issues instruction(s) to restore all callee; /// saved registers and returns true if it isn't possible / profitable to do; /// so by issuing a series of load instructions via loadRegToStackSlot().; /// If it returns true, and any of the registers in CSI is not restored,; /// it sets the corresponding Restored flag in CSI to false.; /// Returns false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:163,Modifiability,variab,variable,163,/// hasFP - Return true if the specified function should have a dedicated; /// frame pointer register. For most targets this is true only if the function; /// has variable sized allocas or if frame pointer elimination is disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:62,Usability,simpl,simplify,62,"/// canSimplifyCallFramePseudos - When possible, it's best to simplify the; /// call frame pseudo ops before doing frame index elimination. This is; /// possible only when frame index references between the pseudos won't; /// need adjusting for the call frame adjustments. Normally, that's true; /// if the function has a reserved call frame or a frame pointer. Some; /// targets (Thumb2, for example) may have more complicated criteria,; /// however, and can override this behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:45,Performance,perform,perform,45,"// needsFrameIndexResolution - Do we need to perform FI resolution for; // this function. Normally, this is required only when the function; // has any stack objects. However, targets may want to override this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:10,Safety,safe,safe,10,// Always safe to dispatch to getFrameIndexReference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:446,Availability,avail,available,446,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.; /// This method should not be called by any passes outside of PEI, because; /// it may change state passed in by \p MF and \p RS. The preferred; /// interface outside PEI is getCalleeSaves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:607,Integrability,interface,interface,607,"/// This method determines which of the registers reported by; /// TargetRegisterInfo::getCalleeSavedRegs() should actually get saved.; /// The default implementation checks populates the \p SavedRegs bitset with; /// all registers which are modified in the function, targets may override; /// this function to save additional registers.; /// This method also sets up the register scavenger ensuring there is a free; /// register or a frameindex available.; /// This method should not be called by any passes outside of PEI, because; /// it may change state passed in by \p MF and \p RS. The preferred; /// interface outside PEI is getCalleeSaves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:190,Integrability,wrap,wrapping,190,"/// Check whether or not the given \p MBB can be used as a prologue; /// for the target.; /// The prologue will be inserted first in this basic block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:311,Integrability,wrap,wrapping,311,"/// Check whether or not the given \p MBB can be used as a prologue; /// for the target.; /// The prologue will be inserted first in this basic block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:206,Integrability,wrap,wrapping,206,"/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:327,Integrability,wrap,wrapping,327,"/// Check whether or not the given \p MBB can be used as a epilogue; /// for the target.; /// The epilogue will be inserted before the first terminator of that block.; /// This method is used by the shrink-wrapping pass to decide if; /// \p MBB will be correctly handled by the target.; /// As soon as the target enable shrink-wrapping without overriding; /// this method, we assume that each basic block is a valid; /// epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:29,Performance,scalab,scalable,29,/// Returns the StackID that scalable vectors should be associated with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:31,Safety,safe,safe,31,/// Check if given function is safe for not having callee saved registers.; /// This is used when interprocedural register allocation is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:106,Integrability,Interface,Interface,106,//---------------------------------------------------------------------------; ///; /// TargetInstrInfo - Interface to description of machine instruction set; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:146,Availability,avail,available,146,"/// Return true if the instruction is trivially rematerializable, meaning it; /// has no side effects and requires no operands that aren't always available.; /// This means the only allowed uses are constants and unallocatable physical; /// registers so that the instructions result is independent of the place; /// in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:405,Availability,avail,available,405,"/// For instructions with opcodes for which the M_REMATERIALIZABLE flag is; /// set, this hook lets the target specify whether the instruction is actually; /// trivially rematerializable, taking into consideration its operands. This; /// predicate must return false if the instruction has any side effects other; /// than producing a value, or if it requres any address registers that are; /// not always available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:406,Usability,simpl,simply,406,"/// This method commutes the operands of the given machine instruction MI.; /// The operands to be commuted are specified by their indices OpIdx1 and; /// OpIdx2.; ///; /// If a target has any instructions that are commutable but require; /// converting to different instructions or making non-trivial changes; /// to commute them, this method can be overloaded to do that.; /// The default implementation simply swaps the commutable operands.; ///; /// If NewMI is false, MI is modified in place and returned; otherwise, a; /// new machine instruction is created and returned.; ///; /// Do not call this method for a non-commutable instruction.; /// Even though the instruction is commutable, the method may still; /// fail to commute the operands, null pointer is returned in such cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:269,Availability,avail,available,269,"/// Return true if the instruction is a ""coalescable"" extension instruction.; /// That is, it's like a copy where it's legal for the source to overlap the; /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's; /// expected the pre-extension value is available as a subreg of the result; /// register. This also returns the sub-register index in SubIdx.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:58,Performance,load,load,58,"/// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:186,Performance,load,loaded,186,"/// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:313,Performance,load,loading,313,"/// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:84,Performance,load,loaded,84,/// Optional extension of isLoadFromStackSlot that returns the number of; /// bytes loaded from the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the load does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:185,Performance,load,loads,185,/// Optional extension of isLoadFromStackSlot that returns the number of; /// bytes loaded from the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the load does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:229,Performance,load,load,229,/// Optional extension of isLoadFromStackSlot that returns the number of; /// bytes loaded from the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the load does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:105,Availability,reliab,reliable,105,/// Check for post-frame ptr elimination stack locations as well.; /// This uses a heuristic so it isn't reliable for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:47,Performance,load,load,47,"/// If the specified machine instruction has a load from a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isLoadFromStackSlot, this returns true for; /// any instructions that loads from the stack. This is just a hint, as some; /// cases may be missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:123,Performance,load,loaded,123,"/// If the specified machine instruction has a load from a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isLoadFromStackSlot, this returns true for; /// any instructions that loads from the stack. This is just a hint, as some; /// cases may be missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:305,Performance,load,loads,305,"/// If the specified machine instruction has a load from a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isLoadFromStackSlot, this returns true for; /// any instructions that loads from the stack. This is just a hint, as some; /// cases may be missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:184,Performance,load,loaded,184,"/// If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:182,Performance,load,loads,182,/// Optional extension of isStoreToStackSlot that returns the number of; /// bytes stored to the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the store does.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:106,Availability,reliab,reliable,106,"/// Check for post-frame ptr elimination stack locations as well.; /// This uses a heuristic, so it isn't reliable for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:122,Performance,load,loaded,122,"/// If the specified machine instruction has a store to a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isStoreToStackSlot,; /// this returns true for any instructions that stores to the; /// stack. This is just a hint, as some cases may be missed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:189,Performance,tune,tuned,189,"/// Return true if the instruction is as cheap as a move instruction.; ///; /// Targets for different archs need to override this, and different; /// micro-architectures can also be finely tuned inside.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:137,Safety,safe,safe,137,/// Return true if the instruction should be sunk by MachineSink.; ///; /// MachineSink determines on its own whether the instruction is safe to sink;; /// this gives the target a hook to override the default behavior with regards; /// to which instructions should be sunk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:197,Modifiability,extend,extend,197,/// Return false if the instruction should not be hoisted by MachineLICM.; ///; /// MachineLICM determines on its own whether the instruction is safe to; /// hoist; this gives the target a hook to extend this assessment and prevent; /// an instruction being hoisted from a given loop for target specific; /// reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:145,Safety,safe,safe,145,/// Return false if the instruction should not be hoisted by MachineLICM.; ///; /// MachineLICM determines on its own whether the instruction is safe to; /// hoist; this gives the target a hook to extend this assessment and prevent; /// an instruction being hoisted from a given loop for target specific; /// reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:130,Deployability,update,update,130,/// Clones instruction or the whole instruction bundle \p Orig and; /// insert into \p MBB before \p InsertBefore. The target may update operands; /// that are required to be unique.; ///; /// \p Orig must not return true for MachineInstr::isNotDuplicable().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:628,Deployability,update,updated,628,"/// This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into one or more true; /// three-address instructions on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the last new instruction.; ///; /// If \p LIS is not nullptr, the LiveIntervals info should be updated for; /// replacing \p MI with new instructions, even though this function does not; /// remove MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:501,Performance,perform,performed,501,"/// This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into one or more true; /// three-address instructions on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the last new instruction.; ///; /// If \p LIS is not nullptr, the LiveIntervals info should be updated for; /// replacing \p MI with new instructions, even though this function does not; /// remove MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:25,Integrability,rout,routine,25,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.; /// If any of the INPUT values is set to the special value; /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable; /// operand, then returns its index in the corresponding argument.; /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method; /// looks for 2 commutable operands.; /// If INPUT values refer to some operands of MI, then the method simply; /// returns true if the corresponding operands are commutable and returns; /// false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:563,Usability,simpl,simply,563,"/// Returns true iff the routine could find two commutable operands in the; /// given machine instruction.; /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.; /// If any of the INPUT values is set to the special value; /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable; /// operand, then returns its index in the corresponding argument.; /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method; /// looks for 2 commutable operands.; /// If INPUT values refer to some operands of MI, then the method simply; /// returns true if the corresponding operands are commutable and returns; /// false otherwise.; ///; /// For example, calling this method this way:; /// unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;; /// findCommutedOpIndices(MI, Op1, Op2);; /// can be interpreted as a query asking to find an operand that would be; /// commutable with the operand#1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1294,Integrability,rout,routine,1294,"/// Analyze the branching code at the end of MBB, returning; /// true if it cannot be understood (e.g. it's a switch dispatch or isn't; /// implemented for a target). Upon success, this returns false and returns; /// with the following information in various cases:; ///; /// 1. If this block ends with no branches (it just falls through to its succ); /// just return false, leaving TBB/FBB null.; /// 2. If this block ends with only an unconditional branch, it sets TBB to be; /// the destination block.; /// 3. If this block ends with a conditional branch and it falls through to a; /// successor block, it sets TBB to be the branch destination block and a; /// list of operands that evaluate the condition. These operands can be; /// passed to other TargetInstrInfo methods to create new branches.; /// 4. If this block ends with a conditional branch followed by an; /// unconditional branch, it returns the 'true' destination in TBB, the; /// 'false' destination in FBB, and a list of operands that evaluate the; /// condition. These operands can be passed to other TargetInstrInfo; /// methods to create new branches.; ///; /// Note that removeBranch and insertBranch must be implemented to support; /// cases where this method returns success.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).; ///; /// The CFG information in MBB.Predecessors and MBB.Successors must be valid; /// before calling this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:164,Availability,failure,failure,164,"/// Analyze the branching code at the end of MBB and parse it into the; /// MachineBranchPredicate structure if possible. Returns false on success; /// and true on failure.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:217,Integrability,rout,routine,217,"/// Analyze the branching code at the end of MBB and parse it into the; /// MachineBranchPredicate structure if possible. Returns false on success; /// and true on failure.; ///; /// If AllowModify is true, then this routine is allowed to modify the basic; /// block (e.g. delete instructions after the unconditional branch).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:135,Deployability,pipeline,pipelined,135,/// Object returned by analyzeLoopForPipelining. Allows software pipelining; /// implementations to query attributes of the loop being pipelined and to; /// apply target-specific updates to the loop once pipelining is complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:179,Deployability,update,updates,179,/// Object returned by analyzeLoopForPipelining. Allows software pipelining; /// implementations to query attributes of the loop being pipelined and to; /// apply target-specific updates to the loop once pipelining is complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:55,Deployability,pipeline,pipelined,55,"/// Return true if the given instruction should not be pipelined and should; /// be ignored. An example could be a loop comparison, or induction variable; /// update with no users being pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:159,Deployability,update,update,159,"/// Return true if the given instruction should not be pipelined and should; /// be ignored. An example could be a loop comparison, or induction variable; /// update with no users being pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:186,Deployability,pipeline,pipelined,186,"/// Return true if the given instruction should not be pipelined and should; /// be ignored. An example could be a loop comparison, or induction variable; /// update with no users being pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:145,Modifiability,variab,variable,145,"/// Return true if the given instruction should not be pipelined and should; /// be ignored. An example could be a loop comparison, or induction variable; /// update with no users being pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:89,Deployability,pipeline,pipeline,89,/// Return true if the proposed schedule should used. Otherwise return; /// false to not pipeline the loop. This function should be used to ensure; /// that pipelined loops meet target-specific quality heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:157,Deployability,pipeline,pipelined,157,/// Return true if the proposed schedule should used. Otherwise return; /// false to not pipeline the loop. This function should be used to ensure; /// that pipelined loops meet target-specific quality heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:32,Energy Efficiency,schedul,schedule,32,/// Return true if the proposed schedule should used. Otherwise return; /// false to not pipeline the loop. This function should be used to ensure; /// that pipelined loops meet target-specific quality heuristics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:588,Deployability,pipeline,pipelined,588,"/// Create a condition to determine if the trip count of the loop is greater; /// than TC, where TC is always one more than for the previous prologue or; /// 0 if this is being called for the outermost prologue.; ///; /// If the trip count is statically known to be greater than TC, return; /// true. If the trip count is statically known to be not greater than TC,; /// return false. Otherwise return nullopt and fill out Cond with the test; /// condition.; ///; /// Note: This hook is guaranteed to be called from the innermost to the; /// outermost prologue of the loop being software pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:437,Testability,test,test,437,"/// Create a condition to determine if the trip count of the loop is greater; /// than TC, where TC is always one more than for the previous prologue or; /// 0 if this is being called for the outermost prologue.; ///; /// If the trip count is statically known to be greater than TC, return; /// true. If the trip count is statically known to be not greater than TC,; /// return false. Otherwise return nullopt and fill out Cond with the test; /// condition.; ///; /// Note: This hook is guaranteed to be called from the innermost to the; /// outermost prologue of the loop being software pipelined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:123,Deployability,Pipeline,PipelinerLoopInfo,123,"/// Analyze loop L, which must be a single-basic-block loop, and if the; /// conditions can be understood enough produce a PipelinerLoopInfo object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:163,Modifiability,variab,variable,163,"/// Analyze the loop code, return true if it cannot be understood. Upon; /// success, this function returns false and returns information about the; /// induction variable and compare instruction used at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:21,Energy Efficiency,reduce,reduce,21,/// Generate code to reduce the loop iteration by one and check if the loop; /// is finished. Return the value/register of the new loop count. We need; /// this function when peeling off one or more iterations of a loop. This; /// function assumes the nth iteration is peeled first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:95,Performance,latency,latency,95,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:316,Safety,predict,predicted,316,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:369,Safety,predict,predicted,369,"/// Second variant of isProfitableToIfCvt. This one; /// checks for the case where two basic blocks from true and false path; /// of a if-then-else (diamond) are predicated on mutually exclusive; /// predicates, where the probability of the true path being taken is given; /// by Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:343,Safety,predict,predicted,343,"/// Return true if it's profitable for if-converter to duplicate instructions; /// of specified accumulated instruction latencies in the specified MBB to; /// enable if-conversion.; /// The probability of the instructions being executed is given by; /// Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:197,Performance,latency,latency,197,"/// Return true if it is possible to insert a select; /// instruction that chooses between TrueReg and FalseReg based on the; /// condition code in Cond.; ///; /// When successful, also return the latency in cycles from TrueReg,; /// FalseReg, and Cond to the destination register. In most cases, a select; /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1; ///; /// Some x86 implementations have 2-cycle cmov instructions.; ///; /// @param MBB Block where select instruction would be inserted.; /// @param Cond Condition returned by analyzeBranch.; /// @param DstReg Virtual dest register that the result should write to.; /// @param TrueReg Virtual register to select when Cond is true.; /// @param FalseReg Virtual register to select when Cond is false.; /// @param CondCycles Latency from Cond+Branch to select output.; /// @param TrueCycles Latency from TrueReg to select output.; /// @param FalseCycles Latency from FalseReg to select output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:808,Performance,Latency,Latency,808,"/// Return true if it is possible to insert a select; /// instruction that chooses between TrueReg and FalseReg based on the; /// condition code in Cond.; ///; /// When successful, also return the latency in cycles from TrueReg,; /// FalseReg, and Cond to the destination register. In most cases, a select; /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1; ///; /// Some x86 implementations have 2-cycle cmov instructions.; ///; /// @param MBB Block where select instruction would be inserted.; /// @param Cond Condition returned by analyzeBranch.; /// @param DstReg Virtual dest register that the result should write to.; /// @param TrueReg Virtual register to select when Cond is true.; /// @param FalseReg Virtual register to select when Cond is false.; /// @param CondCycles Latency from Cond+Branch to select output.; /// @param TrueCycles Latency from TrueReg to select output.; /// @param FalseCycles Latency from FalseReg to select output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:874,Performance,Latency,Latency,874,"/// Return true if it is possible to insert a select; /// instruction that chooses between TrueReg and FalseReg based on the; /// condition code in Cond.; ///; /// When successful, also return the latency in cycles from TrueReg,; /// FalseReg, and Cond to the destination register. In most cases, a select; /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1; ///; /// Some x86 implementations have 2-cycle cmov instructions.; ///; /// @param MBB Block where select instruction would be inserted.; /// @param Cond Condition returned by analyzeBranch.; /// @param DstReg Virtual dest register that the result should write to.; /// @param TrueReg Virtual register to select when Cond is true.; /// @param FalseReg Virtual register to select when Cond is false.; /// @param CondCycles Latency from Cond+Branch to select output.; /// @param TrueCycles Latency from TrueReg to select output.; /// @param FalseCycles Latency from FalseReg to select output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:937,Performance,Latency,Latency,937,"/// Return true if it is possible to insert a select; /// instruction that chooses between TrueReg and FalseReg based on the; /// condition code in Cond.; ///; /// When successful, also return the latency in cycles from TrueReg,; /// FalseReg, and Cond to the destination register. In most cases, a select; /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1; ///; /// Some x86 implementations have 2-cycle cmov instructions.; ///; /// @param MBB Block where select instruction would be inserted.; /// @param Cond Condition returned by analyzeBranch.; /// @param DstReg Virtual dest register that the result should write to.; /// @param TrueReg Virtual register to select when Cond is true.; /// @param FalseReg Virtual register to select when Cond is false.; /// @param CondCycles Latency from Cond+Branch to select output.; /// @param TrueCycles Latency from TrueReg to select output.; /// @param FalseCycles Latency from FalseReg to select output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:366,Availability,avail,available,366,"/// Insert a select instruction into MBB before I that will copy TrueReg to; /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.; ///; /// This function can only be called after canInsertSelect() returned true.; /// The condition in Cond comes from analyzeBranch, and it can be assumed; /// that the same flags or registers required by Cond are available at the; /// insertion point.; ///; /// @param MBB Block where select instruction should be inserted.; /// @param I Insertion point.; /// @param DL Source location for debugging.; /// @param DstReg Virtual register to be defined by select instruction.; /// @param Cond Condition as computed by analyzeBranch.; /// @param TrueReg Virtual register to copy when Cond is true.; /// @param FalseReg Virtual register to copy when Cons is false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:339,Performance,optimiz,optimize,339,"/// Analyze the given select instruction, returning true if; /// it cannot be understood. It is assumed that MI->isSelect() is true.; ///; /// When successful, return the controlling condition and the operands that; /// determine the true and false result values.; ///; /// Result = SELECT Cond, TrueOp, FalseOp; ///; /// Some targets can optimize select instructions, for example by predicating; /// the instruction defining one of the operands. Such targets should set; /// Optimizable.; ///; /// @param MI Select instruction to analyze.; /// @param Cond Condition controlling the select.; /// @param TrueOp Operand number of the value selected when Cond is true.; /// @param FalseOp Operand number of the value selected when Cond is false.; /// @param Optimizable Returned as true if MI is optimizable.; /// @returns False on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:476,Performance,Optimiz,Optimizable,476,"/// Analyze the given select instruction, returning true if; /// it cannot be understood. It is assumed that MI->isSelect() is true.; ///; /// When successful, return the controlling condition and the operands that; /// determine the true and false result values.; ///; /// Result = SELECT Cond, TrueOp, FalseOp; ///; /// Some targets can optimize select instructions, for example by predicating; /// the instruction defining one of the operands. Such targets should set; /// Optimizable.; ///; /// @param MI Select instruction to analyze.; /// @param Cond Condition controlling the select.; /// @param TrueOp Operand number of the value selected when Cond is true.; /// @param FalseOp Operand number of the value selected when Cond is false.; /// @param Optimizable Returned as true if MI is optimizable.; /// @returns False on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:755,Performance,Optimiz,Optimizable,755,"/// Analyze the given select instruction, returning true if; /// it cannot be understood. It is assumed that MI->isSelect() is true.; ///; /// When successful, return the controlling condition and the operands that; /// determine the true and false result values.; ///; /// Result = SELECT Cond, TrueOp, FalseOp; ///; /// Some targets can optimize select instructions, for example by predicating; /// the instruction defining one of the operands. Such targets should set; /// Optimizable.; ///; /// @param MI Select instruction to analyze.; /// @param Cond Condition controlling the select.; /// @param TrueOp Operand number of the value selected when Cond is true.; /// @param FalseOp Operand number of the value selected when Cond is false.; /// @param Optimizable Returned as true if MI is optimizable.; /// @returns False on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:793,Performance,optimiz,optimizable,793,"/// Analyze the given select instruction, returning true if; /// it cannot be understood. It is assumed that MI->isSelect() is true.; ///; /// When successful, return the controlling condition and the operands that; /// determine the true and false result values.; ///; /// Result = SELECT Cond, TrueOp, FalseOp; ///; /// Some targets can optimize select instructions, for example by predicating; /// the instruction defining one of the operands. Such targets should set; /// Optimizable.; ///; /// @param MI Select instruction to analyze.; /// @param Cond Condition controlling the select.; /// @param TrueOp Operand number of the value selected when Cond is true.; /// @param FalseOp Operand number of the value selected when Cond is false.; /// @param Optimizable Returned as true if MI is optimizable.; /// @returns False on success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:190,Availability,failure,failure,190,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:549,Deployability,update,updated,549,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:86,Performance,Optimiz,Optimizable,86,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:117,Performance,optimiz,optimize,117,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:355,Performance,optimiz,optimized,355,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:427,Performance,Optimiz,Optimizable,427,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:631,Performance,optimiz,optimize,631,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:681,Performance,Optimiz,Optimized,681,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:40,Performance,Optimiz,Optimizable,40,// This function must be implemented if Optimizable is ever set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,/// Target-dependent implementation for IsCopyInstr.; /// If the specific machine instruction is a instruction that moves/copies; /// value from one register to another register return destination and source; /// registers as machine operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:360,Integrability,depend,dependent,360,"/// If the specific machine instruction is a instruction that moves/copies; /// value from one register to another register return destination and source; /// registers as machine operands.; /// For COPY-instruction the method naturally returns destination and source; /// registers as machine operands, for all other instructions the method calls; /// target-dependent implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Performance,Load,Load,4,"/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction. If \p; /// DestReg is being directly reloaded as part of assigning a virtual; /// register, \p VReg is the register being assigned. This additional register; /// argument is needed for certain targets when invoked from RegAllocFast to; /// map the loaded physical register to its virtual register. A null register; /// can be passed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:107,Performance,load,load,107,"/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction. If \p; /// DestReg is being directly reloaded as part of assigning a virtual; /// register, \p VReg is the register being assigned. This additional register; /// argument is needed for certain targets when invoked from RegAllocFast to; /// map the loaded physical register to its virtual register. A null register; /// can be passed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:467,Performance,load,loaded,467,"/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction. If \p; /// DestReg is being directly reloaded as part of assigning a virtual; /// register, \p VReg is the register being assigned. This additional register; /// argument is needed for certain targets when invoked from RegAllocFast to; /// map the loaded physical register to its virtual register. A null register; /// can be passed elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:40,Performance,load,load,40,"/// Check whether the target can fold a load that feeds a subreg operand; /// (or a subreg operand that feeds a store).; /// For example, X86 may want to return true if it can fold; /// movl (%esp), %eax; /// subb, %al, ...; /// Into:; /// subb (%esp), ...; ///; /// Ideally, we'd like the target implementation of foldMemoryOperand() to; /// reject subregs - but since this behavior used to be enforced in the; /// target-independent code, moving this responsibility to the targets; /// has the potential of causing nasty silent breakage in out-of-tree targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:10,Deployability,patch,patchpoint,10,"/// For a patchpoint, stackmap, or statepoint intrinsic, return the range of; /// operands which can't be folded into stack references. Operands outside; /// of the range are most likely foldable but it is not guaranteed.; /// These instructions are unique in that stack references for some operands; /// have the same execution cost (e.g. none) as the unfolded register forms.; /// The ranged return is guaranteed to include all operands which can't be; /// folded at zero cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:22,Performance,load,load,22,"/// Attempt to fold a load or store of the specified stack; /// slot into the specified machine instruction for the specified operand(s).; /// If this is possible, a new instruction is returned with the specified; /// operand folded, otherwise NULL is returned.; /// The new instruction is inserted before MI, and the client is responsible; /// for removing the old instruction.; /// If VRM is passed, the assigned physregs can be inspected by target to; /// decide on using an opcode (note that those assignments can still change).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:65,Performance,load,load,65,"/// Same as the previous version except it allows folding of any load and; /// store from / to any address, not just from a specific stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:30,Testability,log,logic,30,/// This function defines the logic to lower COPY instruction to; /// target specific instruction(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:98,Energy Efficiency,reduce,reduce,98,/// Return true if target supports reassociation of instructions in machine; /// combiner pass to reduce register pressure for a given BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:49,Performance,throughput,throughput,49,/// Return true when a code sequence can improve throughput. It; /// should be called only for instructions in loops.; /// \param Pattern - combiner pattern,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:59,Integrability,depend,dependent,59,"/// Return true if the input \P Inst is part of a chain of dependent ops; /// that are suitable for reassociation, otherwise return false.; /// If the instruction's operands must be commuted to have a previous; /// instruction of the same type define the first source operand, \P Commuted; /// will be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:139,Testability,test,tested,139,"/// Return true when \P Inst is both associative and commutative. If \P Invert; /// is true, then the inverse of \P Inst operation must be tested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:23,Performance,latency,latency,23,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:76,Performance,latency,latency,76,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:112,Performance,latency,latency,112,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:79,Energy Efficiency,reduce,reduce,79,/// Attempt to reassociate \P Root and \P Prev according to \P Pattern to; /// reduce critical path length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:57,Energy Efficiency,schedul,scheduling,57,/// Return true if the given SDNode can be copied during scheduling; /// even if it has glue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,/// Target-dependent implementation for foldMemoryOperand.; /// Target-independent code in foldMemoryOperand will; /// take care of adding a MachineMemOperand to the newly created instruction.; /// The instruction and any auxiliary instructions necessary will be inserted; /// at InsertPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,/// Target-dependent implementation for foldMemoryOperand.; /// Target-independent code in foldMemoryOperand will; /// take care of adding a MachineMemOperand to the newly created instruction.; /// The instruction and any auxiliary instructions necessary will be inserted; /// at InsertPt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,"/// Target-dependent implementation of getRegSequenceInputs.; ///; /// \returns true if it is possible to build the equivalent; /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.; ///; /// \pre MI.isRegSequenceLike().; ///; /// \see TargetInstrInfo::getRegSequenceInputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,"/// Target-dependent implementation of getExtractSubregInputs.; ///; /// \returns true if it is possible to build the equivalent; /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.; ///; /// \pre MI.isExtractSubregLike().; ///; /// \see TargetInstrInfo::getExtractSubregInputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,"/// Target-dependent implementation of getInsertSubregInputs.; ///; /// \returns true if it is possible to build the equivalent; /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.; ///; /// \pre MI.isInsertSubregLike().; ///; /// \see TargetInstrInfo::getInsertSubregInputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:71,Performance,load,load,71,"/// unfoldMemoryOperand - Separate a single instruction which folded a load or; /// a store or a load and a store into two or more instruction. If this is; /// possible, returns true as well as the new instructions by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:97,Performance,load,load,97,"/// unfoldMemoryOperand - Separate a single instruction which folded a load or; /// a store or a load and a store into two or more instruction. If this is; /// possible, returns true as well as the new instructions by reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:66,Performance,load,load,66,"/// Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:210,Performance,Load,LoadRegIndex,210,"/// Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:336,Performance,load,loaded,336,"/// Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:37,Energy Efficiency,schedul,scheduler,37,/// This is used by the pre-regalloc scheduler to determine if two loads are; /// loading from the same base address. It should only return true if the base; /// pointers are the same and the only differences between the two addresses; /// are the offset. It also returns the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:67,Performance,load,loads,67,/// This is used by the pre-regalloc scheduler to determine if two loads are; /// loading from the same base address. It should only return true if the base; /// pointers are the same and the only differences between the two addresses; /// are the offset. It also returns the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:82,Performance,load,loading,82,/// This is used by the pre-regalloc scheduler to determine if two loads are; /// loading from the same base address. It should only return true if the base; /// pointers are the same and the only differences between the two addresses; /// are the offset. It also returns the offsets by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:39,Energy Efficiency,schedul,scheduler,39,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:136,Energy Efficiency,schedul,scheduled,136,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:270,Energy Efficiency,schedul,scheduled,270,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:448,Energy Efficiency,schedul,schedule,448,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:543,Energy Efficiency,schedul,scheduled,543,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:120,Performance,load,loads,120,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:184,Performance,load,loads,184,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:194,Performance,load,loading,194,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:234,Performance,cache,cache,234,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:347,Performance,load,load,347,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:465,Performance,load,loads,465,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:509,Performance,load,loads,509,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:170,Security,access,accesses,170,/// Get zero or more base operands and the byte offset of an instruction that; /// reads/writes memory. Note that there may be zero base operands if the; /// instruction accesses a constant address.; /// It returns false if MI does not read/write memory.; /// It returns false if base operands and offset could not be determined.; /// It is not guaranteed to always recognize base operands and offsets in all; /// cases.; /// FIXME: Move Offset and OffsetIsScalable to some ElementCount-style; /// abstraction that supports negative offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,/// Target dependent implementation to get the values constituting the address; /// MachineInstr that is accessing memory. These values are returned as a; /// struct ExtAddrMode which contains all relevant information to make up the; /// address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:105,Security,access,accessing,105,/// Target dependent implementation to get the values constituting the address; /// MachineInstr that is accessing memory. These values are returned as a; /// struct ExtAddrMode which contains all relevant information to make up the; /// address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:122,Performance,load,load,122,"/// Check if it's possible and beneficial to fold the addressing computation; /// `AddrI` into the addressing mode of the load/store instruction `MemI`. The; /// memory instruction is a user of the virtual register `Reg`, which in turn; /// is the ultimate destination of zero or more COPY instructions from the; /// output register of `AddrI`.; /// Return the adddressing mode after folding in `AM`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Performance,load,load,11,"/// Emit a load/store instruction with the same value register as `MemI`, but; /// using the address from `AM`. The addressing mode must have been obtained; /// from `canFoldIntoAddr` for the same memory instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:62,Energy Efficiency,schedul,scheduled,62,"/// Returns true if the two given memory operations should be scheduled; /// adjacent. Note that you have to add:; /// DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));; /// or; /// DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));; /// to TargetPassConfig::createMachineScheduler() to have an effect.; ///; /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.; /// \p Offset1 and \p Offset2 are the byte offsets for the memory; /// operations.; /// \p OffsetIsScalable1 and \p OffsetIsScalable2 indicate if the offset is; /// scaled by a runtime quantity.; /// \p ClusterSize is the number of operations in the resulting load/store; /// cluster if this hook returns true.; /// \p NumBytes is the number of bytes that will be loaded from all the; /// clustered loads if this hook returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:684,Performance,load,load,684,"/// Returns true if the two given memory operations should be scheduled; /// adjacent. Note that you have to add:; /// DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));; /// or; /// DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));; /// to TargetPassConfig::createMachineScheduler() to have an effect.; ///; /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.; /// \p Offset1 and \p Offset2 are the byte offsets for the memory; /// operations.; /// \p OffsetIsScalable1 and \p OffsetIsScalable2 indicate if the offset is; /// scaled by a runtime quantity.; /// \p ClusterSize is the number of operations in the resulting load/store; /// cluster if this hook returns true.; /// \p NumBytes is the number of bytes that will be loaded from all the; /// clustered loads if this hook returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:788,Performance,load,loaded,788,"/// Returns true if the two given memory operations should be scheduled; /// adjacent. Note that you have to add:; /// DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));; /// or; /// DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));; /// to TargetPassConfig::createMachineScheduler() to have an effect.; ///; /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.; /// \p Offset1 and \p Offset2 are the byte offsets for the memory; /// operations.; /// \p OffsetIsScalable1 and \p OffsetIsScalable2 indicate if the offset is; /// scaled by a runtime quantity.; /// \p ClusterSize is the number of operations in the resulting load/store; /// cluster if this hook returns true.; /// \p NumBytes is the number of bytes that will be loaded from all the; /// clustered loads if this hook returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:823,Performance,load,loads,823,"/// Returns true if the two given memory operations should be scheduled; /// adjacent. Note that you have to add:; /// DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));; /// or; /// DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));; /// to TargetPassConfig::createMachineScheduler() to have an effect.; ///; /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.; /// \p Offset1 and \p Offset2 are the byte offsets for the memory; /// operations.; /// \p OffsetIsScalable1 and \p OffsetIsScalable2 indicate if the offset is; /// scaled by a runtime quantity.; /// \p ClusterSize is the number of operations in the resulting load/store; /// cluster if this hook returns true.; /// \p NumBytes is the number of bytes that will be loaded from all the; /// clustered loads if this hook returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:24,Safety,safe,safe,24,/// Return true if it's safe to move a machine; /// instruction that defines the specified register class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:57,Energy Efficiency,schedul,scheduling,57,/// Test if the given instruction should be considered a scheduling boundary.; /// This primarily includes labels and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Testability,Test,Test,4,/// Test if the given instruction should be considered a scheduling boundary.; /// This primarily includes labels and terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:77,Energy Efficiency,schedul,scheduling,77,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,Safety,hazard,hazard,26,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:77,Energy Efficiency,schedul,scheduling,77,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,Safety,hazard,hazard,26,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:77,Energy Efficiency,schedul,scheduling,77,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,Safety,hazard,hazard,26,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and return a hazard recognizer to use for by non-scheduling; /// passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:62,Energy Efficiency,schedul,scheduling,62,/// Allocate and return a hazard recognizer to use for by non-scheduling; /// passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,Safety,hazard,hazard,26,/// Allocate and return a hazard recognizer to use for by non-scheduling; /// passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:50,Safety,hazard,hazard,50,/// Provide a global flag for disabling the PreRA hazard recognizer that; /// targets may choose to honor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:80,Energy Efficiency,efficient,efficient,80,"/// See if the comparison instruction can be converted; /// into something more efficient. E.g., on ARM most instructions can set the; /// flags register, obviating the need for a separate CMP.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:22,Performance,load,load,22,"/// Try to remove the load by folding it to a register operand at the use.; /// We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:92,Performance,load,load,92,"/// Try to remove the load by folding it to a register operand at the use.; /// We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:186,Performance,load,load,186,"/// Try to remove the load by folding it to a register operand at the use.; /// We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:299,Performance,load,load,299,"/// Try to remove the load by folding it to a register operand at the use.; /// We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:146,Energy Efficiency,schedul,scheduler,146,"/// Return true for pseudo instructions that don't consume any; /// machine resources in their current form. These are common cases that the; /// scheduler should consider free, rather than conservatively handling them; /// as instructions with no itinerary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:110,Energy Efficiency,schedul,scheduling,110,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:291,Integrability,interface,interface,291,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:230,Modifiability,variab,variable,230,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:39,Performance,latency,latency,39,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:172,Performance,latency,latency,172,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:427,Performance,latency,latency,427,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:28,Performance,latency,latency,28,"/// Compute the instruction latency of a given instruction.; /// If the instruction has higher cost when predicated, it's returned via; /// PredCost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:32,Performance,latency,latency,32,/// Return the default expected latency for a def based on its opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:40,Performance,latency,latency,40,/// Return true if this opcode has high latency to its result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:20,Performance,latency,latency,20,/// Compute operand latency between a def of 'Reg'; /// and a use in the current loop. Return true if the target considered; /// it 'high'. This is used by optimization passes such as machine LICM to; /// determine whether it makes sense to hoist an instruction out even in a; /// high register pressure situation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:156,Performance,optimiz,optimization,156,/// Compute operand latency between a def of 'Reg'; /// and a use in the current loop. Return true if the target considered; /// it 'high'. This is used by optimization passes such as machine LICM to; /// determine whether it makes sense to hoist an instruction out even in a; /// high register pressure situation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:20,Performance,latency,latency,20,/// Compute operand latency of a def of 'Reg'. Return true; /// if the target considered it 'low'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Performance,Perform,Perform,4,/// Perform target-specific instruction verification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:48,Availability,mask,mask,48,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:501,Availability,mask,mask,501,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:561,Availability,mask,mask,561,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:695,Availability,mask,mask,695,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:777,Availability,mask,mask,777,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:194,Performance,perform,perform,194,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:372,Performance,latency,latency,372,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:101,Availability,mask,mask,101,/// Change the opcode of MI to execute in Domain.; ///; /// The bit (1 << Domain) must be set in the mask returned from; /// getExecutionDomain(MI).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:614,Availability,avail,available,614,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:105,Deployability,update,update,105,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1129,Integrability,depend,dependencies,1129,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1253,Integrability,depend,dependency,1253,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1319,Integrability,depend,dependency,1319,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1443,Integrability,depend,dependency,1443,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1478,Integrability,depend,dependency,1478,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1705,Integrability,depend,dependency,1705,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1021,Safety,avoid,avoided,1021,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:34,Usability,clear,clearance,34,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:932,Usability,clear,clearance,932,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:64,Integrability,depend,dependency,64,// The default implementation returns 0 for no partial register dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:369,Integrability,depend,dependence,369,"/// Return the minimum clearance before an instruction that reads an; /// unused register.; ///; /// For example, AVX instructions may copy part of a register operand into; /// the unused high bits of the destination register.; ///; /// vcvtsi2sdq %rax, undef %xmm0, %xmm14; ///; /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a; /// false dependence on any previous write to %xmm0.; ///; /// This hook works similarly to getPartialRegUpdateClearance, except that it; /// does not take an operand index. Instead sets \p OpNum to the index of the; /// unused register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:23,Usability,clear,clearance,23,"/// Return the minimum clearance before an instruction that reads an; /// unused register.; ///; /// For example, AVX instructions may copy part of a register operand into; /// the unused high bits of the destination register.; ///; /// vcvtsi2sdq %rax, undef %xmm0, %xmm14; ///; /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a; /// false dependence on any previous write to %xmm0.; ///; /// This hook works similarly to getPartialRegUpdateClearance, except that it; /// does not take an operand index. Instead sets \p OpNum to the index of the; /// unused register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:62,Integrability,depend,dependency,62,// The default implementation returns 0 for no undef register dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:618,Energy Efficiency,schedul,scheduler,618,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:13,Integrability,depend,dependency-breaking,13,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:85,Integrability,depend,dependency,85,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:283,Integrability,depend,dependency,283,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:351,Integrability,depend,dependency,351,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:141,Safety,avoid,avoid,141,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:38,Energy Efficiency,schedul,scheduling,38,/// Create machine specific model for scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:413,Energy Efficiency,schedul,scheduling,413,"/// Sometimes, it is possible for the target; /// to tell, even without aliasing information, that two MIs access different; /// memory addresses. This function returns true if two MIs access different; /// memory addresses and false otherwise.; ///; /// Assumes any physical registers used to compute addresses have the same; /// value for both instructions. (This is the most useful assumption for; /// post-RA scheduling.); ///; /// See also MachineInstr::mayAlias, which is implemented on top of this; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:107,Security,access,access,107,"/// Sometimes, it is possible for the target; /// to tell, even without aliasing information, that two MIs access different; /// memory addresses. This function returns true if two MIs access different; /// memory addresses and false otherwise.; ///; /// Assumes any physical registers used to compute addresses have the same; /// value for both instructions. (This is the most useful assumption for; /// post-RA scheduling.); ///; /// See also MachineInstr::mayAlias, which is implemented on top of this; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:185,Security,access,access,185,"/// Sometimes, it is possible for the target; /// to tell, even without aliasing information, that two MIs access different; /// memory addresses. This function returns true if two MIs access different; /// memory addresses and false otherwise.; ///; /// Assumes any physical registers used to compute addresses have the same; /// value for both instructions. (This is the most useful assumption for; /// post-RA scheduling.); ///; /// See also MachineInstr::mayAlias, which is implemented on top of this; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:231,Performance,perform,performance,231,"/// Return the maximal number of alias checks on memory operands. For; /// instructions with more than one memory operands, the alias check on a; /// single MachineInstr pair has quadratic overhead and results in; /// unacceptable performance in the worst case. The limit here is to clamp; /// that maximal checks performed. Usually, that's the product of memory; /// operand numbers from that pair of MachineInstr to be checked. For; /// instance, with two MachineInstrs with 4 and 5 memory operands; /// correspondingly, a total of 20 checks are required. With this limit set to; /// 16, their alias check is skipped. We choose to limit the product instead; /// of the individual instruction as targets may have special MachineInstrs; /// with a considerably high number of memory operands, such as `ldm` in ARM.; /// Setting this limit per MachineInstr would result in either too high; /// overhead or too rigid restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:314,Performance,perform,performed,314,"/// Return the maximal number of alias checks on memory operands. For; /// instructions with more than one memory operands, the alias check on a; /// single MachineInstr pair has quadratic overhead and results in; /// unacceptable performance in the worst case. The limit here is to clamp; /// that maximal checks performed. Usually, that's the product of memory; /// operand numbers from that pair of MachineInstr to be checked. For; /// instance, with two MachineInstrs with 4 and 5 memory operands; /// correspondingly, a total of 20 checks are required. With this limit set to; /// 16, their alias check is skipped. We choose to limit the product instead; /// of the individual instruction as targets may have special MachineInstrs; /// with a considerably high number of memory operands, such as `ldm` in ARM.; /// Setting this limit per MachineInstr would result in either too high; /// overhead or too rigid restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,Integrability,depend,dependent,11,/// Target-dependent implementation for getOutliningTypeImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:56,Safety,safe,safe,56,"/// Optional target hook that returns true if \p MBB is safe to outline from,; /// and returns any target-specific information in \p Flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:218,Availability,down,down,218,"/// Optional target hook which partitions \p MBB into outlinable ranges for; /// instruction mapping purposes. Each range is defined by two iterators:; /// [start, end).; ///; /// Ranges are expected to be ordered top-down. That is, ranges closer to the; /// top of the block should come before ranges closer to the end of the block.; ///; /// Ranges cannot overlap.; ///; /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end()); ///; /// All instructions not present in an outlinable range are considered; /// illegal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:89,Safety,avoid,avoid,89,"/// Insert an architecture-specific instruction to clear a register. If you; /// need to avoid sideeffects (e.g. avoid XOR on x86, which sets EFLAGS), set; /// \p AllowSideEffects to \p false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:113,Safety,avoid,avoid,113,"/// Insert an architecture-specific instruction to clear a register. If you; /// need to avoid sideeffects (e.g. avoid XOR on x86, which sets EFLAGS), set; /// \p AllowSideEffects to \p false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:51,Usability,clear,clear,51,"/// Insert an architecture-specific instruction to clear a register. If you; /// need to avoid sideeffects (e.g. avoid XOR on x86, which sets EFLAGS), set; /// \p AllowSideEffects to \p false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:36,Safety,safe,safely,36,/// Return true if the function can safely be outlined from.; /// A function \p MF is considered safe for outlining if an outlined function; /// produced from instructions in F will produce a program which produces the; /// same output for any set of given inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:97,Safety,safe,safe,97,/// Return true if the function can safely be outlined from.; /// A function \p MF is considered safe for outlining if an outlined function; /// produced from instructions in F will produce a program which produces the; /// same output for any set of given inputs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:45,Safety,safe,safely,45,"/// Return true if the MachineBasicBlock can safely be split to the cold; /// section. On AArch64, certain instructions may cause a block to be unsafe; /// to split to the cold section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:144,Safety,unsafe,unsafe,144,"/// Return true if the MachineBasicBlock can safely be split to the cold; /// section. On AArch64, certain instructions may cause a block to be unsafe; /// to split to the cold section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:48,Performance,load,loading,48,/// Produce the expression describing the \p MI loading a value into; /// the physical register \p Reg. This hook should only be used with; /// \p MIs belonging to VReg-less functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling for lowest register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling for both latency and register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:23,Performance,latency,latency,23,// Scheduling for both latency and register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling for ILP in low register pressure mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Energy Efficiency,Schedul,Scheduling,3,// Scheduling for VLIW targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:24,Energy Efficiency,schedul,scheduling,24,// Fast suboptimal list scheduling,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,Energy Efficiency,schedul,scheduling,21,"// Linearize DAG, no scheduling",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:10,Usability,clear,clears,10,// If set clears out memory with zeros.; // memcpy only,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:96,Performance,load,loaded,96,// Indicates whether the memcpy source is an in-register; // constant so it does not need to be loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Performance,load,load,98,// Inferred alignment of the source or default value if the; // memory operation does not need to load the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:118,Performance,scalab,scalable,118,"// This action is explicitly left unimplemented.; // While it is theoretically possible to; // legalize operations on scalable types with a; // loop that handles the vscale * #lanes of the; // vector, this is non-trivial at SelectionDAG; // level and these types are better to be; // widened or promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:56,Availability,mask,mask,56,// The target supports vector selects with a vector; // mask (ex: x86 blends).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:39,Performance,load,load,39,"/// Enum that specifies what an atomic load/AtomicRMWInst is expanded; /// to, if at all. Exists because different targets have different levels of; /// support for these atomic instructions, and also have different options; /// w.r.t. what they should expand to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:31,Performance,load,loadlinked,31,// Expand the instruction into loadlinked/storeconditional; used; // by ARM/AArch64.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:15,Performance,load,load,15,"// Expand the (load) instruction into just a load-linked, which has; // greater atomic guarantees than a normal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Performance,load,load-linked,45,"// Expand the (load) instruction into just a load-linked, which has; // greater atomic guarantees than a normal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:112,Performance,load,load,112,"// Expand the (load) instruction into just a load-linked, which has; // greater atomic guarantees than a normal load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:62,Modifiability,Rewrite,Rewrite,62,// Generic expansion in terms of other atomic operations.; // Rewrite to a non-atomic form for use in a known non-preemptible; // environment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Modifiability,Extend,Extend,3,// Extend by adding rubbish bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Modifiability,Extend,Extend,3,// Extend by adding zero bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:3,Modifiability,Extend,Extend,3,// Extend by copying the sign bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:178,Deployability,update,updated,178,"/// Return the pointer type for the given address space, defaults to; /// the pointer type from the data layout.; /// FIXME: The default needs to be removed once all the code is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:188,Deployability,update,updated,188,"/// Return the in-memory pointer type for the given address space, defaults to; /// the pointer type from the data layout.; /// FIXME: The default needs to be removed once all the code is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:125,Integrability,depend,depends,125,"/// Returns the type for the shift amount of a shift opcode. For vectors,; /// returns the input type. For scalars, behavior depends on \p LegalTypes. If; /// \p LegalTypes is true, calls getScalarShiftAmountTy, otherwise uses; /// pointer type. If getScalarShiftAmountTy or pointer type cannot represent; /// all possible shift amounts, returns MVT::i32. In general, \p LegalTypes; /// should be set to true for calls during type legalization and after type; /// legalization has been completed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:215,Modifiability,extend,extended,215,"/// Returns the type to be used for the EVL/AVL operand of VP nodes:; /// ISD::VP_ADD, ISD::VP_SUB, etc. It must be a legal scalar integer type,; /// and must be at least as large as i32. The EVL is implicitly zero-extended; /// to any larger type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,Performance,load,load,37,/// This callback is used to inspect load/store instructions and add; /// target-specific MachineMemOperand flags to them. The default; /// implementation does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,Performance,load,load,37,/// This callback is used to inspect load/store SDNode.; /// The default implementation does nothing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Availability,mask,mask,45,/// Return true if the @llvm.get.active.lane.mask intrinsic should be expanded; /// using generic code in SelectionDAGBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:117,Integrability,depend,depends,117,/// Return true if it is profitable to convert a select of FP constants into; /// a constant pool load whose address depends on the select condition. The; /// parameter may be used to differentiate a select with FP compare from; /// integer compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Performance,load,load,98,/// Return true if it is profitable to convert a select of FP constants into; /// a constant pool load whose address depends on the select condition. The; /// parameter may be used to differentiate a select with FP compare from; /// integer compare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:52,Availability,avail,available,52,/// Return true if multiple condition registers are available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:180,Performance,load,loads,180,"// Return true if the half type should be passed around as i16, but promoted; // to float around arithmetic. The default behavior is to pass around as; // float and convert around loads/stores/bitcasts and other places where; // the size matters.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:207,Performance,load,load,207,"// There are two general methods for expanding a BUILD_VECTOR node:; // 1. Use SCALAR_TO_VECTOR on the defined scalar values and then shuffle; // them together.; // 2. Build the vector on the stack and then load it.; // If this function returns true, then method (1) will be used, subject to; // the constraint that all of the necessary shuffles are legal (as determined; // by isShuffleMaskLegal). If this function returns false, then method (2) is; // always used. The vector type, and the number of defined values, are; // provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:168,Integrability,depend,depend,168,"/// Return true if integer divide is usually cheaper than a sequence of; /// several shifts, adds, and multiplies for this target.; /// The definition of ""cheaper"" may depend on whether we're optimizing; /// for speed or for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:192,Performance,optimiz,optimizing,192,"/// Return true if integer divide is usually cheaper than a sequence of; /// several shifts, adds, and multiplies for this target.; /// The definition of ""cheaper"" may depend on whether we're optimizing; /// for speed or for size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Energy Efficiency,power,power,41,/// Return true only if vscale must be a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:78,Safety,avoid,avoided,78,/// Return true if Flow Control is an expensive operation that should be; /// avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:95,Safety,predict,predicted,95,/// Return true if selects are only cheaper than branches if the branch is; /// unlikely to be predicted right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:176,Energy Efficiency,efficient,efficiently,176,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:267,Energy Efficiency,efficient,efficient,267,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:75,Performance,load,load,75,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:88,Performance,load,load,88,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:165,Performance,load,loads,165,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:201,Performance,load,load,201,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:251,Performance,load,loading,251,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:309,Performance,optimiz,optimizations,309,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:299,Usability,undo,undone,299,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:32,Performance,load,loads,32,// Default to the same logic as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:23,Testability,log,logic,23,// Default to the same logic as loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:104,Availability,mask,mask,104,"/// Return if the target supports combining a; /// chain like:; /// \code; /// %andResult = and %val1, #mask; /// %icmpResult = icmp %andResult, 0; /// \endcode; /// into a single machine instruction of a form like:; /// \code; /// cc = test %register, #mask; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:254,Availability,mask,mask,254,"/// Return if the target supports combining a; /// chain like:; /// \code; /// %andResult = and %val1, #mask; /// %icmpResult = icmp %andResult, 0; /// \endcode; /// into a single machine instruction of a form like:; /// \code; /// cc = test %register, #mask; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:237,Testability,test,test,237,"/// Return if the target supports combining a; /// chain like:; /// \code; /// %andResult = and %val1, #mask; /// %icmpResult = icmp %andResult, 0; /// \endcode; /// into a single machine instruction of a form like:; /// \code; /// cc = test %register, #mask; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:53,Energy Efficiency,efficient,efficient,53,"/// Use bitwise logic to make pairs of compares more efficient. For example:; /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0; /// This should be true when it takes more than one instruction to lower; /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on; /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:336,Energy Efficiency,Power,PowerPC,336,"/// Use bitwise logic to make pairs of compares more efficient. For example:; /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0; /// This should be true when it takes more than one instruction to lower; /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on; /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:16,Testability,log,logic,16,"/// Use bitwise logic to make pairs of compares more efficient. For example:; /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0; /// This should be true when it takes more than one instruction to lower; /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on; /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:297,Testability,log,logic,297,"/// Use bitwise logic to make pairs of compares more efficient. For example:; /// and (seteq A, B), (seteq C, D) --> seteq (or (xor A, B), (xor C, D)), 0; /// This should be true when it takes more than one instruction to lower; /// setcc (cmp+set on x86 scalar), when bitwise ops are faster than logic on; /// condition bits (crand on PowerPC), and/or when reducing cmp+br is a win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:174,Energy Efficiency,efficient,efficiently,174,/// Return the preferred operand type if the target has a quick way to compare; /// integer values of the given size. Assume that any legal integer type can; /// be compared efficiently. Targets may override this to allow illegal wide; /// types to return a vector type if there is support to compare that type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:428,Availability,mask,mask,428,"/// Return true if the target should transform:; /// (X & Y) == Y ---> (~X & Y) == 0; /// (X & Y) != Y ---> (~X & Y) != 0; ///; /// This may be profitable if the target has a bitwise and-not operation that; /// sets comparison flags. A target may want to limit the transformation based; /// on the type of Y or if Y is a constant.; ///; /// Note that the transform will not occur if Y is known to be a power-of-2; /// because a mask and compare of a single bit can be handled by inverting the; /// predicate, for example:; /// (X & 8) == 8 ---> (X & 8) != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:402,Energy Efficiency,power,power-of-,402,"/// Return true if the target should transform:; /// (X & Y) == Y ---> (~X & Y) == 0; /// (X & Y) != Y ---> (~X & Y) != 0; ///; /// This may be profitable if the target has a bitwise and-not operation that; /// sets comparison flags. A target may want to limit the transformation based; /// on the type of Y or if Y is a constant.; ///; /// Note that the transform will not occur if Y is known to be a power-of-2; /// because a mask and compare of a single bit can be handled by inverting the; /// predicate, for example:; /// (X & 8) == 8 ---> (X & 8) != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:104,Usability,simpl,simplify,104,/// Return true if the target has a bitwise and-not operation:; /// X = ~A & B; /// This can be used to simplify select or other instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Testability,test,test,40,"/// Return true if the target has a bit-test instruction:; /// (X & (1 << Y)) ==/!= 0; /// This knowledge can be used to prevent breaking the pattern,; /// or creating it if it could be recognized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:72,Availability,Mask,Mask,72,/// There are two ways to clear extreme bits (either low or high):; /// Mask: x & (-1 << y) (the instcombine canonical form); /// Shifts: x >> y << y; /// Return true if the variant with 2 variable shifts is preferred.; /// Return false if there is no preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:189,Modifiability,variab,variable,189,/// There are two ways to clear extreme bits (either low or high):; /// Mask: x & (-1 << y) (the instcombine canonical form); /// Shifts: x >> y << y; /// Return true if the variant with 2 variable shifts is preferred.; /// Return false if there is no preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,clear,clear,26,/// There are two ways to clear extreme bits (either low or high):; /// Mask: x & (-1 << y) (the instcombine canonical form); /// Shifts: x >> y << y; /// Return true if the variant with 2 variable shifts is preferred.; /// Return false if there is no preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:68,Availability,mask,mask,68,"/// Return true if it is profitable to fold a pair of shifts into a mask.; /// This is usually true on most targets. But some targets, like Thumb1,; /// have immediate shift instructions, but no immediate ""and"" instruction;; /// this makes the fold unprofitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:78,Availability,down,down,78,"/// Should we tranform the IR-optimal check for whether given truncation; /// down into KeptBits would be truncating or not:; /// (add %x, (1 << (KeptBits-1))) srccond (1 << KeptBits); /// Into it's more traditional form:; /// ((%x << C) a>> C) dstcond %x; /// Return true if we should transform.; /// Return false if there is no preference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:217,Safety,avoid,avoid,217,"/// Given the pattern; /// (X & (C l>>/<< Y)) ==/!= 0; /// return true if it should be transformed into:; /// ((X <</l>> Y) & C) ==/!= 0; /// WARNING: if 'X' is a constant, the fold may deadlock!; /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat(); /// here because it can end up being not linked in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:58,Testability,test,test,58,// One interesting pattern that we'd want to form is 'bit test':; // ((1 << Y) & C) ==/!= 0; // But we also need to be careful not to try to reverse that fold.; // Is this '1 << Y' ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:17,Testability,test,test,17,// Keep the 'bit test' pattern.; // Will it be '1 << Y' after the transform ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Testability,test,test,20,// Do form the 'bit test' pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:79,Usability,undo,undo,79,"// If 'X' is a constant, and we transform, then we will immediately; // try to undo the fold, thus causing endless combine loop.; // So by default, let's assume everyone prefers the fold; // iff 'X' is not a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:512,Energy Efficiency,power,power,512,"// Return true if its desirable to perform the following transform:; // (fmul C, (uitofp Pow2)); // -> (bitcast_to_FP (add (bitcast_to_INT C), Log2(Pow2) << mantissa)); // (fdiv C, (uitofp Pow2)); // -> (bitcast_to_FP (sub (bitcast_to_INT C), Log2(Pow2) << mantissa)); //; // This is only queried after we have verified the transform will be bitwise; // equals.; //; // SDNode *N : The FDiv/FMul node we want to transform.; // SDValue FPConst: The Float constant operand in `N`.; // SDValue IntPow2: The Integer power of 2 operand in `N`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:35,Performance,perform,perform,35,"// Return true if its desirable to perform the following transform:; // (fmul C, (uitofp Pow2)); // -> (bitcast_to_FP (add (bitcast_to_INT C), Log2(Pow2) << mantissa)); // (fdiv C, (uitofp Pow2)); // -> (bitcast_to_FP (sub (bitcast_to_INT C), Log2(Pow2) << mantissa)); //; // This is only queried after we have verified the transform will be bitwise; // equals.; //; // SDNode *N : The FDiv/FMul node we want to transform.; // SDValue FPConst: The Float constant operand in `N`.; // SDValue IntPow2: The Integer power of 2 operand in `N`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,Safety,avoid,avoiding,14,// Default to avoiding fdiv which is often very expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:114,Availability,mask,mask,114,"// Given:; // (icmp eq/ne (and X, C0), (shift X, C1)); // or; // (icmp eq/ne X, (rotate X, CPow2)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Do we prefer the shift to be shift-right, shift-left, or rotate.; // Note: Its only valid to convert the rotate version to the shift version iff; // the shift-amt (`C1`) is a power of 2 (including 0).; // If ShiftOpc (current Opcode) is returned, do nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:130,Availability,mask,mask,130,"// Given:; // (icmp eq/ne (and X, C0), (shift X, C1)); // or; // (icmp eq/ne X, (rotate X, CPow2)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Do we prefer the shift to be shift-right, shift-left, or rotate.; // Note: Its only valid to convert the rotate version to the shift version iff; // the shift-amt (`C1`) is a power of 2 (including 0).; // If ShiftOpc (current Opcode) is returned, do nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:426,Energy Efficiency,power,power,426,"// Given:; // (icmp eq/ne (and X, C0), (shift X, C1)); // or; // (icmp eq/ne X, (rotate X, CPow2)); // If C0 is a mask or shifted mask and the shift amt (C1) isolates the; // remaining bits (i.e something like `(x64 & UINT32_MAX) == (x64 >> 32)`); // Do we prefer the shift to be shift-right, shift-left, or rotate.; // Note: Its only valid to convert the rotate version to the shift version iff; // the shift-amt (`C1`) is a power of 2 (including 0).; // If ShiftOpc (current Opcode) is returned, do nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,Safety,avoid,avoid,94,"// By default prefer folding (abs (sub nsw x, y)) -> abds(x, y). Some targets; // may want to avoid this to prevent loss of sub_nsw pattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,Performance,optimiz,optimization,47,/// Return true if the target wants to use the optimization that; /// turns ext(promotableInst1(...(promotableInstN(load)))) into; /// promotedInst1(...(promotedInstN(ext(load)))).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:116,Performance,load,load,116,/// Return true if the target wants to use the optimization that; /// turns ext(promotableInst1(...(promotableInstN(load)))) into; /// promotedInst1(...(promotedInstN(ext(load)))).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:171,Performance,load,load,171,/// Return true if the target wants to use the optimization that; /// turns ext(promotableInst1(...(promotableInstN(load)))) into; /// promotedInst1(...(promotedInstN(ext(load)))).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:36,Performance,perform,perform,36,/// Return true if the target shall perform extract vector element and store; /// given that the vector is known to be splat of constant.; /// \p Index[out] gives the index of the vector element to be extracted when; /// this is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,Energy Efficiency,efficient,efficiently,94,/// Return true if inserting a scalar into a variable element of an undef; /// vector is more efficiently handled by splatting the scalar instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Modifiability,variab,variable,45,/// Return true if inserting a scalar into a variable element of an undef; /// vector is more efficiently handled by splatting the scalar instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:526,Modifiability,extend,extended,526,"/// For targets without i1 registers, this gives the nature of the high-bits; /// of boolean values held in types wider than i1.; ///; /// ""Boolean values"" are special true/false values produced by nodes like; /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.; /// Not to be confused with general values promoted from i1. Some cpus; /// distinguish between vectors of boolean and scalars; the isVec parameter; /// selects between the two kinds. For example on X86 a scalar boolean should; /// be zero extended from i1, while the elements of a vector of booleans; /// should be sign extended from i1.; ///; /// Some cpus also treat floating point types the same way as they treat; /// vectors instead of the way they treat scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:607,Modifiability,extend,extended,607,"/// For targets without i1 registers, this gives the nature of the high-bits; /// of boolean values held in types wider than i1.; ///; /// ""Boolean values"" are special true/false values produced by nodes like; /// SETCC and consumed (as the condition) by nodes like SELECT and BRCOND.; /// Not to be confused with general values promoted from i1. Some cpus; /// distinguish between vectors of boolean and scalars; the isVec parameter; /// selects between the two kinds. For example on X86 a scalar boolean should; /// be zero extended from i1, while the elements of a vector of booleans; /// should be sign extended from i1.; ///; /// Some cpus also treat floating point types the same way as they treat; /// vectors instead of the way they treat scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:18,Energy Efficiency,schedul,scheduling,18,/// Return target scheduling preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:9,Energy Efficiency,schedul,scheduler,9,"/// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics; /// for different nodes. This function returns the preference (or none) for; /// the given node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:57,Energy Efficiency,schedul,scheduling,57,"/// Some scheduler, e.g. hybrid, can switch to different scheduling heuristics; /// for different nodes. This function returns the preference (or none) for; /// the given node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:28,Availability,down,down,28,"/// Vector types are broken down into some number of legal first class types.; /// For example, EVT::v8f32 maps to 2 EVT::v4f32 with Altivec or SSE1, or 8; /// promoted EVT::f64 values with the X86 FP stack. Similarly, EVT::v2i64; /// turns into 4 EVT::i32 values with both PPC and X86.; ///; /// This method returns the number of registers needed, and the VT for each; /// register. It also returns the VT and quantity of the intermediate values; /// before they are promoted/expanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:96,Availability,down,down,96,/// Certain targets such as MIPS require that some types such as vectors are; /// always broken down into scalars in some contexts. This occurs even if the; /// vector type is legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Performance,load,load,164,"/// Returns true if the target can instruction select the specified FP; /// immediate natively. If false, the legalizer will materialize the FP; /// immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:119,Availability,mask,masks,119,"/// Targets can use this to indicate that they only support *some*; /// VECTOR_SHUFFLE operations, those with specific masks. By default, if a; /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be; /// legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:193,Availability,mask,mask,193,"/// Targets can use this to indicate that they only support *some*; /// VECTOR_SHUFFLE operations, those with specific masks. By default, if a; /// target supports the VECTOR_SHUFFLE node, all mask values are assumed to be; /// legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Availability,Mask,Mask,2,/*Mask*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:220,Integrability,depend,depend,220,/// Some fixed point operations may be natively supported by the target but; /// only for specific scales. This method allows for checking; /// if the width is supported by the target for a given operation that may; /// depend on scale.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:136,Usability,guid,guide,136,/// Return true if the specified operation is legal on this target or can be; /// made legal with custom lowering. This is used to help guide high-level; /// lowering decisions. LegalOnly is an optional convenience for code paths; /// traversed pre and post legalisation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:131,Usability,guid,guide,131,/// Return true if the specified operation is legal on this target or can be; /// made legal using promotion. This is used to help guide high-level lowering; /// decisions. LegalOnly is an optional convenience for code paths traversed; /// pre and post legalisation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:160,Usability,guid,guide,160,/// Return true if the specified operation is legal on this target or can be; /// made legal with custom lowering or using promotion. This is used to help; /// guide high-level lowering decisions. LegalOnly is an optional convenience; /// for code paths traversed pre and post legalisation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,Testability,test,test,37,"/// Return true if lowering to a bit test is suitable for a set of case; /// clusters which contains \p NumDests unique destinations, \p Low and; /// \p High as its lowest and highest case values, and expects \p NumCmps; /// case value comparisons. Check if the number of destinations, comparison; /// metric, and range are all suitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:245,Testability,test,tests,245,"// FIXME: I don't think NumCmps is the correct metric: a single case and a; // range of cases both require only one branch to lower. Just looking at the; // number of clusters and destinations should be enough to decide whether to; // build bit tests.; // To lower a range with bit tests, the range must fit the bitwidth of a; // machine word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:282,Testability,test,tests,282,"// FIXME: I don't think NumCmps is the correct metric: a single case and a; // range of cases both require only one branch to lower. Just looking at the; // number of clusters and destinations should be enough to decide whether to; // build bit tests.; // To lower a range with bit tests, the range must fit the bitwidth of a; // machine word.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:63,Testability,test,tests,63,"// Decide whether it's profitable to lower this range with bit tests. Each; // destination requires a bit test and branch, and there is an overall range; // check branch. For a small number of clusters, separate comparisons might; // be cheaper, and for many destinations, splitting the range might be; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:106,Testability,test,test,106,"// Decide whether it's profitable to lower this range with bit tests. Each; // destination requires a bit test and branch, and there is an overall range; // check branch. For a small number of clusters, separate comparisons might; // be cheaper, and for many destinations, splitting the range might be; // better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:146,Usability,guid,guide,146,/// Return true if the specified operation is illegal on this target or; /// unlikely to be made legal with custom lowering. This is used to help guide; /// high-level lowering decisions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Performance,load,load,20,"/// Return how this load with extension should be treated: either it is legal,; /// needs to be promoted to a larger size, needs to be expanded to some other; /// code sequence, or the target has a custom expander for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:33,Performance,load,load,33,/// Return true if the specified load with extension is legal on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:33,Performance,load,load,33,/// Return true if the specified load with extension is legal or custom; /// on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,Performance,load,load,27,"/// Return how the indexed load should be treated: either it is legal, needs; /// to be promoted to a larger size, needs to be expanded to some other code; /// sequence, or the target has a custom expander for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Performance,load,load,41,/// Return true if the specified indexed load is legal on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Performance,load,load,41,/// Return true if the specified indexed load is legal on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,Performance,load,load,27,"/// Return how the indexed load should be treated: either it is legal, needs; /// to be promoted to a larger size, needs to be expanded to some other code; /// sequence, or the target has a custom expander for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Performance,load,load,41,/// Return true if the specified indexed load is legal on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Performance,load,load,41,/// Return true if the specified indexed load is legal on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,Availability,mask,masked,41,/// Returns true if the index type for a masked gather/scatter requires; /// extending,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:77,Modifiability,extend,extending,77,/// Returns true if the index type for a masked gather/scatter requires; /// extending,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:60,Availability,mask,masked,60,// Returns true if Extend can be folded into the index of a masked gathers/scatters; // on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:19,Modifiability,Extend,Extend,19,// Returns true if Extend can be folded into the index of a masked gathers/scatters; // on this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:254,Testability,assert,assert,254,"/// Return the EVT corresponding to this LLVM type. This is fixed by the LLVM; /// operations except for the pointer size. If AllowUnknown is true, this; /// will return MVT::Other for types with no EVT counterpart (e.g. structs),; /// otherwise it will assert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:162,Testability,log,logarithm,162,"/// Return the desired alignment for ByVal or InAlloca aggregate function; /// arguments in the caller parameter area. This is the actual alignment, not; /// its logarithm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:160,Energy Efficiency,reduce,reduce,160,"/// If true, then instruction selection should seek to shrink the FP constant; /// of the specified type to a smaller type in order to save space and / or; /// reduce runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:39,Energy Efficiency,reduce,reduce,39,/// Return true if it is profitable to reduce a load to a smaller type.; /// Example: (i16 (trunc (i32 (load x))) -> i16 load x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Performance,load,load,48,/// Return true if it is profitable to reduce a load to a smaller type.; /// Example: (i16 (trunc (i32 (load x))) -> i16 load x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:104,Performance,load,load,104,/// Return true if it is profitable to reduce a load to a smaller type.; /// Example: (i16 (trunc (i32 (load x))) -> i16 load x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:121,Performance,load,load,121,/// Return true if it is profitable to reduce a load to a smaller type.; /// Example: (i16 (trunc (i32 (load x))) -> i16 load x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:87,Performance,load,load,87,"// By default, assume that it is cheaper to extract a subvector from a wide; // vector load rather than creating multiple narrow vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:136,Performance,load,loads,136,"// By default, assume that it is cheaper to extract a subvector from a wide; // vector load rather than creating multiple narrow vector loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,Availability,redundant,redundant,99,"/// Return true (the default) if it is profitable to remove a sext_inreg(x); /// where the sext is redundant, and use x directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,Safety,redund,redundant,99,"/// Return true (the default) if it is profitable to remove a sext_inreg(x); /// where the sext is redundant, and use x directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:80,Performance,perform,perform,80,"/// If true, the target has custom DAG combine transformations that it can; /// perform for the specified node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:227,Performance,perform,performance,227,"/// Get maximum # of store operations permitted for llvm.memset; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memset. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:227,Performance,perform,performance,227,"/// Get maximum # of store operations permitted for llvm.memcpy; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memcpy. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:243,Performance,perform,performance,243,/// \brief Get maximum # of store operations to be glued together; ///; /// This function returns the maximum number of store operations permitted; /// to glue together during lowering of llvm.memcpy. The value is set by; // the target at the performance threshold for such a replacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,Performance,load,load,21,"/// Get maximum # of load operations permitted for memcmp; ///; /// This function returns the maximum number of load operations permitted; /// to replace a call to memcmp. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:112,Performance,load,load,112,"/// Get maximum # of load operations permitted for memcmp; ///; /// This function returns the maximum number of load operations permitted; /// to replace a call to memcmp. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:215,Performance,perform,performance,215,"/// Get maximum # of load operations permitted for memcmp; ///; /// This function returns the maximum number of load operations permitted; /// to replace a call to memcmp. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:229,Performance,perform,performance,229,"/// Get maximum # of store operations permitted for llvm.memmove; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memmove. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:657,Availability,error,error,657,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:54,Security,access,accesses,54,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:139,Security,access,accesses,139,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:274,Security,access,access,274,"/// Determine if the target supports unaligned memory accesses.; ///; /// This function returns true if the target allows unaligned memory accesses; /// of the specified type in the given address space. If true, it also returns; /// a relative speed of the unaligned memory access in the last argument by; /// reference. The higher the speed number the faster the operation comparing; /// to a number returned by another such call. This is used, for example, in; /// situations where an array copy/move/set is converted to a sequence of; /// store operations. Its use helps to ensure that such replacements don't; /// generate code that causes an alignment error (trap) on the target machine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Security,access,access,45,"/// This function returns true if the memory access is aligned or if the; /// target allows this specific unaligned memory access. If the access is; /// allowed, the optional final parameter returns a relative speed of the; /// access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:123,Security,access,access,123,"/// This function returns true if the memory access is aligned or if the; /// target allows this specific unaligned memory access. If the access is; /// allowed, the optional final parameter returns a relative speed of the; /// access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:138,Security,access,access,138,"/// This function returns true if the memory access is aligned or if the; /// target allows this specific unaligned memory access. If the access is; /// allowed, the optional final parameter returns a relative speed of the; /// access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:228,Security,access,access,228,"/// This function returns true if the memory access is aligned or if the; /// target allows this specific unaligned memory access. If the access is; /// allowed, the optional final parameter returns a relative speed of the; /// access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:30,Security,access,access,30,"/// Return true if the memory access of this type is aligned or if the target; /// allows this specific unaligned access for the given MachineMemOperand.; /// If the access is allowed, the optional final parameter returns a relative; /// speed of the access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:114,Security,access,access,114,"/// Return true if the memory access of this type is aligned or if the target; /// allows this specific unaligned access for the given MachineMemOperand.; /// If the access is allowed, the optional final parameter returns a relative; /// speed of the access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:166,Security,access,access,166,"/// Return true if the memory access of this type is aligned or if the target; /// allows this specific unaligned access for the given MachineMemOperand.; /// If the access is allowed, the optional final parameter returns a relative; /// speed of the access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:251,Security,access,access,251,"/// Return true if the memory access of this type is aligned or if the target; /// allows this specific unaligned access for the given MachineMemOperand.; /// If the access is allowed, the optional final parameter returns a relative; /// speed of the access (as defined by the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Security,access,access,48,"/// Return true if the target supports a memory access of this type for the; /// given address space and alignment. If the access is allowed, the optional; /// final parameter returns the relative speed of the access (as defined by; /// the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:123,Security,access,access,123,"/// Return true if the target supports a memory access of this type for the; /// given address space and alignment. If the access is allowed, the optional; /// final parameter returns the relative speed of the access (as defined by; /// the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:210,Security,access,access,210,"/// Return true if the target supports a memory access of this type for the; /// given address space and alignment. If the access is allowed, the optional; /// final parameter returns the relative speed of the access (as defined by; /// the target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Security,access,access,48,"/// Return true if the target supports a memory access of this type for the; /// given MachineMemOperand. If the access is allowed, the optional; /// final parameter returns the relative access speed (as defined by the; /// target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:113,Security,access,access,113,"/// Return true if the target supports a memory access of this type for the; /// given MachineMemOperand. If the access is allowed, the optional; /// final parameter returns the relative access speed (as defined by the; /// target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:187,Security,access,access,187,"/// Return true if the target supports a memory access of this type for the; /// given MachineMemOperand. If the access is allowed, the optional; /// final parameter returns the relative access speed (as defined by the; /// target).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:49,Performance,load,load,49,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; /// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:231,Testability,log,logic,231,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; /// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,Performance,load,load,37,"/// Returns true if it's safe to use load / store of the specified type to; /// expand memcpy / memset inline.; ///; /// This is mostly true for all types except for some special cases. For; /// example, on X86 targets without SSE2 f64 load / store are done with fldl /; /// fstpl which also does type conversion. Note the specified type doesn't; /// have to be legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:236,Performance,load,load,236,"/// Returns true if it's safe to use load / store of the specified type to; /// expand memcpy / memset inline.; ///; /// This is mostly true for all types except for some special cases. For; /// example, on X86 targets without SSE2 f64 load / store are done with fldl /; /// fstpl which also does type conversion. Note the specified type doesn't; /// have to be legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,Safety,safe,safe,25,"/// Returns true if it's safe to use load / store of the specified type to; /// expand memcpy / memset inline.; ///; /// This is mostly true for all types except for some special cases. For; /// example, on X86 targets without SSE2 f64 load / store are done with fldl /; /// fstpl which also does type conversion. Note the specified type doesn't; /// have to be legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:15,Modifiability,variab,variable,15,"/// Return the variable that's previously inserted by insertSSPDeclarations,; /// if any, otherwise return nullptr. Should be used only when; /// getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,Availability,error,error,99,"/// If the target has a standard stack protection check function that; /// performs validation and error handling, returns the function. Otherwise,; /// returns nullptr. Must be previously inserted by insertSSPDeclarations.; /// Should be used only when getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:75,Performance,perform,performs,75,"/// If the target has a standard stack protection check function that; /// performs validation and error handling, returns the function. Otherwise,; /// returns nullptr. Must be previously inserted by insertSSPDeclarations.; /// Should be used only when getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:84,Security,validat,validation,84,"/// If the target has a standard stack protection check function that; /// performs validation and error handling, returns the function. Otherwise,; /// returns nullptr. Must be previously inserted by insertSSPDeclarations.; /// Should be used only when getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,Safety,unsafe,unsafe,47,/// Returns the target-specific address of the unsafe stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:68,Energy Efficiency,reduce,reduce,68,/// Whether AtomicExpandPass should automatically insert fences and reduce; /// ordering for this atomic. This should be true for most architectures with; /// weak memory ordering. Defaults to false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,"/// Perform a load-linked operation on Addr, returning a ""Value *"" with the; /// corresponding pointee type. This may entail some non-trivial operations to; /// truncate or reconstruct types that will be illegal in the backend. See; /// ARMISelLowering for an example implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,Performance,load,load-linked,14,"/// Perform a load-linked operation on Addr, returning a ""Value *"" with the; /// corresponding pointee type. This may entail some non-trivial operations to; /// truncate or reconstruct types that will be illegal in the backend. See; /// ARMISelLowering for an example implementation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,"/// Perform a store-conditional operation to Addr. Return the status of the; /// store. This should be 0 if the store succeeded, non-zero otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,Availability,mask,masked,14,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:253,Availability,mask,masking,253,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:208,Performance,load,loaded,208,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:103,Availability,mask,masked,103,"/// Perform a atomicrmw expansion using a target-specific way. This is; /// expected to be called when masked atomicrmw and bit test atomicrmw don't; /// work, and the target supports another way to lower atomicrmw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,"/// Perform a atomicrmw expansion using a target-specific way. This is; /// expected to be called when masked atomicrmw and bit test atomicrmw don't; /// work, and the target supports another way to lower atomicrmw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:128,Testability,test,test,128,"/// Perform a atomicrmw expansion using a target-specific way. This is; /// expected to be called when masked atomicrmw and bit test atomicrmw don't; /// work, and the target supports another way to lower atomicrmw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,/// Perform a bit test atomicrmw using a target-specific intrinsic. This; /// represents the combined bit test intrinsic which will be lowered at a late; /// stage by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:18,Testability,test,test,18,/// Perform a bit test atomicrmw using a target-specific intrinsic. This; /// represents the combined bit test intrinsic which will be lowered at a late; /// stage by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:106,Testability,test,test,106,/// Perform a bit test atomicrmw using a target-specific intrinsic. This; /// represents the combined bit test intrinsic which will be lowered at a late; /// stage by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,"/// Perform a atomicrmw which the result is only used by comparison, using a; /// target-specific intrinsic. This represents the combined atomic and compare; /// intrinsic which will be lowered at a late stage by the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:14,Availability,mask,masked,14,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:251,Availability,mask,masking,251,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:206,Performance,load,loaded,206,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:632,Deployability,release,release,632,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:859,Energy Efficiency,Power,PowerPC,859,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:332,Performance,perform,performed,332,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:915,Performance,load,load,915,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:338,Energy Efficiency,monitor,monitor,338,"/// @}; // Emits code that executes when the comparison result in the ll/sc; // expansion of a cmpxchg instruction is such that the store-conditional will; // not execute. This makes it possible to balance out the load-linked with; // a dedicated instruction, if desired.; // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would; // be unnecessarily held, except if clrex, inserted by this hook, is executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:214,Performance,load,load-linked,214,"/// @}; // Emits code that executes when the comparison result in the ll/sc; // expansion of a cmpxchg instruction is such that the store-conditional will; // not execute. This makes it possible to balance out the load-linked with; // a dedicated instruction, if desired.; // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would; // be unnecessarily held, except if clrex, inserted by this hook, is executed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Modifiability,extend,extended,45,/// Returns true if arguments should be sign-extended in lib calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Modifiability,extend,extended,40,/// Returns true if arguments should be extended in lib calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:35,Performance,load,load,35,/// Returns how the given (atomic) load should be expanded by the; /// IR-level AtomicExpand pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:35,Performance,load,load,35,/// Returns how the given (atomic) load should be cast by the IR-level; /// AtomicExpand pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:159,Performance,load,load,159,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:249,Performance,cache,cacheline,249,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:295,Performance,perform,performance,295,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:564,Performance,load,load,564,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:669,Performance,load,load,669,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:420,Testability,benchmark,benchmarks,420,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:53,Modifiability,extend,extended,53,"/// Returns how the platform's atomic operations are extended (ZERO_EXTEND,; /// SIGN_EXTEND, or ANY_EXTEND).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:95,Modifiability,extend,extended,95,"/// Returns how the platform's atomic compare and swap expects its comparison; /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is; /// separate from getExtendForAtomicOps, which is concerned with the; /// sign-extension of the instruction's output, whereas here we are concerned; /// with the sign-extension of the input. For targets with compare-and-swap; /// instructions (or sub-word comparisons in their LL/SC loop expansions),; /// the input can be ANY_EXTEND, but the output will still have a specific; /// extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:293,Performance,perform,perform,293,"/// @}; /// Returns true if we should normalize; /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and; /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely; /// that it saves us from materializing N0 and N1 in an integer register.; /// Targets that are able to perform and/or on flags should return false here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:68,Testability,log,logical,68,"// If a target has multiple condition registers, then it likely has logical; // operations on those registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:95,Usability,simpl,simple,95,"/// Return true if a select of constants (select Cond, C1, C2) should be; /// transformed into simple math ops with the condition value. For example:; /// select Cond, C1, C1-1 --> add (zext Cond), C1-1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:97,Usability,simpl,simpler,97,/// Return true if it is profitable to transform an integer; /// multiplication-by-constant into simpler operations like shifts and adds.; /// This may be true if the target does not directly support the; /// multiplication operation for the specified type or the sequence of simpler; /// ops is faster than the multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:276,Usability,simpl,simpler,276,/// Return true if it is profitable to transform an integer; /// multiplication-by-constant into simpler operations like shifts and adds.; /// This may be true if the target does not directly support the; /// multiplication operation for the specified type or the sequence of simpler; /// ops is faster than the multiply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:85,Performance,optimiz,optimizing,85,"/// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.; /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always; /// considered beneficial.; /// If optimizing for size, expansion is only considered beneficial for upto; /// 5 multiplies and a divide (if the exponent is negative).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:186,Performance,optimiz,optimizing,186,"/// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.; /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always; /// considered beneficial.; /// If optimizing for size, expansion is only considered beneficial for upto; /// 5 multiplies and a divide (if the exponent is negative).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Deployability,Configurat,Configuration,98,//===--------------------------------------------------------------------===//; // TargetLowering Configuration Methods - These methods should be invoked by; // the derived class constructor to configure this object for the target.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Modifiability,Config,Configuration,98,//===--------------------------------------------------------------------===//; // TargetLowering Configuration Methods - These methods should be invoked by; // the derived class constructor to configure this object for the target.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:194,Modifiability,config,configure,194,//===--------------------------------------------------------------------===//; // TargetLowering Configuration Methods - These methods should be invoked by; // the derived class constructor to configure this object for the target.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,Modifiability,extend,extends,27,/// Specify how the target extends the result of integer and floating point; /// boolean values from i1 to a wider type. See getBooleanContents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,Modifiability,extend,extends,27,/// Specify how the target extends the result of integer and floating point; /// boolean values from i1 to a wider type. See getBooleanContents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,Modifiability,extend,extends,27,/// Specify how the target extends the result of a vector boolean value from a; /// vector of i1 to a wider type. See getBooleanContents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:23,Energy Efficiency,schedul,scheduling,23,/// Specify the target scheduling preference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:43,Testability,log,logic,43,/// Tells the code generator not to expand logic operations on comparison; /// predicates into separate sequences that increase the amount of flow; /// control.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:43,Availability,avail,available,43,/// Add the specified register class as an available regclass for the; /// specified value type. This indicates the selector can handle values of; /// that class natively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:101,Security,expose,expose,101,"/// Once all of the register classes are added, this allows us to compute; /// derived properties we expose.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:32,Performance,load,load,32,/// Indicate that the specified load with extension does not work with the; /// specified type and indicate what to do about it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Performance,load,load,40,/// Indicate that the specified indexed load does or does not work with the; /// specified type and indicate what to do abort it.; ///; /// NOTE: All indexed mode loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:163,Performance,load,loads,163,/// Indicate that the specified indexed load does or does not work with the; /// specified type and indicate what to do abort it.; ///; /// NOTE: All indexed mode loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:120,Safety,abort,abort,120,/// Indicate that the specified indexed load does or does not work with the; /// specified type and indicate what to do abort it.; ///; /// NOTE: All indexed mode loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Availability,mask,masked,40,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:170,Availability,mask,masked,170,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,Performance,load,load,47,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:177,Performance,load,loads,177,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Availability,mask,masked,40,/// Indicate that the specified indexed masked store does or does not work; /// with the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked stores are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:171,Availability,mask,masked,171,/// Indicate that the specified indexed masked store does or does not work; /// with the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked stores are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:28,Usability,Simpl,SimpleTy,28,/// The lower 3 bits of the SimpleTy index into Nth 4bit set from the; /// 32-bit value and the upper 29 bits index into the second dimension of; /// the array to select what 32-bit value to use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:153,Performance,Perform,PerformDAGCombine,153,/// Targets should invoke this method for each target independent node that; /// they want to provide a custom DAG combiner for by implementing the; /// PerformDAGCombine virtual method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:89,Performance,perform,performance,89,/// Set the target's preferred function alignment. This should be set if; /// there is a performance benefit to higher-than-minimum alignment,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:207,Performance,Load,Load,207,//===--------------------------------------------------------------------===//; // Addressing mode description hooks (used by LSR etc).; //; /// CodeGenPrepare sinks address calculations into the same BB as Load/Store; /// instructions reading the address. This allows as much computation as; /// possible to be done in the address mode for that operand. This hook lets; /// targets also pass back when this should be done on intrinsics which; /// load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:448,Performance,load,load,448,//===--------------------------------------------------------------------===//; // Addressing mode description hooks (used by LSR etc).; //; /// CodeGenPrepare sinks address calculations into the same BB as Load/Store; /// instructions reading the address. This allows as much computation as; /// possible to be done in the address mode for that operand. This hook lets; /// targets also pass back when this should be done on intrinsics which; /// load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Security,Access,AccessTy,2,/*AccessTy*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,Performance,load,load,94,"/// Return true if the addressing mode represented by AM is legal for this; /// target, for a load/store of the specified type.; ///; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type. TODO: Handle; /// pre/postinc as well.; ///; /// If the address space cannot be determined, it will be -1.; ///; /// TODO: Remove default argument",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:236,Performance,load,load,236,"/// Return true if the addressing mode represented by AM is legal for this; /// target, for a load/store of the specified type.; ///; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type. TODO: Handle; /// pre/postinc as well.; ///; /// If the address space cannot be determined, it will be -1.; ///; /// TODO: Remove default argument",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:242,Usability,simpl,simple,242,"/// Return true if it's significantly cheaper to shift a vector by a uniform; /// scalar than by an amount which will vary across each lane. On x86 before; /// AVX2 for example, there is a ""psllw"" instruction for the former case, but; /// no simple instruction for a general ""a << b"" operation on vectors.; /// This should also apply to lowering for vector funnel shifts (rotates).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:63,Performance,load,loaded,63,"/// Given a set in interconnected phis of type 'From' that are loaded/stored; /// or bitcast to type 'To', return true if the set should be converted to; /// 'To'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:38,Testability,log,logic,38,/// Return true if the node is a math/logic binary operator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:252,Performance,perform,performs,252,"/// Return true if a truncation from FromTy to ToTy is permitted when deciding; /// whether a call is in tail position. Typically this means that both results; /// would be assigned to the same register or stack slot, but it could mean; /// the target performs adequate checks of its own before proceeding with the; /// tail call. Targets must return false when FromTy <= ToTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:243,Modifiability,extend,extends,243,"/// Return true if the extension represented by \p I is free.; /// Unlikely the is[Z|FP]ExtFree family which is based on types,; /// this method can use the context provided by \p I to decide; /// whether or not \p I is free.; /// This method extends the behavior of the is[Z|FP]ExtFree family.; /// In other words, if is[Z|FP]Free returns true, then this method; /// returns true as well. The converse is not true.; /// The target can perform the adequate checks by overriding isExtFreeImpl.; /// \pre \p I must be a sign, zero, or fp extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:436,Performance,perform,perform,436,"/// Return true if the extension represented by \p I is free.; /// Unlikely the is[Z|FP]ExtFree family which is based on types,; /// this method can use the context provided by \p I to decide; /// whether or not \p I is free.; /// This method extends the behavior of the is[Z|FP]ExtFree family.; /// In other words, if is[Z|FP]Free returns true, then this method; /// returns true as well. The converse is not true.; /// The target can perform the adequate checks by overriding isExtFreeImpl.; /// \pre \p I must be a sign, zero, or fp extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:22,Performance,Load,Load,22,"/// Return true if \p Load and \p Ext can form an ExtLoad.; /// For example, in AArch64; /// %L = load i8, i8* %ptr; /// %E = zext i8 %L to i32; /// can be lowered into one load instruction; /// ldrb w0, [x0]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Performance,load,load,98,"/// Return true if \p Load and \p Ext can form an ExtLoad.; /// For example, in AArch64; /// %L = load i8, i8* %ptr; /// %E = zext i8 %L to i32; /// can be lowered into one load instruction; /// ldrb w0, [x0]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:173,Performance,load,load,173,"/// Return true if \p Load and \p Ext can form an ExtLoad.; /// For example, in AArch64; /// %L = load i8, i8* %ptr; /// %E = zext i8 %L to i32; /// can be lowered into one load instruction; /// ldrb w0, [x0]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:10,Performance,load,load,10,"// If the load has other users and the truncate is not free, the ext; // probably isn't free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:55,Performance,load,loads,55,// Check whether the target supports casts folded into loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,Modifiability,extend,extends,99,"/// Return true if any actual instruction that defines a value of type FromTy; /// implicitly zero-extends the value to ToTy in the result register.; ///; /// The function should return true when it is likely that the truncate can; /// be freely folded with an instruction defining a value of FromTy. If; /// the defining instruction is unknown (because you're looking at a; /// function argument, PHI, etc.) then the target may require an; /// explicit truncate, which is not necessarily free, but this function; /// does not deal with those cases.; /// Targets must return false when FromTy >= ToTy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:24,Modifiability,extend,extending,24,/// Return true if zero-extending the specific node Val to type VT2 is free; /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or; /// because it's folded such as X86 zero-extending loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:118,Modifiability,extend,extended,118,/// Return true if zero-extending the specific node Val to type VT2 is free; /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or; /// because it's folded such as X86 zero-extending loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:196,Modifiability,extend,extending,196,/// Return true if zero-extending the specific node Val to type VT2 is free; /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or; /// because it's folded such as X86 zero-extending loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:206,Performance,load,loads,206,/// Return true if zero-extending the specific node Val to type VT2 is free; /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or; /// because it's folded such as X86 zero-extending loads).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Modifiability,extend,extended,48,/// Return true if this constant should be sign extended when promoting to; /// a larger type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Modifiability,extend,extending,20,"/// Try to optimize extending or truncating conversion instructions (like; /// zext, trunc, fptoui, uitofp) for the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Performance,optimiz,optimize,11,"/// Try to optimize extending or truncating conversion instructions (like; /// zext, trunc, fptoui, uitofp) for the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:64,Performance,load,load,64,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:78,Performance,load,loaded,78,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:100,Performance,Load,LoadedType,100,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:259,Performance,load,load,259,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:332,Performance,load,loads,332,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:385,Performance,load,loads,385,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:436,Performance,load,load,436,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:491,Performance,load,load,491,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:599,Performance,optimiz,optimized,599,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:624,Performance,load,load,624,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:649,Performance,load,load,649,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:751,Performance,perform,performs,751,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:772,Performance,load,load,772,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:868,Performance,load,loads,868,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Performance,Load,LoadedType,2,/*LoadedType*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:60,Security,access,accesses,60,/// Get the maximum supported factor for interleaved memory accesses.; /// Default to be the minimum interleave factor: 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,Performance,load,load,25,/// Lower an interleaved load to target specific intrinsics. Return; /// true on success.; ///; /// \p LI is the vector load instruction.; /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.; /// \p Indices is the corresponding indices for each shufflevector.; /// \p Factor is the interleave factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:120,Performance,load,load,120,/// Lower an interleaved load to target specific intrinsics. Return; /// true on success.; ///; /// \p LI is the vector load instruction.; /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.; /// \p Indices is the corresponding indices for each shufflevector.; /// \p Factor is the interleave factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:202,Performance,load,loaded,202,/// Lower an interleaved load to target specific intrinsics. Return; /// true on success.; ///; /// \p LI is the vector load instruction.; /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.; /// \p Indices is the corresponding indices for each shufflevector.; /// \p Factor is the interleave factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:56,Performance,load,load,56,/// Lower a deinterleave intrinsic to a target specific load intrinsic.; /// Return true on success. Currently only supports; /// llvm.experimental.vector.deinterleave2; ///; /// \p DI is the deinterleave intrinsic.; /// \p LI is the accompanying load instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:247,Performance,load,load,247,/// Lower a deinterleave intrinsic to a target specific load intrinsic.; /// Return true on success. Currently only supports; /// llvm.experimental.vector.deinterleave2; ///; /// \p DI is the deinterleave intrinsic.; /// \p LI is the accompanying load instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:129,Modifiability,extend,extended,129,"/// Return true if an fpext operation is free (for instance, because; /// single-precision floating-point numbers are implicitly extended to; /// double-precision).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Modifiability,extend,extended,164,"/// Return true if an fpext operation input to an \p Opcode operation is free; /// (for instance, because half-precision floating-point numbers are; /// implicitly extended to float-precision) for an FMA instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Modifiability,extend,extended,164,"/// Return true if an fpext operation input to an \p Opcode operation is free; /// (for instance, because half-precision floating-point numbers are; /// implicitly extended to float-precision) for an FMA instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:80,Modifiability,extend,extend,80,"/// Return true if folding a vector load into ExtVal (a sign, zero, or any; /// extend node) is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:36,Performance,load,load,36,"/// Return true if folding a vector load into ExtVal (a sign, zero, or any; /// extend node) is profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:140,Energy Efficiency,efficient,efficient,140,/// Return true if it is beneficial to convert a load of a constant to; /// just the constant itself.; /// On some targets it might be more efficient to use a combination of; /// arithmetic instructions to materialize the constant instead of loading it; /// from a constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:49,Performance,load,load,49,/// Return true if it is beneficial to convert a load of a constant to; /// just the constant itself.; /// On some targets it might be more efficient to use a combination of; /// arithmetic instructions to materialize the constant instead of loading it; /// from a constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:242,Performance,load,loading,242,/// Return true if it is beneficial to convert a load of a constant to; /// just the constant itself.; /// On some targets it might be more efficient to use a combination of; /// arithmetic instructions to materialize the constant instead of loading it; /// from a constant pool.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:201,Integrability,depend,depends,201,"/// Return true if EXTRACT_SUBVECTOR is cheap for extracting this result type; /// from this source type with this index. This is needed because; /// EXTRACT_SUBVECTOR usually has custom lowering that depends on the index of; /// the first element, and only the target knows which lowering is cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:30,Modifiability,inherit,inherited,30,// TODO: The default logic is inherited from code in CodeGenPrepare.; // The opcode should not make a difference by default?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,Testability,log,logic,21,// TODO: The default logic is inherited from code in CodeGenPrepare.; // The opcode should not make a difference by default?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:33,Usability,clear,clearing,33,/// Does this target require the clearing of high-order bits in a register; /// passed to the fp16 to fp conversion library function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:141,Integrability,rout,routine,141,//===--------------------------------------------------------------------===//; // Runtime Library hooks; //; /// Rename the default libcall routine name for the specified libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Integrability,rout,routine,20,/// Get the libcall routine name for the specified libcall.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Testability,test,test,48,/// Override the default CondCode to be used to test the result of the; /// comparison libcall against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:42,Testability,test,test,42,/// Get the CondCode that's to be used to test the result of the comparison; /// libcall against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:15,Energy Efficiency,schedul,scheduling,15,/// The target scheduling preference: shortest possible total cycles or lowest; /// register usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:46,Performance,optimiz,optimizing,46,"/// The minimum function alignment (used when optimizing for size, and to; /// prevent explicitly provided alignment from leading to incorrect code).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:79,Performance,optimiz,optimizing,79,/// The preferred function alignment (used when alignment unspecified and; /// optimizing for speed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:72,Security,Access,Accesses,72,/// Size in bits of the maximum atomics size the backend supports.; /// Accesses larger than this will be expanded by AtomicExpandPass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:153,Energy Efficiency,schedul,scheduler,153,"/// This indicates the ""representative"" register class to use for each; /// ValueType the target supports natively. This information is used by the; /// scheduler to track register pressure. By default, the representative; /// register class is the largest legal super-reg register class of the; /// register class of the specified type. e.g. On x86, i8, i16, and i32's; /// representative class would be GR32.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:118,Energy Efficiency,schedul,scheduler,118,"/// This indicates the ""cost"" of the ""representative"" register class for each; /// ValueType. The cost is used by the scheduler to approximate register; /// pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:13,Performance,load,load,13,"/// For each load extension type and each value type, keep a LegalizeAction; /// that indicates how instruction selection should deal with a load of a; /// specific value type and extension type. Uses 4-bits to store the action; /// for each of the 4 load ext types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:141,Performance,load,load,141,"/// For each load extension type and each value type, keep a LegalizeAction; /// that indicates how instruction selection should deal with a load of a; /// specific value type and extension type. Uses 4-bits to store the action; /// for each of the 4 load ext types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:251,Performance,load,load,251,"/// For each load extension type and each value type, keep a LegalizeAction; /// that indicates how instruction selection should deal with a load of a; /// specific value type and extension type. Uses 4-bits to store the action; /// for each of the 4 load ext types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Availability,mask,maskedload,164,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:177,Availability,mask,maskedstore,177,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:144,Performance,load,load,144,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:316,Performance,load,load,316,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:55,Performance,Perform,PerformDAGCombine,55,"/// Targets can specify ISD nodes that they would like PerformDAGCombine; /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this; /// array.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:239,Security,access,access,239,"/// For operations that must be promoted to a specific type, this holds the; /// destination type. This map should be sparse, so don't hold it as an; /// array.; ///; /// Targets add entries to this map with AddPromotedToType(..), clients access; /// this with getTypeToPromoteTo(..).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Testability,test,test,45,/// The ISD::CondCode that should be used to test the result of each of the; /// comparison libcall against zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:71,Integrability,depend,dependencies,71,"/// Depth that GatherAllAliases should continue looking for chain; /// dependencies when trying to find a more preferable chain. As an; /// approximation, this should be more than the number of consecutive stores; /// expected to be merged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,Performance,load,load,37,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:167,Performance,load,load,167,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:397,Performance,load,load,397,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:506,Performance,load,loading,506,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:596,Performance,load,load,596,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:615,Performance,load,load,615,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:640,Performance,load,load,640,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:103,Safety,predict,predicted,103,/// Tells the code generator that select is more expensive than a branch if; /// the branch is usually predicted right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:63,Integrability,depend,dependent,63,/// Replace/modify any TargetFrameIndex operands with a targte-dependent; /// sequence of memory operands that is recognized by PrologEpilogInserter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:166,Performance,load,load,166,"/// Returns true by value, base pointer and offset pointer and addressing mode; /// by reference if the node's address can be legally represented as; /// pre-indexed load / store address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:133,Performance,load,load,133,"/// Returns true by value, base pointer and offset pointer and addressing mode; /// by reference if this node can be combined with a load / store to form a; /// post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:174,Performance,load,load,174,"/// Returns true by value, base pointer and offset pointer and addressing mode; /// by reference if this node can be combined with a load / store to form a; /// post-indexed load / store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:116,Performance,load,load,116,/// Returns true if the specified base+offset is a legal indexed addressing; /// mode for this target. \p MI is the load or store instruction that is being; /// considered for transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:59,Availability,error,error,59,"/// Returns a pair of (return value, chain).; /// It is an error to pass RTLIB::UNKNOWN_LIBCALL as \p LC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,Performance,Optimiz,Optimization,98,"//===--------------------------------------------------------------------===//; // TargetLowering Optimization Methods; //; /// A convenience struct that encapsulates a DAG, and two SDValues for; /// returning information from TargetLowering to its clients that want to; /// combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:273,Performance,perform,perform,273,/// Determines the optimal series of memory ops to replace the memset / memcpy.; /// Return true if the number of memory ops is below the threshold (Limit).; /// Note that this is always the case when Limit is ~0.; /// It returns the types of the sequence of memory ops to perform; /// memset / memcpy by reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,"/// Helper wrapper around ShrinkDemandedConstant, demanding all elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:43,Performance,optimiz,optimization,43,"// Target hook to do target-specific const optimization, which is called by; // ShrinkDemandedConstant. This function should return true if the target; // doesn't want ShrinkDemandedConstant to further optimize the constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:202,Performance,optimiz,optimize,202,"// Target hook to do target-specific const optimization, which is called by; // ShrinkDemandedConstant. This function should return true if the target; // doesn't want ShrinkDemandedConstant to further optimize the constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:110,Availability,down,downstream,110,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:334,Availability,mask,mask,334,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:505,Availability,mask,masks,505,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:161,Usability,simpl,simplify,161,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:187,Usability,simpl,simplified,187,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:403,Usability,simpl,simplify,403,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:600,Usability,simpl,simplify,600,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:760,Usability,simpl,simply,760,"/// Look at Op. At this point, we know that only the DemandedBits bits of the; /// result of Op are ever used downstream. If we can use this information to; /// simplify Op, create a new simplified DAG node and return true, returning; /// the original and new nodes in Old and New. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,"/// Helper wrapper around SimplifyDemandedBits, demanding all elements.; /// Adds Op back to the worklist upon success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyDemandedBits,26,"/// Helper wrapper around SimplifyDemandedBits, demanding all elements.; /// Adds Op back to the worklist upon success.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,/// Helper wrapper around SimplifyDemandedBits.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyDemandedBits,26,/// Helper wrapper around SimplifyDemandedBits.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,/// Helper wrapper around SimplifyDemandedBits.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyDemandedBits,26,/// Helper wrapper around SimplifyDemandedBits.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:28,Usability,Simpl,SimplifyDemandedBits,28,"/// More limited version of SimplifyDemandedBits that can be used to ""look; /// through"" ops that don't contribute to the DemandedBits/DemandedElts -; /// bitwise ops etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,"/// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyMultipleUseDemandedBits,26,"/// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all; /// elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,"/// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all; /// bits from only some vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyMultipleUseDemandedBits,26,"/// Helper wrapper around SimplifyMultipleUseDemandedBits, demanding all; /// bits from only some vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:121,Availability,down,downstream,121,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:335,Availability,mask,mask,335,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:172,Usability,simpl,simplify,172,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:198,Usability,simpl,simplified,198,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:410,Usability,simpl,simplify,410,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:616,Usability,simpl,simplify,616,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:776,Usability,simpl,simply,776,"/// Look at Vector Op. At this point, we know that only the DemandedElts; /// elements of the result of Op are ever used downstream. If we can use; /// this information to simplify Op, create a new simplified DAG node and; /// return true, storing the original and new nodes in TLO.; /// Otherwise, analyze the expression and return a mask of KnownUndef and; /// KnownZero elements for the expression (used to simplify the caller).; /// The KnownUndef/Zero elements may only be accurate for those bits; /// in the DemandedMask.; /// \p AssumeSingleUse When this parameter is true, this function will; /// attempt to simplify \p Op even if there are multiple uses.; /// Callers are responsible for correctly updating the DAG based on the; /// results of this function, because simply replacing TLO.Old; /// with TLO.New will be incorrect when this parameter is true and TLO.Old; /// has multiple uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Integrability,wrap,wrapper,11,/// Helper wrapper around SimplifyDemandedVectorElts.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:26,Usability,Simpl,SimplifyDemandedVectorElts,26,/// Helper wrapper around SimplifyDemandedVectorElts.; /// Adds Op back to the worklist upon success.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:39,Usability,simpl,simplifying,39,/// Return true if the target supports simplifying demanded vector elements by; /// converting them to undefs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Availability,Mask,Mask,45,/// Determine which of the bits specified in Mask are known to be either zero; /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts; /// argument allows us to only collect the known bits that are shared by the; /// requested vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Availability,Mask,Mask,45,/// Determine which of the bits specified in Mask are known to be either zero; /// or one and return them in the KnownZero/KnownOne bitsets. The DemandedElts; /// argument allows us to only collect the known bits that are shared by the; /// requested vector elements. This is for GISel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:59,Security,expose,expose,59,/// This method can be implemented by targets that want to expose additional; /// information about sign bits to the DAG Combiner. The DemandedElts; /// argument allows us to only collect the minimum sign bits that are shared; /// by the requested vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:59,Security,expose,expose,59,/// This method can be implemented by targets that want to expose additional; /// information about sign bits to GlobalISel combiners. The DemandedElts; /// argument allows us to only collect the minimum sign bits that are shared; /// by the requested vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Availability,mask,mask,164,"/// Attempt to simplify any target nodes based on the demanded vector; /// elements, returning true on success. Otherwise, analyze the expression and; /// return a mask of KnownUndef and KnownZero elements for the expression; /// (used to simplify the caller). The KnownUndef/Zero elements may only be; /// accurate for those bits in the DemandedMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:15,Usability,simpl,simplify,15,"/// Attempt to simplify any target nodes based on the demanded vector; /// elements, returning true on success. Otherwise, analyze the expression and; /// return a mask of KnownUndef and KnownZero elements for the expression; /// (used to simplify the caller). The KnownUndef/Zero elements may only be; /// accurate for those bits in the DemandedMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:239,Usability,simpl,simplify,239,"/// Attempt to simplify any target nodes based on the demanded vector; /// elements, returning true on success. Otherwise, analyze the expression and; /// return a mask of KnownUndef and KnownZero elements for the expression; /// (used to simplify the caller). The KnownUndef/Zero elements may only be; /// accurate for those bits in the DemandedMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:158,Availability,mask,mask,158,"/// Attempt to simplify any target nodes based on the demanded bits/elts,; /// returning true on success. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:329,Availability,mask,masks,329,"/// Attempt to simplify any target nodes based on the demanded bits/elts,; /// returning true on success. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:15,Usability,simpl,simplify,15,"/// Attempt to simplify any target nodes based on the demanded bits/elts,; /// returning true on success. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:227,Usability,simpl,simplify,227,"/// Attempt to simplify any target nodes based on the demanded bits/elts,; /// returning true on success. Otherwise, analyze the; /// expression and return a mask of KnownOne and KnownZero bits for the; /// expression (used to simplify the caller). The KnownZero/One bits may only; /// be accurate for those bits in the Demanded masks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:28,Usability,Simpl,SimplifyDemandedBits,28,"/// More limited version of SimplifyDemandedBits that can be used to ""look; /// through"" ops that don't contribute to the DemandedBits/DemandedElts -; /// bitwise ops etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:107,Availability,Mask,Mask,107,/// Tries to build a legal vector shuffle using the provided parameters; /// or equivalent variations. The Mask argument maybe be modified as the; /// function tries different variations.; /// Returns an empty SDValue if the operation fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:61,Performance,load,loaded,61,/// This method returns the constant pool value that will be loaded by LD.; /// NOTE: You must check for implicit extensions of the constant by LD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,Modifiability,extend,extended,40,/// Return if \p N is a True value when extended to \p VT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,Usability,simpl,simplify,11,"/// Try to simplify a setcc built with the specified operands and cc. If it is; /// unable to simplify it, return a null SDValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,Usability,simpl,simplify,94,"/// Try to simplify a setcc built with the specified operands and cc. If it is; /// unable to simplify it, return a null SDValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,Integrability,wrap,wrap,21,"// For targets which wrap address, unwrap for analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:463,Performance,perform,perform,463,"/// This method will be invoked for all target nodes and for any; /// target-independent nodes that the target has registered with invoke it; /// for.; ///; /// The semantics are as follows:; /// Return Value:; /// SDValue.Val == 0 - No change was made; /// SDValue.Val == N - N was replaced, is dead, and is already handled.; /// otherwise - N should be replaced by the returned Operand.; ///; /// In addition, methods provided by DAGCombinerInfo may be used to perform; /// more complex transformations.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:51,Performance,perform,perform,51,"/// GlobalISel - return true if it's profitable to perform the combine:; /// shl ([sza]ext x), y => zext (shl x, y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:186,Energy Efficiency,power,power,186,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:76,Performance,optimiz,optimize,76,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:85,Testability,Log,LogicOp,85,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:556,Testability,Log,LogicOp,556,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:568,Testability,log,logic,568,"// Return AndOrSETCCFoldKind::{AddAnd, ABS} if its desirable to try and; // optimize LogicOp(SETCC0, SETCC1). An example (what is implemented as of; // writing this) is:; // With C as a power of 2 and C != 0 and C != INT_MIN:; // AddAnd:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq and(add(A, C), ~(C + C)), 0); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne and(add(A, C), ~(C + C)), 0); // ABS:; // (icmp eq A, C) | (icmp eq A, -C); // -> (icmp eq Abs(A), C); // (icmp ne A, C) & (icmp ne A, -C)w; // -> (icmp ne Abs(A), C); //; // @param LogicOp the logic op; // @param SETCC0 the first of the SETCC nodes; // @param SETCC0 the second of the SETCC nodes",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:59,Testability,log,logical,59,"/// Return true if it is profitable to combine an XOR of a logical shift; /// to create a logical shift of NOT. This transformation may not be desirable; /// if it disrupts a particularly auspicious target-specific tree (e.g.; /// BIC on ARM/AArch64). By default, it returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:90,Testability,log,logical,90,"/// Return true if it is profitable to combine an XOR of a logical shift; /// to create a logical shift of NOT. This transformation may not be desirable; /// if it disrupts a particularly auspicious target-specific tree (e.g.; /// BIC on ARM/AArch64). By default, it returns true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,Performance,load,load,164,/// Return true if it is profitable for dag combiner to transform a floating; /// point op of specified opcode to a equivalent op of an integer; /// type. e.g. f32 load -> i32 load can be profitable on ARM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:176,Performance,load,load,176,/// Return true if it is profitable for dag combiner to transform a floating; /// point op of specified opcode to a equivalent op of an integer; /// type. e.g. f32 load -> i32 load can be profitable on ARM.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:64,Performance,optimiz,optimizes,64,/// Return true if the target supports swifterror attribute. It optimizes; /// loads and stores to reading and writing a specific register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:79,Performance,load,loads,79,/// Return true if the target supports swifterror attribute. It optimizes; /// loads and stores to reading and writing a specific register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Performance,Perform,Perform,4,/// Perform necessary initialization to handle a subset of CSRs explicitly; /// via copies. This function is called at the beginning of instruction; /// selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:34,Safety,avoid,avoid,34,// Remove the new created node to avoid the side effect to the DAG.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:102,Energy Efficiency,Schedul,ScheduleDAGSDNodes,102,"/// Allows the target to handle physreg-carried dependency; /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether; /// to add the edge to the dependency graph.; /// Def - input: Selection DAG node defininfg physical register; /// User - input: Selection DAG node using physical register; /// Op - input: Number of User operand; /// PhysReg - inout: set to the physical register if the edge is; /// necessary, unchanged otherwise; /// Cost - inout: physical register copy cost.; /// Returns 'true' is the edge is necessary, 'false' otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,Integrability,depend,dependency,48,"/// Allows the target to handle physreg-carried dependency; /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether; /// to add the edge to the dependency graph.; /// Def - input: Selection DAG node defininfg physical register; /// User - input: Selection DAG node using physical register; /// Op - input: Number of User operand; /// PhysReg - inout: set to the physical register if the edge is; /// necessary, unchanged otherwise; /// Cost - inout: physical register copy cost.; /// Returns 'true' is the edge is necessary, 'false' otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:167,Integrability,depend,dependency,167,"/// Allows the target to handle physreg-carried dependency; /// in target-specific way. Used from the ScheduleDAGSDNodes to decide whether; /// to add the edge to the dependency graph.; /// Def - input: Selection DAG node defininfg physical register; /// User - input: Selection DAG node using physical register; /// Op - input: Number of User operand; /// PhysReg - inout: set to the physical register if the edge is; /// necessary, unchanged otherwise; /// Cost - inout: physical register copy cost.; /// Returns 'true' is the edge is necessary, 'false' otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:90,Performance,perform,perform,90,// IsTailCall should be modified by implementations of; // TargetLowering::LowerCall that perform tail call conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:186,Performance,perform,performed,186,"/// This hook should be implemented to check whether the return values; /// described by the Outs array can fit into the return registers. If false; /// is returned, an sret-demotion is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:105,Performance,optimiz,optimization,105,/// Return true if the target may be able emit the call instruction as a tail; /// call. This is used by optimization passes to determine if it's profitable; /// to duplicate return instructions to enable tailcall optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:214,Performance,optimiz,optimization,214,/// Return true if the target may be able emit the call instruction as a tail; /// call. This is used by optimization passes to determine if it's profitable; /// to duplicate return instructions to enable tailcall optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:106,Performance,cache,cache,106,/// Return the builtin name for the __builtin___clear_cache intrinsic; /// Default is to invoke the clear cache library call,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:100,Usability,clear,clear,100,/// Return the builtin name for the __builtin___clear_cache intrinsic; /// Default is to invoke the clear cache library call,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:85,Modifiability,variab,variables,85,/// Return the register ID of the name passed in. Used by named register; /// global variables extension. There is no target-independent behaviour; /// so the default action is to bail.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:56,Modifiability,extend,extend,56,"/// Return the type that should be used to zero or sign extend a; /// zeroext/signext integer return value. FIXME: Some C calling conventions; /// require the return type to be promoted, but this is not true all the time,; /// e.g. i1/i8/i16 on x86/x86_64. It is also not necessary for non-C calling; /// conventions. The frontend should handle this and include all of the; /// necessary information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:2,Modifiability,Extend,ExtendKind,2,/*ExtendKind*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:57,Availability,down,down,57,"/// For some targets, an LLVM struct type must be broken down into multiple; /// simple types, but the calling convention specifies that the entire struct; /// must be passed in a block of consecutive registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:81,Usability,simpl,simple,81,"/// For some targets, an LLVM struct type must be broken down into multiple; /// simple types, but the calling convention specifies that the entire struct; /// must be passed in a block of consecutive registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:50,Availability,down,down,50,"/// For most targets, an LLVM type must be broken down into multiple; /// smaller types. Usually the halves are ordered according to the endianness; /// but for some platform that would break. So this method will default to; /// matching the endianness but can be overridden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:58,Safety,safe,safely,58,/// Returns a 0 terminated array of registers that can be safely used as; /// scratch registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:62,Performance,load,load,62,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:134,Performance,load,load,134,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:282,Performance,load,load,282,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:316,Performance,cache,cache-coherent,316,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:340,Performance,perform,performed,340,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:312,Safety,abort,aborts,312,"/// This callback is invoked for operations that are unsupported by the; /// target, which are registered to use 'custom' lowering, and whose defined; /// values are all legal. If the target has no operations that require custom; /// lowering, it need not implement this. The default implementation of this; /// aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:564,Safety,abort,aborts,564,"/// This callback is invoked when a node result type is illegal for the; /// target, and the operation was registered to use 'custom' lowering for that; /// result type. The target places new result values for the node in Results; /// (their number and types must exactly match those of the original return; /// values of the node), or leaves Results empty, which indicates that the; /// node is not to be custom lowered after all.; ///; /// If the target has no operations that require custom lowering, it need not; /// implement this. The default implementation aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:247,Usability,simpl,simple,247,"//===--------------------------------------------------------------------===//; // Inline Asm Support hooks; //; /// This hook allows the target to expand an inline asm call to be explicit; /// llvm code if it wants to. This is useful for turning simple inline asms; /// into LLVM intrinsics, which gives the compiler more information about the; /// behavior of the code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:273,Availability,error,error,273,"/// Split up the constraint string from the inline assembly value into the; /// specific constraints and their prefixes, and also tie in the associated; /// operand values. If this returns an empty vector, and if the constraint; /// string itself isn't empty, there was an error parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:203,Availability,avail,available,203,"/// Determines the constraint code and constraint type to use for the specific; /// AsmOperandInfo, setting OpInfo.ConstraintCode and OpInfo.ConstraintType.; /// If the actual operand being passed in is available, it can be passed in as; /// Op, otherwise an empty SDValue can be passed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:370,Availability,error,error,370,"/// Given a physical register constraint (e.g. {edx}), return the register; /// number and the register class for the register.; ///; /// Given a register class constraint, like 'r', if this corresponds directly; /// to an LLVM register class, return a register of 0 and the register class; /// pointer.; ///; /// This should only be used for C_Register constraints. On error, this; /// returns a register number of 0 and a null register class pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:17,Energy Efficiency,power,power-of-,17,// Build sdiv by power-of-2 with conditional move instructions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:80,Energy Efficiency,power,power-of-,80,"/// Targets may override this function to provide custom SDIV lowering for; /// power-of-2 denominators. If the target returns an empty SDValue, LLVM; /// assumes SDIV is expensive and replaces it with a series of other integer; /// operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:80,Energy Efficiency,power,power-of-,80,"/// Targets may override this function to provide custom SREM lowering for; /// power-of-2 denominators. If the target returns an empty SDValue, LLVM; /// assumes SREM is expensive and replaces it with a series of other integer; /// operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:996,Safety,avoid,avoid,996,"/// Hooks for building estimates in place of slower divisions and square; /// roots.; /// Return either a square root or its reciprocal estimate value for the input; /// operand.; /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or; /// 'Enabled' as set by a potential default override attribute.; /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson; /// refinement iterations required to generate a sufficient (though not; /// necessarily IEEE-754 compliant) estimate is returned in that parameter.; /// The boolean UseOneConstNR output is used to select a Newton-Raphson; /// algorithm implementation that uses either one or two constants.; /// The boolean Reciprocal is used to select whether the estimate is for the; /// square root of the input operand or the reciprocal of its square root.; /// A target may choose to implement its own refinement within this function.; /// If that's true, then return '0' as the number of RefinementSteps to avoid; /// any further refinement of the estimate.; /// An empty SDValue return means no estimate sequence can be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:322,Integrability,depend,dependency,322,"/// Try to convert the fminnum/fmaxnum to a compare/select sequence. This is; /// required for correctness since InstCombine might have canonicalized a; /// fcmp+select sequence to a FMINNUM/FMAXNUM intrinsic. If we were to fall; /// through to the default expansion/soften to libcall, we might introduce a; /// link-time dependency on libm into a file that originally did not have one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:583,Safety,avoid,avoid,583,"/// Return a reciprocal estimate value for the input operand.; /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or; /// 'Enabled' as set by a potential default override attribute.; /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson; /// refinement iterations required to generate a sufficient (though not; /// necessarily IEEE-754 compliant) estimate is returned in that parameter.; /// A target may choose to implement its own refinement within this function.; /// If that's true, then return '0' as the number of RefinementSteps to avoid; /// any further refinement of the estimate.; /// An empty SDValue return means no estimate sequence can be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Integrability,depend,dependent,20,"/// Return a target-dependent comparison result if the input operand is; /// suitable for use with a square root estimate calculation. For example, the; /// comparison may check if the operand is NAN, INF, zero, normal, etc. The; /// result should be used as the condition operand for a select or branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,Integrability,depend,dependent,20,/// Return a target-dependent result if the input operand is not suitable for; /// use with a square root estimate calculation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:120,Performance,perform,performed,120,"/// Expand rotations.; /// \param N Node to expand; /// \param AllowVectorOps expand vector rotate, this should only be performed; /// if the legalization is happening outside of LegalizeVectorOps; /// \returns The expansion if successful, SDValue() otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:161,Performance,perform,perform,161,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:192,Performance,optimiz,optimization,192,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:118,Testability,test,tested,118,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:144,Testability,Test,Test,144,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:153,Testability,test,test,153,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:9,Performance,load,load,9,/// Turn load of vector type into a load of the individual elements.; /// \param LD load to expand; /// \returns BUILD_VECTOR and TokenFactor nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:36,Performance,load,load,36,/// Turn load of vector type into a load of the individual elements.; /// \param LD load to expand; /// \returns BUILD_VECTOR and TokenFactor nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:84,Performance,load,load,84,/// Turn load of vector type into a load of the individual elements.; /// \param LD load to expand; /// \returns BUILD_VECTOR and TokenFactor nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,Performance,load,load,25,"/// Expands an unaligned load to 2 half-size loads for an integer, and; /// possibly more for vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:45,Performance,load,loads,45,"/// Expands an unaligned load to 2 half-size loads for an integer, and; /// possibly more for vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:315,Availability,Mask,Mask,315,"/// Increments memory address \p Addr according to the type of the value; /// \p DataVT that should be stored. If the data is stored in compressed; /// form, the memory address should be incremented according to the number of; /// the stored elements. This number is equal to the number of '1's bits; /// in the \p Mask.; /// \p DataVT is a vector type. \p Mask is a vector value.; /// \p DataVT and \p Mask have the same number of vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:357,Availability,Mask,Mask,357,"/// Increments memory address \p Addr according to the type of the value; /// \p DataVT that should be stored. If the data is stored in compressed; /// form, the memory address should be incremented according to the number of; /// the stored elements. This number is equal to the number of '1's bits; /// in the \p Mask.; /// \p DataVT is a vector type. \p Mask is a vector value.; /// \p DataVT and \p Mask have the same number of vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:403,Availability,Mask,Mask,403,"/// Increments memory address \p Addr according to the type of the value; /// \p DataVT that should be stored. If the data is stored in compressed; /// form, the memory address should be incremented according to the number of; /// the stored elements. This number is equal to the number of '1's bits; /// in the \p Mask.; /// \p DataVT is a vector type. \p Mask is a vector value.; /// \p DataVT and \p Mask have the same number of vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:180,Performance,perform,performed,180,/// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This; /// method accepts integers as its arguments.; /// Note: This method may fail if the division could not be performed; /// within the type. Clients must retry with a wider type if this happens.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:146,Availability,Mask,Mask,146,"/// Legalize a SETCC or VP_SETCC with given LHS and RHS and condition code CC; /// on the current target. A VP_SETCC will additionally be given a Mask; /// and/or EVL not equal to SDValue().; ///; /// If the SETCC has been legalized using AND / OR, then the legalized node; /// will be stored in LHS. RHS and CC will be set to SDValue(). NeedInvert; /// will be set to false. This will also hold if the VP_SETCC has been; /// legalized using VP_AND / VP_OR.; ///; /// If the SETCC / VP_SETCC has been legalized by using; /// getSetCCSwappedOperands(), then the values of LHS and RHS will be; /// swapped, CC will be set to the new condition, and NeedInvert will be set; /// to false.; ///; /// If the SETCC / VP_SETCC has been legalized using the inverse condcode,; /// then LHS and RHS will be unchanged, CC will set to the inverted condcode,; /// and NeedInvert will be set to true. The caller must invert the result of; /// the SETCC with SelectionDAG::getLogicalNOT() or take equivalent action to; /// swap the effect of a true/false result.; ///; /// \returns true if the SETCC / VP_SETCC has been legalized, false if it; /// hasn't.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:128,Security,expose,expose,128,"// seteq(x, 0) -> truncate(srl(ctlz(zext(x)), log2(#bits))); // If we're comparing for equality to zero and isCtlzFast is true, expose the; // fact that this can be implemented as a ctlz/srl pair, so that the dag; // combiner can fold the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h:83,Modifiability,variab,variable,83,/// Return an MCExpr to use for a reference to the specified type info global; /// variable from exception handling information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h:62,Testability,stub,stub,62,/// The mach-o version of this method defaults to returning a stub reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLoweringObjectFileImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h:37,Performance,optimiz,optimization,37,/// \returns true if \p Opcode is an optimization hint opcode which is not; /// supposed to appear after ISel.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:430,Deployability,Configurat,Configuration,430,"//===- TargetPassConfig.h - Code Generation pass options --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Target-Independent Code Generator Pass Configuration Options pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:430,Modifiability,Config,Configuration,430,"//===- TargetPassConfig.h - Code Generation pass options --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Target-Independent Code Generator Pass Configuration Options pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:373,Availability,redundant,redundant,373,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:157,Deployability,configurat,configuration,157,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:133,Energy Efficiency,efficient,efficient,133,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:157,Modifiability,config,configuration,157,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:113,Safety,safe,safer,113,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:280,Safety,unsafe,unsafe,280,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:373,Safety,redund,redundant,373,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:43,Deployability,Configurat,Configuration,43,/// Target-Independent Code Generator Pass Configuration Options.; ///; /// This is an ImmutablePass solely for the purpose of exposing CodeGen options; /// to the internals of other CodeGen passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:43,Modifiability,Config,Configuration,43,/// Target-Independent Code Generator Pass Configuration Options.; ///; /// This is an ImmutablePass solely for the purpose of exposing CodeGen options; /// to the internals of other CodeGen passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:258,Usability,clear,clear,258,"/// Set the StartAfter, StartBefore and StopAfter passes to allow running only; /// a portion of the normal code-gen pass sequence.; ///; /// If the StartAfter and StartBefore pass ID is zero, then compilation will; /// begin at the normal point; otherwise, clear the Started flag to indicate; /// that passes should not be added until the starting pass is seen. If the; /// Stop pass ID is zero, then compilation will continue to the end.; ///; /// This function expects that at least one of the StartAfter or the; /// StartBefore pass IDs is null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:32,Modifiability,config,configured,32,"// Flagged after all passes are configured.; // Target Pass Options; // Targets provide a default setting, user flags override.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:126,Performance,load,load,126,/// Enable sinking of instructions in MachineSink where a computation can be; /// folded into the addressing mode of a memory load/store instruction or; /// replace a copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:127,Deployability,pipeline,pipeline,127,"/// If hasLimitedCodeGenPipeline is true, this method returns; /// a string with the name of the options that caused this; /// pipeline to be limited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:82,Deployability,pipeline,pipeline,82,"/// Allow the target to override a specific pass without overriding the pass; /// pipeline. When passes are added to the standard pipeline at the; /// point where StandardID is expected, add TargetID in its place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:130,Deployability,pipeline,pipeline,130,"/// Allow the target to override a specific pass without overriding the pass; /// pipeline. When passes are added to the standard pipeline at the; /// point where StandardID is expected, add TargetID in its place.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:42,Deployability,pipeline,pipeline,42,/// Return true if the optimized regalloc pipeline is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,Performance,optimiz,optimized,23,/// Return true if the optimized regalloc pipeline is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:269,Availability,error,error,269,"/// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:168,Performance,optimiz,optimization,168,"/// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:41,Deployability,install,install,41,"/// addInstSelector - This method should install an instruction selector pass,; /// which converts from LLVM code to machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,Deployability,install,install,23,"/// This method should install an IR translator pass, which converts from; /// LLVM code to machine instructions with possibly generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,Deployability,install,install,23,"/// This method should install a legalize pass, which converts the instruction; /// sequence into one that can be selected by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,Deployability,install,install,23,"/// This method should install a register bank selector pass, which; /// assigns register banks to virtual registers without a register; /// class or register banks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,Deployability,install,install,23,"/// This method should install a (global) instruction selector pass, which; /// converts possibly generic instructions to fully target-specific; /// instructions, thereby constraining all generic virtual registers to; /// register classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:26,Energy Efficiency,Schedul,ScheduleDAGInstrs,26,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:275,Energy Efficiency,Schedul,ScheduleDAGMI,275,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:306,Energy Efficiency,Schedul,ScheduleDAGMI,306,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:445,Energy Efficiency,schedul,scheduler,445,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:150,Performance,optimiz,optimization,150,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:67,Energy Efficiency,schedul,scheduling,67,/// Similar to createMachineScheduler but used when postRA machine scheduling; /// is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:18,Performance,perform,perform,18,/// Add a pass to perform basic verification of the machine function if; /// verification is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:52,Availability,error,error,52,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:139,Availability,error,erroring,139,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:43,Safety,abort,abort,43,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:18,Deployability,continuous,continuous,18,"/// Check whether continuous CSE should be enabled in GISel passes.; /// By default, it's enabled for non O0 levels.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:56,Performance,optimiz,optimization,56,/// Returns the CSEConfig object to use for the current optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:94,Deployability,pipeline,pipeline,94,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addPreISelPasses - This method should add any ""last minute"" LLVM->LLVM; /// passes (which are run just before instruction selector).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:57,Performance,optimiz,optimize,57,/// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:20,Performance,optimiz,optimize,20,"/// Add passes that optimize instruction level parallelism for out-of-order; /// targets. These passes are run while the machine code is still in SSA; /// form, so they can use MachineTraceMetrics to control their heuristics.; ///; /// All passes added here should preserve the MachineDominatorTree,; /// MachineLoopInfo, and MachineTraceMetrics analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:107,Performance,optimiz,optimization,107,/// createTargetRegisterAllocator - Create the register allocator pass for; /// this target at the current optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:68,Deployability,pipeline,pipeline,68,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:38,Performance,optimiz,optimized,38,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:86,Deployability,pipeline,pipeline,86,/// addPostFastRegAllocRewrite - Add passes to the optimized register; /// allocation pipeline after fast register allocation is complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:51,Performance,optimiz,optimized,51,/// addPostFastRegAllocRewrite - Add passes to the optimized register; /// allocation pipeline after fast register allocation is complete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:106,Deployability,pipeline,pipeline,106,/// This method may be implemented by targets that want to run passes after; /// register allocation pass pipeline but before prolog-epilog insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:139,Energy Efficiency,schedul,scheduling,139,/// This method may be implemented by targets that want to run passes after; /// prolog-epilog insertion and before the second instruction scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:111,Deployability,pipeline,pipeline,111,"/// Utilities for targets to add passes to the pass manager.; ///; /// Add a CodeGen pass at this point in the pipeline after checking overrides.; /// Return the pass that was added, or zero if no pass was added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:415,Integrability,interface,interface,415,"//==- CodeGen/TargetRegisterInfo.h - Target Register Information -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file describes an abstract interface used to get information about a; // target machines register file. This information is used for a variety of; // purposed, especially register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:12,Modifiability,variab,variables,12,"// Instance variables filled by tablegen, do not use!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:4,Modifiability,Config,Configurable,4,/// Configurable target specific flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:257,Energy Efficiency,allocate,allocate,257,"/// Returns the preferred order for allocating registers from this register; /// class in MF. The raw order comes directly from the .td file and may; /// include reserved registers that are not allocatable.; /// Register allocators should also make sure to allocate; /// callee-saved registers only after all the volatiles are used. The; /// RegisterClassInfo class provides filtered allocation orders with; /// callee-saved registers moved to the end.; ///; /// The MachineFunction argument can be used to tune the allocatable; /// registers based on the characteristics of the function, subtarget, or; /// other criteria.; ///; /// By default, this method returns all registers in the class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:507,Performance,tune,tune,507,"/// Returns the preferred order for allocating registers from this register; /// class in MF. The raw order comes directly from the .td file and may; /// include reserved registers that are not allocatable.; /// Register allocators should also make sure to allocate; /// callee-saved registers only after all the volatiles are used. The; /// RegisterClassInfo class provides filtered allocation orders with; /// callee-saved registers moved to the end.; ///; /// The MachineFunction argument can be used to tune the allocatable; /// registers based on the characteristics of the function, subtarget, or; /// other criteria.; ///; /// By default, this method returns all registers in the class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:40,Availability,mask,masks,40,/// Returns the combination of all lane masks of register in this class.; /// The lane masks of the registers are the combination of all lane masks; /// of their subregisters. Returns 1 if there are no subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:87,Availability,mask,masks,87,/// Returns the combination of all lane masks of register in this class.; /// The lane masks of the registers are the combination of all lane masks; /// of their subregisters. Returns 1 if there are no subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:142,Availability,mask,masks,142,/// Returns the combination of all lane masks of register in this class.; /// The lane masks of the registers are the combination of all lane masks; /// of their subregisters. Returns 1 if there are no subregisters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:202,Usability,simpl,simply,202,"/// TargetRegisterInfo base class - We assume that the target defines a static; /// array of TargetRegisterDesc objects that represent all of the machine; /// registers that the target has. As such, we simply have to track a pointer; /// to this array so that we can turn register number into a register; /// descriptor.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:57,Availability,mask,masks,57,"// Names of subreg indexes.; // Pointer to array of lane masks, one per sub-reg index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:406,Energy Efficiency,allocate,allocated,406,"// Register numbers can represent physical registers, virtual registers, and; // sometimes stack slots. The unsigned values are divided into these ranges:; //; // 0 Not a register, can be used as a sentinel.; // [1;2^30) Physical registers assigned by TableGen.; // [2^30;2^31) Stack slots. (Rarely used.); // [2^31;2^32) Virtual registers assigned by MachineRegisterInfo.; //; // Further sentinels can be allocated from the small negative integers.; // DenseMapInfo<unsigned> uses -1u and -2u.; /// Return the size in bits of a register from class RC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:47,Energy Efficiency,allocate,allocated,47,/// Return the size in bytes of the stack slot allocated to hold a spilled; /// copy of a register from class RC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:158,Availability,mask,mask,158,"/// Return a bitmask representing the parts of a register that are covered by; /// SubIdx \see LaneBitmask.; ///; /// SubIdx == 0 is allowed, it has the lane mask ~0u.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:13,Availability,mask,masks,13,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:400,Availability,mask,masks,400,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:772,Availability,mask,mask,772,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:903,Availability,Mask,MaskA,903,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:946,Availability,Mask,MaskB,946,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:998,Availability,Mask,MaskA,998,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:1008,Availability,Mask,MaskB,1008,"/// The lane masks returned by getSubRegIndexLaneMask() above can only be; /// used to determine if sub-registers overlap - they can't be used to; /// determine if a set of sub-registers completely cover another; /// sub-register.; ///; /// The X86 general purpose registers have two lanes corresponding to the; /// sub_8bit and sub_8bit_hi sub-registers. Both sub_32bit and sub_16bit have; /// lane masks '3', but the sub_16bit sub-register doesn't fully cover the; /// sub_32bit sub-register.; ///; /// On the other hand, the ARM NEON lanes fully cover their registers: The; /// dsub_0 sub-register is completely covered by the ssub_0 and ssub_1 lanes.; /// This is related to the CoveredBySubRegs property on register definitions.; ///; /// This function returns a bit mask of lanes that completely cover their; /// sub-registers. More precisely, given:; ///; /// Covering = getCoveringLanes();; /// MaskA = getSubRegIndexLaneMask(SubA);; /// MaskB = getSubRegIndexLaneMask(SubB);; ///; /// If (MaskA & ~(MaskB & Covering)) == 0, then SubA is completely covered by; /// SubB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:256,Availability,down,down,256,"/// Return a null-terminated list of all of the callee-saved registers on; /// this target. The register should be in the order of desired callee-save; /// stack frame offset. The first register is closest to the incoming stack; /// pointer if stack grows down, and vice versa.; /// Notice: This function does not take into account disabled CSRs.; /// In most cases you will want to use instead the function; /// getCalleeSavedRegs that is implemented in MachineRegisterInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:13,Availability,mask,mask,13,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:113,Availability,mask,mask,113,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:280,Availability,mask,mask,280,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:465,Availability,mask,mask,465,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:676,Availability,Mask,Mask,676,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:757,Availability,mask,mask,757,"/// Return a mask of call-preserved registers for the given calling convention; /// on the current function. The mask should include all call-preserved; /// aliases. This is used by the register allocator to determine which; /// registers can be live across a call.; ///; /// The mask is an array containing (TRI::getNumRegs()+31)/32 entries.; /// A set bit indicates that all bits of the corresponding register are; /// preserved across the function call. The bit mask is expected to be; /// sub-register complete, i.e. if A is preserved, so are all its; /// sub-registers.; ///; /// Bits are numbered from the LSB, so the bit for physical register Reg can; /// be found as (Mask[Reg / 32] >> Reg % 32) & 1.; ///; /// A NULL pointer means that no register mask will be used, and call; /// instructions should use implicit-def operands to indicate call clobbered; /// registers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:15,Availability,mask,mask,15,// The default mask clobbers everything. All targets should override.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:22,Availability,mask,mask,22,"/// Return a register mask for the registers preserved by the unwinder,; /// or nullptr if no custom mask is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:101,Availability,mask,mask,101,"/// Return a register mask for the registers preserved by the unwinder,; /// or nullptr if no custom mask is needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:22,Availability,mask,mask,22,/// Return a register mask that clobbers everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:44,Availability,mask,mask,44,/// Return true if all bits that are set in mask \p mask0 are also set in; /// \p mask1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:43,Availability,mask,masks,43,/// Return all the call-preserved register masks defined for this target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:467,Energy Efficiency,allocate,allocated,467,"/// Returns a bitset indexed by physical register number indicating if a; /// register is a special register that has particular uses and should be; /// considered unavailable at all times, e.g. stack pointer, return address.; /// A reserved register:; /// - is not allocatable; /// - is considered always live; /// - is ignored by liveness tracking; /// It is often necessary to reserve the super registers of a reserved; /// register as well, to avoid them getting allocated indirectly. You may use; /// markSuperRegs() and checkAllSuperRegsMarked() in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:448,Safety,avoid,avoid,448,"/// Returns a bitset indexed by physical register number indicating if a; /// register is a special register that has particular uses and should be; /// considered unavailable at all times, e.g. stack pointer, return address.; /// A reserved register:; /// - is not allocatable; /// - is considered always live; /// - is ignored by liveness tracking; /// It is often necessary to reserve the super registers of a reserved; /// register as well, to avoid them getting allocated indirectly. You may use; /// markSuperRegs() and checkAllSuperRegsMarked() in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:203,Deployability,update,updated,203,/// Physical registers that may be modified within a function but are; /// guaranteed to be restored before any uses. This is useful for targets that; /// have call sequences where a GOT register may be updated by the caller; /// prior to a call and is guaranteed to be restored (also by the caller); /// after the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getCallPreservedMask().; /// Return true if the register is preserved after the call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:33,Availability,mask,mask,33,"/// Prior to adding the live-out mask to a stackmap or patchpoint; /// instruction, provide the target the opportunity to adjust it (mainly to; /// remove pseudo-registers that should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:55,Deployability,patch,patchpoint,55,"/// Prior to adding the live-out mask to a stackmap or patchpoint; /// instruction, provide the target the opportunity to adjust it (mainly to; /// remove pseudo-registers that should be ignored).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:201,Availability,Mask,Mask,201,"/// Transform a lanemask given for a virtual register to the corresponding; /// lanemask before using subregister with index \p IdxA.; /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a; /// valie lane mask (no invalid bits set) the following holds:; /// X0 = composeSubRegIndexLaneMask(Idx, Mask); /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0); /// => X1 == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:227,Availability,mask,mask,227,"/// Transform a lanemask given for a virtual register to the corresponding; /// lanemask before using subregister with index \p IdxA.; /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a; /// valie lane mask (no invalid bits set) the following holds:; /// X0 = composeSubRegIndexLaneMask(Idx, Mask); /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0); /// => X1 == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:317,Availability,Mask,Mask,317,"/// Transform a lanemask given for a virtual register to the corresponding; /// lanemask before using subregister with index \p IdxA.; /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a; /// valie lane mask (no invalid bits set) the following holds:; /// X0 = composeSubRegIndexLaneMask(Idx, Mask); /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0); /// => X1 == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:390,Availability,Mask,Mask,390,"/// Transform a lanemask given for a virtual register to the corresponding; /// lanemask before using subregister with index \p IdxA.; /// This is the reverse of composeSubRegIndexLaneMask(), assuming Mask is a; /// valie lane mask (no invalid bits set) the following holds:; /// X0 = composeSubRegIndexLaneMask(Idx, Mask); /// X1 = reverseComposeSubRegIndexLaneMask(Idx, X0); /// => X1 == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:93,Energy Efficiency,schedul,scheduler,93,"/// Return the register pressure ""high water mark"" for the specific register; /// class. The scheduler is in high register pressure mode (for the specific; /// register class) if it goes over the limit.; ///; /// Note: this is the old register pressure model that relies on a manually; /// specified representative register class per value type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:39,Energy Efficiency,schedul,scheduler,39,/// Return a heuristic for the machine scheduler to compare the profitability; /// of increasing one register pressure set versus another. The scheduler; /// will prefer increasing the register pressure of the set which returns; /// the largest value for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:143,Energy Efficiency,schedul,scheduler,143,/// Return a heuristic for the machine scheduler to compare the profitability; /// of increasing one register pressure set versus another. The scheduler; /// will prefer increasing the register pressure of the set which returns; /// the largest value for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:43,Deployability,update,update,43,"/// A callback to allow target a chance to update register allocation hints; /// when a register is ""changed"" (e.g. coalesced) to another register.; /// e.g. On ARM, some virtual registers should target register pairs,; /// if one of pair is coalesced to another register, the allocation hint of; /// the other half of the pair should be changed to point to the new register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:298,Availability,down,down,298,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:96,Energy Efficiency,allocate,allocate,96,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:187,Energy Efficiency,reduce,reduce,187,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:513,Performance,perform,performance,513,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:317,Usability,simpl,simpler,317,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:175,Availability,avail,available,175,/// Allow the target to override the cost of using a callee-saved register for; /// the first time. Default value of 0 means we will use a callee-saved; /// register if it is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:64,Security,access,accesses,64,/// Returns true if the target wants to use frame pointer based accesses to; /// spill to the scavenger emergency spill slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:123,Energy Efficiency,efficient,efficient,123,/// Returns true if the target wants the LocalStackAllocation pass to be run; /// and virtual base registers used for more efficient stack access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:139,Security,access,access,139,/// Returns true if the target wants the LocalStackAllocation pass to be run; /// and virtual base registers used for more efficient stack access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:417,Availability,error,error,417,"/// Last chance recoloring has a high compile time cost especially for; /// targets with a lot of registers.; /// This method is used to decide whether or not \p VirtReg should; /// go through this expensive heuristic.; /// When this target hook is hit, by returning false, there is a high; /// chance that the register allocation will fail altogether (usually with; /// ""ran out of registers"").; /// That said, this error usually points to another problem in the; /// optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:482,Deployability,pipeline,pipeline,482,"/// Last chance recoloring has a high compile time cost especially for; /// targets with a lot of registers.; /// This method is used to decide whether or not \p VirtReg should; /// go through this expensive heuristic.; /// When this target hook is hit, by returning false, there is a high; /// chance that the register allocation will fail altogether (usually with; /// ""ran out of registers"").; /// That said, this error usually points to another problem in the; /// optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:469,Performance,optimiz,optimization,469,"/// Last chance recoloring has a high compile time cost especially for; /// targets with a lot of registers.; /// This method is used to decide whether or not \p VirtReg should; /// go through this expensive heuristic.; /// When this target hook is hit, by returning false, there is a high; /// chance that the register allocation will fail altogether (usually with; /// ""ran out of registers"").; /// That said, this error usually points to another problem in the; /// optimization pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:205,Energy Efficiency,allocate,allocated,205,//===--------------------------------------------------------------------===//; /// Debug information queries.; /// getFrameRegister - This method should return the register used as a base; /// for values allocated in the current stack frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:317,Availability,Mask,Mask,317,"//===----------------------------------------------------------------------===//; // SuperRegClassIterator; //===----------------------------------------------------------------------===//; //; // Iterate over the possible super-registers for a given register class. The; // iterator will visit a list of pairs (Idx, Mask) corresponding to the; // possible classes of super-registers.; //; // Each bit mask will have at least one set bit, and each set bit in Mask; // corresponds to a SuperRC such that:; //; // For all Reg in SuperRC: Reg:Idx is in RC.; //; // The iterator can include (O, RC->getSubClassMask()) as the first entry which; // also satisfies the above requirement, assuming Reg:0 == Reg.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:402,Availability,mask,mask,402,"//===----------------------------------------------------------------------===//; // SuperRegClassIterator; //===----------------------------------------------------------------------===//; //; // Iterate over the possible super-registers for a given register class. The; // iterator will visit a list of pairs (Idx, Mask) corresponding to the; // possible classes of super-registers.; //; // Each bit mask will have at least one set bit, and each set bit in Mask; // corresponds to a SuperRC such that:; //; // For all Reg in SuperRC: Reg:Idx is in RC.; //; // The iterator can include (O, RC->getSubClassMask()) as the first entry which; // also satisfies the above requirement, assuming Reg:0 == Reg.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:459,Availability,Mask,Mask,459,"//===----------------------------------------------------------------------===//; // SuperRegClassIterator; //===----------------------------------------------------------------------===//; //; // Iterate over the possible super-registers for a given register class. The; // iterator will visit a list of pairs (Idx, Mask) corresponding to the; // possible classes of super-registers.; //; // Each bit mask will have at least one set bit, and each set bit in Mask; // corresponds to a SuperRC such that:; //; // For all Reg in SuperRC: Reg:Idx is in RC.; //; // The iterator can include (O, RC->getSubClassMask()) as the first entry which; // also satisfies the above requirement, assuming Reg:0 == Reg.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:20,Availability,mask,mask,20,/// Returns the bit mask of register classes that getSubReg() projects into; /// RC.; /// See TargetRegisterClass::getSubClassMask() for how to use it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:221,Testability,log,logic,221,"//===----------------------------------------------------------------------===//; // BitMaskClassIterator; //===----------------------------------------------------------------------===//; /// This class encapuslates the logic to iterate over bitmask returned by; /// the various RegClass related APIs.; /// E.g., this class can be used to iterate over the subclasses provided by; /// TargetRegisterClass::getSubClassMask or SuperRegClassIterator::getMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:4,Availability,Mask,Mask,4,/// Mask we are iterating over.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:25,Availability,Mask,Mask,25,/// Current chunk of the Mask we are traversing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:94,Availability,Mask,Mask,94,/// Create a BitMaskClassIterator that visits all the register classes; /// represented by \p Mask.; ///; /// \pre \p Mask != nullptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:118,Availability,Mask,Mask,118,/// Create a BitMaskClassIterator that visits all the register classes; /// represented by \p Mask.; ///; /// \pre \p Mask != nullptr,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:504,Availability,avail,available,504,"//===- llvm/CodeGen/TargetSchedule.h - Sched Machine Model ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper around MCSchedModel that allows the interface to; // benefit from information currently only available in TargetInstrInfo.; // Ideally, the scheduling interface would be fully defined in the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:551,Energy Efficiency,schedul,scheduling,551,"//===- llvm/CodeGen/TargetSchedule.h - Sched Machine Model ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper around MCSchedModel that allows the interface to; // benefit from information currently only available in TargetInstrInfo.; // Ideally, the scheduling interface would be fully defined in the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:403,Integrability,wrap,wrapper,403,"//===- llvm/CodeGen/TargetSchedule.h - Sched Machine Model ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper around MCSchedModel that allows the interface to; // benefit from information currently only available in TargetInstrInfo.; // Ideally, the scheduling interface would be fully defined in the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:447,Integrability,interface,interface,447,"//===- llvm/CodeGen/TargetSchedule.h - Sched Machine Model ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper around MCSchedModel that allows the interface to; // benefit from information currently only available in TargetInstrInfo.; // Ideally, the scheduling interface would be fully defined in the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:562,Integrability,interface,interface,562,"//===- llvm/CodeGen/TargetSchedule.h - Sched Machine Model ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a wrapper around MCSchedModel that allows the interface to; // benefit from information currently only available in TargetInstrInfo.; // Ideally, the scheduling interface would be fully defined in the MC layer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:27,Energy Efficiency,schedul,scheduling,27,/// Provide an instruction scheduling machine model to CodeGen passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:29,Performance,Latency,Latency,29,// Resource units per cycle. Latency normalization factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:49,Energy Efficiency,schedul,scheduling,49,/// Initialize the machine model for instruction scheduling.; ///; /// The machine model API keeps a copy of the top-level MCSchedModel table; /// indices and may query TargetSubtargetInfo and TargetInstrInfo to resolve; /// dynamic properties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:73,Energy Efficiency,schedul,scheduling,73,"/// Return true if this machine model includes an instruction-level; /// scheduling model.; ///; /// This is more detailed than the course grain IssueWidth and default; /// latency properties, but separate from the per-cycle itinerary data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:173,Performance,latency,latency,173,"/// Return true if this machine model includes an instruction-level; /// scheduling model.; ///; /// This is more detailed than the course grain IssueWidth and default; /// latency properties, but separate from the per-cycle itinerary data.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:147,Deployability,pipeline,pipeline,147,/// Return true if this machine model includes cycle-to-cycle itinerary; /// data.; ///; /// This models scheduling at each stage in the processor pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:105,Energy Efficiency,schedul,scheduling,105,/// Return true if this machine model includes cycle-to-cycle itinerary; /// data.; ///; /// This models scheduling at each stage in the processor pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:73,Energy Efficiency,schedul,scheduling,73,/// Return true if this machine model includes an instruction-level; /// scheduling model or cycle-to-cycle itinerary data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:44,Energy Efficiency,schedul,scheduled,44,/// Maximum number of micro-ops that may be scheduled per cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:69,Energy Efficiency,schedul,scheduling,69,// Get an iterator into the processor resources consumed by this; // scheduling class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:41,Availability,avail,available,41,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:125,Integrability,depend,dependent,125,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:20,Performance,latency,latency,20,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:99,Performance,latency,latency,99,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:49,Availability,avail,available,49,"/// Compute the instruction latency based on the available machine; /// model.; ///; /// Compute and return the expected latency of this instruction independent of; /// a particular use. computeOperandLatency is the preferred API, but this is; /// occasionally useful to help estimate instruction cost.; ///; /// If UseDefaultDefLatency is false and no new machine sched model is; /// present this method falls back to TII->getInstrLatency with an empty; /// instruction itinerary (this is so we preserve the previous behavior of the; /// if converter after moving it to TargetSchedModel).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:28,Performance,latency,latency,28,"/// Compute the instruction latency based on the available machine; /// model.; ///; /// Compute and return the expected latency of this instruction independent of; /// a particular use. computeOperandLatency is the preferred API, but this is; /// occasionally useful to help estimate instruction cost.; ///; /// If UseDefaultDefLatency is false and no new machine sched model is; /// present this method falls back to TII->getInstrLatency with an empty; /// instruction itinerary (this is so we preserve the previous behavior of the; /// if converter after moving it to TargetSchedModel).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:121,Performance,latency,latency,121,"/// Compute the instruction latency based on the available machine; /// model.; ///; /// Compute and return the expected latency of this instruction independent of; /// a particular use. computeOperandLatency is the preferred API, but this is; /// occasionally useful to help estimate instruction cost.; ///; /// If UseDefaultDefLatency is false and no new machine sched model is; /// present this method falls back to TII->getInstrLatency with an empty; /// instruction itinerary (this is so we preserve the previous behavior of the; /// if converter after moving it to TargetSchedModel).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:11,Integrability,depend,dependency,11,/// Output dependency latency of a pair of defs of the same register.; ///; /// This is typically one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:22,Performance,latency,latency,22,/// Output dependency latency of a pair of defs of the same register.; ///; /// This is typically one cycle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:27,Performance,throughput,throughput,27,/// Compute the reciprocal throughput of the given instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:249,Security,expose,exposed,249,//===----------------------------------------------------------------------===//; ///; /// TargetSubtargetInfo - Generic base class for all target subtargets. All; /// Target-specific options that control code generation and printing should; /// be exposed through a TargetSubtargetInfo-derived class.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:99,Energy Efficiency,schedul,scheduling,99,// AntiDepBreakMode - Type of anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:35,Integrability,depend,dependence,35,// AntiDepBreakMode - Type of anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:74,Performance,perform,performed,74,// AntiDepBreakMode - Type of anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:127,Deployability,Pipeline,Pipelines,127,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:141,Energy Efficiency,schedul,scheduling,141,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:3,Integrability,Interface,Interfaces,3,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:345,Performance,cache,cache,345,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:337,Safety,safe,safe,337,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:60,Energy Efficiency,schedul,scheduler,60,/// Target can subclass this hook to select a different DAG scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:49,Availability,avail,available,49,"/// getRegisterInfo - If register information is available, return it. If; /// not, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:49,Availability,avail,available,49,"/// If the information for the register banks is available, return it.; /// Otherwise return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:137,Availability,Mask,Mask,137,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:352,Availability,Mask,Mask,352,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:375,Availability,mask,mask,375,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:28,Integrability,depend,dependency,28,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:196,Integrability,depend,dependency,196,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:420,Integrability,depend,dependencies,420,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:399,Usability,clear,cleared,399,"/// Returns true if MI is a dependency breaking zero-idiom instruction for the; /// subtarget.; ///; /// This function also sets bits in Mask related to input operands that; /// are not in a data dependency relationship. There is one bit for each; /// machine operand; implicit operands follow explicit operands in the bit; /// representation used for Mask. An empty (i.e. a mask with all bits; /// cleared) means: data dependencies are ""broken"" for all the explicit input; /// machine operands of MI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:287,Availability,mask,mask,287,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:379,Availability,Mask,Mask,379,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:28,Integrability,depend,dependency,28,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:170,Integrability,depend,dependency,170,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:304,Integrability,depend,dependencies,304,"/// Returns true if MI is a dependency breaking instruction for the subtarget.; ///; /// Similar in behavior to `isZeroIdiom`. However, it knows how to identify; /// all dependency breaking instructions (i.e. not just zero-idioms).; /// ; /// As for `isZeroIdiom`, this method returns a mask of ""broken"" dependencies.; /// (See method `isZeroIdiom` for a detailed description of Mask).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:110,Performance,optimiz,optimized,110,"/// Returns true if MI is a candidate for move elimination.; ///; /// A candidate for move elimination may be optimized out at register renaming; /// stage. Subtargets can specify the set of optimizable moves by; /// instantiating tablegen class `IsOptimizableRegisterMove` (see; /// llvm/Target/TargetInstrPredicate.td).; ///; /// SubtargetEmitter is responsible for processing all the definitions of class; /// IsOptimizableRegisterMove, and auto-generate an override for this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:191,Performance,optimiz,optimizable,191,"/// Returns true if MI is a candidate for move elimination.; ///; /// A candidate for move elimination may be optimized out at register renaming; /// stage. Subtargets can specify the set of optimizable moves by; /// instantiating tablegen class `IsOptimizableRegisterMove` (see; /// llvm/Target/TargetInstrPredicate.td).; ///; /// SubtargetEmitter is responsible for processing all the definitions of class; /// IsOptimizableRegisterMove, and auto-generate an override for this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:139,Energy Efficiency,schedul,scheduler,139,"/// True if the subtarget should run MachineScheduler after aggressive; /// coalescing.; ///; /// This currently replaces the SelectionDAG scheduler with the ""source"" order; /// scheduler (though see below for an option to turn this off and use the; /// TargetLowering preference). It does not yet disable the postRA scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:178,Energy Efficiency,schedul,scheduler,178,"/// True if the subtarget should run MachineScheduler after aggressive; /// coalescing.; ///; /// This currently replaces the SelectionDAG scheduler with the ""source"" order; /// scheduler (though see below for an option to turn this off and use the; /// TargetLowering preference). It does not yet disable the postRA scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:317,Energy Efficiency,schedul,scheduler,317,"/// True if the subtarget should run MachineScheduler after aggressive; /// coalescing.; ///; /// This currently replaces the SelectionDAG scheduler with the ""source"" order; /// scheduler (though see below for an option to turn this off and use the; /// TargetLowering preference). It does not yet disable the postRA scheduler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:24,Energy Efficiency,schedul,scheduler,24,/// True if the machine scheduler should disable the TLI preference; /// for preRA scheduling with the source level scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:83,Energy Efficiency,schedul,scheduling,83,/// True if the machine scheduler should disable the TLI preference; /// for preRA scheduling with the source level scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:116,Energy Efficiency,schedul,scheduler,116,/// True if the machine scheduler should disable the TLI preference; /// for preRA scheduling with the source level scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:115,Energy Efficiency,schedul,scheduler,115,"/// True if the subtarget should enable joining global copies.; ///; /// By default this is enabled if the machine scheduler is enabled, but; /// can be overridden.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:39,Energy Efficiency,schedul,scheduler,39,/// True if the subtarget should run a scheduler after register allocation.; ///; /// By default this queries the PostRAScheduling bit in the scheduling model; /// which is the preferred way to influence this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:142,Energy Efficiency,schedul,scheduling,142,/// True if the subtarget should run a scheduler after register allocation.; ///; /// By default this queries the PostRAScheduling bit in the scheduling model; /// which is the preferred way to influence this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:47,Energy Efficiency,schedul,scheduler,47,/// True if the subtarget should run a machine scheduler after register; /// allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:21,Energy Efficiency,schedul,scheduling,21,/// Override generic scheduling policy within a region.; ///; /// This is a convenient way for targets that don't provide any custom; /// scheduling heuristics (no custom MachineSchedStrategy) to make; /// changes to the generic scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:138,Energy Efficiency,schedul,scheduling,138,/// Override generic scheduling policy within a region.; ///; /// This is a convenient way for targets that don't provide any custom; /// scheduling heuristics (no custom MachineSchedStrategy) to make; /// changes to the generic scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:229,Energy Efficiency,schedul,scheduling,229,/// Override generic scheduling policy within a region.; ///; /// This is a convenient way for targets that don't provide any custom; /// scheduling heuristics (no custom MachineSchedStrategy) to make; /// changes to the generic scheduling policy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:59,Energy Efficiency,schedul,schedule,59,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:133,Energy Efficiency,schedul,schedule,133,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:72,Integrability,depend,dependency,72,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:142,Integrability,depend,dependency,142,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:3,Performance,Perform,Perform,3,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:46,Performance,latency,latency,46,"// Perform target-specific adjustments to the latency of a schedule; // dependency.; // If a pair of operands is associated with the schedule dependency, DefOpIdx; // and UseOpIdx are the indices of the operands in Def and Use, respectively.; // Otherwise, either may be -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:111,Energy Efficiency,schedul,scheduling,111,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:47,Integrability,depend,dependence,47,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:86,Performance,perform,performed,86,// For use with PostRAScheduling: get the anti-dependence breaking that should; // be performed before post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:126,Integrability,depend,dependence,126,"// For use with PostRAScheduling: in CriticalPathRCs, return any register; // classes that should only be considered for anti-dependence breaking if they; // are on the critical path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:30,Energy Efficiency,schedul,schedule,30,// Provide an ordered list of schedule DAG mutations for the post-RA; // scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:73,Energy Efficiency,schedul,scheduler,73,// Provide an ordered list of schedule DAG mutations for the post-RA; // scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:73,Deployability,pipeline,pipeliner,73,// Provide an ordered list of schedule DAG mutations for the machine; // pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:30,Energy Efficiency,schedul,schedule,30,// Provide an ordered list of schedule DAG mutations for the machine; // pipeliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:98,Energy Efficiency,schedul,scheduling,98,// For use with PostRAScheduling: get the minimum optimization level needed; // to enable post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:50,Performance,optimiz,optimization,50,// For use with PostRAScheduling: get the minimum optimization level needed; // to enable post-RA scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:196,Performance,tune,tune,196,"/// True if the subtarget should run the local reassignment; /// heuristic of the register allocator.; /// This heuristic may be compile time intensive, \p OptLevel provides; /// a finer grain to tune the register allocator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:72,Energy Efficiency,schedul,scheduling,72,"/// Enable use of alias analysis during code generation (during MI; /// scheduling, DAGCombine, etc.).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:41,Performance,load,loaded,41,/// This is called after a .mir file was loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:141,Energy Efficiency,allocate,allocate,141,"/// True if the register allocator should use the allocation orders exactly as; /// written in the tablegen descriptions, false if it should allocate; /// the specified physical register later if is it callee-saved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:94,Availability,redundant,redundant,94,/// Enable spillage copy elimination in MachineCopyPropagation pass. This; /// helps removing redundant copies generated by register allocator when; /// handling complex eviction chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:94,Safety,redund,redundant,94,/// Enable spillage copy elimination in MachineCopyPropagation pass. This; /// helps removing redundant copies generated by register allocator when; /// handling complex eviction chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h:555,Integrability,interface,interface,555,"//===- llvm/CodeGen/TileShapeInfo.h - ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Shape utility for AMX.; /// AMX hardware requires to config the shape of tile data register before use.; /// The 2D shape includes row and column. In AMX intrinsics interface the shape; /// is passed as 1st and 2nd parameter and they are lowered as the 1st and 2nd; /// machine operand of AMX pseudo instructions. ShapeT class is to facilitate; /// tile config and register allocator. The row and column are machine operand; /// of AMX pseudo instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h:443,Modifiability,config,config,443,"//===- llvm/CodeGen/TileShapeInfo.h - ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Shape utility for AMX.; /// AMX hardware requires to config the shape of tile data register before use.; /// The 2D shape includes row and column. In AMX intrinsics interface the shape; /// is passed as 1st and 2nd parameter and they are lowered as the 1st and 2nd; /// machine operand of AMX pseudo instructions. ShapeT class is to facilitate; /// tile config and register allocator. The row and column are machine operand; /// of AMX pseudo instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h:744,Modifiability,config,config,744,"//===- llvm/CodeGen/TileShapeInfo.h - ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Shape utility for AMX.; /// AMX hardware requires to config the shape of tile data register before use.; /// The 2D shape includes row and column. In AMX intrinsics interface the shape; /// is passed as 1st and 2nd parameter and they are lowered as the 1st and 2nd; /// machine operand of AMX pseudo instructions. ShapeT class is to facilitate; /// tile config and register allocator. The row and column are machine operand; /// of AMX pseudo instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TileShapeInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h:558,Performance,perform,performs,558,"//===-- UnreachableBlockElim.h - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h:407,Usability,simpl,simple,407,"//===-- UnreachableBlockElim.h - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h:429,Usability,Simpl,SimplifyCFG,429,"//===-- UnreachableBlockElim.h - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h:569,Usability,simpl,simple,569,"//===-- UnreachableBlockElim.h - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:4,Modifiability,Extend,Extended,4,"/// Extended Value Type. Capable of holding value types which are not native; /// for any processor (such as the i12345 type), as well as the types an MVT; /// can represent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:76,Performance,scalab,scalable,76,"/// Test if the given EVT has zero size, this will fail if called on a; /// scalable type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:4,Testability,Test,Test,4,"/// Test if the given EVT has zero size, this will fail if called on a; /// scalable type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:57,Modifiability,extend,extended,57,/// Test if the given EVT is simple (as opposed to being extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:4,Testability,Test,Test,4,/// Test if the given EVT is simple (as opposed to being extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:29,Usability,simpl,simple,29,/// Test if the given EVT is simple (as opposed to being extended).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:29,Modifiability,extend,extended,29,/// Test if the given EVT is extended (as opposed to being simple).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:4,Testability,Test,Test,4,/// Test if the given EVT is extended (as opposed to being simple).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:59,Usability,simpl,simple,59,/// Test if the given EVT is extended (as opposed to being simple).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:82,Integrability,depend,dependent,82,/// Return true if this is a vector type where the runtime; /// length is machine dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:82,Integrability,depend,dependent,82,/// Return true if this is a vector type where the runtime; /// length is machine dependent,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:33,Performance,scalab,scalable,33,/// Return true if the type is a scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:33,Energy Efficiency,power,power-of-two,33,/// Return true if the size is a power-of-two number of bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:15,Usability,Simpl,SimpleValueType,15,/// Return the SimpleValueType held in the specified simple EVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:53,Usability,simpl,simple,53,/// Return the SimpleValueType held in the specified simple EVT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:21,Performance,scalab,scalable,21,"// Given a (possibly scalable) vector type, return the ElementCount",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:90,Performance,scalab,scalable,90,"/// Return the size of the specified value type in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:116,Performance,scalab,scalable,116,"/// Return the size of the specified value type in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:114,Performance,scalab,scalable,114,/// Return the size of the specified fixed width value type in bits. The; /// function will assert if the type is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:92,Testability,assert,assert,92,/// Return the size of the specified fixed width value type in bits. The; /// function will assert if the type is scalable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:121,Performance,scalab,scalable,121,"/// Return the number of bytes overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:147,Performance,scalab,scalable,147,"/// Return the number of bytes overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:120,Performance,scalab,scalable,120,"/// Return the number of bits overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:146,Performance,scalab,scalable,146,"/// Return the number of bits overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:68,Energy Efficiency,power,power,68,"/// Rounds the bit-width of the given integer EVT up to the nearest power of; /// two (and at least to eight), and returns the integer EVT with that; /// number of bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:153,Modifiability,extend,extended,153,"/// Finds the smallest simple value type that is greater than or equal to; /// half the width of this EVT. If no simple value type can be found, an; /// extended integer value type of half the size (rounded up) is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:23,Usability,simpl,simple,23,"/// Finds the smallest simple value type that is greater than or equal to; /// half the width of this EVT. If no simple value type can be found, an; /// extended integer value type of half the size (rounded up) is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:113,Usability,simpl,simple,113,"/// Finds the smallest simple value type that is greater than or equal to; /// half the width of this EVT. If no simple value type can be found, an; /// extended integer value type of half the size (rounded up) is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:116,Modifiability,extend,extended,116,/// Return a VT for an integer vector type with the size of the; /// elements doubled. The typed returned may be an extended type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:129,Modifiability,extend,extended,129,// Return a VT for a vector type with the same element type but; // half the number of elements. The type returned may be an; // extended type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:131,Modifiability,extend,extended,131,// Return a VT for a vector type with the same element type but; // double the number of elements. The type returned may be an; // extended type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:42,Energy Efficiency,power,power,42,/// Returns true if the given vector is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:64,Energy Efficiency,power,power,64,/// Widens the length of the given vector EVT up to the nearest power of 2; /// and returns that type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:153,Safety,abort,abort,153,"/// This method returns an LLVM type corresponding to the specified EVT.; /// For integer types, this returns an unsigned type. Note that this will; /// abort for types that cannot be represented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:152,Integrability,depend,dependency,152,// Methods for handling the Extended-type case in functions above.; // These are all out-of-line to prevent users of this header file; // from having a dependency on Type.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:28,Modifiability,Extend,Extended-type,28,// Methods for handling the Extended-type case in functions above.; // These are all out-of-line to prevent users of this header file; // from having a dependency on Type.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:542,Deployability,update,updated,542,"//===- llvm/CodeGen/VirtRegMap.h - Virtual Register Map ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a virtual register map. This maps virtual registers to; // physical registers and virtual registers to stack slots. It is created and; // updated by a register allocator and then used by a machine code rewriter that; // adds spill code and rewrites virtual into physical register references.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:606,Modifiability,rewrite,rewriter,606,"//===- llvm/CodeGen/VirtRegMap.h - Virtual Register Map ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a virtual register map. This maps virtual registers to; // physical registers and virtual registers to stack slots. It is created and; // updated by a register allocator and then used by a machine code rewriter that; // adds spill code and rewrites virtual into physical register references.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:644,Modifiability,rewrite,rewrites,644,"//===- llvm/CodeGen/VirtRegMap.h - Virtual Register Map ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a virtual register map. This maps virtual registers to; // physical registers and virtual registers to stack slots. It is created and; // updated by a register allocator and then used by a machine code rewriter that; // adds spill code and rewrites virtual into physical register references.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:239,Performance,load,load,239,/// Virt2PhysMap - This is a virtual to physical register; /// mapping. Each virtual register is required to have an entry in; /// it; even spilled virtual registers (the register mapped to a; /// spilled register is the temporary used to load it from the; /// stack).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:22,Energy Efficiency,Allocate,Allocate,22,/// createSpillSlot - Allocate a spill slot for RC from MFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:4,Usability,clear,clears,4,"/// clears the specified virtual register's, physical; /// register mapping",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:4,Usability,clear,clears,4,/// clears all virtual to physical register mappings,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:72,Availability,avail,available,72,/// create a mapping for the specifed virtual register to; /// the next available stack slot,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:45,Energy Efficiency,Schedul,Scheduling,45,"//===- VLIWMachineScheduler.h - VLIW-Focused Scheduling Pass ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:62,Energy Efficiency,schedul,scheduler,62,/// Local packet/bundle model. Purely; /// internal to the MI scheduler at the time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:24,Energy Efficiency,Schedul,ScheduleDAGMILive,24,/// Extend the standard ScheduleDAGMILive to provide more context and override; /// the top-level schedule() driver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:98,Energy Efficiency,schedul,schedule,98,/// Extend the standard ScheduleDAGMILive to provide more context and override; /// the top-level schedule() driver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:4,Modifiability,Extend,Extend,4,/// Extend the standard ScheduleDAGMILive to provide more context and override; /// the top-level schedule() driver.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:4,Energy Efficiency,Schedul,Schedule,4,/// Schedule - This is called back from ScheduleDAGInstrs::Run() when it's; /// time to do some work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:40,Energy Efficiency,Schedul,ScheduleDAGInstrs,40,/// Schedule - This is called back from ScheduleDAGInstrs::Run() when it's; /// time to do some work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:8,Energy Efficiency,schedul,scheduling,8,// Best scheduling cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:63,Performance,queue,queue,63,/// Represent the type of SchedCandidate found within a single queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:9,Energy Efficiency,Schedul,Scheduling,9,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:54,Performance,queue,queues,54,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:165,Safety,hazard,hazards,165,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:184,Safety,interlock,interlocks,184,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:184,Security,interlock,interlocks,184,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:41,Availability,avail,available,41,/// MinReadyCycle - Cycle of the soonest available instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:37,Performance,latency,latency,37,// Remember the greatest min operand latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:19,Modifiability,extend,extend,19,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:12,Performance,queue,queues,12,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:36,Performance,queue,queues,36,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:64,Energy Efficiency,schedul,scheduling,64,"// Initialize the critical path length limit, which used by the scheduling; // cost model to determine the value for scheduling an instruction. We use; // a slightly different heuristic for small and large functions. For small; // functions, it's important to use the height/depth of the instruction.; // For large functions, prioritizing by height or depth increases spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:117,Energy Efficiency,schedul,scheduling,117,"// Initialize the critical path length limit, which used by the scheduling; // cost model to determine the value for scheduling an instruction. We use; // a slightly different heuristic for small and large functions. For small; // functions, it's important to use the height/depth of the instruction.; // For large functions, prioritizing by height or depth increases spills.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:55,Energy Efficiency,reduce,reduce,55,"// We divide by two as a cheap and simple heuristic to reduce the; // critcal path length, which increases the priority of using the graph; // height/depth in the scheduler's cost computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:163,Energy Efficiency,schedul,scheduler,163,"// We divide by two as a cheap and simple heuristic to reduce the; // critcal path length, which increases the priority of using the graph; // height/depth in the scheduler's cost computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:35,Usability,simpl,simple,35,"// We divide by two as a cheap and simple heuristic to reduce the; // critcal path length, which increases the priority of using the graph; // height/depth in the scheduler's cost computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:31,Energy Efficiency,schedul,scheduled,31,// State of the top and bottom scheduled instruction boundaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:56,Availability,avail,available,56,"/// Original IR callsite corresponding to this call, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:39,Performance,optimiz,optimized,39,/// True if the call must be tail call optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:77,Performance,optimiz,optimization,77,/// True if the call passes all target-independent checks for tail call; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:397,Integrability,depend,depend,397,"/// Argument handling is mostly uniform between the four places that; /// make these decisions: function formal arguments, call; /// instruction args, call instruction returns and function; /// returns. However, once a decision has been made on where an; /// argument should go, exactly what happens can vary slightly. This; /// class abstracts the differences.; ///; /// ValueAssigner should not depend on any specific function state, and; /// only determine the types and locations for arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:35,Integrability,depend,depending,35,// Some targets change the handler depending on whether the call is; // varargs or not. If,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:4,Integrability,Wrap,Wrap,4,/// Wrap call to (typically tablegenerated CCAssignFn). This may be; /// overridden to track additional state information as arguments are; /// assigned or apply target specific hacks around the legacy; /// infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:30,Energy Efficiency,allocate,allocated,30,/// The size of the currently allocated portion of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:47,Integrability,depend,depending,47,/// Select the appropriate assignment function depending on whether this is; /// a variadic call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:157,Integrability,depend,depending,157,"/// Materialize a VReg containing the address of the specified; /// stack-based object. This is either based on a FrameIndex or; /// direct SP manipulation, depending on the context. \p MPO; /// should be initialized to an appropriate description of the; /// address created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:100,Energy Efficiency,allocate,allocated,100,/// Return the in-memory size to write for the argument at \p VA. This may; /// be smaller than the allocated stack slot size.; ///; /// This is overridable primarily for targets to maintain compatibility with; /// hacks around the existing DAG call lowering infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:68,Performance,Load,Load,68,"/// The specified value has been assigned to a stack; /// location. Load or store it there, with appropriate extension; /// if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:4,Modifiability,Extend,Extend,4,"/// Extend a register to the location type given in VA, capped at extending; /// to at most MaxSize bits. If MaxSizeBits is 0 then no maximum is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:66,Modifiability,extend,extending,66,"/// Extend a register to the location type given in VA, capped at extending; /// to at most MaxSize bits. If MaxSizeBits is 0 then no maximum is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:160,Availability,down,down,160,"/// Break \p OrigArgInfo into one or more pieces the calling convention can; /// process, returned in \p SplitArgs. For example, this should break structs; /// down into individual fields.; ///; /// If \p Offsets is non-null, it points to a vector to be filled in; /// with the in-memory offsets of each of the individual values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:130,Modifiability,extend,extended,130,/// \return true if the target is capable of handling swifterror values that; /// have been promoted to a specified register. The extended versions of; /// lowerReturn and lowerCall should be implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:4,Performance,Load,Load,4,/// Load the returned value from the stack into virtual registers in \p VRegs.; /// It uses the frame index \p FI and the start offset from \p DemoteReg.; /// The loaded data size will be determined from \p RetTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:163,Performance,load,loaded,163,/// Load the returned value from the stack into virtual registers in \p VRegs.; /// It uses the frame index \p FI and the start offset from \p DemoteReg.; /// The loaded data size will be determined from \p RetTy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:86,Performance,perform,performing,86,/// \return True if the return type described by \p Outs can be returned; /// without performing sret demotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:163,Performance,perform,performing,163,/// Toplevel function to check the return type based on the target calling; /// convention. \return True if the return value of \p MF can be returned; /// without performing sret demotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:177,Performance,perform,performed,177,"/// This hook must be implemented to check whether the return values; /// described by \p Outs can fit into the return registers. If false; /// is returned, an sret-demotion is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:29,Modifiability,extend,extended,29,"/// This hook behaves as the extended lowerReturn function, but for targets; /// that do not support swifterror value promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:501,Modifiability,inherit,inherits,501,"//== ----- llvm/CodeGen/GlobalISel/Combiner.h -------------------*- C++ -*-== //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This contains the base class for all Combiners generated by TableGen.; /// Backends need to create class that inherits from ""Combiner"" and put all of; /// the TableGen-erated code in there, as it implements the virtual functions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:131,Safety,Avoid,Avoid,131,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:82,Security,expose,expose,82,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:242,Security,access,accessed,242,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:270,Security,Access,Accessing,270,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:26,Modifiability,extend,extend,26,// The result type of the extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:83,Performance,load,load,83,// True if Offset is a constant that needs to be; // rematerialized before the new load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:16,Modifiability,extend,extend,16,"/// If \p MI is extend that consumes the result of a load, try to combine it.; /// Returns true if MI changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:53,Performance,load,load,53,"/// If \p MI is extend that consumes the result of a load, try to combine it.; /// Returns true if MI changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:25,Availability,mask,mask,25,"/// Match (and (load x), mask) -> zextload x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:16,Performance,load,load,16,"/// Match (and (load x), mask) -> zextload x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:40,Performance,load,load,40,/// Combine a G_EXTRACT_VECTOR_ELT of a load into a narrowed; /// load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:66,Performance,load,load,66,/// Combine a G_EXTRACT_VECTOR_ELT of a load into a narrowed; /// load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:21,Performance,load,load,21,"/// Match sext_inreg(load p), imm -> sextload p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Performance,Optimiz,Optimize,4,"/// Optimize memcpy intrinsics et al, e.g. constant len calls.; /// /p MaxLen if non-zero specifies the max length of a mem libcall to inline.; ///; /// For example (pre-indexed):; ///; /// $addr = G_PTR_ADD $base, $offset; /// [...]; /// $val = G_LOAD $addr; /// [...]; /// $whatever = COPY $addr; ///; /// -->; ///; /// $val, $addr = G_INDEXED_LOAD $base, $offset, 1 (IsPre); /// [...]; /// $whatever = COPY $addr; ///; /// or (post-indexed):; ///; /// G_STORE $val, $base; /// [...]; /// $addr = G_PTR_ADD $base, $offset; /// [...]; /// $whatever = COPY $addr; ///; /// -->; ///; /// $addr = G_INDEXED_STORE $val, $base, $offset; /// [...]; /// $whatever = COPY $addr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:48,Testability,log,logic,48,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:207,Testability,log,logic,207,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:30,Energy Efficiency,power,power-of-,30,/// Transform a multiply by a power-of-2 value to a left shift.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:29,Modifiability,extend,extended,29,// Transform a G_SHL with an extended source into a narrower shift if; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce a shift by a constant to an unmerge and a shift on a half sized; /// type. This will not produce a shift smaller than \p TargetShiftSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:69,Availability,mask,mask,69,/// Return true if a G_SHUFFLE_VECTOR instruction \p MI has an undef mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Performance,Optimiz,Optimize,4,/// Optimize (cond ? x : x) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Performance,Optimiz,Optimize,4,/// Optimize (x op x) -> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:47,Energy Efficiency,power,power,47,/// Check if operand \p OpIdx is known to be a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:46,Usability,simpl,simplified,46,/// Return true if MI is a G_ADD which can be simplified to a G_SUB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:29,Energy Efficiency,power,power,29,"/// Combine G_UREM x, (known power of 2) to an add and bitmasking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:214,Performance,load,load,214,/// Match expression trees of the form; ///; /// \code; /// sN *a = ...; /// sM val = a[0] | (a[1] << N) | (a[2] << 2N) | (a[3] << 3N) ...; /// \endcode; ///; /// And check if the tree can be replaced with a M-bit load + possibly a; /// bswap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:56,Performance,perform,perform,56,"/// Use a function which takes in a MachineIRBuilder to perform a combine.; /// By default, it erases the instruction \p MI from the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:56,Performance,perform,perform,56,/// Use a function which takes in a MachineIRBuilder to perform a combine.; /// This variant does not erase \p MI after calling the build function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:30,Availability,mask,mask,30,"/// Match: and (lshr x, cst), mask -> ubfx x, cst, width",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:47,Security,expose,exposed,47,/// Do constant folding when opportunities are exposed after MIR building.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:47,Security,expose,exposed,47,/// Do constant folding when opportunities are exposed after MIR building.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:50,Security,expose,exposed,50,/// Do constant FP folding when opportunities are exposed after MIR building.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:175,Energy Efficiency,Power,PowerPC,175,"/// Given an G_UDIV \p MI expressing a divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:201,Usability,Guid,Guide,201,"/// Given an G_UDIV \p MI expressing a divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:182,Energy Efficiency,Power,PowerPC,182,"/// Given an G_SDIV \p MI expressing a signed divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:208,Usability,Guid,Guide,208,"/// Given an G_SDIV \p MI expressing a signed divide by constant, return an; /// expression that implements it by multiplying by a magic number.; /// Ref: ""Hacker's Delight"" or ""The PowerPC Compiler Writer's Guide"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:9,Performance,load,loads,9,"/// Emit loads and stores that perform the given memcpy.; /// Assumes \p MI is a G_MEMCPY_INLINE; /// TODO: implement dynamically sized inline memcpy,; /// and rename: s/bool tryEmit/void emit/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:31,Performance,perform,perform,31,"/// Emit loads and stores that perform the given memcpy.; /// Assumes \p MI is a G_MEMCPY_INLINE; /// TODO: implement dynamically sized inline memcpy,; /// and rename: s/bool tryEmit/void emit/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:39,Usability,simpl,simplify,39,/// \returns true if it is possible to simplify a select instruction \p MI; /// to a min/max instruction of some sort.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:24,Performance,load,load,24,"/// Given a non-indexed load or store instruction \p MI, find an offset that; /// can be usefully and legally folded into it as a post-indexing operation.; ///; /// \returns true if a candidate is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:24,Performance,load,load,24,"/// Given a non-indexed load or store instruction \p MI, find an offset that; /// can be usefully and legally folded into it as a pre-indexing operation.; ///; /// \returns true if a candidate is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:106,Performance,load,load,106,/// Helper function for matchLoadOrCombine. Searches for Registers; /// which may have been produced by a load instruction + some arithmetic.; ///; /// \param [in] Root - The search root.; ///; /// \returns The Registers found during the search.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:113,Performance,load,load,113,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:222,Performance,load,load,222,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:263,Performance,load,load,263,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:326,Performance,load,load,326,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:412,Performance,load,load,412,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:460,Performance,load,load,460,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:67,Performance,perform,performing,67,/// Examines the G_PTR_ADD instruction \p PtrAdd and determines if performing; /// a re-association of its operands would break an existing legal addressing; /// mode that the address computation currently represents.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:27,Testability,log,logical,27,/// Try to fold selects to logical operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:12,Performance,optimiz,optimizations,12,/// Whether optimizations should be enabled. This is to distinguish between; /// uses of the combiner unconditionally and only when optimizations are; /// specifically enabled/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:132,Performance,optimiz,optimizations,132,/// Whether optimizations should be enabled. This is to distinguish between; /// uses of the combiner unconditionally and only when optimizations are; /// specifically enabled/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:18,Performance,optimiz,optimizing,18,/// Whether we're optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:18,Performance,optimiz,optimizing,18,/// Whether we're optimizing for minsize (-Oz).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:407,Deployability,continuous,continuously,407,"//===- llvm/CodeGen/GlobalISel/CSEInfo.h ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Provides analysis for continuously CSEing during GISel passes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:17,Integrability,wrap,wraps,17,/// A class that wraps MachineInstrs and derives from FoldingSetNode in order to; /// be uniqued in a CSEMap. The tradeoff here is extra memory allocations for; /// UniqueMachineInstr vs making MachineInstr bigger.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:9,Modifiability,config,config,9,// A CSE config for fully optimized builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:26,Performance,optimiz,optimized,26,// A CSE config for fully optimized builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:24,Modifiability,config,config,24,// Commonly used for O0 config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:270,Integrability,depend,depend,270,"// Returns the standard expected CSEConfig for the given optimization level.; // We have this logic here so targets can make use of it from their derived; // TargetPassConfig, but can't put this logic into TargetPassConfig directly; // because the CodeGen library can't depend on GlobalISel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:57,Performance,optimiz,optimization,57,"// Returns the standard expected CSEConfig for the given optimization level.; // We have this logic here so targets can make use of it from their derived; // TargetPassConfig, but can't put this logic into TargetPassConfig directly; // because the CodeGen library can't depend on GlobalISel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:94,Testability,log,logic,94,"// Returns the standard expected CSEConfig for the given optimization level.; // We have this logic here so targets can make use of it from their derived; // TargetPassConfig, but can't put this logic into TargetPassConfig directly; // because the CodeGen library can't depend on GlobalISel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:195,Testability,log,logic,195,"// Returns the standard expected CSEConfig for the given optimization level.; // We have this logic here so targets can make use of it from their derived; // TargetPassConfig, but can't put this logic into TargetPassConfig directly; // because the CodeGen library can't depend on GlobalISel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:39,Deployability,install,installs,39,"/// The CSE Analysis object.; /// This installs itself as a delegate to the MachineFunction to track; /// new instructions as well as deletions. It however will not be able to; /// track instruction mutations. In such cases, recordNewInstruction should be; /// called (for eg inside MachineIRBuilder::recordInsertion).; /// Also because of how just the instruction can be inserted without adding any; /// operands to the instruction, instructions are uniqued and inserted lazily.; /// CSEInfo should assert when trying to enter an incomplete instruction into; /// the CSEMap. There is Opcode level granularity on which instructions can be; /// CSE'd and for now, only Generic instructions are CSEable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:500,Testability,assert,assert,500,"/// The CSE Analysis object.; /// This installs itself as a delegate to the MachineFunction to track; /// new instructions as well as deletions. It however will not be able to; /// track instruction mutations. In such cases, recordNewInstruction should be; /// called (for eg inside MachineIRBuilder::recordInsertion).; /// Also because of how just the instruction can be inserted without adding any; /// operands to the instruction, instructions are uniqued and inserted lazily.; /// CSEInfo should assert when trying to enter an incomplete instruction into; /// the CSEMap. There is Opcode level granularity on which instructions can be; /// CSE'd and for now, only Generic instructions are CSEable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:11,Security,access,accessible,11,// Make it accessible only to CSEMIRBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:11,Performance,cache,cache,11,"/// Keep a cache of UniqueInstrs for each MachineInstr. In GISel,; /// often instructions are mutated (while their ID has completely changed).; /// Whenever mutation happens, invalidate the UniqueMachineInstr for the; /// MachineInstr",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:160,Safety,avoid,avoid,160,"/// Store instructions that are not fully formed in TemporaryInsts.; /// Also because CSE insertion happens lazily, we can remove insts from this; /// list and avoid inserting and then removing from the CSEMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:16,Testability,assert,asserts,16,// Only used in asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and construct a new UniqueMachineInstr for MI and return.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:23,Energy Efficiency,allocate,allocate,23,/// Use this method to allocate a new UniqueMachineInstr for MI and insert it; /// into the CSEMap. MI should return true for shouldCSE(MI->getOpcode()),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:260,Security,hash,hashing,260,"/// Records a newly created inst in a list and lazily insert it to the CSEMap.; /// Sometimes, this method might be called with a partially constructed; /// MachineInstr,; // (right after BuildMI without adding any operands) - and in such cases,; // defer the hashing of the instruction to a later stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:3,Usability,Simpl,Simple,3,// Simple builder class to easily profile properties about MIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:136,Deployability,configurat,configuration,136,/// Simple wrapper that does the following.; /// 1) Lazily evaluate the MachineFunction to compute CSEable instructions.; /// 2) Allows configuration of which instructions are CSEd through CSEConfig; /// object. Provides a method called get which takes a CSEConfig object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:11,Integrability,wrap,wrapper,11,/// Simple wrapper that does the following.; /// 1) Lazily evaluate the MachineFunction to compute CSEable instructions.; /// 2) Allows configuration of which instructions are CSEd through CSEConfig; /// object. Provides a method called get which takes a CSEConfig object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:136,Modifiability,config,configuration,136,/// Simple wrapper that does the following.; /// 1) Lazily evaluate the MachineFunction to compute CSEable instructions.; /// 2) Allows configuration of which instructions are CSEd through CSEConfig; /// object. Provides a method called get which takes a CSEConfig object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:4,Usability,Simpl,Simple,4,/// Simple wrapper that does the following.; /// 1) Lazily evaluate the MachineFunction to compute CSEable instructions.; /// 2) Allows configuration of which instructions are CSEd through CSEConfig; /// object. Provides a method called get which takes a CSEConfig object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:29,Integrability,wrap,wrapper,29,/// The actual analysis pass wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:334,Testability,assert,assert,334,"/// Defines a builder that does CSE of MachineInstructions using GISelCSEInfo.; /// Eg usage.; ///; ///; /// GISelCSEInfo *Info =; /// &getAnalysis<GISelCSEAnalysisWrapperPass>().getCSEInfo(); CSEMIRBuilder; /// CB(Builder.getState()); CB.setCSEInfo(Info); auto A = CB.buildConstant(s32,; /// 42); auto B = CB.buildConstant(s32, 42); assert(A == B); unsigned CReg =; /// MRI.createGenericVirtualRegister(s32); auto C = CB.buildConstant(CReg, 42);; /// assert(C->getOpcode() == TargetOpcode::COPY);; /// Explicitly passing in a register would materialize a copy if possible.; /// CSEMIRBuilder also does trivial constant folding for binary ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:452,Testability,assert,assert,452,"/// Defines a builder that does CSE of MachineInstructions using GISelCSEInfo.; /// Eg usage.; ///; ///; /// GISelCSEInfo *Info =; /// &getAnalysis<GISelCSEAnalysisWrapperPass>().getCSEInfo(); CSEMIRBuilder; /// CB(Builder.getState()); CB.setCSEInfo(Info); auto A = CB.buildConstant(s32,; /// 42); auto B = CB.buildConstant(s32, 42); assert(A == B); unsigned CReg =; /// MRI.createGenericVirtualRegister(s32); auto C = CB.buildConstant(CReg, 42);; /// assert(C->getOpcode() == TargetOpcode::COPY);; /// Explicitly passing in a register would materialize a copy if possible.; /// CSEMIRBuilder also does trivial constant folding for binary ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:413,Availability,down,down,413,"/// Returns true if A dominates B (within the same basic block).; /// Both iterators must be in the same basic block.; //; // TODO: Another approach for checking dominance is having two iterators and; // making them go towards each other until they meet or reach begin/end. Which; // approach is better? Should this even change dynamically? For G_CONSTANTS; // most of which will be at the top of the BB, the top down approach would be; // a better choice. Does IRTranslator placing constants at the beginning still; // make sense? Should this change based on Opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:79,Safety,safe,safe,79,/// Simple check if we can CSE (we have the CSEInfo) or if this Opcode is; /// safe to CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:4,Usability,Simpl,Simple,4,/// Simple check if we can CSE (we have the CSEInfo) or if this Opcode is; /// safe to CSE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:412,Integrability,wrap,wrapper,412,"//===- llvm/CodeGen/GlobalISel/GenericMachineInstrs.h -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Declares convenience wrapper classes for interpreting MachineInstr instances; /// as specific generic operations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:4,Security,Access,Access,4,/// Access the Idx'th operand as a register and return it.; /// This assumes that the Idx'th operand is a Register type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:44,Security,access,access,44,/// Returns the size in bytes of the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:43,Security,access,access,43,/// Returns the size in bits of the memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h
