id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html530/RooAbsCachedPdf.html:41301,Integrability,integrat,integrator,41301,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43435,Integrability,integrat,integration,43435,"et = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCache",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43612,Integrability,integrat,integration,43612," evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; R",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43874,Integrability,integrat,integration,43874,"e histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(con",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:10814,Modifiability,extend,extendedTerm,10814,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:10924,Modifiability,extend,extendMode,10924,"ion = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:14165,Modifiability,extend,extended,14165,"::generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars,",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:28210,Modifiability,config,config,28210," = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bo",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:28317,Modifiability,config,config,28317," = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:41204,Modifiability,config,configuration,41204,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:41312,Modifiability,config,configuration,41312,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43139,Modifiability,config,configuration,43139,"Named::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:393,Performance,cache,cache,393,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:550,Performance,cache,cache,550,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:919,Performance,cache,cached,919,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:1079,Performance,cache,cache,1079,". RooAbsCachedPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedPdf. class RooAbsCachedPdf: public RooAbsPdf. RooAbsCachedPdf is the abstract base class for p.d.f.s that need or; want to cache their evaluate() output in a RooHistPdf defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistPdf cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedPdf must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the p.d.fs function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virt",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:2664,Performance,cache,cacheUniqueSuffix,2664,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStat",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:11533,Performance,cache,cacheList,11533,"Event(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:11621,Performance,cache,cacheList,11621,"RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:22507,Performance,optimiz,optimizeCacheMode,22507,"ialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:22579,Performance,optimiz,optimizeCacheMode,22579,"ialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:26877,Performance,cache,cache,26877,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::Set",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:28108,Performance,cache,cache,28108,"RooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCoun",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:30603,Performance,cache,cache,30603,"bsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:31648,Performance,cache,cache,31648,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:32203,Performance,cache,cache,32203,"vables(const RooArgSet& nset) const; virtual RooArgSet*actualParameters(const RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedPdf::PdfCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; RooAbsCachedPdf::PdfCacheElem*getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<R",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:34583,Performance,optimiz,optimizeDirtyHook,34583,"tCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringhistNameSuffix() const; static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:38099,Performance,cache,cache,38099,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:38298,Performance,cache,caches,38298,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:38337,Performance,cache,cache,38337,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:38880,Performance,cache,cache,38880,"tegration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:39197,Performance,cache,cache,39197,te contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_norm,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:39555,Performance,cache,cache,39555,luesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of ,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:39638,Performance,cache,cache,39638,rg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- ,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:40106,Performance,cache,cache,40106,pping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculatin,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:40771,Performance,cache,cache,40771,"alueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInter",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:41570,Performance,cache,cache,41570,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:41816,Performance,cache,cache,41816,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42502,Performance,cache,cache,42502,ool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& ,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42681,Performance,cache,cache,42681,"objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42814,Performance,cache,cache,42814," numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArg",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42916,Performance,cache,cache,42916,"tic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42953,Performance,cache,cache,42953,"tic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42994,Performance,cache,cacheNameSuffix,42994,"Named::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43080,Performance,cache,cache,43080,"Named::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43133,Performance,cache,cache,43133,"Named::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbs",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43253,Performance,cache,cache,43253,"ts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return R",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43671,Performance,cache,cache,43671," pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) c",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43686,Performance,cache,cache,43686,"f observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inpu",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43933,Performance,cache,cache,43933,"e) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histOb",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:43948,Performance,cache,cache,43948,"ed (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44150,Performance,cache,cache,44150," names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44247,Performance,cache,cached,44247,"lation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44352,Performance,cache,cached,44352," forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44591,Performance,cache,cache,44591," const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44671,Performance,cache,cache,44671," const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:44986,Performance,cache,cache,44986," const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return RooDataHist with cached values. Int_t getInterpolationOrder() const; Set interpolation order in RooHistPdf that represent cached histogram. PdfCacheElem* getCache(const RooArgSet* nset, Bool_t recalculate = kTRUE) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Return name of binning to be used for creation of cache histogram. PdfCacheElem* createCache(const RooArgSet* nset) const; Create cache storage element. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. RooAbsArg& pdfObservable(RooAbsArg& histObservable) const; { return histObservable ; }. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const. TString histNameSuffix() const; { return TString("""") ; }. void disableCache(Bool_t flag); Flag to disable caching mechanism. » Last changed: Mon Jul 4 15:21:18 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:38194,Security,validat,validate,38194,,MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:9057,Testability,test,testArg,9057,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:9151,Testability,test,testArg,9151,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:20465,Testability,log,logEvalError,20465,"f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:20564,Testability,log,logEvalError,20564,"AbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tRooAbsPdf::isDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsR",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:21670,Testability,test,testArg,21670,"tring = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:21765,Testability,test,testArg,21765,"xVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tRooAbsPdf::minDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:22723,Testability,test,testArg,22723,"ialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:3184,Usability,clear,clearEvalError,3184,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:3225,Usability,clear,clearEvalErrorLog,3225,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:3261,Usability,clear,clearShapeDirty,3261,"RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const Roo",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:3301,Usability,clear,clearValueDirty,3301,"ring>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const ",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedPdf.html:42868,Usability,clear,clearCacheObject,42868,"tic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root/html530/RooAbsCachedPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html
https://root.cern/root/html530/RooAbsCachedReal.html:1246,Availability,avail,available,1246,"FIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData&",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:10507,Availability,error,error,10507,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:10591,Availability,error,error,10591,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31186,Deployability,integrat,integration,31186,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32500,Deployability,integrat,integration,32500,e contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsRea,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33789,Deployability,integrat,integrator,33789,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33800,Deployability,configurat,configuration,33800,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35362,Deployability,integrat,integration,35362,"r dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35905,Deployability,integrat,integration,35905,"n of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. void disableCache(Bool_t flag); Switch to disable caching mechanism. » Last changed: Mon Jul 4 15:21:19 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:7886,Integrability,depend,dependentVars,7886,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9128,Integrability,depend,dependentOverlaps,9128,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9220,Integrability,depend,dependentOverlaps,9220,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9314,Integrability,depend,dependsOn,9314,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9443,Integrability,depend,dependsOn,9443,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9561,Integrability,depend,dependsOnValue,9561,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9668,Integrability,depend,dependsOnValue,9668,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:16805,Integrability,message,message,16805,"ct() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOver",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:16956,Integrability,message,message,16956,"g::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) c",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31186,Integrability,integrat,integration,31186,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32500,Integrability,integrat,integration,32500,e contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsRea,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33789,Integrability,integrat,integrator,33789,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35362,Integrability,integrat,integration,35362,"r dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35905,Integrability,integrat,integration,35905,"n of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. void disableCache(Bool_t flag); Switch to disable caching mechanism. » Last changed: Mon Jul 4 15:21:19 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:23428,Modifiability,config,config,23428,""", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); vir",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33800,Modifiability,config,configuration,33800,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:400,Performance,cache,cache,400,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:559,Performance,cache,cache,559,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:932,Performance,cache,cached,932,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:1092,Performance,cache,cache,1092,". RooAbsCachedReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCachedReal. class RooAbsCachedReal: public RooAbsReal. RooAbsCachedReal is the abstract base class for functions that need or; want to cache their evaluate() output in a RooHistFunc defined in; terms of the used observables. This base class manages the creation; and storage of all RooHistFunc cache p.d.fs and the RooDataHists; that define their shape. Implementations of RooAbsCachedReal must; define member function fillCacheObject() which serves to fill an; already created RooDataHist with the functions function values. In; addition the member functions actualObservables() and; actualParameters() must be define which report what the actual; observables to be cached are for a given set of observables passed; by the user to getVal() and on which parameters need to be tracked; for changes to trigger a refilling of the cache histogram.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCachedReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:2678,Performance,cache,cacheUniqueSuffix,2678,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:11325,Performance,cache,cacheList,11325,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:11413,Performance,cache,cacheList,11413,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::get",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:18692,Performance,optimiz,optimizeCacheMode,18692,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:18764,Performance,optimiz,optimizeCacheMode,18764,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:22157,Performance,cache,cache,22157,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDto",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:23322,Performance,cache,cache,23322,", Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*R",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:25208,Performance,cache,cache,25208,":OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:26172,Performance,cache,cache,26172,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:26731,Performance,cache,cache,26731,"(const RooArgSet& nset) const; virtual RooArgSet*actualParameters(const RooArgSet& nset) const; virtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*binningName() const; TStringcacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidclearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedReal::FuncCacheElem*createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voiddisableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooAbsReal::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:28683,Performance,optimiz,optimizeDirtyHook,28683,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual const char*payloadUniqueSuffix() const; virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31404,Performance,cache,cache,31404,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31603,Performance,cache,caches,31603,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31642,Performance,cache,cache,31642,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32184,Performance,cache,cache,32184,"ntegration codes; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal:",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32401,Performance,cache,cache,32401,"cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32759,Performance,cache,cache,32759,bset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_s,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:32842,Performance,cache,cache,32842,rg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<s,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33441,Performance,cache,cache,33441,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:33994,Performance,cache,cache,33994,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:34791,Performance,cache,cache,34791,"meric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represe",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:34940,Performance,cache,cache,34940,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35003,Performance,cache,cacheNameSuffix,35003,"ches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* b",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35082,Performance,cache,cache,35082,"ches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* b",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35196,Performance,cache,cache,35196,"; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(con",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:35786,Performance,cache,cache,35786,"n of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. void disableCache(Bool_t flag); Switch to disable caching mechanism. » Last changed: Mon Jul 4 15:21:19 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:36101,Performance,cache,cache,36101,"n of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. void disableCache(Bool_t flag); Switch to disable caching mechanism. » Last changed: Mon Jul 4 15:21:19 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:36390,Performance,cache,cache,36390,"n of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCache(const RooArgSet* nset) const. const char* payloadUniqueSuffix() const; { return 0 ; }. const char* binningName() const; Returns name of binning to be used for cache histogram creation. FuncCacheElem* createCache(const RooArgSet* nset) const. const char* inputBaseName() const. RooArgSet* actualObservables(const RooArgSet& nset) const. RooArgSet* actualParameters(const RooArgSet& nset) const. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const. void disableCache(Bool_t flag); Switch to disable caching mechanism. » Last changed: Mon Jul 4 15:21:19 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:31499,Security,validat,validate,31499,,MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9187,Testability,test,testArg,9187,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:9281,Testability,test,testArg,9281,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:16780,Testability,log,logEvalError,16780,"tual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRoo",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:16879,Testability,log,logEvalError,16879,"t; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:17855,Testability,test,testArg,17855,"tic voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:17950,Testability,test,testArg,17950,"* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:18908,Testability,test,testArg,18908,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:4069,Usability,clear,clearEvalErrorLog,4069,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmd",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:4105,Usability,clear,clearShapeDirty,4105,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 ",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:4145,Usability,clear,clearValueDirty,4145,"(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCachedReal.html:34890,Usability,clear,clearCacheObject,34890,"o not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedReal(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsReal. Return value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedReal. void clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; Mark all bins as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct unique suffix name for cache p.d.f object. void setInterpolationOrder(Int_t order); Set interpolation order of RooHistFunct representing cache histogram. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integration capabilities of the RooHistFunc that corresponds to the set of observables in allVars. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Forward call to implementation in relevant RooHistFunc instance. Bool_t selfNormalized() const; Declares function self normalized. Int_t getInterpolationOrder() const; Set interpolation order in RooHistFuncs that represent cache histograms. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force all observables to be offered for internal integration. FuncCacheElem* getCac",MatchSource.WIKI,root/html530/RooAbsCachedReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html
https://root.cern/root/html530/RooAbsCacheElement.html:712,Availability,avail,available,712,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts i",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:447,Integrability,interface,interface,447,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts i",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:394,Performance,cache,cache,394,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts i",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:545,Performance,optimiz,optimization,545,". RooAbsCacheElement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts i",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:923,Performance,cache,cacheList,923,"ader viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCacheElement. class RooAbsCacheElement. RooAbsCacheElement is the abstract base class for objects to be stored; in RooAbsCache cache manager objects. Each storage element has an ; interface to pass on calls for server redirection, operation mode; change calls and constant term optimization management calls; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCacheElement(); static TClass*Class(); virtual RooArgListcontainedArgs(RooAbsCacheElement::Action); virtual voidfindConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimize",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:1989,Performance,cache,cache,1989,"odes); virtual TClass*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or s",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:2126,Performance,optimiz,optimizeCacheMode,2126,"tual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:2233,Performance,cache,cache,2233,"tual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:2239,Performance,optimiz,optimization,2239,"tual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:2446,Performance,cache,cacheList,2446,"tual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCacheElement.html:2517,Performance,optimiz,optimization,2517,"tual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Mon Jul 4 15:21:17 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCacheElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCacheElement.html
https://root.cern/root/html530/RooAbsCategory.html:809,Availability,avail,available,809,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObser",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:4234,Availability,error,error,4234,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; Ro",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:4318,Availability,error,error,4318,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloning",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:21485,Availability,avail,available,21485,"~RooAbsCategory(); Destructor. Int_t getIndex() const; Return index number of current state. const char* getLabel() const; Return label string of current state. RooCatType traceEval() const; Recalculate current value and check validity of new result. TIterator* typeIterator() const; Return iterator over all defined states. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* c",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:24785,Deployability,integrat,integration,24785,"attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Mon Jul 4 15:21:20 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:584,Integrability,interface,interface,584,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObser",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:644,Integrability,interface,interface,644,". RooAbsCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategory. class RooAbsCategory: public RooAbsArg. RooAbsCategory is the common abstract base class for objects that; represent a discrete value with a finite number of states. Each; state consist of a label/index pair, which is stored in a; RooCatType object.; ; Implementation of RooAbsCategory may be derived, there no interface; is provided to modify the contents, nor a public interface to define states.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObser",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3197,Integrability,depend,dependentOverlaps,3197,"bsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3289,Integrability,depend,dependentOverlaps,3289,"*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3383,Integrability,depend,dependsOn,3383," newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3512,Integrability,depend,dependsOn,3512," TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3630,Integrability,depend,dependsOnValue,3630,"amed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3737,Integrability,depend,dependsOnValue,3737,"UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:23629,Integrability,synchroniz,synchronize,23629,"m& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return nu",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:24785,Integrability,integrat,integration,24785,"attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Mon Jul 4 15:21:20 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:1792,Performance,cache,cacheUniqueSuffix,1792," virtual~RooAbsCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObser",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:4660,Performance,cache,cacheList,4660,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:4748,Performance,cache,cacheList,4748,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tgetIndex() const; virtua",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:10472,Performance,optimiz,optimizeCacheMode,10472,"ata* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:10544,Performance,optimiz,optimizeCacheMode,10544,"verlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:12956,Performance,cache,cache,12956,"g indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voi",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:13888,Performance,cache,cache,13888,"ol_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) con",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:15315,Performance,cache,cache,15315,"static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:16997,Performance,optimiz,optimizeDirtyHook,16997,"t) const. protected:. virtual voidattachToTree(TTree& t, Int_t bufSize = 32000); TStringRooAbsArg::cleanBranchName() const; voidclearTypes(); virtual voidcopyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*defineType(const char* label); const RooCatType*defineType(const char* label, Int_t index); const RooCatType*defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidfillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tisValid() const; virtual Bool_tisValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidsetTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidsyncCache(const RooArgSet* set = 0); RooCatTypetraceEval() const; virtual Bool_ttraceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:18580,Performance,cache,cache,18580,,MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:18670,Performance,cache,caches,18670,,MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:19205,Performance,cache,cache,19205,,MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:23665,Performance,cache,cache,23665,"m& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return nu",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:23749,Performance,cache,cached,23749,"ream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet*",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:23864,Performance,cache,cache,23864,"label name). void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsArg::printStream() we add:. Shape : label, index, defined types. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PA",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:24769,Safety,safe,safe,24769,"attachToTree(TTree& t, Int_t bufSize = 32000); Attach the category index and label to as branches to the given; TTree. The index field will be attached as integer with name; <name>_idx, the label field will be attached as char[] with label; <name>_lbl. void fillTreeBranch(TTree& t); Fill tree branches associated with current object with current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)activate associate tree branch. void syncCache(const RooArgSet* set = 0); Explicitly synchronize RooAbsCategory internal cache. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. const RooCatType* getOrdinal(UInt_t n, const char* rangeName = 0) const; Return state definition of ordinal nth defined state,; needed by the generator mechanism. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooCategory fundamental object with our properties. Bool_t isSignType(Bool_t mustHaveZero = kFALSE) const; Determine if category has 2 or 3 states with index values -1,0,1. Bool_t operator!=(Int_t index); { return !operator==(index);}. Bool_t operator!=(const char* label); { return !operator==(label);}. Bool_t operator!=(const RooAbsArg& other); { return !operator==(other);}. Int_t numTypes(const char* = 0) const; Return number of types defined (in range named rangeName if rangeName!=0). Bool_t isIntegrationSafeLValue(const RooArgSet* ) const; Is this l-value object safe for use as integration observable. Bool_t traceEvalHook(RooCatType ) const; coverity[PASS_BY_VALUE]. RooCatType evaluate() const. » Last changed: Mon Jul 4 15:21:20 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3256,Testability,test,testArg,3256,"lientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:3350,Testability,test,testArg,3350,"bject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:9509,Testability,test,testArg,9509,"e() const; Bool_tisValidIndex(Int_t index) const; Bool_tisValidLabel(const char* label) const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observ",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:9604,Testability,test,testArg,9604,"Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tnumTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNo",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:10688,Testability,test,testArg,10688,"ar* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:2173,Usability,clear,clearShapeDirty,2173,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; B",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:2213,Usability,clear,clearValueDirty,2213,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const ",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategory.html:21804,Usability,clear,clearTypes,21804,"es. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root/html530/RooAbsCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategory.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:872,Availability,avail,available,872,". RooAbsCategoryLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCategoryLValue. class RooAbsCategoryLValue: public RooAbsCategory, public RooAbsLValue. RooAbsCategoryLValue is the common abstract base class for objects that represent a; discrete value that may appear on the left hand side of an equation ('lvalue'); Each implementation must provide setIndex()/setLabel() members to allow direct modification ; of the value. RooAbsCategoryLValue may be derived, but its functional relation; to other RooAbsArgs must be invertible; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDepende",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:4335,Availability,error,error,4335,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; vi",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:4419,Availability,error,error,4419,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbs",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3298,Integrability,depend,dependentOverlaps,3298,"TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3390,Integrability,depend,dependentOverlaps,3390,"wname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3484,Integrability,depend,dependsOn,3484,"AbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3613,Integrability,depend,dependsOn,3613,"voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3731,Integrability,depend,dependsOnValue,3731,"; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3838,Integrability,depend,dependsOnValue,3838,"r* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:1861,Performance,cache,cacheUniqueSuffix,1861," virtual~RooAbsCategoryLValue(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDepende",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:4761,Performance,cache,cacheList,4761,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) ",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:4849,Performance,cache,cacheList,4849,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual const RooAbsBinning*getBinningPtr(const char*) const; virtual Double_tgetBinWidth(Int_t, const char* = 0) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbs",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:11170,Performance,optimiz,optimizeCacheMode,11170,"method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:11242,Performance,optimiz,optimizeCacheMode,11242," voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:13736,Performance,cache,cache,13736,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCach",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:14766,Performance,cache,cache,14766,"er(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<s",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:16343,Performance,cache,cache,16343,"const char* label, Bool_t printError = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual Double_tvolume(const char* rangeName) const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:18238,Performance,optimiz,optimizeDirtyHook,18238,"CatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeRooAbsCategory::evaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tsetOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:19956,Performance,cache,cache,19956,,MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:20046,Performance,cache,caches,20046,,MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:20581,Performance,cache,cache,20581,,MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:22464,Performance,cache,cached,22464,"AbsCategory::_typeIter!; TObjArrayRooAbsCategory::_typesArray of allowed values; RooCatTypeRooAbsCategory::_valueCurrent value; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTR",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:22579,Performance,cache,cache,22579,"ue; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCategoryLValue(); Destructor. RooAbsArg& operator=(Int_t index); Assignment operator from integer index number. RooAbsArg& operator=(const char* label); Assignment operator from string pointer. RooAbsArg& operator=(const RooAbsCategory& other); Assignment from another RooAbsCategory. Bool_t setOrdinal(UInt_t index, const char* rangeName); Set our state to our n'th defined type and return kTRUE.; Return kFALSE if n is out of range. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value from given source and raise dirty flag.; It is the callers responsability to ensure that the sources; cache is clean(valid) before this function is called, e.g. by; calling syncCache() on the source. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream (dummy implementation). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream (dummy implementation). void randomize(const char* rangeName = 0); Randomize current value. void setBin(Int_t ibin, const char* rangeName = 0); Set category to i-th fit bin, which is the i-th registered state. Int_t getBin(const char* rangeName = 0) const; Get index of plot bin for current value this category. Int_t numBins(const char* rangeName) const; Returm the number of fit bins ( = number of types ). Bool_t setIndex(Int_t index, Bool_t printError = kTRUE); Value modifiers. Bool_t setLabel(const char* label, Bool_t printError = kTRUE). Int_t getBin(const char* rangeName = 0) const. Double_t getBinWidth(Int_t , const char* = 0) const; Return volume of i-t",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3357,Testability,test,testArg,3357,"Object*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:3451,Testability,test,testArg,3451,"r* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:10034,Testability,test,testArg,10034,"alueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtu",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:10129,Testability,test,testArg,10129,":isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); virtual Int_tnumBins(const char* rangeName) const; Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::oper",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:11386,Testability,test,testArg,11386,"oid* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:2242,Usability,clear,clearShapeDirty,2242,"peProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delet",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:2282,Usability,clear,clearValueDirty,2282,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRoo",MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCategoryLValue.html:17013,Usability,clear,clearTypes,17013,,MatchSource.WIKI,root/html530/RooAbsCategoryLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html
https://root.cern/root/html530/RooAbsCollection.html:879,Availability,avail,available,879,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooAbsCollection&assignFast(const RooAbsCollection& other); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_t",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:3038,Availability,error,error,3038,"ol_tcontainsInstance(const RooAbsArg& var) const; stringcontentsString() const; virtual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:3122,Availability,error,error,3122,"ual voidTObject::Copy(TObject& object) const; virtual TObject*create(const char* newname) const; TIterator*createIterator(Bool_t dir = kIterForward) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voiddump() const; virtual voidTObject::Dump() constMENU ; Bool_tequals(const RooAbsCollection& otherColl) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; RooAbsArg*find(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*first() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tgetHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tgetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(c",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:18312,Availability,error,error,18312,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:18341,Availability,error,error,18341,"ult behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:18544,Availability,error,error,18544,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:20117,Deployability,release,releaseOwnership,20117,"n. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:9853,Integrability,depend,dependencies,9853,"fmt, va_list va) const; voidTObject::MakeZombie(); voidsafeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10167,Integrability,depend,dependents,10167,"ey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10215,Integrability,depend,dependents,10215,"ey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10235,Integrability,depend,dependents,10235,"ey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operat",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10382,Integrability,depend,dependents,10382,"Option { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10702,Integrability,depend,dependents,10702,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specif",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10750,Integrability,depend,dependents,10750,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specif",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10770,Integrability,depend,dependents,10770,"; Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specif",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:10917,Integrability,depend,dependents,10917,"ny client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagge",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:19710,Integrability,interface,interface,19710,"n. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:19915,Integrability,interface,interface,19915,"n. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:11806,Modifiability,variab,variable,11806,"t). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t addServerClonesToList(const RooAbsArg& var); Add clones of servers of given argument to list. RooAbsCollection & operator=(const RooAbsCollection& other); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this c",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:12196,Modifiability,variab,variable,12196,"rgument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:12277,Modifiability,variab,variables,12277,"rgument in our set; that also appears in the other set. RooAbsCollection & assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:12410,Modifiability,variab,variables,12410,"); The assignment operator sets the value of any argument in our set; that also appears in the other set. RooAbsCollection & assignFast(const RooAbsCollection& other); Functional equivalent of operator=() but assumes this and other collection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:12565,Modifiability,variab,variable,12565,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:12636,Modifiability,variab,variables,12636,"ection; have same layout. Also no attributes are copied. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list.; This method can only be called on a list that is flagged as owning; all of its contents, or else on an empty list (which will force the; list into that mode). RooAbsArg * addClone(const RooAbsArg& var, Bool_t silent = kFALSE); Add a clone of the specified argument to list. Returns a pointer to; the clone if successful, or else zero if a variable of the same name; is already in the list or the list does *not* own its variables (in; this case, try add() instead.) Calling addClone() on an empty list; forces it to take ownership of all its subsequent variables. Bool_t add(const RooAbsArg& var, Bool_t silent = kFALSE); Add the specified argument to list. Returns kTRUE if successful, or; else kFALSE if a variable of the same name is already in the list; or the list owns its variables (in this case, try addClone() or addOwned() instead). Bool_t add(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling add(); for each element in the source collection. Bool_t addOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:13989,Modifiability,variab,variable,13989,"element in the source collection. void addClone(const RooAbsCollection& list, Bool_t silent = kFALSE); Add a collection of arguments to this collection by calling addOwned(); for each element in the source collection. Bool_t replace(const RooAbsCollection& other); Replace any args in our set with args of the same name from the other set; and return kTRUE for success. Fails if this list is a copy of another. Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2); Replace var1 with var2 and return kTRUE for success. Fails if; this list is a copy of another, if var1 is not already in this set,; or if var2 is already in this set. var1 and var2 do not need to have; the same name. Bool_t remove(const RooAbsArg& var, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove the specified argument from our list. Return kFALSE if; the specified argument is not found in our list. An exact pointer; match is required, not just a match by name. A variable can be; removed from a copied list and will be deleted at the same time. Bool_t remove(const RooAbsCollection& list, Bool_t silent = kFALSE, Bool_t matchByNameOnly = kFALSE); Remove each argument in the input list from our list using remove(const RooAbsArg&).; Return kFALSE in case of problems. void removeAll(); Remove all arguments from our set, deleting them if we own them.; This effectively restores our object to the state it would have; just after calling the RooAbsCollection(const char*) constructor. void setAttribAll(const Text_t* name, Bool_t value = kTRUE); Set given attribute in each element of the collection by; calling each elements setAttribute() function. RooAbsCollection* selectByAttrib(const char* name, Bool_t value) const; Create a subset of the current collection, consisting only of those; elements with the specified attribute set. The caller is responsibe; for deleting the returned collection. RooAbsCollection* selectCommon(const RooAbsCollection& refColl) const; Create a subset of the current col",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:17287,Modifiability,variab,variable,17287," inline printing only show value of objects, for default print show; name,class name value and extras of each object. In verbose mode; also add object adress, argument and title. void printValue(ostream& os) const; Print value of collection, i.e. a comma separated list of contained; object names. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Implement multiline printin of collection, one line for each ontained object showing; the requested content. void dump() const; Base contents dumper for debugging purposes. void printLatex(const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()) const; Output content of collection as LaTex table. By default a table with two columns is created: the left; column contains the name of each variable, the right column the value. The following optional named arguments can be used to modify the default behavior. Columns(Int_t ncol) -- Fold table into multiple columns, i.e. ncol=3 will result in 3 x 2 = 6 total columns; Sibling(const RooAbsCollection& other) -- Define sibling list. The sibling list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:18641,Modifiability,variab,variable,18641,"ing list is assumed to have objects with the same; name in the same order. If this is not the case warnings will be printed. If a single; sibling list is specified, 3 columns will be output: the (common) name, the value of this; list and the value in the sibling list. Multiple sibling lists can be specified by; repeating the Sibling() command.; Format(const char* str) -- Classic format string, provided for backward compatibility; Format(...) -- Formatting arguments, details are given below; OutputFile(const char* fname) -- Send output to file with given name rather than standard output. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:9813,Safety,safe,safeDeleteList,9813,"fmt, va_list va) const; voidTObject::MakeZombie(); voidsafeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:9898,Safety,safe,safe,9898,"fmt, va_list va) const; voidTObject::MakeZombie(); voidsafeDeleteList(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_listActual object store; TString_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_t_ownContFlag to identify a list that owns its contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCollection(); Destructor. RooLinkedListIter iterator(Bool_t dir = kIterForward) const. void safeDeleteList(); Examine client server dependencies in list and; delete contents in safe order: any client; is deleted before a server is deleted. RooAbsCollection* snapshot(Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list elements and the cloned external dependents are reconnected to; each other, making the snapshot a completely self-contained entity. Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy = kTRUE) const; Take a snap shot of current collection contents:; An owning collection is returned containing clones of. - Elements in this collection; - External dependents of all elements; and recursively any dependents of those dependents; (if deepCopy flag is set). If deepCopy is specified, the client-server links between the cloned; list ",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:672,Security,hash,hash-table,672,". RooAbsCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsCollection. class RooAbsCollection: public TObject, public RooPrintable. RooAbsCollection is an abstract container object that can hold; multiple RooAbsArg objects. Collections are ordered and can; contain multiple objects of the same name, (but a derived; implementation can enforce unique names). The storage of objects in; implement through class RooLinkedList, a doubly linked list with an; an optional hash-table lookup mechanism for fast indexing of large; collections. ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsCollection(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tadd(const RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_tadd(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual RooAbsArg*addClone(const RooAbsArg& var, Bool_t silent = kFALSE); virtual voidaddClone(const RooAbsCollection& list, Bool_t silent = kFALSE); virtual Bool_taddOwned(RooAbsArg& var, Bool_t silent = kFALSE); virtual Bool_taddOwned(const RooAbsCollection& list, Bool_t silent = kFALSE); Bool_tallInRange(const char* rangeSpec) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooAbsCollection&assignFast(const RooAbsCollection& other); RooAbsCollection&assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*clone(const char* newname) const; virtual TObject*Clone(const char* newname = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_t",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsCollection.html:19382,Security,hash,hash,19382,"nit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. Example use: list.printLatex(Columns(2), Format(""NEU"",AutoPrecision(1),VerbatimName()) ) ;. void printLatex(ostream& ofs, Int_t ncol, const char* option = ""NEYU"", Int_t sigDigit = 1, const RooLinkedList& siblingLists = RooLinkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has b",MatchSource.WIKI,root/html530/RooAbsCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsCollection.html
https://root.cern/root/html530/RooAbsData.html:730,Availability,avail,available,730,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*covarianceMatrix(const char* cutSpec = 0, co",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:3560,Availability,error,error,3560,"& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tgetRange(RooRealVar& var, Double_t& ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:3644,Availability,error,error,3644,"rg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tgetRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17668,Availability,error,error,17668,"a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17840,Availability,error,error,17840,"f data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataEr",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:18838,Availability,error,error,18838,"eight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWid",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:18954,Availability,error,error,18954,"const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:20165,Availability,error,error,20165,"e intervals. SumW2 draws symmetric sum-of-weights error; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically ca",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:27614,Availability,error,error,27614,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) di",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:27643,Availability,error,error,27643,"- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) di",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:27846,Availability,error,error,27846,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; S",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:28562,Availability,error,error,28562,"ng structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; Split dataset into subsets based on states of given splitCat in this dataset.; A TList of RooDataSets is returned in which each RooDataSet is named; after the state name of splitCat of which it contains the dataset subset.; The observables splitCat itself is no longer present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binn",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:30133,Availability,error,error,30133," present in the sub datasets.; If createEmptyDataSets is kFALSE (default) this method only creates datasets for states; which have at least one entry The caller takes ownership of the returned list and its contents. RooPlot* plotOn(RooPlot* frame, const RooLinkedList& cmdList) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:30328,Availability,error,error,30328," dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t s",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:30373,Availability,error,error,30373," dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the data in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t s",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:31710,Availability,error,error,31710,"ization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOp",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:34930,Availability,error,error,34930,"s; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14354,Deployability,release,releaseVars,14354,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:19454,Deployability,update,update,19454,"named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category [F(+)-F(-)] / [F(+)+F(-)].; Category must have two states with indices -1 and +1 or three states with indeces -1,0 and +1.; DataError(RooAbsData::EType) -- Select the type of error drawn: Poisson (default) draws asymmetric Poisson; confidence intervals. SumW2 draws symmetric sum-of-weights error; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add construct",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:30878,Deployability,update,update,30878," and +1 or three states with indeces -1,0 and +1.; Efficiency(const RooCategory& c)-- Show the efficiency F(acc)/[F(acc)+F(rej)]. Category must have two states with indices 0 and 1; DataError(RooAbsData::EType) -- Select the type of error drawn:; - Auto(default) results in Poisson for unweighted data and SumW2 for weighted data; - Poisson draws asymmetric Poisson confidence intervals.; - SumW2 draws symmetric sum-of-weights error ( sum(w)^2/sum(w^2) ); - None draws no error bars; Binning(double xlo, double xhi, -- Use specified binning to draw dataset; int nbins); Binning(const RooAbsBinning&) -- Use specified binning to draw dataset; Binning(const char* name) -- Use binning with specified name to draw dataset; RefreshNorm(Bool_t flag) -- Force refreshing for PDF normalization information in frame.; If set, any subsequent PDF will normalize to this dataset, even if it is; not the first one added to the frame. By default only the 1st dataset; added to a frame will update the normalization information; Rescale(Double_t f) -- Rescale drawn histogram by given factor. Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:8132,Energy Efficiency,reduce,reduce,8132,"const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOpti",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:8168,Energy Efficiency,reduce,reduce,8168,"one(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; stat",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:8216,Energy Efficiency,reduce,reduce,8216,", const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:8284,Energy Efficiency,reduce,reduce,8284,"ect::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetN",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:8360,Energy Efficiency,reduce,reduce,8360,"rintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*reduce(const char* cut); RooAbsData*reduce(const RooFormulaVar& cutVar); RooAbsData*reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_treleaseVars(RooAbsData*); virtual voidreset(); voidTObject::ResetBit(UInt_t f); RooRealVar*rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObject",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:12963,Energy Efficiency,reduce,reduceEng,12963,"dweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMa",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:15209,Energy Efficiency,reduce,reduce,15209,"RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:15508,Energy Efficiency,reduce,reduced,15508,"RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cu",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16286,Energy Efficiency,reduce,reduce,16286,"arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaV",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16547,Energy Efficiency,reduce,reduce,16547,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16617,Energy Efficiency,reduce,reduce,16617,"et& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16830,Energy Efficiency,reduce,reduced,16830,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16867,Energy Efficiency,reduce,reduce,16867,"ents inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = R",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17209,Energy Efficiency,reduce,reduce,17209,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17279,Energy Efficiency,reduce,reduce,17279," on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binni",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17569,Energy Efficiency,reduce,reduced,17569,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:38121,Energy Efficiency,reduce,reduceEng,38121," const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:412,Integrability,interface,interface,412,". RooAbsData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsData. class RooAbsData: public TNamed, public RooPrintable. RooAbsData is the common abstract base class for binned and unbinned; datasets. The abstract interface defines plotting and tabulating entry; points for its contents and provides an iterator over its elements; (bins for binned data sets, data points for unbinned datasets).; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsData(); voidTObject::AbstractMethod(const char* method) const; virtual voidadd(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidaddOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Bool_tcanSplitFast() const; virtual Bool_tchangeObservableName(const char* from, const char* to); voidcheckInit() const; static voidclaimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Double_tcorrelation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tcovariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*covarianceMatrix(const char* cutSpec = 0, co",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:36458,Integrability,interface,interface,36458,"_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; Do events in dataset have non-integer weights?. void Print(Option_t* options = 0) const; Printing interface (human readable). Double_t mean(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:13812,Modifiability,variab,variables,13812,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:13854,Modifiability,variab,variables,13854,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:13988,Modifiability,variab,variables,13988,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14405,Modifiability,variab,variables,14405,"Pick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16426,Modifiability,variab,variable,16426,"g(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16478,Modifiability,variab,variables,16478,"s dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subs",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:16754,Modifiability,variab,variable,16754,"ving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events inside range with given name. Multiple CutRange; arguments may be given to select multiple ranges; EventRange(int lo, int hi) -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::Error",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17088,Modifiability,variab,variable,17088," -- Only retain events with given sequential event numbers; Name(const char* name) -- Give specified name to output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = R",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17140,Modifiability,variab,variables,17140,"o output dataset; Title(const char* name) -- Give specified title to output dataset. RooAbsData* reduce(const char* cut); Create a subset of the data set by applying the given cut on the data points.; The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:17493,Modifiability,variab,variable,17493,"he equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default be",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:20800,Modifiability,variab,variables,20800,"color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). TH1 * createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset for the variables with given names; The range of each observable that is histogrammed is always automatically calculated from the distribution in; the dataset. The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this dataset. This function accepts the following arguments. name -- Name of the ROOT histogram; xvar -- Observable to be ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:26597,Modifiability,variab,variable,26597,"nt is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooRealVar* rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; Create a RooRealVar containing the RMS of observable 'var' in; this dataset. If cutSpec and/or cutRange are specified the; moment is calculated on the subset of the data which pass the C++; cut specification expression 'cutSpec' and/or are inside the; range named 'cutRange'. RooPlot* statOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with statistics information to the specified frame. By default a box with the; event count, mean and rms of the plotted variable is added. The following optional named arguments are accepted. What(const char* whatstr) -- Controls what is printed: ""N"" = count, ""M"" is mean, ""R"" is RMS.; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Contro",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:27943,Modifiability,variab,variable,27943,"at,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box; Cut(const char* expression) -- Apply given cut expression to data when calculating statistics; CutRange(const char* rangeName) -- Only consider events within given range when calculating statistics. Multiple; CutRange() argument may be specified to combine ranges. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default); VerbatimName(Bool_t flag) -- Put variable name in a \verb+ + clause. RooPlot* statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.15, Double_t xmax = 0.65, Double_t ymax = 0.85, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); Implementation back-end of statOn() mehtod with named arguments. TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; Loop over columns of our tree data and fill the input histogram. Returns a pointer to the; input histogram, or zero in case of an error. The input histogram can be any TH1 subclass, and; therefore of arbitrary dimension. Variables are matched with the (x,y,...) dimensions of the input; histogram according to the order in which they appear in the input plotVars list. TList* split(const RooAbsCategory& splitCat, Bool_t createEmptyDataSets = kFALSE) const; S",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:32247,Modifiability,variab,variable,32247,"line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plo",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:32295,Modifiability,variab,variable,32295," default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut stri",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:32433,Modifiability,variab,variable,32433,"- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; FillStyle(Int_t style) -- Select fill style, default is filled.; FillColor(Int_t color) -- Select fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable con",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:32635,Modifiability,variab,variable,32635," fill color by ROOT color code; XErrorSize(Double_t frac) -- Select size of X error bar as fraction of the bin width, default is 1. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogr",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:33007,Modifiability,variab,variable,33007,"e referenced later; Invisble() -- Add curve to frame, but do not display. Useful in combination AddTo(); AddTo(const char* name, -- Add constructed histogram to already existing histogram with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). RooPlot * plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; Create and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:33214,Modifiability,variab,variable,33214,"te and fill a histogram of the frame's variable and append it to the frame.; The frame variable must be one of the data sets dimensions. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the T",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:33416,Modifiability,variab,variable,33416,"meters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:33774,Modifiability,variab,variable,33774,"contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ),; where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is cu",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:33936,Modifiability,variab,variable,33936,"ber of data points with asymCat=+1 and asymCat=-1; as function of the frames variable. The asymmetry category 'asymCat' must; have exactly 2 (or 3) states defined with index values +1,-1 (and 0). The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and e",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:34138,Modifiability,variab,variable,34138,"range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. RooPlot* plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expr",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:34585,Modifiability,variab,variable,34585," const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; Create and fill a histogram with the effiency N[1] / ( N[1] + N[0] ),; where N(1/0) is the number of data points with effCat=1 and effCat=0; as function of the frames variable. The efficiency category 'effCat' must; have exactly 2 +1 and 0. The plot range and the number of plot bins is determined by the parameters; of the plot variable of the frame (RooAbsReal::setPlotRange(), RooAbsReal::setPlotBins()). The optional cut string expression can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:11897,Performance,cache,cachedVars,11897,"dweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMa",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:12022,Performance,cache,cacheClone,12022,"dweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMa",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:12615,Performance,cache,cacheList,12615,"dweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tallClientsCached(RooAbsArg*, const RooArgSet&); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tcorrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidoptimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMa",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:13805,Performance,cache,cached,13805,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:13864,Performance,cache,cached,13864,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14667,Performance,cache,cacheArgs,14667,"se; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output datas",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14852,Performance,cache,cached,14852,"ars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14937,Performance,cache,cachedVars,14937,"tor! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:14996,Performance,cache,cache,14996,"tor! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cut formula; CutRange(const char* name) -- Only retain events ins",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:34952,Performance,optimiz,optimizeReadingWithCaching,34952,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more ro",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:35012,Performance,cache,cacheList,35012,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more ro",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:35083,Performance,cache,cached,35083,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more ro",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:35117,Performance,cache,cacheList,35117,"on can be used to select the events to be plotted.; The cut specification may refer to any variable contained in the data set. The drawOptions are passed to the TH1::Draw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more ro",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:35261,Performance,cache,cached,35261,"raw() method. Roo1DTable* table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Create and fill a 1-dimensional table for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* c",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:35428,Performance,cache,cached,35428,"le for given category column; This functions is the equivalent of plotOn() for category dimensions. The optional cut string expression can be used to select the events to be tabulated; The cut specification may refer to any variable contained in the data set. The option string is currently not used. Bool_t getRange(RooRealVar& var, Double_t& lowest, Double_t& highest, Double_t marginFrac = 0, Bool_t symMode = kFALSE) const; Fill Doubles 'lowest' and 'highest' with the lowest and highest value of; observable 'var' in this dataset. If the return value is kTRUE and error; occurred. void optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); Prepare dataset for use with cached constant terms listed in; 'cacheList' of expression 'arg'. Deactivate tree branches; for any dataset observable that is either not used at all,; or is used exclusively by cached branch nodes. Bool_t allClientsCached(RooAbsArg* , const RooArgSet& ); Utility function that determines if all clients of object 'var'; appear in given list of cached nodes. Bool_t canSplitFast() const. RooAbsData* getSimData(const char* idxstate). void addOwnedComponent(const char* idxlabel, RooAbsData& data). void checkInit() const. void Draw(Option_t* option = """"); Forward draw command to data store. Bool_t hasFilledCache() const. const TTree* tree() const. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const. RooAbsDataStore* store(); { return _dstore ; }. const RooAbsDataStore* store() const; { return _dstore ; }. void add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); Add one ore more rows of data. const RooArgSet* get() const; Load a given row of data. Double_t weight() const. Bool_t valid() const; { return kTRUE ; }. Double_t sumEntries(const char* cutSpec = 0, const char* cutRange = 0) const. Bool_t isWeighted() const; Do events in dataset have weights?. Bool_t isNonPoissonWeighted() const; D",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsData.html:38009,Performance,cache,cacheClone,38009," const char* cutSpec = 0, const char* cutRange = 0) const; { return moment(var,1,0,cutSpec,cutRange) ; }. Double_t sigma(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return sqrt(moment(var,2,cutSpec,cutRange)) ; }. Double_t skewness(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,3,cutSpec,cutRange) ; }. Double_t kurtosis(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; { return standMoment(var,4,cutSpec,cutRange) ; }. Double_t covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kFALSE) ; }. Double_t correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcov(x,y,cutSpec,cutRange,kTRUE) ; }. TMatrixDSym* covarianceMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return covarianceMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; { return correlationMatrix(*get(),cutSpec,cutRange) ; }. TMatrixDSym* covarianceMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kFALSE) ; }. TMatrixDSym* correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; { return corrcovMatrix(vars,cutSpec,cutRange,kTRUE) ; }. RooAbsData* cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0). RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE). » Last changed: Mon Jul 4 15:21:21 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsData.html
https://root.cern/root/html530/RooAbsDataStore.html:582,Availability,avail,available,582,". RooAbsDataStore. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsDataStore. class RooAbsDataStore: public TNamed, public RooPrintable. RooAbsDataStore is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:2379,Availability,error,error,2379,"e() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasFilledCache()",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:2463,Availability,error,error,2463,":Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:9300,Integrability,interface,interface,9300,"terator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0)",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10269,Integrability,interface,interface,10269," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10412,Integrability,interface,interface,10412," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:8125,Modifiability,variab,variables,8125,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:8295,Modifiability,variab,variables,8295,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:995,Performance,cache,cachedVars,995," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:1089,Performance,cache,cacheOwner,1089," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:1164,Performance,cache,cachedVars,1164," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:1208,Performance,cache,cacheOwner,1208," virtual~RooAbsDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:8118,Performance,cache,cached,8118,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:8228,Performance,load,loading,8228,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose,",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:8605,Performance,load,loaded,8605," kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars; Bool_t_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. void printName(ostream& os) const; Print name of dataset. void printTitle(ostream& os) const; Print title of dataset. void printClassName(ostream& os) const; Print class name of dataset. void printValue(ostream& os) const; Print value of the dataset, i.e. the sum of weights contained in the dataset. void printArgs(ostream& os) const; Print argument of dataset, i.e. the observable names. Int_t defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) co",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10302,Performance,cache,cacheArgs,10302," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10329,Performance,cache,cacheOwner,10329," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10402,Performance,optimiz,optimizer,10402," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10440,Performance,cache,cacheOwner,10440," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10515,Performance,cache,cachedVars,10515," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsDataStore.html:10601,Performance,cache,cachedVars,10601," defaultPrintContents(Option_t* opt) const; Define default print options, for a given print style. void printMultiline(ostream& os, Int_t content, Bool_t verbose, TString indent) const; Detailed printing interface. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const. Int_t fill(); Write current row. const RooArgSet* get(Int_t index) const; Retrieve a row. const RooArgSet* get() const; { return &_vars ; }. Double_t weight() const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Double_t weight(Int_t index) const. Bool_t isWeighted() const. Bool_t changeObservableName(const char* from, const char* to); Change observable name. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add one or more columns. RooArgSet* addColumns(const RooArgList& varList). RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge column-wise. void append(RooAbsDataStore& other); Add rows. Int_t numEntries() const. void reset(). void Print(Option_t* options = 0) const; Printing interface (human readable). void cacheArgs(const RooAbsArg* cacheOwner, RooArgSet& varSet, const RooArgSet* nset = 0); Constant term optimizer interface. const RooAbsArg* cacheOwner(). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars). void setArgStatus(const RooArgSet& set, Bool_t active). const RooArgSet& cachedVars() const; { return _cachedVars ; }. void resetCache(). void setDirtyProp(Bool_t flag); { _doDirtyProp = flag ; }. void checkInit() const; {}. Bool_t hasFilledCache() const; { return _cachedVars.getSize()>0 ; }. const TTree* tree() const; { return 0 ; }. » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsDataStore.html
https://root.cern/root/html530/RooAbsFunc.html:856,Availability,avail,available,856,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:292,Integrability,interface,interface,292,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:425,Integrability,interface,interface,425,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:557,Integrability,interface,interface,557,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:352,Modifiability,variab,variable,352,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:366,Performance,perform,performing,366,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsFunc.html:530,Usability,simpl,simple,530,". RooAbsFunc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsFunc. class RooAbsFunc. Abstract interface for evaluating a real-valued function of one real variable; and performing numerical algorithms on it. The purpose of this interface is; to decouple RooAbsArg-specific implementations from numerical algorithms that; only need a simple function evaluation interface. The domain of the function; is assumed to be an n-dimensional box with edge coordinates specified by the; the getMinLimit() and getMaxLimit() methods.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsFunc(); static TClass*Class(); UInt_tgetDimension() const; virtual Double_tgetMaxLimit(UInt_t dimension) const; virtual Double_tgetMinLimit(UInt_t dimension) const; virtual const char*getName() const; virtual TClass*IsA() const; Bool_tisValid() const; Int_tnumCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&operator=(const RooAbsFunc&); virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidresetNumCall() const; virtual voidrestoreXVec() const; virtual voidsaveXVec() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. UInt_t_dimensionNumber of observables; Int_t_ncallFunction call counter; Bool_t_validIs binding in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~RooAbsFunc(); { }. UInt_t getDimension() const; Dimension of function. Bool_t isValid() const; Is function in valid state. Double_t operator()(const Double_t* xvector) const. Double_t getMinLi",MatchSource.WIKI,root/html530/RooAbsFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsFunc.html
https://root.cern/root/html530/RooAbsGenContext.html:853,Availability,avail,available,853,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:2069,Availability,error,error,2069,"rtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooDataSet*generate(Int_t nEvents = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:2153,Availability,error,error,2153,"bject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooDataSet*generate(Int_t nEvents = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:8753,Availability,avail,available,8753," according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the loo",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:8888,Availability,error,error,8888,"et_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype d",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:576,Integrability,interface,interface,576,". RooAbsGenContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsGenContext. class RooAbsGenContext: public TNamed, public RooPrintable. RooAbsGenContext is the abstract base class for generator contexts of ; RooAbsPdf objects. A generator context is an object that controls; the generation of events from a given p.d.f in one or more sessions.; This class defines the common interface for all such contexts and organizes; storage of common components, such as the observables definition, the ; prototype data etc..; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsGenContext(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattach(const RooArgSet& params); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptiondefaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual ",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:7487,Modifiability,extend,extended,7487,"TObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual RooDataSet*createDataSet(const char* name, const char* title, const RooArgSet& obs); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidgenerateEvent(RooArgSet& theEvent, Int_t remaining); virtual voidinitGenerator(const RooArgSet& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an emp",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:7741,Performance,load,load,7741,"t& theEvent); voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Int_t nEvents = 0); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of events, if non-zero. The returned; dataset belongs to the ca",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsGenContext.html:10326,Usability,clear,clear,10326,"cted number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsGenContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html
https://root.cern/root/html530/RooAbsHiddenReal.html:761,Availability,avail,available,761,". RooAbsHiddenReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsHiddenReal. class RooAbsHiddenReal: public RooAbsReal. RooAbsHiddenReal is a base class for objects that want to hide; their return value from interactive use, e.g. for implementations; of parameter unblinding functions. This class overrides all; printing methods with versions that do not reveal the objects value; and it has a protected version of getVal(); . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsHiddenReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) con",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:10034,Availability,error,error,10034,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:10118,Availability,error,error,10118,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:31321,Deployability,integrat,integration,31321,s validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32554,Deployability,integrat,integrator,32554,"ues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32565,Deployability,configurat,configuration,32565,"ues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:7413,Integrability,depend,dependentVars,7413,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt)",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8655,Integrability,depend,dependentOverlaps,8655,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8747,Integrability,depend,dependentOverlaps,8747,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8841,Integrability,depend,dependsOn,8841,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8970,Integrability,depend,dependsOn,8970,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:9088,Integrability,depend,dependsOnValue,9088,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:9195,Integrability,depend,dependsOnValue,9195,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:16395,Integrability,message,message,16395,"ject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOver",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:16546,Integrability,message,message,16546,"irtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) c",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:31321,Integrability,integrat,integration,31321,s validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32554,Integrability,integrat,integrator,32554,"ues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:22960,Modifiability,config,config,22960,"bject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32565,Modifiability,config,configuration,32565,"ues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:2205,Performance,cache,cacheUniqueSuffix,2205,"ol_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:10852,Performance,cache,cacheList,10852,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooAr",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:10940,Performance,cache,cacheList,10940,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRoo",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:18282,Performance,optimiz,optimizeCacheMode,18282,"t_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:18354,Performance,optimiz,optimizeCacheMode,18354,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:21727,Performance,cache,cache,21727,"dent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& stream) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsRea",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:22854,Performance,cache,cache,22854,"RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:24700,Performance,cache,cache,24700,"e(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:27667,Performance,optimiz,optimizeDirtyHook,27667,"ual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:30234,Performance,cache,cache,30234,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:30433,Performance,cache,caches,30433,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:31005,Performance,cache,cache,31005,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:31222,Performance,cache,cache,31222,"ransient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed by",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:31580,Performance,cache,cache,31580,dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration spec,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32206,Performance,cache,cache,32206,"e! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject iden",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:32813,Performance,cache,cache,32813,"ues from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:30329,Security,validat,validate,30329,,MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:34003,Security,access,accessor,34003,"r RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; RooCategoryProxy_stateProxy to hiding state category; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsHiddenReal(); Destructor. void printValue(ostream& stream) const; Special version of printValue that doesn't reveal the objects value. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Special version of readFromStream that disallows reading from stream. void writeToStream(ostream& os, Bool_t compact) const; Special version of writeToStream that disallows reading from stream. RooAbsCategory& dummyBlindState() const; Return reference to internal dummy RooCategory implementation; blinding state switch. Bool_t isHidden() const; If true, hiding mode is active. Double_t getHiddenVal(const RooArgSet* nset = 0) const; Bypass accessor to function value that also works in hidden mode. return getVal(nset). » Last changed: Mon Jul 4 15:21:23 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8714,Testability,test,testArg,8714,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:8808,Testability,test,testArg,8808,"l*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:16370,Testability,log,logEvalError,16370,"t() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRoo",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:16469,Testability,log,logEvalError,16469,"oneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; Bool_tisHidden() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:17445,Testability,test,testArg,17445,"tic voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:17540,Testability,test,testArg,17540,"* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:18498,Testability,test,testArg,18498,"umEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:3596,Usability,clear,clearEvalErrorLog,3596,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmd",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:3632,Usability,clear,clearShapeDirty,3632,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 ",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsHiddenReal.html:3672,Usability,clear,clearValueDirty,3672,"(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& ar",MatchSource.WIKI,root/html530/RooAbsHiddenReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsHiddenReal.html
https://root.cern/root/html530/RooAbsIntegrator.html:580,Availability,avail,available,580,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:1890,Availability,error,error,1890,"nIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:1974,Availability,error,error,1974,"teOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:364,Deployability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6181,Deployability,integrat,integration,6181,"rtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6209,Deployability,integrat,integrator,6209,"rtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6512,Deployability,integrat,integration,6512,"t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last ",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6808,Deployability,integrat,integrator,6808,"st va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:350,Integrability,interface,interface,350,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:364,Integrability,integrat,integrators,364,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:432,Integrability,interface,interface,432,". RooAbsIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsIntegrator. class RooAbsIntegrator: public TObject. RooAbsIntegrator is the abstract interface for integrators of real-valued; functions that implement the RooAbsFunc interface.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6181,Integrability,integrat,integration,6181,"rtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6209,Integrability,integrat,integrator,6209,"rtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6512,Integrability,integrat,integration,6512,"t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last ",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6808,Integrability,integrat,integrator,6808,"st va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:1293,Modifiability,config,config,1293," virtual~RooAbsIntegrator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tcalculate(const Double_t* yvec = 0); virtual Bool_tcanIntegrate1D() const; virtual Bool_tcanIntegrate2D() const; virtual Bool_tcanIntegrateND() const; virtual Bool_tcanIntegrateOpenEnded() const; virtual Bool_tcheckLimits() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual RooAbsIntegrator*clone(const RooAbsFunc& function, const RooNumIntConfig& config) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTOb",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsIntegrator.html:6766,Modifiability,config,config,6766,"st va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const RooAbsFunc*_functionPointer to function binding of integrand; Bool_t_printEvalCounterIf true print number of function evaluation required for integration; Bool_t_validIs integrator in valid state?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t calculate(const Double_t* yvec = 0); Calculate integral value with given array of parameter values. Bool_t setLimits(Double_t xmin, Double_t xmax); Interface to set limits on integration. Bool_t setUseIntegrandLimits(Bool_t flag); Interface function that allows to defer limit definition to integrand definition. virtual ~RooAbsIntegrator(); Destructor. RooAbsIntegrator* clone(const RooAbsFunc& function, const RooNumIntConfig& config) const. Bool_t isValid() const; Is integrator in valid state. Double_t integrand(const Double_t* x) const; Return value of integrand at given observable values. const RooAbsFunc * integrand() const; Return integrand function binding. Bool_t checkLimits() const; If true, finite limits are required on the observable range. Double_t integral(const Double_t* yvec = 0). Bool_t canIntegrate1D() const. Bool_t canIntegrate2D() const. Bool_t canIntegrateND() const. Bool_t canIntegrateOpenEnded() const. Bool_t printEvalCounter() const; { return _printEvalCounter ; }. void setPrintEvalCounter(Bool_t value); { _printEvalCounter = value ; }. Bool_t setLimits(Double_t* , Double_t* ); { return kFALSE ; }. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsIntegrator.html
https://root.cern/root/html530/RooAbsLValue.html:730,Availability,avail,available,730,". RooAbsLValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsLValue. class RooAbsLValue. Abstract base class for objects that are lvalues, i.e. objects; whose value can be modified directly. This class implements; abstract methods for binned fits that return the number of fit; bins and change the value of the object to the central value of a; given fit bin, regardless of the type of value.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsLValue(); static TClass*Class(); virtual Int_tgetBin(const char* rangeName = 0) const; virtual Int_tgetBin(const RooAbsBinning*) const; virtual const RooAbsBinning*getBinningPtr(const char* rangeName) const; virtual Double_tgetBinWidth(Int_t i, const char* rangeName = 0) const; virtual TClass*IsA() const; virtual Int_tnumBins(const char* rangeName = 0) const; RooAbsLValue&operator=(const RooAbsLValue&); virtual voidrandomize(const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual Double_tvolume(const char* rangeName) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsLValue(); Destructor. void setBin(Int_t ibin, const char* rangeName = 0). Int_t getBin(const char* rangeName = 0) const. Int_t numBins(const char* rangeName = 0) const. Double_t getBinWidth(Int_t i, const char* rangeName = 0) const. Double_t volume(const char* rangeName) const. void randomize(const char* rangeName = 0). const RooAbsBinning* getBinningPtr(const char* rangeName) const. Int_t getBin(const RooAbsBinning* ) const. » Last ch",MatchSource.WIKI,root/html530/RooAbsLValue.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsLValue.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:1990,Availability,error,error,1990,"r* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char*",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:2074,Availability,error,error,2074,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9723,Deployability,configurat,configuration,9723,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:5899,Integrability,depend,dependents,5899,"MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. RooArgSet*allDependents(); Bool_tbinGenData(); RooArgSet*dependents(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_textendedGen(); RooArgSet*fitInitParams(); RooAbsPdf*fitModel(); const char*fitOptions(); RooLinkedList*fitOptList(); RooArgSet*fitParams(); RooAbsGenContext*genContext(); RooArgSet*genInitParams(); RooAbsPdf*genModel(); RooArgSet*genParams(); const RooDataSet*genProtoData(); RooAbsData*genSample(); voidTObject::MakeZombie(); RooRealVar*nllVar(); Double_tnumExpGen(); RooArgSet*projDeps(); Bool_trandProto(); RooFitResult*refit(RooAbsData* inGenSample = 0); Bool_tverboseGen(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:8897,Integrability,depend,dependents,8897,"(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If tr",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9213,Integrability,depend,dependents,9213,"eters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » La",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:10171,Integrability,message,message,10171,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:647,Modifiability,variab,variables,647,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); RooAbsMCStudyModule(const char* name, const char* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0);",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9723,Modifiability,config,configuration,9723,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9825,Modifiability,extend,extendedGen,9825,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9848,Modifiability,extend,extended,9848,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:404,Performance,perform,perform,404,". RooAbsMCStudyModule. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsMCStudyModule. class RooAbsMCStudyModule: public TNamed. RooAbsMCStudyModule is a base class for add-on modules to RooMCStudy that; can perform additional calculations on each generate+fit cycle managed; by RooMCStudy; This class can insert code to be executed before each generation step,; between the generation and fitting step and after the fitting step.; Any summary output variables declared in the RooDataSet exported through; summaryData() is merged with the 'master' summary dataset in RooMCStudy; Look at RooDLLSignificanceMCStudyModule for an example of an implementation; . Function Members (Methods); public:. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); RooAbsMCStudyModule(const char* name, const char* title); virtual~RooAbsMCStudyModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tdoInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0);",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:7756,Performance,perform,performed,7756,"kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooMCStudy*_mcsPointer to RooMCStudy object module is attached to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsMCStudyModule(const char* name, const char* title); Constructor. RooAbsMCStudyModule(const RooAbsMCStudyModule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAb",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:8218,Performance,perform,performed,8218,"ule& other); Copy constructor. Bool_t doInitializeInstance(RooMCStudy& ); Store reference to RooMCStudy object that this module relates to and call internal module; initialization function. virtual ~RooAbsMCStudyModule(); {}. Bool_t initializeInstance(); Initializer called immediately after attachment to RooMCStudy object and initialization of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:8504,Performance,perform,performed,8504,"ation of module base class. Bool_t initializeRun(Int_t ); Method called at the beginning of each RooMCStudy run. RooDataSet* finalizeRun(); Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy. Bool_t processBeforeGen(Int_t ); Method called after resetting of generator parameters to initial values and before call to generator context; Any modifications to generator parameters will affect next generation operation (only). Bool_t processBetweenGenAndFit(Int_t ); Method called after generation of toy data sample and resetting of fit parameters to initial values and before; actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist. Bool_t processAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsMCStudyModule.html:9633,Testability,log,log,9633,"rocessAfterFit(Int_t ); Method called after fit has been performed. RooFitResult* refit(RooAbsData* inGenSample = 0); Interface methods to RooMCStudy objects,; which are only functional after module has been attached to a RooMCStudy object. RooAbsData* genSample(); Return generate sample. RooAbsPdf* genModel(); Return generator pdf. RooAbsGenContext* genContext(); Accessor for generator context, generator parameters,	prototype data and projected dependents. RooArgSet* genInitParams(); Return initial value of generator model parameters. RooArgSet* genParams(); Return current value of generator model parameters. const RooDataSet* genProtoData(); Return generator prototype data provided by user. RooArgSet* projDeps(); Return projected observables. RooArgSet* dependents(); Accessors for fit observables, fit model, current and initial fit parameters and NLL value. RooArgSet* allDependents(); Returna all observables. RooAbsPdf* fitModel(); Return fit model. RooArgSet* fitInitParams(); Return initial value of parameters of fit model. RooArgSet* fitParams(); Return current value of parameters of fit model. RooRealVar* nllVar(); Return pointer to RooRealVar holding minimized -log(L) value. const char* fitOptions(); Accessors for fit options, generator annd MCstudy configuration flags. RooLinkedList* fitOptList(); Return list of fit options provided by user. Bool_t extendedGen(); If true extended mode generation is requested. Bool_t binGenData(); If true binning of data between generating and fitting is requested. Double_t numExpGen(); Return expected number of events from generator model. Bool_t randProto(); If true randomization of prototype data order is requested. Bool_t verboseGen(); If true verbose message in the generation step is requested. » Last changed: Mon Jul 4 15:21:24 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsMCStudyModule.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsMCStudyModule.html
https://root.cern/root/html530/RooAbsNumGenerator.html:605,Availability,avail,available,605,". RooAbsNumGenerator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsNumGenerator. class RooAbsNumGenerator: public TNamed, public RooPrintable. Class RooAbsNumGenerator is the abstract base class for MC event generator; implementations like RooAcceptReject and RooFoam; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsNumGenerator.html:2140,Availability,error,error,2140," RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tT",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsNumGenerator.html:2224,Availability,error,error,2224,"et& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfm",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsNumGenerator.html:9007,Integrability,interface,interface,9007,"t*_cloneSetSet owning clone of input function; RooAbsReal*_funcClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStore; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verbose; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Mon Jul 4 15:21:25 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsNumGenerator.html:1264,Modifiability,config,config,1264," virtual~RooAbsNumGenerator(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidattachParameters(const RooArgSet& vars); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tcanSampleCategories() const; virtual Bool_tcanSampleConditional() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal&, const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voi",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsNumGenerator.html:8545,Modifiability,config,config,8545,"t*_cloneSetSet owning clone of input function; RooAbsReal*_funcClonePointer to top level node of cloned function; const RooAbsReal*_funcMaxValContainer for maximum function value; RooRealVar*_funcValPtrRRVs storing function value in context and in output dataset; RooRealVar*_funcValStore; Bool_t_isValidVerbose and valid flag; static Int_tRooPrintable::_nameLength; RooArgSet_realVarsSets of discrete and real valued observabeles; Bool_t_verbose; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsNumGenerator(); Destructor. void attachParameters(const RooArgSet& vars); Reattach original parameters to function clone. void printName(ostream& os) const; Print name of the generator. void printTitle(ostream& os) const; Print the title of the generator. void printClassName(ostream& os) const; Print the class name of the generator. void printArgs(ostream& os) const; Print the arguments of the generator. RooAbsNumGenerator* clone(const RooAbsReal& , const RooArgSet& genVars, const RooArgSet& condVars, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; If true, generator is in a valid state. void setVerbose(Bool_t verbose = kTRUE); If flag is true, verbose messaging will be active during generation. Bool_t isVerbose() const; Return status of verbose messaging flag. const RooArgSet * generateEvent(UInt_t remaining, Double_t& resampleRatio). Double_t getFuncMax(); { return 0 ; }. void Print(Option_t* options = 0) const; ascii printing interface. Bool_t canSampleCategories() const; Advertisement of capabilities. { return kFALSE ; }. Bool_t canSampleConditional() const; { return kFALSE ; }. » Last changed: Mon Jul 4 15:21:25 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsNumGenerator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsNumGenerator.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:1212,Availability,avail,available,1212," data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:10837,Availability,error,error,10837,,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:10921,Availability,error,error,10921,,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:33319,Deployability,integrat,integration,33319,tlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSe,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35533,Deployability,integrat,integrator,35533," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35544,Deployability,configurat,configuration,35544," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:8166,Integrability,depend,dependentVars,8166,"const char* rangeName = 0) const; virtual RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*RooAbsReal::createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual I",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9458,Integrability,depend,dependentOverlaps,9458,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9550,Integrability,depend,dependentOverlaps,9550,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9644,Integrability,depend,dependsOn,9644,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9773,Integrability,depend,dependsOn,9773,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9891,Integrability,depend,dependsOnValue,9891,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9998,Integrability,depend,dependsOnValue,9998,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:17380,Integrability,message,message,17380,"U ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOver",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:17531,Integrability,message,message,17531,"() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) c",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:33319,Integrability,integrat,integration,33319,tlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSe,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35533,Integrability,integrat,integrator,35533," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37500,Integrability,depend,depends,37500,"oAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37809,Integrability,depend,dependent,37809,"ternal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37874,Integrability,depend,dependent,37874,"ternal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38021,Integrability,message,messages,38021,"to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char*",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:23832,Modifiability,config,config,23832,"bject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNum",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35544,Modifiability,config,configuration,35544," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:521,Performance,optimiz,optimizations,521,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:2651,Performance,cache,cacheUniqueSuffix,2651,"verList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:11655,Performance,cache,cacheList,11655,"rRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunc",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:11743,Performance,cache,cacheList,11743,"ggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), co",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:19219,Performance,optimiz,optimizeCacheMode,19219,"(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:19291,Performance,optimiz,optimizeCacheMode,19291,"rg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:22509,Performance,cache,cache,22509,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Opt",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:23726,Performance,cache,cache,23726,"; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidseal(const char* notice = """"); const char*sealNotice() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsTestStatistic::setData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:25572,Performance,cache,cache,25572,":OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:28853,Performance,optimiz,optimizeDirtyHook,28853," RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; Int_tRooAbsTestStatistic::numSets() const; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::operMode() const; virtual voidRooAbsArg::operModeHook(); voidoptimizeCaching(); voidoptimizeConstantTerms(Bool_t); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; virtual voidprintCompactTreeHook(ostream& os, const char* indent = """"); virtual Bool_tredirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); virtual RooArgSetrequiredExtraObservables() const",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:32135,Performance,cache,cache,32135,,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:32334,Performance,cache,caches,32334,,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:33003,Performance,cache,cache,33003,"ing>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:33220,Performance,cache,cache,33220,always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Roo,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:33803,Performance,cache,cache,33803,riginal input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of pro,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:34942,Performance,cache,cache,34942,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35833,Performance,cache,cache,35833," statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. voi",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37115,Performance,optimiz,optimizations,37115,"values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bo",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37189,Performance,optimiz,optimization,37189,"rboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are fo",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37275,Performance,optimiz,optimizations,37275,"ringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AC",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37383,Performance,optimiz,optimizations,37383,"; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branch",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37418,Performance,optimiz,optimizeCaching,37418,"oAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38053,Performance,optimiz,optimizeConstantTerms,38053,"ate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Overr",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38134,Performance,optimiz,optimization,38134,"ate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Overr",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38191,Performance,cache,cached,38191,"ent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38238,Performance,cache,cached,38238,"ent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38991,Performance,cache,cacheUniqueSuffix,38991,"these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Mon Jul 4 15:21:25 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:32230,Security,validat,validate,32230,,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35120,Security,access,access,35120,"o own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNam",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:401,Testability,test,test,401,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:1059,Testability,test,test,1059,". RooAbsOptTestStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsOptTestStatistic. class RooAbsOptTestStatistic: public RooAbsTestStatistic. RooAbsOptTestStatistic is the abstract base class for test; statistics objects that evaluate a function or PDF at each point of a given; dataset. This class provides generic optimizations, such as; caching and precalculation of constant terms that can be made for; all such quantities; Implementations should define evaluatePartition(), which calculates the; value of a (sub)range of the dataset and optionally combinedValue(),; which combines the values calculated for each partition. If combinedValue(); is not overloaded, the default implementation will add the partition results; to obtain the combined result; Support for calculation in partitions is needed to allow multi-core; parallelized calculation of test statistics; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsOptTestStatistic(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtua",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9517,Testability,test,testArg,9517,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:9611,Testability,test,testArg,9611,"& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsData&data(); const RooAbsData&data() const; virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:17355,Testability,log,logEvalError,17355,"ect::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRoo",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:17454,Testability,log,logEvalError,17454,"bsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tisDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tisSealed() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:18430,Testability,test,testArg,18430,"tic voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg&",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:18525,Testability,test,testArg,18525,"* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const;",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:19435,Testability,test,testArg,19435,"rg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:34344,Testability,test,test,34344,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:34885,Testability,test,test,34885,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:35087,Testability,test,test,35087,lag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_t_sealedIs test statistic sealed -- i.,MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:36548,Testability,test,test,36548,"r configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defin",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37132,Testability,test,test,37132,"values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bo",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37475,Testability,log,logic,37475,"oAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:37586,Testability,test,test,37586," values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the ",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:38678,Testability,test,test,38678," these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AClean meaning that; their getVal() call will never result in an evaluate call.; Finally the branches in the dataset that correspond to observables; that are exclusively used in constant terms are disabled as; they serve no more purpose. Bool_t setDataSlave(RooAbsData& data, Bool_t cloneData = kTRUE); Change dataset that is used to given one. If cloneData is kTRUE, a clone of; in the input dataset is made. If the test statistic was constructed with; a range specification on the data, the cloneData argument is ignore and; the data is always cloned. RooAbsData& data(). const RooAbsData& data() const. RooAbsReal& function(); { return *_funcClone ; }. const RooAbsReal& function() const; { return *_funcClone ; }. const char* cacheUniqueSuffix() const; { return Form(""_%lx"", (ULong_t)_dataClone) ; }. Bool_t isDerived() const; Override this to be always true to force calculation of likelihood without parameters. { return kTRUE ; }. void seal(const char* notice = """"); { _sealed = kTRUE ; _sealNotice = notice ; }. Bool_t isSealed() const; { return _sealed ; }. const char* sealNotice() const; { return _sealNotice.Data() ; }. Bool_t allowFunctionCache(); { return kTRUE ; }. RooArgSet requiredExtraObservables() const; { return RooArgSet() ; }. » Last changed: Mon Jul 4 15:21:25 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:4042,Usability,clear,clearEvalErrorLog,4042,", const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:4078,Usability,clear,clearShapeDirty,4078,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdLis",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsOptTestStatistic.html:4118,Usability,clear,clearValueDirty,4118,"(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcombinedValue(RooAbsReal** gofArray, Int_t nVal) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsTestStatistic*RooAbsTestStatistic::create(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::creat",MatchSource.WIKI,root/html530/RooAbsOptTestStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html
https://root.cern/root/html530/RooAbsPdf.html:461,Availability,error,error,461,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:4441,Availability,avail,available,4441,"d with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:13473,Availability,error,error,13473,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:13557,Availability,error,error,13557,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40194,Availability,error,errors,40194,"oolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_norm",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:44273,Availability,error,error,44273,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCachin",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:44290,Availability,error,error,44290,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCachin",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:46694,Availability,error,error,46694,"values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:46755,Availability,error,error,46755,"values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47085,Availability,error,error,47085,"d histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:53104,Availability,error,errors,53104," Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:53191,Availability,error,error,53191," Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:53976,Availability,error,errors,53976,"is option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:54097,Availability,error,error,54097,"(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:54178,Availability,error,error,54178," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:55529,Availability,error,errors,55529,"arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:55555,Availability,error,errors,55555,"arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:57182,Availability,error,error,57182," os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event an",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:59128,Availability,error,error,59128,"copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the s",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:61539,Availability,error,error,61539,"otype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62689,Availability,error,error,62689,"nst RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64973,Availability,error,error,64973,"getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not speci",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:66114,Availability,error,error,66114,"- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67310,Availability,error,error,67310,"rint informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set)",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:70975,Availability,down,downward,70975,"rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). void plotOnCompSelect(RooArgSet* selNodes) const; Helper function for plotting of composite p.d.fs. Given; a set of selected components that should be plotted,; find all nodes that (in)directly depend on these selected; nodes. Mark all directly and indirecty selected nodes; as 'selected' using the selectComp() method. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is co",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:72949,Availability,error,errors,72949,"n)directly depend on these selected; nodes. Mark all directly and indirecty selected nodes; as 'selected' using the selectComp() method. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:73819,Availability,error,error,73819,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserte",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:73848,Availability,error,error,73848,"::none()); Add a box with parameter values (and errors) to the specified frame. The following named arguments are supported. Parameters(const RooArgSet& param) -- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserte",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:74051,Availability,error,error,74051,"-- Only the specified subset of parameters will be shown.; By default all non-contant parameters are shown; ShowConstants(Bool_t flag) -- Also display constant parameters; Format(const char* optStr) -- Classing [arameter formatting options, provided for backward compatibility; Format(const char* what,...) -- Parameter formatting options, details given below; Label(const chat* label) -- Add header label to parameter box; Layout(Double_t xmin, -- Specify relative position of left,right side of box and top of box. Position of; Double_t xmax, Double_t ymax) bottom of box is calculated automatically from number lines in box. The Format(const char* what,...) has the following structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital re",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:74776,Availability,error,errors,74776,"g structure. const char* what -- Controls what is shown. ""N"" adds name, ""E"" adds error,; ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; FixedPrecision(int n) -- Controls precision, set fixed number of digits; AutoPrecision(int n) -- Controls precision. Number of shown digits is calculated from error; + n specified additional digits (1 is sensible default). Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;. RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function o",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77916,Availability,error,error,77916,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77970,Availability,error,error,77970,"egrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherw",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78026,Availability,error,error,78026,"d. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is re",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1457,Deployability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1770,Deployability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1877,Deployability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2452,Deployability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2550,Deployability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2623,Deployability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2635,Deployability,configurat,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2656,Deployability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2949,Deployability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2997,Deployability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3164,Deployability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40495,Deployability,integrat,integration,40495,e of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsRea,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40945,Deployability,integrat,integrated,40945,Iter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_t,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42237,Deployability,configurat,configuration,42237,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42334,Deployability,integrat,integrator,42334,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42345,Deployability,configurat,configuration,42345,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43339,Deployability,integrat,integrating,43339,"torConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43689,Deployability,integrat,integration,43689,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:45483,Deployability,integrat,integrated,45483,"er all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects num",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67914,Deployability,integrat,integrated,67914," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:68753,Deployability,integrat,integration,68753,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:75577,Deployability,integrat,integrated,75577,"ion_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:75874,Deployability,integrat,integrated,75874,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76108,Deployability,integrat,integrated,76108," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76730,Deployability,integrat,integration,76730,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76926,Deployability,integrat,integrates,76926,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76951,Deployability,integrat,integrates,76951,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77110,Deployability,integrat,integration,77110,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77209,Deployability,integrat,integration,77209,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78122,Deployability,configurat,configuration,78122,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78230,Deployability,integrat,integrator,78230,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78241,Deployability,configurat,configuration,78241,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78313,Deployability,configurat,configuration,78313,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78444,Deployability,integrat,integrator,78444," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78455,Deployability,configurat,configuration,78455," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78527,Deployability,configurat,configuration,78527,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78639,Deployability,integrat,integrator,78639,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78651,Deployability,configurat,configuration,78651,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78677,Deployability,install,installed,78677,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78702,Deployability,configurat,configuration,78702,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78814,Deployability,configurat,configuration,78814,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78868,Deployability,configurat,configuration,78868,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78920,Deployability,configurat,configuration,78920,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78970,Deployability,configurat,configuration,78970,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79087,Deployability,configurat,configuration,79087,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79134,Deployability,configurat,configuration,79134,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79236,Deployability,configurat,configuration,79236,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3493,Energy Efficiency,efficient,efficient,3493,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:53640,Energy Efficiency,consumption,consumption,53640,"ult; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg ar",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:60930,Energy Efficiency,efficient,efficient,60930,"be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; G",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:325,Integrability,interface,interface,325,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:495,Integrability,interface,interface,495,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1097,Integrability,depend,dependents,1097,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1427,Integrability,depend,dependents,1427,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1457,Integrability,integrat,integrated,1457,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1770,Integrability,integrat,integration,1770," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1877,Integrability,integrat,integration,1877," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1896,Integrability,depend,dependents,1896," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2165,Integrability,depend,dependents,2165,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2431,Integrability,depend,dependents,2431,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2452,Integrability,integrat,integration,2452,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2518,Integrability,depend,dependents,2518," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2550,Integrability,integrat,integrate,2550," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2623,Integrability,integrat,integration,2623," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2656,Integrability,integrat,integration,2656,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2949,Integrability,integrat,integration,2949,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2981,Integrability,depend,dependent,2981,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2997,Integrability,integrat,integrated,2997,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3034,Integrability,depend,dependents,3034,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3146,Integrability,depend,dependent,3146,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3164,Integrability,integrat,integration,3164,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3302,Integrability,depend,dependents,3302,"et, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Member",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3408,Integrability,depend,dependent,3408,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.;",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3999,Integrability,depend,dependent,3999,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbs",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:4172,Integrability,depend,dependent,4172,"integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:10611,Integrability,depend,dependentVars,10611,"rg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Do",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12068,Integrability,depend,dependentOverlaps,12068,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12160,Integrability,depend,dependentOverlaps,12160,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12254,Integrability,depend,dependsOn,12254,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12383,Integrability,depend,dependsOn,12383,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12501,Integrability,depend,dependsOnValue,12501,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12608,Integrability,depend,dependsOnValue,12608,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:23066,Integrability,message,message,23066,"TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsRe",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:23217,Integrability,message,message,23217," const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg)",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40495,Integrability,integrat,integration,40495,e of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsRea,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40945,Integrability,integrat,integrated,40945,Iter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_t,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42334,Integrability,integrat,integrator,42334,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43339,Integrability,integrat,integrating,43339,"torConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its s",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43689,Integrability,integrat,integration,43689,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:45483,Integrability,integrat,integrated,45483,"er all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects num",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:46761,Integrability,message,messages,46761,"values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:46934,Integrability,message,messages,46934,"eature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47091,Integrability,message,message,47091,"d histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:49349,Integrability,message,messages,49349,"lihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:51948,Integrability,interface,interface,51948,"A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for back",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52009,Integrability,interface,interface,52009,"A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for back",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:53794,Integrability,message,messages,53794,"2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:54197,Integrability,message,messages,54197," matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCm",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:57385,Integrability,message,messages,57385,"roto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:59331,Integrability,message,messages,59331,"d. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64228,Integrability,depend,depends,64228,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64250,Integrability,rout,route,64250,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:65176,Integrability,message,messages,65176,". Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named argum",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:66317,Integrability,message,messages,66317,"xpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67461,Integrability,interface,interface,67461,"s generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; onl",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67914,Integrability,integrat,integrated,67914," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:68132,Integrability,message,message,68132,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:68753,Integrability,integrat,integration,68753,"ame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- A",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:69789,Integrability,depend,depends,69789,"ed by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d); ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable; NormRange(const char* name) -- Calculate curve normalization w.r.t. only in specified ranges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default i",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:71767,Integrability,depend,depend,71767," by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points; Invisble(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). void plotOnCompSelect(RooArgSet* selNodes) const; Helper function for plotting of composite p.d.fs. Given; a set of selected components that should be plotted,; find all nodes that (in)directly depend on these selected; nodes. Mark all directly and indirecty selected nodes; as 'selected' using the selectComp() method. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plot oneself on 'frame'. In addition to features detailed in RooAbsReal::plotOn(),; the scale factor for a PDF can be interpreted in three different ways. The interpretation; is controlled by ScaleType. Relative - Scale factor is applied on top of PDF normalization scale factor; NumEvent - Scale factor is interpreted as a number of events. The surface area; under the PDF curve will match that of a histogram containing the specified; number of event; Raw - Scale factor is applied to the raw (projected) probability density.; Not too useful, option provided for completeness. RooPlot* paramOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:75577,Integrability,integrat,integrated,75577,"ion_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = R",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:75874,Integrability,integrat,integrated,75874,"ill be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76108,Integrability,integrat,integrated,76108," plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76730,Integrability,integrat,integration,76730,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76926,Integrability,integrat,integrates,76926,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76951,Integrability,integrat,integrates,76951,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77110,Integrability,integrat,integration,77110,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77209,Integrability,integrat,integration,77209,"reateCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration f",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78230,Integrability,integrat,integrator,78230,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78444,Integrability,integrat,integrator,78444," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78639,Integrability,integrat,integrator,78639,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:960,Modifiability,variab,variables,960,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:995,Modifiability,variab,variables,995,". RooAbsPdf. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1379,Modifiability,variab,variables,1379,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1413,Modifiability,variab,variables,1413,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2635,Modifiability,config,configuration,2635," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:17100,Modifiability,extend,extended,17100,"nerate(RooAbsPdf::GenSpec&) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; RooDataHist*generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataHist*generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsR",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:30654,Modifiability,config,config,30654,"s(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::s",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:30761,Modifiability,config,config,30761," out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42237,Modifiability,config,configuration,42237,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42345,Modifiability,config,configuration,42345,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47159,Modifiability,extend,extendedTerm,47159,"the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fla",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47242,Modifiability,extend,extended,47242,"the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fla",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47427,Modifiability,extend,extendable,47427,"use that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given r",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:48263,Modifiability,extend,extended,48263,"(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:50777,Modifiability,extend,extended,50777,", RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flo",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:55458,Modifiability,extend,extended,55458,"elihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFAL",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:56904,Modifiability,variab,variables,56904,"split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:57040,Modifiability,variab,variables,57040,"malization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:57543,Modifiability,extend,extended,57543,"f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const R",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:58081,Modifiability,variab,variables,58081,"s of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:58352,Modifiability,variab,variables,58352,"; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:58850,Modifiability,variab,variables,58850,"dOrder) the order of the events in the dataset will be read in a random order; if the requested number of events to be generated does not match the; number of events in the prototype dataset. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:58986,Modifiability,variab,variables,58986," otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode event",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:59548,Modifiability,extend,extended,59548,"Arg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:60280,Modifiability,variab,variables,60280,"r* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified vari",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:60551,Modifiability,variab,variables,60551," use with extended maximum likelihood fits; ProtoData(const RooDataSet& data, -- Use specified dataset as prototype dataset. If randOrder is set to true; Bool_t randOrder, the order of the events in the dataset will be read in a random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:60777,Modifiability,config,configured,60777,"random order; Bool_t resample) if the requested number of events to be generated does not match the; number of events in the prototype dataset. If resample is also set to; true, the prototype dataset will be resampled rather than be strictly; reshuffled. In this mode events of the protodata may be used more than; once. If ProtoData() is used, the specified existing dataset as a prototype: the new dataset will contain; the same number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t res",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:61244,Modifiability,variab,variables,61244,"e number of events as the prototype (unless otherwise specified), and any prototype variables not in; whatVars will be copied into the new dataset for each generated event and also used to set our PDF parameters.; The user can specify a number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:61397,Modifiability,variab,variables,61397,"to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars randomized. Variables in whatVars that; are not in the prototype will be added as new columns to the generated dataset. RooDataSet * generate(RooAbsPdf::GenSpec& ) const; Generate data according to a pre-configured specification created by; RooAbsPdf::prepareMultiGen(). If many identical generation requests; are needed, e.g. in toy MC studies, it is more efficient to use the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62047,Modifiability,variab,variables,62047,"e the prepareMultiGen()/generate(); combination than calling the standard generate() multiple times as; initialization overhead is only incurred once. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents = 0, Bool_t verbose = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62246,Modifiability,variab,variables,62246,"he specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0.; Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator al",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62518,Modifiability,variab,variables,62518,"ers. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet * generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; Internal method. RooDataSet * generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The defaul",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64695,Modifiability,variab,variables,64695,"s will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64831,Modifiability,variab,variables,64831,"sponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distributi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:65334,Modifiability,extend,extended,65334,"ateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified numb",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:65836,Modifiability,variab,variables,65836," the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooData",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:65972,Modifiability,variab,variables,65972,"taset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is k",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:66534,Modifiability,extend,extended,66534,"RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:66784,Modifiability,extend,extended,66784,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:66858,Modifiability,variab,variables,66858,"erate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67168,Modifiability,variab,variables,67168,"e(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; NumEvent(int nevt) -- Generate specified number of events; Extended() -- The actual number of events generated will be sampled from a Poisson distribution; with mu=nevt. For use with extended maximum likelihood fits; ExpectedData() -- Return a binned dataset _without_ statistical fluctuations (also aliased as Asimov()). RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67725,Modifiability,variab,variable,67725,"whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; Generate a new dataset containing the specified variables with; events sampled from our distribution. Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:67934,Modifiability,variab,variables,67934," Generate the specified; number of events or else try to use expectedEvents() if nEvents <= 0. If expectedData is kTRUE (it is kFALSE by default), the returned histogram returns the 'expected'; data sample, i.e. no statistical fluctuations are present. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:75226,Modifiability,extend,extended,75226," const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.50, Double_t xmax = 0.99, Double_t ymax = 0.95); OBSOLETE FUNCTION PROVIDED FOR BACKWARD COMPATIBILITY. RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.65, Double_t xmax = 0.99, Double_t ymax = 0.95, const RooCmdArg* formatCmd = 0); Add a text box with the current parameter values and their errors to the frame.; Observables of this PDF appearing in the 'data' dataset will be omitted. Optional label will be inserted as first line of the text box. Use 'sigDigits'; to modify the default number of significant digits printed. The 'xmin,xmax,ymax'; values specify the inital relative position of the text box in the plot frame. Double_t expectedEvents(const RooArgSet* nset) const; Return expected number of events from this p.d.f for use in extended; likelihood calculations. This default implementation returns zero. void verboseEval(Int_t stat); Change global level of verbosity for p.d.f. evaluations. Int_t verboseEval(); Return global level of verbosity for p.d.f. evaluations. RooAbsPdf* createProjection(const RooArgSet& iset); Return a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argum",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76912,Modifiability,variab,variables,76912,"bservables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalEr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78122,Modifiability,config,configuration,78122,"tion_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configurat",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78241,Modifiability,config,configuration,78241,"tion [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized nu",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78313,Modifiability,config,configuration,78313,"ng technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeN",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78455,Modifiability,config,configuration,78455," intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78527,Modifiability,config,configuration,78527,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78651,Modifiability,config,configuration,78651,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78702,Modifiability,config,configuration,78702,"ooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78814,Modifiability,config,configuration,78814,"aints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78868,Modifiability,config,configuration,78868,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78920,Modifiability,config,configuration,78920,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:78970,Modifiability,config,configuration,78970,"_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79064,Modifiability,config,config,79064,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79087,Modifiability,config,configuration,79087,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79134,Modifiability,config,configuration,79134,"he default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:79236,Modifiability,config,configuration,79236,"cialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setGeneratorConfig(const RooNumGenConfig& config); Set the given configuration as default numeric MC generator; configuration for this object. void setGeneratorConfig(); Remove the specialized numeric MC generator configuration associated; with this object. void setNormRange(const char* rangeName). void setNormRangeOverride(const char* rangeName). GenSpec* prepareMultiGen(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) co",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:80684,Modifiability,extend,extendMode,80684,"4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Int_t minDimNormValueCaching() const; { return _minDimNormValueCache ; }. Int_t intOrderNormValueCaching() const; { return _valueCacheIntOrder ; }. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Mon Jul 4 15:21:26 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:80741,Modifiability,extend,extended,80741,"4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Int_t minDimNormValueCaching() const; { return _minDimNormValueCache ; }. Int_t intOrderNormValueCaching() const; { return _valueCacheIntOrder ; }. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Mon Jul 4 15:21:26 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:80958,Modifiability,extend,extended,80958,"4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Int_t minDimNormValueCaching() const; { return _minDimNormValueCache ; }. Int_t intOrderNormValueCaching() const; { return _valueCacheIntOrder ; }. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Mon Jul 4 15:21:26 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:81034,Modifiability,extend,extended,81034,"4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(), const RooCmdArg& arg10 = RooCmdArg::none()) const. RooArgSet* getConstraints(const RooArgSet& , RooArgSet& , Bool_t ) const; Constraint management. Int_t minDimNormValueCaching() const; { return _minDimNormValueCache ; }. Int_t intOrderNormValueCaching() const; { return _valueCacheIntOrder ; }. Double_t getNorm(const RooArgSet& nset) const; Get p.d.f normalization term needed for observables 'nset'. Bool_t selfNormalized() const; If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term; This default implementation return false. ExtendMode extendMode() const; Returns ability of p.d.f to provided extended likelihood terms. Possible; answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This; default implementation always return CanNotBeExtended. Bool_t canBeExtended() const; If true p.d.f can provide extended likelihood term. Bool_t mustBeExtended() const; If true p.d.f must extended likelihood term. Double_t expectedEvents(const RooArgSet* nset) const. const char* normRange() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Hook function intercepting redirectServer calls. Discard current normalization; object if any server is redirected. » Last changed: Mon Jul 4 15:21:26 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1853,Performance,perform,perform,1853," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2676,Performance,perform,performed,2676,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:5866,Performance,cache,cacheUniqueSuffix,5866,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opco",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:14548,Performance,cache,cacheList,14548,"_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:14636,Performance,cache,cacheList,14636,"ual Double_texpectedEvents(const RooArgSet* nset) const; virtual Double_texpectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_textendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeextendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsR",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:25050,Performance,optimiz,optimizeCacheMode,25050,"t; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:25122,Performance,optimiz,optimizeCacheMode,25122,"t; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:29354,Performance,cache,cache,29354,"e::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:30574,Performance,cache,cache,30574,"irtual voidresetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetGeneratorConfig(); voidsetGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidsetNormRange(const char* rangeName); voidsetNormRangeOverride(const char* rangeName); voidsetNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:32919,Performance,cache,cache,32919,"idsetTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*specialGeneratorConfig() const; RooNumGenConfig*specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_ttraceEvalHook(Double_t value) const; Bool_ttraceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intverboseEval(); static voidverboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:36203,Performance,optimiz,optimizeDirtyHook,36203,"Context& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:39367,Performance,cache,cache,39367,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:39566,Performance,cache,caches,39566,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40101,Performance,cache,cache,40101,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40396,Performance,cache,cache,40396,"branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:40754,Performance,cache,cache,40754,oAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of ,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:41205,Performance,cache,cache,41205,ng to print; static Bool_t_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specG,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:41826,Performance,cache,cache,41826," label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_t_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_t_negCountNumber of negative probablities remaining to print; RooAbsReal*_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value ca",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42592,Performance,cache,cache,42592,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:42827,Performance,cache,cache,42827,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43506,Performance,cache,cached,43506,"RooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43580,Performance,cache,cache,43580,"RooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43619,Performance,cache,cached,43619,"RooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:43720,Performance,perform,performance,43720,"value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsPdf(); Destructor. Double_t getVal(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:44870,Performance,cache,cached,44870,"tical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. i",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:44957,Performance,cache,cached,44957,"RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so th",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:45565,Performance,cache,cache,45565,"ral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:45629,Performance,cache,cache,45629,"ral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:45713,Performance,cache,cache,45713,"nst RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so that the; an interpolated histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:48784,Performance,optimiz,optimization,48784,"::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAb",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:50386,Performance,perform,performed,50386,"likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:50455,Performance,perform,performed,50455," in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the stat",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52401,Performance,optimiz,optimization,52401," to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:54380,Performance,perform,performed,54380,"ce matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are suppo",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:54449,Performance,perform,performed,54449,"ing the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. See RooAbsPdf::fitTo(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:68190,Performance,perform,performed,68190,"esent. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); Special generator interface for generation of 'global observables' -- for RooStats tools. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables; Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only.; ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique; ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:76762,Performance,perform,performed,76762,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:2074,Safety,safe,safe,2074," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64119,Safety,safe,safely,64119,"rs with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:64264,Safety,safe,safe,64264,"cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the algorithm; corresponding to the specified code. The meaning of each code is; defined by the getGenerator() implementation. The default; implementation does nothing. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Check if given observable can be safely generated using the; pdfs internal generator mechanism (if that existsP). Observables; on which a PDF depends via more than route are not safe; for use with internal generators because they introduce; correlations not known to the internal generator. RooDataHist * generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); Generate a new dataset containing the specified variables with events sampled from our distribution.; Generate the specified number of events or expectedEvents() if not specified. Any variables of this PDF that are not in whatVars will use their; current values and be treated as fixed parameters. Returns zero; in case of an error. The caller takes ownership of the returned; dataset. The following named arguments are supported. Name(const char* name) -- Name of the output dataset; Verbose(Bool_t flag) -- Print informational messages during event generation; Extended() -- The actual number of events generated will be sampled from a Poi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:39462,Security,validat,validate,39462,,MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62871,Security,access,access,62871,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:62981,Security,access,accessed,62981,"& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; Generate a new dataset with values of the whatVars variables; sampled from our distribution. Use the specified existing dataset; as a prototype: the new dataset will contain the same number of; events as the prototype (by default), and any prototype variables not in; whatVars will be copied into the new dataset for each generated; event and also used to set our PDF parameters. The user can specify a; number of events to generate that will override the default. The result is a; copy of the prototype dataset with only variables in whatVars; randomized. Variables in whatVars that are not in the prototype; will be added as new columns to the generated dataset. Returns; zero in case of an error. The caller takes ownership of the; returned dataset. Int_t* randomizeProtoOrder(Int_t nProto, Int_t nGen, Bool_t resample = kFALSE) const; Return lookup table with randomized access order for prototype events,; given nProto prototype data events and nGen events that will actually; be accessed. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Load generatedVars with the subset of directVars that we can generate events for,; and return a code that specifies the generator algorithm we will use. A code of; zero indicates that we cannot generate any of the directVars (in this case, nothing; should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); implementation, but otherwise its value is arbitrary. The default implemetation of; this method returns zero. Subclasses will usually implement this method using the; matchArgs() methods to advertise the algorithms they provide. void initGenerator(Int_t code); Interface for one-time initialization to setup the generator for the specified code. void generateEvent(Int_t code); Interface for generation of anan event using the ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1690,Testability,log,logic,1690," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:3274,Testability,assert,assert,3274,"e implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:4299,Testability,assert,assert,4299," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsPdf(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12127,Testability,test,testArg,12127,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:12221,Testability,test,testArg,12221,":createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:23041,Testability,log,logEvalError,23041,"Bit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:23140,Testability,log,logEvalError,23140,"; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tisDirectGenSafe(const RooAbsArg& arg) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAb",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:24213,Testability,test,testArg,24213,"message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNo",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:24308,Testability,test,testArg,24308,"t; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*RooAbsReal::mean(RooRealVar& obs); RooMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); Int_tminDimNormValueCaching() const; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; con",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:25266,Testability,test,testArg,25266,"t; virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tmustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const char*normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47031,Testability,log,log,47031,"d histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47133,Testability,log,log,47133,"d histogram is a good approximation of the true integral value.; The improved convergence behavior is a result of making the value of the normalization; integral deterministic for each value of the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned,",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47288,Testability,log,log,47288,"the parameters. If (multi-dimensional) numeric; integrals are calculated at insufficient precision (>=1e-7) MINUIT convergence may; be impaired by the effects numerical noise that can cause that subsequent evaluations; of an integral at the same point in parameter space can give slightly different answers. Bool_t traceEvalHook(Double_t value) const; WVE 08/21/01 Probably obsolete now. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limiting the number; of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t fla",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:47936,Testability,log,log,47936," of future error messages for this pdf to 'resetValue'. void setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); Reset trace counter to given value, limiting the; number of future trace messages for this pdf to 'value'. Double_t getLogVal(const RooArgSet* set = 0) const; Return the log of the current value with given normalization; An error message is printed if the argument of the log is negative. Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset = 0) const; Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected); of this PDF for the given number of observed events. For successfull operation the PDF implementation must indicate; it is extendable by overloading canBeExtended() and must; implemented the expectedEvents() function. RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. The following named arguments are supported. ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:49557,Testability,log,log,49557," separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default); SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrain(const RooArgSet&pars) -- For p.d.f.s that contain internal parameter constraint terms, only apply constraints to given subset of parameters; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Verbose(Bool_t flag) -- Constrols RooFit informational messages in likelihood construction; CloneData(Bool flag) -- Use clone of dataset in NLL (default is true). RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList); Construct representation of -log(L) of PDFwith given dataset. If dataset is unbinned, an unbinned likelihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; comman",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:50646,Testability,log,log,50646,"ihood is constructed. If the dataset; is binned, a binned likelihood is constructed. See RooAbsPdf::createNLL(RooAbsData& data, RooCmdArg arg1, RooCmdArg arg2, RooCmdArg arg3, RooCmdArg arg4,; RooCmdArg arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Fit PDF to given dataset. If dataset is unbinned, an unbinned maximum likelihood is performed. If the dataset; is binned, a binned maximum likelihood is performed. By default the fit is executed through the MINUIT; commands MIGRAD, HESSE and MINOS in succession. The following named arguments are supported. Options to control construction of -log(L). ConditionalObservables(const RooArgSet& set) -- Do not normalize PDF over listed observables; Extended(Bool_t flag) -- Add extended likelihood term, off by default; Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; SumCoefRange(const char* name) -- Set the range in which to interpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52417,Testability,test,test,52417," to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using sum-of-weights covariance matrix; to obtain correct error for weighted likelihood fits. If this option is activated the; corrected covariance matrix is calculated as Vcorr = V C-1 V, where V is the original; covariance matrix and C is the inverse of the covariance matrix calculated using the; weights squared. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time ",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:70393,Testability,log,log,70393,"ges. NB: A Range() by default implies a NormRange(); on the same range, but this option allows to override the default, or specify a normalization ranges; when the full curve is to be drawn. Misc content control. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events.; Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1.; ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions; AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is blue; LineWidth(Int_t width) -- Select line with in pixels, default is 3; FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code; Range(const char* name) -- Only draw curve in range defined by given name; Range(double lo, double hi) -- Only draw curve in specified range; VLines() -- Add vertical lines to y=0 at end points of curve; Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve point",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:1067,Usability,simpl,simply,1067,"ce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf. class RooAbsPdf: public RooAbsReal. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:6394,Usability,clear,clearEvalErrorLog,6394,"ataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:6430,Usability,clear,clearShapeDirty,6430,"RooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdA",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:6470,Usability,clear,clearValueDirty,6470,"ataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooC",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52070,Usability,simpl,simplex,52070,"terpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using su",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52097,Usability,simpl,simplex,52097,"terpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using su",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:52157,Usability,simpl,simplex,52157,"terpret the coefficients of RooAddPdf components; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; SplitRange(Bool_t flag) -- Use separate fit ranges in a simultaneous fit. Actual range name for each; subsample is assumed to by rangeName_{indexState} where indexState; is the state of the master index category of the simultaneous fit; Constrained() -- Apply all constrained contained in the p.d.f. in the likelihood; Contrain(const RooArgSet&pars) -- Apply constraints to listed parameters in likelihood using internal constrains in p.d.f; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinuit; interface, but others can be specified (through RooMinimizer interface). Type Algorithm; ------ ---------; Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correaction to errors and covariance matrix using su",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf.html:77877,Usability,clear,clearEvalError,77877,"unction, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder). RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; This helper function finds and collects all constraints terms of all coponent p.d.f.s; and returns a RooArgSet with all those terms. void clearEvalError(); Clear the evaluation error flag. Bool_t evalError(); Return the evaluation error flag. void raiseEvalError(); Raise the evaluation error flag. RooNumGenConfig* defaultGeneratorConfig(); Returns the default numeric MC generator configuration for all RooAbsReals. RooNumGenConfig* specialGeneratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumGenConfig* getGeneratorConfig() const; Return the numeric MC generator configuration used for this object. If; a specialized configuration was associated wi",MatchSource.WIKI,root/html530/RooAbsPdf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:469,Availability,error,error,469,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1465,Deployability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1778,Deployability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1885,Deployability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2460,Deployability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2558,Deployability,integrat,integrate,2558," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2631,Deployability,integrat,integration,2631," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2643,Deployability,configurat,configuration,2643," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2664,Deployability,integrat,integration,2664,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2957,Deployability,integrat,integration,2957,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3005,Deployability,integrat,integrated,3005,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3172,Deployability,integrat,integration,3172,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3501,Energy Efficiency,efficient,efficient,3501,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&ope",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:333,Integrability,interface,interface,333,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:503,Integrability,interface,interface,503,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1105,Integrability,depend,dependents,1105,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1435,Integrability,depend,dependents,1435,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1465,Integrability,integrat,integrated,1465,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1778,Integrability,integrat,integration,1778," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1885,Integrability,integrat,integration,1885," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1904,Integrability,depend,dependents,1904," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2173,Integrability,depend,dependents,2173,"are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2439,Integrability,depend,dependents,2439,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2460,Integrability,integrat,integration,2460,"hich; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2526,Integrability,depend,dependents,2526," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2558,Integrability,integrat,integrate,2558," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2631,Integrability,integrat,integration,2631," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2664,Integrability,integrat,integration,2664,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2957,Integrability,integrat,integration,2957,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2989,Integrability,depend,dependent,2989,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3005,Integrability,integrat,integrated,3005,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3042,Integrability,depend,dependents,3042,"ill be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent val",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3154,Integrability,depend,dependent,3154,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3172,Integrability,integrat,integration,3172,"h other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never c",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3310,Integrability,depend,dependents,3310,"et, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Member",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3416,Integrability,depend,dependent,3416,"is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&ope",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4007,Integrability,depend,dependent,4007,"ained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto;",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4180,Integrability,depend,dependent,4180,"integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:968,Modifiability,variab,variables,968,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1003,Modifiability,variab,variables,1003,". RooAbsPdf::GenSpec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their fun",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1387,Modifiability,variab,variables,1387,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1421,Modifiability,variab,variables,1421,"cal/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'in",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2643,Modifiability,config,configuration,2643," each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4817,Modifiability,extend,extended,4817,"; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). GenSpec(); { _genContext = 0 ; _protoData = 0 ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:5277,Modifiability,extend,extended,5277,"t function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). GenSpec(); { _genContext = 0 ; _protoData = 0 ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:5501,Modifiability,extend,extended,5501,"t function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). GenSpec(); { _genContext = 0 ; _protoData = 0 ; }. GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1861,Performance,perform,perform,1861," is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions wil",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2684,Performance,perform,performed,2684,"alization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:2082,Safety,safe,safe,2082," variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to b",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1698,Testability,log,logic,1698," part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian terms,; multiplication with other PDFs that have one or more dependents in; commen etc). To implement analytical integrals, two functions must be implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t an",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:3282,Testability,assert,assert,3282,"e implemented. First,. Int_t getAnalyticalIntegral(const RooArgSet& integSet, RooArgSet& anaIntSet). advertises the analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Second,. Double_t analyticalIntegral(Int_t code). Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. The integration range for real each dependent to be integrated can; be obtained from the dependents' proxy functions min() and; max(). Never call these proxy functions for any proxy not known to; be a dependent via the integration code. Doing so may be; ill-defined, e.g. in case the proxy holds a function, and will; trigger an assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:4307,Testability,assert,assert,4307," assert. Integrated category dependents should always be; summed over all of their states. [Direct generation of observables]. Any PDF dependent can be generated with the accept/reject method,; but for certain PDFs more efficient methods may be implemented. To; implement direct generation of one or more observables, two; functions need to be implemented, similar to those for analytical; integrals:. Int_t getGenerator(const RooArgSet& generateVars, RooArgSet& directVars) and; void generateEvent(Int_t code). The first function advertises observables that can be generated,; similar to the way analytical integrals are advertised. The second; function implements the generator for the advertised observables. The generated dependent values should be store in the proxy; objects. For this the assignment operator can be used (i.e. xProxy; = 3.0 ). Never call assign to any proxy not known to be a dependent; via the generation code. Doing so may be ill-defined, e.g. in case; the proxy holds a function, and will trigger an assert. Function Members (Methods); public:. virtual~GenSpec(); static TClass*Class(); RooAbsPdf::GenSpecGenSpec(); virtual TClass*IsA() const; RooAbsPdf::GenSpec&operator=(const RooAbsPdf::GenSpec&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. RooAbsPdf::GenSpecGenSpec(const RooAbsPdf::GenSpec& other); RooAbsPdf::GenSpecGenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended, Bool_t randProto, Bool_t resampleProto, TString dsetName). Data Members; private:. TString_dsetName; Bool_t_extended; RooAbsGenContext*_genContext; Int_t_nGen; RooDataSet*_protoData; Bool_t_randProto; Bool_t_resampleProto; RooArgSet_whatVars. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~GenSpec(). GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t exten",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsPdf__GenSpec.html:1075,Usability,simpl,simply,1075,"rce file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsPdf::GenSpec. class RooAbsPdf::GenSpec. RooAbsPdf is the abstract interface for all probability density; functions The class provides hybrid analytical/numerical; normalization for its implementations, error tracing and a MC; generator interface. A minimal implementation of a PDF class derived from RooAbsPdf; should overload the evaluate() function. This functions should; return PDFs value. [Normalization/Integration]. Although the normalization of a PDF is an integral part of a; probability density function, normalization is treated separately; in RooAbsPdf. The reason is that a RooAbsPdf object is more than a; PDF: it can be a building block for a more complex, composite PDF; if any of its variables are functions instead of variables. In; such cases the normalization of the composite may not be simply the; integral over the dependents of the top level PDF as these are; functions with potentially non-trivial Jacobian terms themselves.; Therefore. --> No explicit attempt should be made to normalize; the functions output in evaluate(). In addition, RooAbsPdf objects do not have a static concept of what; variables are parameters and what variables are dependents (which; need to be integrated over for a correct PDF normalization).; Instead the choice of normalization is always specified each time a; normalized values is requested from the PDF via the getVal(); method. RooAbsPdf manages the entire normalization logic of each PDF with; help of a RooRealIntegral object, which coordinates the integration; of a given choice of normalization. By default, RooRealIntegral will; perform a fully numeric integration of all dependents. However,; PDFs can advertise one or more (partial) analytical integrals of; their function, and these will be used by RooRealIntegral, if it; determines that this is safe (i.e. no hidden Jacobian ter",MatchSource.WIKI,root/html530/RooAbsPdf__GenSpec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsPdf__GenSpec.html
https://root.cern/root/html530/RooAbsProxy.html:666,Availability,avail,available,666,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Return normalization set to be used for evaluation of contents. Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automa",MatchSource.WIKI,root/html530/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsProxy.html
https://root.cern/root/html530/RooAbsProxy.html:466,Deployability,update,updated,466,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Return normalization set to be used for evaluation of contents. Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automa",MatchSource.WIKI,root/html530/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsProxy.html
https://root.cern/root/html530/RooAbsProxy.html:313,Integrability,interface,interface,313,". RooAbsProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsProxy. class RooAbsProxy. RooAbsProxy is the abstact interface for proxy classes.; Proxy classes hold pointers to other Roofit objects ; and process serverRedirect changes so that the proxied; pointers are updated accordingly on a clone or copy of; of the owning class; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsProxy(); static TClass*Class(); virtual TClass*IsA() const; virtual const char*name() const; const RooArgSet*nset() const; RooAbsProxy&operator=(const RooAbsProxy&); virtual voidprint(ostream& os, Bool_t addContents = kFALSE) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. virtual voidchangeNormSet(const RooArgSet* newNormSet); virtual Bool_tchangePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). Data Members; protected:. RooArgSet*_nset! Normalization set to be used for evaluation of RooAbsPdf contents. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void changeNormSet(const RooArgSet* newNormSet); Destructor. void print(ostream& os, Bool_t addContents = kFALSE) const; Print proxy name. virtual ~RooAbsProxy(); Destructor. const char* name() const; Return name of proxy. const RooArgSet* nset() const; Return normalization set to be used for evaluation of contents. Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange = kFALSE, Bool_t factoryInitMode = kFALSE). » Last changed: Mon Jul 4 15:21:27 2011 » Last generated: 2011-07-04 15:21; This page has been automa",MatchSource.WIKI,root/html530/RooAbsProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsProxy.html
https://root.cern/root/html530/RooAbsReal.html:822,Availability,avail,available,822,". RooAbsReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsReal. class RooAbsReal: public RooAbsArg. RooAbsReal is the common abstract base class for objects that represent a; real value and implements functionality common to all real-valued objects; such as the ability to plot them, to construct integrals of them, the; ability to advertise (partial) analytical integrals etc..; Implementation of RooAbsReal may be derived, thus no interface; is provided to modify the contents.; ; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFAL",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:9645,Availability,error,error,9645,,MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:9729,Availability,error,error,9729,,MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32629,Availability,error,error,32629,"tringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integra",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:39670,Availability,error,error,39670,"Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:40280,Availability,error,error,40280,"eate a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:41178,Availability,error,error,41178,"iables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the functions density (function value times the; bin volume) rather than function value. If showProgress is true; a process indicator is printed on stdout in steps of one percent,; which is mostly useful for the sampling of expensive functions; such as likelihoods. TH1* createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function for the variables with given names; The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none()",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:46515,Availability,error,errors,46515,"ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire cu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:46620,Availability,error,error,46620,"ta(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:46701,Availability,error,error,46701,"present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projecti",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:46827,Availability,error,error,46827,"en set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plot",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:48272,Availability,down,downward,48272,"given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid. LineColor(Int_t color) -- Select line color by ROOT color code, default is blue. LineWidth(Int_t width) -- Select line with in pixels, default is 3. FillStyle(Int_t style) -- Select fill style, default is not filled. If a filled style is selected, also use VLines(); to add vertical downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:49262,Availability,error,error,49262,"cal downward lines at end of curve to ensure proper closure; FillColor(Int_t color) -- Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:49330,Availability,error,error,49330," Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curve",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:49380,Availability,error,error,49380," Select fill color by ROOT color code. Range(const char* name) -- Only draw curve in range defined by given name. Range(double lo, double hi) -- Only draw curve in specified range. VLines() -- Add vertical lines to y=0 at end points of curve. Precision(Double_t eps) -- Control precision of drawn curve w.r.t to scale of plot, default is 1e-3. Higher precision; will result in more and more densely spaced curve points. Invisible(Bool_t flag) -- Add curve to frame, but do not display. Useful in combination AddTo(). VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curve",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:49909,Availability,robust,robust,49909," Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:49916,Availability,error,error,49916," Double_t Z=1, Bool_t linearMethod=kTRUE); -- Visualize the uncertainty on the parameters, as given in fitres, at 'Z' sigma'. VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;; -- Visualize the uncertainty on the subset of parameters 'param', as given in fitres, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:50162,Availability,error,error,50162,"res, at 'Z' sigma'. Details on error band visualization. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51365,Availability,error,errors,51365,"sen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52945,Availability,error,error,52945,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52973,Availability,error,errors,52973,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:53060,Availability,error,error,53060,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:53095,Availability,error,error,53095,"bsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the p",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:53683,Availability,error,error,53683,"erformed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by ca",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:53854,Availability,error,error,53854,"ct. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be suc",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:53904,Availability,error,error,53904,"ct. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be suc",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:54412,Availability,robust,robust,54412,"rgList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Uti",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:54419,Availability,error,error,54419,"rgList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Uti",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:54665,Availability,error,error,54665,"RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linMethod=kTRUE) a linearized error is shown which is calculated as follows; T; error(x) = Z* F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) the plotted curve and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameter",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62241,Availability,error,error,62241,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62301,Availability,error,error,62301,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62418,Availability,error,error,62418," of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62444,Availability,error,errors,62444,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62593,Availability,error,errors,62593,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63067,Availability,error,error,63067," in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = R",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63150,Availability,error,errors,63150,"e, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63316,Availability,error,error,63316,"logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63468,Availability,error,error,63468,"ors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63600,Availability,error,error,63600,"gh RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63671,Availability,error,errors,63671,"valError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = k",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63794,Availability,error,error,63794,"n are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63834,Availability,error,errors,63834,"n are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63891,Availability,error,errors,63891,". Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63980,Availability,error,errors,63980,"duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization range choice is only fixed for those; RooAddPdf components that currently use the de",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:73049,Availability,error,errors,73049,"s run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Act",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:73170,Availability,error,error,73170,"NOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:73251,Availability,error,error,73251,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); I",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:74009,Availability,error,errors,74009,"printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given colum",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:74035,Availability,error,errors,74035,"printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given colum",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:74868,Availability,error,errors,74868,"guments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of an",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:75152,Availability,error,errors,75152,"processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to create a chi2. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights, or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76444,Availability,error,errors,76444,"s run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76565,Availability,error,error,76565,"NOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control constructi",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76646,Availability,error,error,76646,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:77410,Availability,error,errors,77410," of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:77694,Availability,error,errors,77694,"h error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to f",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78075,Availability,error,error,78075,"& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& ar",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78133,Availability,error,error,78133,"dArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78204,Availability,error,errors,78204,"dArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78322,Availability,error,error,78322,"be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCm",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:79849,Availability,error,error,79849," flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset. return createIntegral(iset,&nset,0,rangeName). Int_t minTrialSamples(const RooArgSet& ) const; { return 0 ; }. Double_t defaultErrorLevel() const; Return default level for MINUIT error analysis. ErrorLoggingMode evalErrorLoggingMode(). EvalErrorIter evalErrorIter(). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& , Double_t , Double_t ) const; Interface for returning an optional hint for initial sampling points when constructing a curve; projected on observable. RooMoment* mean(RooRealVar& obs); { return moment(obs,1,kFALSE,kFALSE) ; }. RooMoment* mean(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs); { return moment(obs,2,kTRUE,kTRUE) ; }. RooMoment* sigma(RooRealVar& obs, const RooArgSet& nset); { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }. Bool_t setData(RooAbsData& , Bool_t = kTRUE); { return kTRUE ; }. Bool_t traceEvalHook(Double_t ) const; Hook function to add functionality to evaluation tracing in derived classes. Double_t evaluate() const. void syncCache(const RooArgSet* set = 0); { getVal(set) ; }. void selectComp(Bool_t flag); If flag",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:29919,Deployability,integrat,integration,29919,"s from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag se",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:31032,Deployability,integrat,integrator,31032," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:31043,Deployability,configurat,configuration,31043," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33418,Deployability,integrat,integration,33418,"t. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(ist",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33516,Deployability,integrat,integrate,33516,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33589,Deployability,integrat,integration,33589,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33601,Deployability,configurat,configuration,33601,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33622,Deployability,integrat,integration,33622,"pper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:35815,Deployability,integrat,integration,35815,"or now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represen",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36011,Deployability,integrat,integrates,36011,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36036,Deployability,integrat,integrates,36036,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36241,Deployability,configurat,configuration,36241,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36271,Deployability,integrat,integration,36271,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36692,Deployability,integrat,integration,36692,"(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual i",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36888,Deployability,integrat,integrates,36888,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36913,Deployability,integrat,integrates,36913,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37177,Deployability,integrat,integrated,37177,"- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37261,Deployability,integrat,integration,37261,"ration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37932,Deployability,integrat,integration,37932," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38005,Deployability,integrat,integrated,38005," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38200,Deployability,integrat,integrated,38200,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38432,Deployability,integrat,integrated,38432,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38490,Deployability,integrat,integration,38490,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:40123,Deployability,integrat,integrating,40123,"ction for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHi",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44434,Deployability,integrat,integrated,44434,",Binning(-1,1,20), YVar(y,Binning(-1,1,30)), ZVar(z,Binning(""zbinning""))). The caller takes ownership of the returned histogram. TH1* createHistogram(const char* name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; Internal method implementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Overri",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:45657,Deployability,integrat,integration,45657," dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51089,Deployability,integrat,integration,51089,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52649,Deployability,integrat,integration,52649,"ch can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59533,Deployability,integrat,integration,59533,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59545,Deployability,configurat,configuration,59545,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59654,Deployability,integrat,integrator,59654,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59665,Deployability,configurat,configuration,59665,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59737,Deployability,configurat,configuration,59737,". If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59869,Deployability,integrat,integrator,59869," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59880,Deployability,configurat,configuration,59880," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59952,Deployability,configurat,configuration,59952," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60064,Deployability,integrat,integrator,60064," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60076,Deployability,configurat,configuration,60076," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60102,Deployability,install,installed,60102," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60127,Deployability,configurat,configuration,60127," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60227,Deployability,integrat,integration,60227,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60239,Deployability,configurat,configuration,60239,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60293,Deployability,configurat,configuration,60293,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60345,Deployability,configurat,configuration,60345,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60395,Deployability,configurat,configuration,60395,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60501,Deployability,integrat,integration,60501,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60513,Deployability,configurat,configuration,60513,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60567,Deployability,configurat,configuration,60567,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60619,Deployability,configurat,configuration,60619,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60669,Deployability,configurat,configuration,60669,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60787,Deployability,integrat,integrator,60787,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60798,Deployability,configurat,configuration,60798,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60831,Deployability,integrat,integration,60831,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60844,Deployability,configurat,configuration,60844,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60934,Deployability,integrat,integration,60934,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60946,Deployability,configurat,configuration,60946,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66417,Deployability,integrat,integration,66417,"ent 'obs' and should be copied in their preferred; order into argument 'orderdObs', This default implementation indicates no preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which f",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66613,Deployability,integrat,integrates,66613," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66638,Deployability,integrat,integrates,66638," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66768,Deployability,integrat,integration,66768,"enting 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which or",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66996,Deployability,integrat,integration,66996," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67130,Deployability,integrat,integrates,67130," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67262,Deployability,integrat,integration,67262,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67594,Deployability,integrat,integrate,67594," integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68098,Deployability,integrat,integration,68098,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68365,Deployability,integrat,integration,68365,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68921,Deployability,integrat,integration,68921,"ng integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:70345,Deployability,integrat,integrated,70345,",3 object bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments ar",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78705,Deployability,integrat,integration,78705,"tion over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33117,Energy Efficiency,efficient,efficient,33117,"perator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analy",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56098,Energy Efficiency,adapt,adaptor,56098,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56374,Energy Efficiency,adapt,adaptor,56374,"ooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:61861,Energy Efficiency,efficient,efficiently,61861,"tion for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:72713,Energy Efficiency,consumption,consumption,72713,"L calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76108,Energy Efficiency,consumption,consumption,76108,"ol_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:634,Integrability,interface,interface,634,". RooAbsReal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooAbsReal. class RooAbsReal: public RooAbsArg. RooAbsReal is the common abstract base class for objects that represent a; real value and implements functionality common to all real-valued objects; such as the ability to plot them, to construct integrals of them, the; ability to advertise (partial) analytical integrals etc..; Implementation of RooAbsReal may be derived, thus no interface; is provided to modify the contents.; ; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~RooAbsReal(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFAL",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:7144,Integrability,depend,dependentVars,7144,"nst RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName = 0) const; virtual RooAbsReal*createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; RooAbsReal*createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); const RooAbsReal*createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0)",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8314,Integrability,depend,dependentOverlaps,8314,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8406,Integrability,depend,dependentOverlaps,8406,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8500,Integrability,depend,dependsOn,8500,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8629,Integrability,depend,dependsOn,8629,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8747,Integrability,depend,dependsOnValue,8747,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:8854,Integrability,depend,dependsOnValue,8854,"onst RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*createProfile(const RooArgSet& paramsOfInterest); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tdefaultErrorLevel() const; static RooNumIntConfig*defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:15787,Integrability,message,message,15787,"bject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tRooAbsArg::isCloneOf(const RooAbsArg& other) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidlogEvalError(const char* message, const char* serverValueString = 0) const; static voidlogEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*mean(RooRealVar& obs); RooMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooA",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:15926,Integrability,message,message,15926,"r) const; Bool_tRooAbsArg::isConstant() const; virtual Bool_tRooAbsArg::isDerived() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsArg::isLValue() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; voidlogEvalError(const char* message, const char* serverValueString = 0) const; static voidlogEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tmaxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooMoment*mean(RooRealVar& obs); RooMoment*mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tminTrialSamples(const RooArgSet&) const; RooMoment*moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooMoment*moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVer",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:29919,Integrability,integrat,integration,29919,"s from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag se",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:31032,Integrability,integrat,integrator,31032," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32643,Integrability,wrap,wrapper,32643,"tringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integra",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33397,Integrability,depend,dependents,33397,"t. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(ist",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33418,Integrability,integrat,integration,33418,"t. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(ist",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33484,Integrability,depend,dependents,33484,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33516,Integrability,integrat,integrate,33516,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33589,Integrability,integrat,integration,33589,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33622,Integrability,integrat,integration,33622,"pper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:35815,Integrability,integrat,integration,35815,"or now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represen",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36011,Integrability,integrat,integrates,36011,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36036,Integrability,integrat,integrates,36036,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36271,Integrability,integrat,integration,36271,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36692,Integrability,integrat,integration,36692,"(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual i",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36888,Integrability,integrat,integrates,36888,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36913,Integrability,integrat,integrates,36913,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37177,Integrability,integrat,integrated,37177,"- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37261,Integrability,integrat,integration,37261,"ration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37932,Integrability,integrat,integration,37932," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38005,Integrability,integrat,integrated,38005," integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38162,Integrability,depend,depend,38162,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38200,Integrability,integrat,integrated,38200,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38432,Integrability,integrat,integrated,38432,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38490,Integrability,integrat,integration,38490,"h is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = --------",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:39007,Integrability,depend,dependentVars,39007,"nges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin ce",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:39490,Integrability,depend,dependentVars,39490," name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input pl",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:40123,Integrability,integrat,integrating,40123,"ction for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHi",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44434,Integrability,integrat,integrated,44434,",Binning(-1,1,20), YVar(y,Binning(-1,1,30)), ZVar(z,Binning(""zbinning""))). The caller takes ownership of the returned histogram. TH1* createHistogram(const char* name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; Internal method implementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Overri",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44652,Integrability,message,message,44652,"mplementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For ob",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:45657,Integrability,integrat,integration,45657," dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For observables present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:46720,Integrability,message,messages,46720,"present in given dataset; projection of PDF is achieved by constructing an average over all observable values in given set.; Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, -- As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging; const RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projecti",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:47004,Integrability,depend,depends,47004,"RooAbsData& d). ProjectionRange(const char* rn) -- Override default range of projection integrals to a different range speficied by given range name.; This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) -- Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control. PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per curve. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(Double_t value) -- Set curve points at which (pdf) evaluation error occur to specified value. By default the; function value is plotted. Normalization(Double_t scale, -- Adjust normalization by given scale factor. Interpretation of number depends on code: Relative:; ScaleType code) relative adjustment factor, NumEvent: scale to match given number of events. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) -- Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than; the PDF projection. Category must have two states with indices -1 and +1 or three states with; indeces -1,0 and +1. ShiftToZero(Bool_t flag) -- Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when; plotting -log(L) or chi^2 distributions. AddTo(const char* name, -- Add constructed projection to already existing curve with given name and relative weight factors; double_t wgtSelf, double_t wgtOther). Plotting control. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object. LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid. LineColor(Int_t color) -- Select line color by ROOT color code",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51089,Integrability,integrat,integration,51089,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51295,Integrability,depend,dependents,51295,"tions; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, R",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51732,Integrability,depend,dependents,51732,"(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51828,Integrability,interface,interface,51828,"* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52649,Integrability,integrat,integration,52649,"ch can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52859,Integrability,depend,dependents,52859,"interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the error evaluation; Argument argList can contain any RooCmdArg named argument that can be applied to a regular plotOn() operation. By default (linM",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55656,Integrability,depend,depend,55656,"nstructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56088,Integrability,interface,interface,56088,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59533,Integrability,integrat,integration,59533,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59654,Integrability,integrat,integrator,59654,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59869,Integrability,integrat,integrator,59869," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60064,Integrability,integrat,integrator,60064," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60227,Integrability,integrat,integration,60227,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60501,Integrability,integrat,integration,60501,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60787,Integrability,integrat,integrator,60787,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60831,Integrability,integrat,integration,60831,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60934,Integrability,integrat,integration,60934,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:61205,Integrability,depend,depends,61205," integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:61483,Integrability,depend,depends,61483,"egration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than gener",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62169,Integrability,message,message,62169,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62255,Integrability,message,messages,62255,"e depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for im",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62352,Integrability,message,message,62352," of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62424,Integrability,message,message,62424," of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62458,Integrability,rout,routed,62458,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62486,Integrability,protocol,protocol,62486,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62523,Integrability,message,message,62523,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62747,Integrability,message,messages,62747,"s provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to m",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:62887,Integrability,message,messages,62887,"ximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63474,Integrability,message,messages,63474,"ors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63800,Integrability,message,messages,63800,"n are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:63855,Integrability,message,message,63855,". Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66417,Integrability,integrat,integration,66417,"ent 'obs' and should be copied in their preferred; order into argument 'orderdObs', This default implementation indicates no preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which f",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66613,Integrability,integrat,integrates,66613," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66638,Integrability,integrat,integrates,66638," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66768,Integrability,integrat,integration,66768,"enting 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which or",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66996,Integrability,integrat,integration,66996," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67130,Integrability,integrat,integrates,67130," RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which shoul",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67262,Integrability,integrat,integration,67262,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67594,Integrability,integrat,integrate,67594," integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68098,Integrability,integrat,integration,68098,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68365,Integrability,integrat,integration,68365,"o; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooA",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:68921,Integrability,integrat,integration,68921,"ng integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf; ScanNum() -- Apply scanning technique if cdf integral involves numeric integration; ScanAll() -- Always apply scanning technique; ScanNone() -- Never apply scanning technique. RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); Utility function for createRunningIntegral that construct an object; implementing the numeric scanning technique for calculating the running integral. RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Utility function for createRunningIntegral that construct an; object implementing the standard (analytical) integration; technique for calculating the running integral. RooFunctor* functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a RooFunctor object bound to this RooAbsReal with given definition of observables; and parameters. TF1* asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Return a ROOT TF1,2,3 object bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:70345,Integrability,integrat,integrated,70345,",3 object bound to this RooAbsReal with given definition of observables; and parameters. RooDerivative* derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments ar",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:72867,Integrability,message,messages,72867,"; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control constructio",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:73270,Integrability,message,messages,73270,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. DataError(RooAbsData::ErrorType) -- Choose between Poisson errors and Sum-of-weights errors; NumCPU(Int_t) -- Activate parallel processing feature on N processes; Range() -- Calculate Chi2 only in selected region. RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList); I",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76262,Integrability,message,messages,76262,"; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:76665,Integrability,message,messages,76665,"duced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit steps, off by default; PrintLevel(Int_t level) -- Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; messages are suppressed as well; Warnings(Bool_t flag) -- Enable or disable MINUIT warnings (enabled by default); PrintEvalErrors(Int_t numErr) -- Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative; value suppress output completely, a zero value will only print the error count per p.d.f component,; a positive value is will print details of each error up to numErr messages per p.d.f component. RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a series of x and y value stored in a dataset.; The y values can either be the event weights (default), or can be another column designated; by the YVar() argument. The y value must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:78705,Integrability,integrat,integration,78705,"tion over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeName. return createIntegral(iset,0,0,rangeName). RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName = 0) const; Create integral over observables in iset in range named rangeName with integrand normalized over observables in",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:22084,Modifiability,config,config,22084," shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:31043,Modifiability,config,configuration,31043," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32225,Modifiability,variab,variable,32225,"ransient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSe",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32282,Modifiability,variab,variable,32282,"ects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function g",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33601,Modifiability,config,configuration,33601,"rorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(o",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:34289,Modifiability,variab,variable,34289,"e = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all paramet",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:34372,Modifiability,variab,variable,34372,"l integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegr",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:35997,Modifiability,variab,variables,35997,"value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is reque",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36241,Modifiability,config,configuration,36241,"meters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36874,Modifiability,variab,variables,36874,"rformed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37239,Modifiability,config,configure,37239,"ration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37856,Modifiability,parameteriz,parameterized,37856,"urn object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38108,Modifiability,parameteriz,parameterized,38108,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:38136,Modifiability,parameteriz,parameterization,38136,"nge, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Construct string with unique suffix name to give to integral object that encodes; integrated observables, normalization observables and the integration range name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:39569,Modifiability,variab,variables,39569," name. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. const RooAbsReal * createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; Utility function for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input pl",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:40143,Modifiability,variab,variables,40143,"ction for plotOn() that creates a projection of a function or p.d.f; to be plotted on a RooPlot. Create a new object G that represents the normalized projection:. Integral [ F[x,y,p] , { y } ]; G[x,p] = ---------------------------------; Integral [ F[x,y,p] , { x,y } ]. where F[x,y,p] is the function we represent, ""x"" are the; specified dependentVars, ""y"" are the specified projectedVars, and; ""p"" are our remaining variables (""parameters""). Return a; pointer to the newly created object, or else zero in case of an; error. The caller is responsible for deleting the contents of; cloneSet (which includes the returned projection object). TH1 * fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHi",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:40948,Modifiability,extend,extendedMode,40948," = 0, Bool_t setError = kTRUE) const; Fill the ROOT histogram 'hist' with values sampled from this; function at the bin centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the functions density (function value times the; bin volume) rather than function value. If showProgress is true; a process indicator is printed on stdout in steps of one percent,; which is mostly useful for the sampling of expensive functions; such as likelihoods. TH1* createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function for the variables with given names; The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * crea",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:41705,Modifiability,variab,variables,41705,"e bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the functions density (function value times the; bin volume) rather than function value. If showProgress is true; a process indicator is printed on stdout in steps of one percent,; which is mostly useful for the sampling of expensive functions; such as likelihoods. TH1* createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function for the variables with given names; The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function. This function accepts the following arguments. name -- Name of the ROOT histogram; xvar -- Observable to be mapped on x axis of ROOT histogram. Binning(const char* name) -- Apply binning with given name ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44245,Modifiability,variab,variable,44245,"apped on z axis of ROOT histogram. The YVar() and ZVar() arguments can be supplied with optional Binning() arguments to control the binning of the Y and Z axes, e.g.; createHistogram(""histo"",x,Binning(-1,1,20), YVar(y,Binning(-1,1,30)), ZVar(z,Binning(""zbinning""))). The caller takes ownership of the returned histogram. TH1* createHistogram(const char* name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; Internal method implementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting i",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44454,Modifiability,variab,variables,44454,",Binning(-1,1,20), YVar(y,Binning(-1,1,30)), ZVar(z,Binning(""zbinning""))). The caller takes ownership of the returned histogram. TH1* createHistogram(const char* name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const; Internal method implementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Overri",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55580,Modifiability,variab,variables,55580,"nstructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55631,Modifiability,variab,variables,55631,"nstructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56098,Modifiability,adapt,adaptor,56098,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56145,Modifiability,variab,variables,56145,"asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56374,Modifiability,adapt,adaptor,56374,"ooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59545,Modifiability,config,configuration,59545,"o analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configu",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59665,Modifiability,config,configuration,59665,"nst RooArgProxy& c, const RooArgProxy& d) const; Utility function for use in getAnalyticalIntegral(). If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is ret",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59737,Modifiability,config,configuration,59737,". If the; contents of proxies a,b,c,d occur in set 'allDeps' then the arguments; held in a,b,c,d are copied from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59880,Modifiability,config,configuration,59880," from allDeps to analDeps. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Utility function for use in getAnalyticalIntegral(). If the; contents of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; conf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:59952,Modifiability,config,configuration,59952," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60076,Modifiability,config,configuration,60076," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60127,Modifiability,config,configuration,60127," of 'refset' occur in set 'allDeps' then the arguments; held in 'refset' are copied from allDeps to analDeps. Bool_t matchArgsByName(const RooArgSet& allArgs, RooArgSet& matchedArgs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depS",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60239,Modifiability,config,configuration,60239,"gs, const TList& nameList) const; Check if allArgs contains matching elements for each name in nameList. If it does,; add the corresponding args from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60293,Modifiability,config,configuration,60293,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60345,Modifiability,config,configuration,60345,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60395,Modifiability,config,configuration,60395,"s from allArgs to matchedArgs and return kTRUE. Otherwise; return kFALSE and do not change matchedArgs. RooNumIntConfig* defaultIntegratorConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface fun",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60513,Modifiability,config,configuration,60513,"rConfig(); Returns the default numeric integration configuration for all RooAbsReals. RooNumIntConfig* specialIntegratorConfig() const; Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on t",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60567,Modifiability,config,configuration,60567,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60619,Modifiability,config,configuration,60619,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60669,Modifiability,config,configuration,60669,"eturns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned. RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const Roo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60764,Modifiability,config,config,60764,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60798,Modifiability,config,configuration,60798,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60844,Modifiability,config,configuration,60844,"g* specialIntegratorConfig(Bool_t createOnTheFly); Returns the specialized integrator configuration for _this_ RooAbsReal.; If this object has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this inf",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:60946,Modifiability,config,configuration,60946,"t has no specialized configuration, a null pointer is returned,; unless createOnTheFly is kTRUE in which case a clone of the default integrator; configuration is created, installed as specialized configuration, and returned. const RooNumIntConfig* getIntegratorConfig() const; Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. RooNumIntConfig* getIntegratorConfig(); Return the numeric integration configuration used for this object. If; a specialized configuration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empiric",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66599,Modifiability,variab,variables,66599," preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:2212,Performance,cache,cacheUniqueSuffix,2212,"::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = R",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:10439,Performance,cache,cacheList,10439,"* msgfmt) const; static RooAbsReal::EvalErrorIterevalErrorIter(); static RooAbsReal::ErrorLoggingModeevalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tfindRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidfixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidfixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidforceNumInt(Bool_t flag = kTRUE); RooFunctor*functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:10527,Performance,cache,cacheList,10527,"orLoggingModeevalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tfindRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidfixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidfixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidforceNumInt(Bool_t flag = kTRUE); RooFunctor*functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:17542,Performance,optimiz,optimizeCacheMode,17542,"ool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:17614,Performance,optimiz,optimizeCacheMode,17614,"ool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tnumEvalErrorItems(); static Int_tnumEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Double_t value) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:20911,Performance,cache,cache,20911,"g indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsRea",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:22002,Performance,cache,cache,22002,"replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:23752,Performance,cache,cache,23752,"tatic voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNumIntConfig*specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:26406,Performance,optimiz,optimizeDirtyHook,26406,"y = kFALSE) const; Bool_tisSelectedComp() const; virtual Bool_tisValid() const; virtual Bool_tisValidReal(Double_t value, Bool_t printError = kFALSE) const; voidmakeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tmatchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tplotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidselectComp(Bool_t flag); virtual voidselectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const;",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:28905,Performance,cache,cache,28905,,MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:29092,Performance,cache,caches,29092,,MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:29627,Performance,cache,cache,29627,,MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:29832,Performance,cache,cache,29832,"boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRef",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:30154,Performance,cache,cache,30154,"ts; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Boo",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:30708,Performance,cache,cache,30708," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:31213,Performance,cache,cache,31213," cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_t_plotBinsNumber of plot bins; Double_t_plotMaxMaximum of plot range; Double_t_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_t_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_t_treeVar!do not persist; UInt_t_uintValue! Transient cache for unsigned integer values from tree branches ; TString_unitUnit for objects value; Double_t_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32416,Performance,cache,cache,32416,"l_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32444,Performance,cache,cached,32444,"l_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:32507,Performance,cache,cache,32507,"l_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static Int_t_evalErrorCount; static map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >_evalErrorList; static RooAbsReal::ErrorLoggingMode_evalErrorMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsReal(); Destructor. Bool_t operator==(Double_t value) const; Equality operator comparing to a Double_t. Bool_t operator==(const RooAbsArg& other); Equality operator when comparing to another RooAbsArg.; Only functional when the other arg is a RooAbsReal. TString getTitle(Bool_t appendUnit = kFALSE) const; Return this variable's title string. If appendUnit is true and; this variable has units, also append a string "" (<unit>)"". Double_t getVal(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Int_t numEvalErrorItems(). Double_t traceEval(const RooArgSet* set) const; Calculate current value of object, with error tracing wrapper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function sho",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:33642,Performance,perform,performed,33642,"pper. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Variant of getAnalyticalIntegral that is also passed the normalization set; that should be applied to the integrand of which the integral is request.; For certain operator p.d.f it is useful to overload this function rather; than analyticalIntegralWN() as the additional normalization information; may be useful in determining a more efficient decomposition of the; requested integral. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Interface function getAnalyticalIntergral advertises the; analytical integrals that are supported. 'integSet'; is the set of dependents for which integration is requested. The; function should copy the subset of dependents it can analytically; integrate to anaIntSet and return a unique identification code for; this integration configuration. If no integration can be; performed, zero should be returned. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Implements the actual analytical integral(s) advertised by; getAnalyticalIntegral. This functions will only be called with; codes returned by getAnalyticalIntegral, except code zero. const char * getPlotLabel() const; Get the label associated with the variable. void setPlotLabel(const char* label); Set the label associated with this variable. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) cons",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:35847,Performance,perform,performed,35847,"or now). void printValue(ostream& os) const; Print object value. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Structure printing. Bool_t isValid() const; Check if current value is valid. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Interface function to check if given value is a valid value for this object.; This default implementation considers all values valid. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Create a RooProfileLL object that eliminates all nuisance parameters in the; present function. The nuisance parameters are defined as all parameters; of the function except the stated paramsOfInterest. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represen",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:36724,Performance,perform,performed,36724,"(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. NormSet(const RooArgSet&) -- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual i",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37094,Performance,perform,performed,37094,"- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37142,Performance,perform,performed,37142,"- Specify normalization set, mostly useful when working with PDFS; NumIntConfig(const RooNumIntConfig&) -- Use given configuration for any numeric integration, if necessary; Range(const char* name) -- Integrate only over given range. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ran",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:37335,Performance,perform,performed,37335,"nge. Multiple ranges may be specified; by passing multiple Range() arguments. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. If nset is specified the integrand is request; to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; the integral is performed over the named range, otherwise it is performed over the domain of each; integrated observable. If cfg is specified it will be used to configure any numeric integration; aspect of the integral. It will not force the integral to be performed numerically, which is; decided automatically by RooRealIntegral. RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; Utility function for createIntegral that creates the actual integreal object. void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; Utility function for createIntObj() that aids in the construct of recursive integrals; over functions with multiple observables with parameterized ranges. This function; finds in a given set allObs over which integration is requested the largeset subset; of observables that can be integrated simultaneously. This subset consists of; observables with fixed ranges and observables with parameterized ranges whose; parameterization does not depend on any observable that is also integrated. TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Con",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:41099,Performance,perform,performed,41099,"n centers. Our value is calculated by first; integrating out any variables in projectedVars and then scaling; the result by scaleFactor. Returns a pointer to the input; histogram, or zero in case of an error. The input histogram can; be any TH1 subclass, and therefore of arbitrary; dimension. Variables are matched with the (x,y,...) dimensions of; the input histogram according to the order in which they appear; in the input plotVars list. If scaleForDensity is true the; histogram is filled with a the functions density rather than; the functions value (i.e. the value at the bin center is multiplied; with bin volume). RooDataHist* fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; Fill a RooDataHist with values sampled from this function at the; bin centers. If extendedMode is true, the p.d.f. values is multiplied; by the number of expected events in each bin. An optional scaling by a given scaleFactor can be performed.; Returns a pointer to the input RooDataHist, or zero; in case of an error. If correctForBinSize is true the RooDataHist; is filled with the functions density (function value times the; bin volume) rather than function value. If showProgress is true; a process indicator is printed on stdout in steps of one percent,; which is mostly useful for the sampling of expensive functions; such as likelihoods. TH1* createHistogram(const char* varNameList, Int_t xbins = 0, Int_t ybins = 0, Int_t zbins = 0) const; Create and fill a ROOT histogram TH1,TH2 or TH3 with the values of this function for the variables with given names; The number of bins can be controlled using the [xyz]bins parameters. For a greater degree of control; use the createHistogram() method below with named arguments. The caller takes ownership of the returned histogram. TH1 * createHistogram(const char* name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg&",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:44710,Performance,perform,performed,44710,"mplementing createHistogram. RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; will show a unit normalized curve in the frame variable, taken at the present value; of other observables defined for this PDF. If a PDF is plotted in a frame in which a dataset has already been plotted, it will; show a projected curve integrated over all variables that were present in the shown; dataset except for the one on the x-axis. The normalization of the curve will also; be adjusted to the event count of the plotted dataset. An informational message; will be printed for each projection step that is performed. This function takes the following named arguments. Projection control. Slice(const RooArgSet& set) -- Override default projection behaviour by omittting observables listed; in set from the projection, resulting a 'slice' plot. Slicing is usually; only sensible in discrete observables. The slice is position at the 'current'; value of the observable objects. Slice(RooCategory& cat, -- Override default projection behaviour by omittting specified category; const char* label) observable from the projection, resulting in a 'slice' plot. The slice is positioned; at the given label value. Multiple Slice() commands can be given to specify slices; in multiple observables. Project(const RooArgSet& set) -- Override default projection behaviour by projecting over observables; given in set and complete ignoring the default projection behavior. Advanced use only. ProjWData(const RooAbsData& d) -- Override default projection _technique_ (integration). For ob",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:50590,Performance,perform,perform,50590,"it result; Z = requested significance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively (linMethod=kFALSE), a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51132,Performance,perform,performed,51132,"alues, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, c",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:51182,Performance,perform,performed,51182,"tions; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); longer to calculate. RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const; Internal back-end function of plotOn() with named arguments. RooPlot* plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; Plotting engine function for internal use. Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; function that occur in the previously plotted dataset are projected via partial integration,; otherwise no projections are performed. Optionally, certain projections can be performed; by summing over the values present in a provided dataset ('projData'), to correctly; project out data dependents that are not properly described by the PDF (e.g. per-event errors). The functions value can be multiplied with an optional scale factor. The interpretation; of the scale factor is unique for generic real functions, for PDFs there are various interpretations; possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details). The default projection behaviour can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, R",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:52692,Performance,perform,performed,52692," can be overriden by supplying an optional set of dependents; to project. For most cases, plotSliceOn() and plotProjOn() provide a more intuitive interface; to modify the default projection behavour. RooPlot* plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.0, RooAbsReal::ScaleType stype = Relative, const RooAbsData* projData = 0) const; OBSOLETE -- RETAINED FOR BACKWARD COMPATIBILITY. Use the plotOn(frame,Slice(...)) instead. RooPlot* plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))). Plot asymmetry of ourselves, defined as. asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ). on frame. If frame contains a histogram, all dimensions of the plotted; asymmetry function that occur in the previously plotted dataset are projected via partial integration.; Otherwise no projections are performed,. The asymmetry function can be multiplied with an optional scale factor. The default projection; behaviour can be overriden by supplying an optional set of dependents to project. Double_t getPropagatedError(const RooFitResult& fr); Calculate error on self by propagated errors on parameters with correlations as given by fit result; The linearly propagated error is calculated as follows; T; error(x) = F_a(x) * Corr(a,a') F_a'(x). where F_a(x) = [ f(x,a+da) - f(x,a-da) ] / 2, with f(x) this function and 'da' taken from the fit result; Corr(a,a') = the correlation matrix from the fit result. RooPlot* plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Plot function or p.d.f. on frame with support for visualization of the uncertainty encoded in the given fit result fr.; If params is non-zero, only the subset of the parameters in fr that occur in params is considered for the",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55093,Performance,perform,perform,55093,"(a,a') = the correlation matrix from the fit result; Z = requested signifance 'Z sigma band'. The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid =",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55226,Performance,perform,perform,55226,"ere N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56460,Performance,cache,cached,56460,"plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (D",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56501,Performance,cache,cache,56501,"plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (D",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56543,Performance,cache,cached,56543,"e list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundament",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56619,Performance,cache,cache,56619,"e list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundament",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:56777,Performance,cache,cache,56777,"t pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an object; F(x1,x2,x3,x4) returns an object f(x1,x3) that is evaluated using the; current values of x2 and x4. The caller takes ownership of the returned adaptor. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy the cached value of another RooAbsArg to our cache.; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. By default it will; register the internal value cache RooAbsReal::_value as branch; buffer for a Double_t tree branch with the same name as this; object. If no Double_t branch is found with the name of this; object, this method looks for a Float_t Int_t, UChar_t and UInt_t; branch in that order. If any of these are found the buffer for; that branch is set to a correctly typed conversion buffer in this; RooRealVar. A flag is set that will cause copyCache to copy the; object value from the appropriate conversion buffer instead of; the _value buffer. void fillTreeBranch(TTree& t); Fill the tree branch that associated with this object with its current value. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooRealVar fundamental object with our properties. The new; object will be created without any fit limits. Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Utility function for use in getAnalyticalIntegral(). If",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:61584,Performance,cache,cache,61584,"uration was associated with this object, that configuration; is returned, otherwise the default configuration for all RooAbsReals is returned. void setIntegratorConfig(const RooNumIntConfig& config); Set the given integrator configuration as default numeric integration; configuration for this object. void setIntegratorConfig(); Remove the specialized numeric integration configuration associated; with this object. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function to force use of a given set of observables; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function to force use of a given normalization range; to interpret function value. Needed for functions or p.d.f.s; whose shape depends on the choice of normalization such as; RooAddPdf. void setCacheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:66449,Performance,perform,performed,66449,"ent 'obs' and should be copied in their preferred; order into argument 'orderdObs', This default implementation indicates no preference; and copies the original order of 'obs' into 'orderedObs'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a running integral over this function, i.e. given a f(x), create an object; representing 'int[x_lo,x] f(x_prime) dx_prime'. RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which f",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67201,Performance,perform,performance,67201,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:67237,Performance,perform,perform,67237,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:70571,Performance,perform,performed,70571,"ative of this function. RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps = 0.001); Return function representing first, second or third order derivative of this function. RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); Return function representing moment of function of given order. If central is; true, the central moment is given <(x-<x>)^2>. RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Return function representing moment of p.d.f (normalized w.r.t given observables) of given order. If central is; true, the central moment is given <(x-<x>)^2>. If intNormObs is true, the moment of the function integrated over; all normalization observables is returned. Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval). Return value of x (in range xmin,xmax) at which function equals yval.; (Calculation is performed with Brent root finding algorithm). RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()). RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the f",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:71773,Performance,optimiz,optimization,71773,"(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()). RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Perform a chi^2 fit to given histogram By default the fit is executed through the MINUIT; commands MIGRAD, HESSE in succession. The following named arguments are supported. Options to control construction of -log(L). Range(const char* name) -- Fit only data inside range with given name; Range(Double_t lo, Double_t hi) -- Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; Multiple comma separated range names can be specified.; NumCPU(int num) -- Parallelize NLL calculation on num CPUs; Optimize(Bool_t flag) -- Activate constant term optimization (on by default). Options to control flow of fit procedure. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, on by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. Options to control informational output. Verbose(Bool_t flag) -- Flag controls if verbose output is printed (NLL, parameter changes during fit; Timer(Bool_t flag) -- Time CPU and wall clock consumption of fit s",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55242,Safety,sanity check,sanity check,55242,"ere N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
https://root.cern/root/html530/RooAbsReal.html:55274,Safety,safe,safe,55274,"ere N is the number of parameters), but may; not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made. Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; for each valye of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations. Bool_t plotSanityChecks(RooPlot* frame) const; Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations. void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; Utility function for plotOn() that constructs the set of; observables to project when plotting ourselves as function of; 'plotVar'. 'allVars' is the list of variables that must be; projected, but may contain variables that we do not depend on. If; 'silent' is cleared, warnings about inconsistent input parameters; will be printed. Bool_t isSelectedComp() const; If true, the current pdf is a selected component (for use in plotting). void globalSelectComp(Bool_t flag); Global switch controlling the activation of the selectComp() functionality. RooAbsFunc * bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; Create an interface adaptor f(vars) that binds us to the specified variables; (in arbitrary order). For example, calling bindVars({x1,x3}) on an ",MatchSource.WIKI,root/html530/RooAbsReal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/RooAbsReal.html
