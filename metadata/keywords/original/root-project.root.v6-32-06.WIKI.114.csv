id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TCling_8cxx_source.html:291345,Integrability,rout,routines,291345,"+= ' ';; 7436 allIncludes += includePaths[i + 1];; 7437 }; 7438 ; 7439 fprintf(fout, ""%s\n"", allIncludes.c_str());; 7440 }; 7441 ; 7442 return 0;; 7443}; 7444 ; 7445////////////////////////////////////////////////////////////////////////////////; 7446/// Interface to cling function; 7447 ; 7448void* TCling::FindSym(const char* entry) const; 7449{; 7450 R__LOCKGUARD(gInterpreterMutex);; 7451 return fInterpreter->getAddressOfGlobal(entry);; 7452}; 7453 ; 7454////////////////////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:291397,Integrability,wrap,wrapper,291397,"+= ' ';; 7436 allIncludes += includePaths[i + 1];; 7437 }; 7438 ; 7439 fprintf(fout, ""%s\n"", allIncludes.c_str());; 7440 }; 7441 ; 7442 return 0;; 7443}; 7444 ; 7445////////////////////////////////////////////////////////////////////////////////; 7446/// Interface to cling function; 7447 ; 7448void* TCling::FindSym(const char* entry) const; 7449{; 7450 R__LOCKGUARD(gInterpreterMutex);; 7451 return fInterpreter->getAddressOfGlobal(entry);; 7452}; 7453 ; 7454////////////////////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:291618,Integrability,wrap,wrapper,291618,"/////////////////////////////; 7446/// Interface to cling function; 7447 ; 7448void* TCling::FindSym(const char* entry) const; 7449{; 7450 R__LOCKGUARD(gInterpreterMutex);; 7451 return fInterpreter->getAddressOfGlobal(entry);; 7452}; 7453 ; 7454////////////////////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:291662,Integrability,rout,routines,291662," entry) const; 7449{; 7450 R__LOCKGUARD(gInterpreterMutex);; 7451 return fInterpreter->getAddressOfGlobal(entry);; 7452}; 7453 ; 7454////////////////////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile(const char* path) const; 7501{; 7502 // Modifying the interpreter state needs locking.; 7503 R__LOCKGUARD(gInte",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:296725,Integrability,message,messages,296725,"; 7575 assert(fClingCallbacks && ""We must have callbacks!"");; 7576 bool oldVal = fClingCallbacks->IsAutoLoadingEnabled();; 7577 fClingCallbacks->SetAutoLoadingEnabled(autoload);; 7578 return oldVal;; 7579}; 7580 ; 7581////////////////////////////////////////////////////////////////////////////////; 7582/// Enable/Disable the Autoparsing of headers.; 7583/// Returns the old value, i.e whether it was enabled or not.; 7584 ; 7585int TCling::SetClassAutoparsing(int autoparse); 7586{; 7587 bool oldVal = fHeaderParsingOnDemand;; 7588 fHeaderParsingOnDemand = autoparse;; 7589 return oldVal;; 7590}; 7591 ; 7592////////////////////////////////////////////////////////////////////////////////; 7593/// Suspend the Autoparsing of headers.; 7594/// Returns the old value, i.e whether it was suspended or not.; 7595 ; 7596Bool_t TCling::SetSuspendAutoParsing(Bool_t value) {; 7597 Bool_t old = fIsAutoParsingSuspended;; 7598 fIsAutoParsingSuspended = value;; 7599 if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);; 7600 return old;; 7601}; 7602 ; 7603////////////////////////////////////////////////////////////////////////////////; 7604/// Set a callback to receive error messages.; 7605 ; 7606void TCling::SetErrmsgcallback(void* p) const; 7607{; 7608#if defined(R__MUST_REVISIT); 7609#if R__MUST_REVISIT(6,2); 7610 Warning(""SetErrmsgcallback"", ""Interface not available yet."");; 7611#endif; 7612#endif; 7613}; 7614 ; 7615void TCling::ReportDiagnosticsToErrorHandler(bool enable); 7616{; 7617 if (enable) {; 7618 auto consumer = new TClingDelegateDiagnosticPrinter(; 7619 &fInterpreter->getDiagnostics().getDiagnosticOptions(),; 7620 fInterpreter->getCI()->getLangOpts(),; 7621 [] (clang::DiagnosticsEngine::Level Level, const std::string &Info) {; 7622 if (Level == clang::DiagnosticsEngine::Warning) {; 7623 ::Warning(""cling"", ""%s"", Info.c_str());; 7624 } else if (Level == clang::DiagnosticsEngine::Error; 7625 || Level == clang::DiagnosticsEngine::Fatal) {; 7626 ::Error(""cling"", """,MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:300281,Integrability,interface,interfaces,300281," 7674}; 7675 ; 7676////////////////////////////////////////////////////////////////////////////////; 7677/// Get the interpreter value corresponding to the statement.; 7678int TCling::Evaluate(const char* code, TInterpreterValue& value); 7679{; 7680 auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());; 7681 auto compRes = fInterpreter->evaluate(code, *V);; 7682 return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;; 7683}; 7684 ; 7685////////////////////////////////////////////////////////////////////////////////; 7686 ; 7687void TCling::RegisterTemporary(const TInterpreterValue& value); 7688{; 7689 using namespace cling;; 7690 const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());; 7691 RegisterTemporary(*V);; 7692}; 7693 ; 7694////////////////////////////////////////////////////////////////////////////////; 7695/// Register value as a temporary, extending its lifetime to that of the; 7696/// interpreter. This is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:302378,Integrability,rout,routine,302378," then restore it.; 7720 ; 7721 if (gDirectory) {; 7722 auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);; 7723 if (iSpecObjMap != fSpecialObjectMaps.end()) {; 7724 auto iSpecObj = iSpecObjMap->second.find(Name);; 7725 if (iSpecObj != iSpecObjMap->second.end()) {; 7726 LookupCtx = gDirectory;; 7727 return iSpecObj->second;; 7728 }; 7729 }; 7730 }; 7731 ; 7732 // Save state of the PP; 7733 Sema &SemaR = fInterpreter->getSema();; 7734 ASTContext& C = SemaR.getASTContext();; 7735 Preprocessor &PP = SemaR.getPreprocessor();; 7736 Parser& P = const_cast<Parser&>(fInterpreter->getParser());; 7737 Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);; 7738 Parser::ParserCurTokRestoreRAII savedCurToken(P);; 7739 // After we have saved the token reset the current one to something which; 7740 // is safe (semi colon usually means empty decl); 7741 Token& Tok = const_cast<Token&>(P.getCurToken());; 7742 Tok.setKind(tok::semi);; 7743 ; 7744 // We can't PushDeclContext, because we go up and the routine that pops; 7745 // the DeclContext assumes that we drill down always.; 7746 // We have to be on the global context. At that point we are in a; 7747 // wrapper function so the parent context must be the global.; 7748 Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),; 7749 SemaR.TUScope);; 7750 ; 7751 TObject* specObj = gROOT->FindSpecialObject(Name, LookupCtx);; 7752 if (specObj) {; 7753 if (!LookupCtx) {; 7754 Error(""GetObjectAddress"", ""Got a special object without LookupCtx!"");; 7755 } else {; 7756 fSpecialObjectMaps[LookupCtx][Name] = specObj;; 7757 }; 7758 }; 7759 return specObj;; 7760}; 7761 ; 7762////////////////////////////////////////////////////////////////////////////////; 7763/// Inject function as a friend into klass.; 7764/// With function being f in void f() {new N::PrivKlass(); } this enables; 7765/// I/O of non-public classes.; 7766 ; 7767void TCling::AddFriendToClass(clang::FunctionDecl* function,; 7768 clang::CXXRecordDecl* klass) c",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:302537,Integrability,wrap,wrapper,302537,"iSpecObj = iSpecObjMap->second.find(Name);; 7725 if (iSpecObj != iSpecObjMap->second.end()) {; 7726 LookupCtx = gDirectory;; 7727 return iSpecObj->second;; 7728 }; 7729 }; 7730 }; 7731 ; 7732 // Save state of the PP; 7733 Sema &SemaR = fInterpreter->getSema();; 7734 ASTContext& C = SemaR.getASTContext();; 7735 Preprocessor &PP = SemaR.getPreprocessor();; 7736 Parser& P = const_cast<Parser&>(fInterpreter->getParser());; 7737 Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);; 7738 Parser::ParserCurTokRestoreRAII savedCurToken(P);; 7739 // After we have saved the token reset the current one to something which; 7740 // is safe (semi colon usually means empty decl); 7741 Token& Tok = const_cast<Token&>(P.getCurToken());; 7742 Tok.setKind(tok::semi);; 7743 ; 7744 // We can't PushDeclContext, because we go up and the routine that pops; 7745 // the DeclContext assumes that we drill down always.; 7746 // We have to be on the global context. At that point we are in a; 7747 // wrapper function so the parent context must be the global.; 7748 Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),; 7749 SemaR.TUScope);; 7750 ; 7751 TObject* specObj = gROOT->FindSpecialObject(Name, LookupCtx);; 7752 if (specObj) {; 7753 if (!LookupCtx) {; 7754 Error(""GetObjectAddress"", ""Got a special object without LookupCtx!"");; 7755 } else {; 7756 fSpecialObjectMaps[LookupCtx][Name] = specObj;; 7757 }; 7758 }; 7759 return specObj;; 7760}; 7761 ; 7762////////////////////////////////////////////////////////////////////////////////; 7763/// Inject function as a friend into klass.; 7764/// With function being f in void f() {new N::PrivKlass(); } this enables; 7765/// I/O of non-public classes.; 7766 ; 7767void TCling::AddFriendToClass(clang::FunctionDecl* function,; 7768 clang::CXXRecordDecl* klass) const; 7769{; 7770 using namespace clang;; 7771 ASTContext& Ctx = klass->getASTContext();; 7772 FriendDecl::FriendUnion friendUnion(function);; 7773 // one dummy object for the",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:306020,Integrability,interface,interface,306020,"* data) const; 7811{; 7812 if (data) return ((TClingDataMemberInfo*)data)->GetDeclId();; 7813 return nullptr;; 7814}; 7815 ; 7816////////////////////////////////////////////////////////////////////////////////; 7817/// Return a unique identifier of the declaration represented by the; 7818/// MethodInfo; 7819 ; 7820TInterpreter::DeclId_t TCling::GetDeclId(MethodInfo_t* method) const; 7821{; 7822 if (method) return ((TClingMethodInfo*)method)->GetDeclId();; 7823 return nullptr;; 7824}; 7825 ; 7826////////////////////////////////////////////////////////////////////////////////; 7827/// Return a unique identifier of the declaration represented by the; 7828/// TypedefInfo; 7829 ; 7830TInterpreter::DeclId_t TCling::GetDeclId(TypedefInfo_t* tinfo) const; 7831{; 7832 if (tinfo) return ((TClingTypedefInfo*)tinfo)->GetDecl()->getCanonicalDecl();; 7833 return nullptr;; 7834}; 7835 ; 7836//______________________________________________________________________________; 7837//; 7838// CallFunc interface; 7839//; 7840 ; 7841////////////////////////////////////////////////////////////////////////////////; 7842 ; 7843void TCling::CallFunc_Delete(CallFunc_t* func) const; 7844{; 7845 delete (TClingCallFunc*) func;; 7846}; 7847 ; 7848////////////////////////////////////////////////////////////////////////////////; 7849 ; 7850void TCling::CallFunc_Exec(CallFunc_t* func, void* address) const; 7851{; 7852 TClingCallFunc* f = (TClingCallFunc*) func;; 7853 f->Exec(address);; 7854}; 7855 ; 7856////////////////////////////////////////////////////////////////////////////////; 7857 ; 7858void TCling::CallFunc_Exec(CallFunc_t* func, void* address, TInterpreterValue& val) const; 7859{; 7860 TClingCallFunc* f = (TClingCallFunc*) func;; 7861 f->Exec(address, &val);; 7862}; 7863 ; 7864////////////////////////////////////////////////////////////////////////////////; 7865 ; 7866void TCling::CallFunc_ExecWithReturn(CallFunc_t* func, void* address, void* ret) const; 7867{; 7868 TClingCallFunc* f = (TCli",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:316584,Integrability,wrap,wrapper,316584,"///////////////////////////////////////; 8098/// Interface to cling function; 8099 ; 8100void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const; 8101{; 8102 TClingCallFunc* f = (TClingCallFunc*) func;; 8103 TClingClassInfo* ci = (TClingClassInfo*) info;; 8104 llvm::SmallVector<clang::QualType, 4> funcProto;; 8105 for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();; 8106 iter != end; ++iter) {; 8107 funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );; 8108 }; 8109 f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);; 8110}; 8111 ; 8112std::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const; 8113{; 8114 TClingCallFunc *f = (TClingCallFunc *)func;; 8115 std::string wrapper_name;; 8116 std::string wrapper;; 8117 f->get_wrapper_code(wrapper_name, wrapper);; 8118 return wrapper;; 8119}; 8120 ; 8121//______________________________________________________________________________; 8122//; 8123// ClassInfo interface; 8124//; 8125 ; 8126////////////////////////////////////////////////////////////////////////////////; 8127/// Return true if the entity pointed to by 'declid' is declared in; 8128/// the context described by 'info'. If info is null, look into the; 8129/// global scope (translation unit scope).; 8130 ; 8131Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const; 8132{; 8133 if (!declid); 8134 return kFALSE;; 8135 ; 8136 const clang::DeclContext *ctxt = nullptr;; 8137 if (info) {; 8138 ctxt = clang::Decl::castToDeclContext(((TClingClassInfo*)info)->GetDecl());; 8139 } else {; 8140 ctxt = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 8141 }; 8142 if (!ctxt); 8143 return kFALSE;; 8144 ; 8145 const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);; 8146 if (!decl); 8147 r",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:316633,Integrability,wrap,wrapper,316633,"///////////////////////////////////////; 8098/// Interface to cling function; 8099 ; 8100void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const; 8101{; 8102 TClingCallFunc* f = (TClingCallFunc*) func;; 8103 TClingClassInfo* ci = (TClingClassInfo*) info;; 8104 llvm::SmallVector<clang::QualType, 4> funcProto;; 8105 for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();; 8106 iter != end; ++iter) {; 8107 funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );; 8108 }; 8109 f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);; 8110}; 8111 ; 8112std::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const; 8113{; 8114 TClingCallFunc *f = (TClingCallFunc *)func;; 8115 std::string wrapper_name;; 8116 std::string wrapper;; 8117 f->get_wrapper_code(wrapper_name, wrapper);; 8118 return wrapper;; 8119}; 8120 ; 8121//______________________________________________________________________________; 8122//; 8123// ClassInfo interface; 8124//; 8125 ; 8126////////////////////////////////////////////////////////////////////////////////; 8127/// Return true if the entity pointed to by 'declid' is declared in; 8128/// the context described by 'info'. If info is null, look into the; 8129/// global scope (translation unit scope).; 8130 ; 8131Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const; 8132{; 8133 if (!declid); 8134 return kFALSE;; 8135 ; 8136 const clang::DeclContext *ctxt = nullptr;; 8137 if (info) {; 8138 ctxt = clang::Decl::castToDeclContext(((TClingClassInfo*)info)->GetDecl());; 8139 } else {; 8140 ctxt = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 8141 }; 8142 if (!ctxt); 8143 return kFALSE;; 8144 ; 8145 const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);; 8146 if (!decl); 8147 r",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:316656,Integrability,wrap,wrapper,316656,"///////////////////////////////////////; 8098/// Interface to cling function; 8099 ; 8100void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const; 8101{; 8102 TClingCallFunc* f = (TClingCallFunc*) func;; 8103 TClingClassInfo* ci = (TClingClassInfo*) info;; 8104 llvm::SmallVector<clang::QualType, 4> funcProto;; 8105 for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();; 8106 iter != end; ++iter) {; 8107 funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );; 8108 }; 8109 f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);; 8110}; 8111 ; 8112std::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const; 8113{; 8114 TClingCallFunc *f = (TClingCallFunc *)func;; 8115 std::string wrapper_name;; 8116 std::string wrapper;; 8117 f->get_wrapper_code(wrapper_name, wrapper);; 8118 return wrapper;; 8119}; 8120 ; 8121//______________________________________________________________________________; 8122//; 8123// ClassInfo interface; 8124//; 8125 ; 8126////////////////////////////////////////////////////////////////////////////////; 8127/// Return true if the entity pointed to by 'declid' is declared in; 8128/// the context described by 'info'. If info is null, look into the; 8129/// global scope (translation unit scope).; 8130 ; 8131Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const; 8132{; 8133 if (!declid); 8134 return kFALSE;; 8135 ; 8136 const clang::DeclContext *ctxt = nullptr;; 8137 if (info) {; 8138 ctxt = clang::Decl::castToDeclContext(((TClingClassInfo*)info)->GetDecl());; 8139 } else {; 8140 ctxt = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 8141 }; 8142 if (!ctxt); 8143 return kFALSE;; 8144 ; 8145 const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);; 8146 if (!decl); 8147 r",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:316791,Integrability,interface,interface,316791,"///////////////////////////////////////; 8098/// Interface to cling function; 8099 ; 8100void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const; 8101{; 8102 TClingCallFunc* f = (TClingCallFunc*) func;; 8103 TClingClassInfo* ci = (TClingClassInfo*) info;; 8104 llvm::SmallVector<clang::QualType, 4> funcProto;; 8105 for (std::vector<TypeInfo_t*>::const_iterator iter = proto.begin(), end = proto.end();; 8106 iter != end; ++iter) {; 8107 funcProto.push_back( ((TClingTypeInfo*)(*iter))->GetQualType() );; 8108 }; 8109 f->SetFuncProto(ci, method, funcProto, objectIsConst, offset, mode);; 8110}; 8111 ; 8112std::string TCling::CallFunc_GetWrapperCode(CallFunc_t *func) const; 8113{; 8114 TClingCallFunc *f = (TClingCallFunc *)func;; 8115 std::string wrapper_name;; 8116 std::string wrapper;; 8117 f->get_wrapper_code(wrapper_name, wrapper);; 8118 return wrapper;; 8119}; 8120 ; 8121//______________________________________________________________________________; 8122//; 8123// ClassInfo interface; 8124//; 8125 ; 8126////////////////////////////////////////////////////////////////////////////////; 8127/// Return true if the entity pointed to by 'declid' is declared in; 8128/// the context described by 'info'. If info is null, look into the; 8129/// global scope (translation unit scope).; 8130 ; 8131Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const; 8132{; 8133 if (!declid); 8134 return kFALSE;; 8135 ; 8136 const clang::DeclContext *ctxt = nullptr;; 8137 if (info) {; 8138 ctxt = clang::Decl::castToDeclContext(((TClingClassInfo*)info)->GetDecl());; 8139 } else {; 8140 ctxt = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 8141 }; 8142 if (!ctxt); 8143 return kFALSE;; 8144 ; 8145 const clang::Decl *decl = reinterpret_cast<const clang::Decl*>(declid);; 8146 if (!decl); 8147 r",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:329170,Integrability,interface,interface,329170,"(); // NOLINT; 8430}; 8431 ; 8432////////////////////////////////////////////////////////////////////////////////; 8433 ; 8434const char* TCling::ClassInfo_Name(ClassInfo_t* cinfo) const; 8435{; 8436 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8437 return TClinginfo->Name();; 8438}; 8439 ; 8440////////////////////////////////////////////////////////////////////////////////; 8441 ; 8442const char* TCling::ClassInfo_Title(ClassInfo_t* cinfo) const; 8443{; 8444 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8445 return TClinginfo->Title();; 8446}; 8447 ; 8448////////////////////////////////////////////////////////////////////////////////; 8449 ; 8450const char* TCling::ClassInfo_TmpltName(ClassInfo_t* cinfo) const; 8451{; 8452 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8453 return TClinginfo->TmpltName();; 8454}; 8455 ; 8456 ; 8457 ; 8458//______________________________________________________________________________; 8459//; 8460// BaseClassInfo interface; 8461//; 8462 ; 8463////////////////////////////////////////////////////////////////////////////////; 8464 ; 8465void TCling::BaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const; 8466{; 8467 delete(TClingBaseClassInfo*) bcinfo;; 8468}; 8469 ; 8470////////////////////////////////////////////////////////////////////////////////; 8471 ; 8472BaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* cinfo) const; 8473{; 8474 R__LOCKGUARD(gInterpreterMutex);; 8475 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8476 return (BaseClassInfo_t*) new TClingBaseClassInfo(GetInterpreterImpl(), TClinginfo);; 8477}; 8478 ; 8479////////////////////////////////////////////////////////////////////////////////; 8480 ; 8481BaseClassInfo_t* TCling::BaseClassInfo_Factory(ClassInfo_t* derived,; 8482 ClassInfo_t* base) const; 8483{; 8484 R__LOCKGUARD(gInterpreterMutex);; 8485 TClingClassInfo* TClinginfo = (TClingClassInfo*) derived;; 8486 TClingClassInfo* TClinginfoBase = (TClingClassInfo*) ba",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:333886,Integrability,interface,interface,333886,,MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:340003,Integrability,interface,interface,340003,";; 8709 return TClinginfo->Title();; 8710}; 8711 ; 8712////////////////////////////////////////////////////////////////////////////////; 8713 ; 8714const char* TCling::DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; 8715{; 8716 TTHREAD_TLS_DECL(std::string,result);; 8717 ; 8718 TClingDataMemberInfo* TClinginfo = (TClingDataMemberInfo*) dminfo;; 8719 result = TClinginfo->ValidArrayIndex().str();; 8720 return result.c_str(); // NOLINT; 8721}; 8722 ; 8723////////////////////////////////////////////////////////////////////////////////; 8724 ; 8725void TCling::SetDeclAttr(DeclId_t declId, const char* attribute); 8726{; 8727 Decl* decl = static_cast<Decl*>(const_cast<void*>(declId));; 8728 ASTContext &C = decl->getASTContext();; 8729 decl->addAttr(AnnotateAttr::CreateImplicit(C, attribute, nullptr, 0));; 8730}; 8731 ; 8732//______________________________________________________________________________; 8733//; 8734// Function Template interface; 8735//; 8736 ; 8737////////////////////////////////////////////////////////////////////////////////; 8738 ; 8739static void ConstructorName(std::string &name, const clang::Decl *decl,; 8740 cling::Interpreter &interp,; 8741 const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt); 8742{; 8743 const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());; 8744 if (!td) return;; 8745 ; 8746 clang::QualType qualType(td->getTypeForDecl(),0);; 8747 ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);; 8748 unsigned int level = 0;; 8749 for(size_t cursor = name.length()-1; cursor != 0; --cursor) {; 8750 if (name[cursor] == '>') ++level;; 8751 else if (name[cursor] == '<' && level) --level;; 8752 else if (level == 0 && name[cursor] == ':') {; 8753 name.erase(0,cursor+1);; 8754 break;; 8755 }; 8756 }; 8757}; 8758 ; 8759////////////////////////////////////////////////////////////////////////////////; 8760 ; 8761void TCling::GetFunctionName(const clang::Decl *decl, std::string &output) const",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:349390,Integrability,interface,interface,349390,"r the redeclarations, we can have multiple definitions in the; 8977 // redecl chain (came from merging of pcms).; 8978 if (const RedeclarableTemplateDecl *AnnotFD; 8979 = ROOT::TMetaUtils::GetAnnotatedRedeclarable((const RedeclarableTemplateDecl*)ft)) {; 8980 if (AnnotateAttr *A = AnnotFD->getAttr<AnnotateAttr>()) {; 8981 output = A->getAnnotation().str();; 8982 return;; 8983 }; 8984 }; 8985 if (!ft->isFromASTFile()) {; 8986 // Try to get the comment from the header file if present; 8987 // but not for decls from AST file, where rootcling would have; 8988 // created an annotation; 8989 output = ROOT::TMetaUtils::GetComment(*ft).str();; 8990 }; 8991}; 8992 ; 8993 ; 8994//______________________________________________________________________________; 8995//; 8996// MethodInfo interface; 8997//; 8998 ; 8999////////////////////////////////////////////////////////////////////////////////; 9000/// Interface to cling function; 9001 ; 9002void TCling::MethodInfo_Delete(MethodInfo_t* minfo) const; 9003{; 9004 delete(TClingMethodInfo*) minfo;; 9005}; 9006 ; 9007////////////////////////////////////////////////////////////////////////////////; 9008 ; 9009void TCling::MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const; 9010{; 9011 TClingMethodInfo* info = (TClingMethodInfo*) minfo;; 9012 // The next call locks the interpreter mutex.; 9013 info->CreateSignature(signature);; 9014}; 9015 ; 9016////////////////////////////////////////////////////////////////////////////////; 9017 ; 9018MethodInfo_t* TCling::MethodInfo_Factory() const; 9019{; 9020 R__LOCKGUARD(gInterpreterMutex);; 9021 return (MethodInfo_t*) new TClingMethodInfo(GetInterpreterImpl());; 9022}; 9023 ; 9024////////////////////////////////////////////////////////////////////////////////; 9025 ; 9026MethodInfo_t* TCling::MethodInfo_Factory(ClassInfo_t* clinfo) const; 9027{; 9028 R__LOCKGUARD(gInterpreterMutex);; 9029 return (MethodInfo_t*) new TClingMethodInfo(GetInterpreterImpl(), (TClingClassInfo*",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:357857,Integrability,interface,interface,357857,,MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:361516,Integrability,interface,interface,361516,"////////////////////////////////////////; 9311 ; 9312const char* TCling::MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const; 9313{; 9314 TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;; 9315 return info->TypeName();; 9316}; 9317 ; 9318////////////////////////////////////////////////////////////////////////////////; 9319 ; 9320std::string TCling::MethodArgInfo_TypeNormalizedName(MethodArgInfo_t* marginfo) const; 9321{; 9322 TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;; 9323 return info->Type()->NormalizedName(*fNormalizedCtxt);; 9324}; 9325 ; 9326////////////////////////////////////////////////////////////////////////////////; 9327 ; 9328TypeInfo_t* TCling::MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) const; 9329{; 9330 TClingMethodArgInfo* info = (TClingMethodArgInfo*) marginfo;; 9331 return (TypeInfo_t*) info->Type();; 9332}; 9333 ; 9334//______________________________________________________________________________; 9335//; 9336// TypeInfo interface; 9337//; 9338 ; 9339////////////////////////////////////////////////////////////////////////////////; 9340 ; 9341void TCling::TypeInfo_Delete(TypeInfo_t* tinfo) const; 9342{; 9343 delete (TClingTypeInfo*) tinfo;; 9344}; 9345 ; 9346////////////////////////////////////////////////////////////////////////////////; 9347 ; 9348TypeInfo_t* TCling::TypeInfo_Factory() const; 9349{; 9350 R__LOCKGUARD(gInterpreterMutex);; 9351 return (TypeInfo_t*) new TClingTypeInfo(GetInterpreterImpl());; 9352}; 9353 ; 9354////////////////////////////////////////////////////////////////////////////////; 9355 ; 9356TypeInfo_t* TCling::TypeInfo_Factory(const char *name) const; 9357{; 9358 R__LOCKGUARD(gInterpreterMutex);; 9359 return (TypeInfo_t*) new TClingTypeInfo(GetInterpreterImpl(), name);; 9360}; 9361 ; 9362////////////////////////////////////////////////////////////////////////////////; 9363 ; 9364TypeInfo_t* TCling::TypeInfo_FactoryCopy(TypeInfo_t* tinfo) const; 9365{; 9366 return (TypeInfo_t*) new T",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:364935,Integrability,interface,interface,364935,"TClinginfo->RefType();; 9408}; 9409 ; 9410////////////////////////////////////////////////////////////////////////////////; 9411 ; 9412int TCling::TypeInfo_Size(TypeInfo_t* tinfo) const; 9413{; 9414 TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;; 9415 return TClinginfo->Size();; 9416}; 9417 ; 9418////////////////////////////////////////////////////////////////////////////////; 9419 ; 9420const char* TCling::TypeInfo_TrueName(TypeInfo_t* tinfo) const; 9421{; 9422 TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;; 9423 return TClinginfo->TrueName(*fNormalizedCtxt);; 9424}; 9425 ; 9426////////////////////////////////////////////////////////////////////////////////; 9427 ; 9428void* TCling::TypeInfo_QualTypePtr(TypeInfo_t* tinfo) const; 9429{; 9430 TClingTypeInfo* TClinginfo = (TClingTypeInfo*) tinfo;; 9431 return TClinginfo->QualTypePtr();; 9432}; 9433 ; 9434 ; 9435//______________________________________________________________________________; 9436//; 9437// TypedefInfo interface; 9438//; 9439 ; 9440////////////////////////////////////////////////////////////////////////////////; 9441 ; 9442void TCling::TypedefInfo_Delete(TypedefInfo_t* tinfo) const; 9443{; 9444 delete(TClingTypedefInfo*) tinfo;; 9445}; 9446 ; 9447////////////////////////////////////////////////////////////////////////////////; 9448 ; 9449TypedefInfo_t* TCling::TypedefInfo_Factory() const; 9450{; 9451 R__LOCKGUARD(gInterpreterMutex);; 9452 return (TypedefInfo_t*) new TClingTypedefInfo(GetInterpreterImpl());; 9453}; 9454 ; 9455////////////////////////////////////////////////////////////////////////////////; 9456 ; 9457TypedefInfo_t* TCling::TypedefInfo_Factory(const char *name) const; 9458{; 9459 R__LOCKGUARD(gInterpreterMutex);; 9460 return (TypedefInfo_t*) new TClingTypedefInfo(GetInterpreterImpl(), name);; 9461}; 9462 ; 9463////////////////////////////////////////////////////////////////////////////////; 9464 ; 9465TypedefInfo_t* TCling::TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) cons",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:382791,Integrability,interface,interface,382791," TCling.cxx:233; TCling__AutoLoadCallbackint TCling__AutoLoadCallback(const char *className)Definition TCling.cxx:623; LoadModulestatic bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp)Definition TCling.cxx:1030; RegisterCxxModulesstatic void RegisterCxxModules(cling::Interpreter &clingInterp)Definition TCling.cxx:1183; ConstructorNamestatic void ConstructorName(std::string &name, const clang::Decl *decl, cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)Definition TCling.cxx:8739; TCling__PrintStackTracevoid TCling__PrintStackTrace()Print a StackTrace!Definition TCling.cxx:326; HandleInterpreterExceptionstatic int HandleInterpreterException(cling::MetaProcessor *metaProcessor, const char *input_line, cling::Interpreter::CompilationResult &compRes, cling::Value *result)Let cling process a command line.Definition TCling.cxx:2423; GetSharedLibImmediateDepsSlowstatic std::string GetSharedLibImmediateDepsSlow(std::string lib, cling::Interpreter *interp, bool skipLoadedLibs=true)This interface returns a list of dependent libraries in the form: lib libA.so libB....Definition TCling.cxx:7161; TCling__DEBUG__printNamevoid TCling__DEBUG__printName(clang::Decl *D)Definition TCling.cxx:236; FindTemplateInNamespacestatic clang::ClassTemplateDecl * FindTemplateInNamespace(clang::Decl *decl)Find a template decl within N nested namespaces, 0<=N<inf Assumes 1 and only 1 template present and 1...Definition TCling.cxx:680; PrintDlErrorstatic void PrintDlError(const char *dyLibName, const char *modulename)Definition TCling.cxx:1964; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; GetClassSharedLibsForModulestatic std::string GetClassSharedLibsForModule(const char *cls, cling::LookupHelper &LH, bool skipCore)Definition TCling.cxx:6996; fantomlineconst char * fantomlineDefinition TCling.cxx:841; TCling__LibraryLoadedRTTIvoid TCling__LibraryLoadedRTTI(const void *dyL",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:382819,Integrability,depend,dependent,382819," TCling.cxx:233; TCling__AutoLoadCallbackint TCling__AutoLoadCallback(const char *className)Definition TCling.cxx:623; LoadModulestatic bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp)Definition TCling.cxx:1030; RegisterCxxModulesstatic void RegisterCxxModules(cling::Interpreter &clingInterp)Definition TCling.cxx:1183; ConstructorNamestatic void ConstructorName(std::string &name, const clang::Decl *decl, cling::Interpreter &interp, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt)Definition TCling.cxx:8739; TCling__PrintStackTracevoid TCling__PrintStackTrace()Print a StackTrace!Definition TCling.cxx:326; HandleInterpreterExceptionstatic int HandleInterpreterException(cling::MetaProcessor *metaProcessor, const char *input_line, cling::Interpreter::CompilationResult &compRes, cling::Value *result)Let cling process a command line.Definition TCling.cxx:2423; GetSharedLibImmediateDepsSlowstatic std::string GetSharedLibImmediateDepsSlow(std::string lib, cling::Interpreter *interp, bool skipLoadedLibs=true)This interface returns a list of dependent libraries in the form: lib libA.so libB....Definition TCling.cxx:7161; TCling__DEBUG__printNamevoid TCling__DEBUG__printName(clang::Decl *D)Definition TCling.cxx:236; FindTemplateInNamespacestatic clang::ClassTemplateDecl * FindTemplateInNamespace(clang::Decl *decl)Find a template decl within N nested namespaces, 0<=N<inf Assumes 1 and only 1 template present and 1...Definition TCling.cxx:680; PrintDlErrorstatic void PrintDlError(const char *dyLibName, const char *modulename)Definition TCling.cxx:1964; CreateInterpreterTInterpreter * CreateInterpreter(void *interpLibHandle, const char *argv[])Definition TCling.cxx:608; GetClassSharedLibsForModulestatic std::string GetClassSharedLibsForModule(const char *cls, cling::LookupHelper &LH, bool skipCore)Definition TCling.cxx:6996; fantomlineconst char * fantomlineDefinition TCling.cxx:841; TCling__LibraryLoadedRTTIvoid TCling__LibraryLoadedRTTI(const void *dyL",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:386828,Integrability,message,messages,386828,"@ kIsFundamentalDefinition TDictionary.h:70; kIsCompiled@ kIsCompiledDefinition TDictionary.h:86; kIsStatic@ kIsStaticDefinition TDictionary.h:80; kIsExplicit@ kIsExplicitDefinition TDictionary.h:94; kIsStruct@ kIsStructDefinition TDictionary.h:66; kIsProtected@ kIsProtectedDefinition TDictionary.h:76; kIsVirtual@ kIsVirtualDefinition TDictionary.h:72; kIsUnion@ kIsUnionDefinition TDictionary.h:67; kIsPureVirtual@ kIsPureVirtualDefinition TDictionary.h:73; kIsNamespace@ kIsNamespaceDefinition TDictionary.h:95; kIsNotReacheable@ kIsNotReacheableDefinition TDictionary.h:87; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnumConstant.h; TEnum.h; TEnv.h; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; TFunctionTemplate.h; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:387107,Integrability,rout,routines,387107,"sProtectedDefinition TDictionary.h:76; kIsVirtual@ kIsVirtualDefinition TDictionary.h:72; kIsUnion@ kIsUnionDefinition TDictionary.h:67; kIsPureVirtual@ kIsPureVirtualDefinition TDictionary.h:73; kIsNamespace@ kIsNamespaceDefinition TDictionary.h:95; kIsNotReacheable@ kIsNotReacheableDefinition TDictionary.h:87; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnumConstant.h; TEnum.h; TEnv.h; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; TFunctionTemplate.h; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:405070,Integrability,wrap,wrapper,405070," constDefinition TClingCallFunc.cxx:1704; TClingCallFunc::ExecIntLongptr_t ExecInt(void *address)Definition TClingCallFunc.cxx:1552; TClingCallFunc::IFacePtrTInterpreter::CallFuncIFacePtr_t IFacePtr()Definition TClingCallFunc.cxx:1712; TClingCallFunc::SetFuncvoid SetFunc(const TClingClassInfo *info, const char *method, const char *arglist, Longptr_t *poffset)Definition TClingCallFunc.cxx:1756; TClingCallFunc::InterfaceMethodvoid * InterfaceMethod()Definition TClingCallFunc.cxx:1682; TClingCallFunc::ExecWithArgsAndReturnvoid ExecWithArgsAndReturn(void *address, const void *args[]=0, int nargs=0, void *ret=0)Definition TClingCallFunc.cxx:1567; TClingCallFunc::Execvoid Exec(void *address, TInterpreterValue *interpVal=0)Definition TClingCallFunc.cxx:1515; TClingCallFunc::FactoryMethodTClingMethodInfo * FactoryMethod() constDefinition TClingCallFunc.cxx:1656; TClingCallFunc::ResetArgvoid ResetArg()Definition TClingCallFunc.cxx:1737; TClingCallFunc::get_wrapper_codeint get_wrapper_code(std::string &wrapper_name, std::string &wrapper)Definition TClingCallFunc.cxx:480; TClingCallFunc::IgnoreExtraArgsvoid IgnoreExtraArgs(bool ignore)Definition TClingCallFunc.h:178; TClingCallFunc::SetArgvoid SetArg(T arg)Definition TClingCallFunc.h:206; TClingCallFunc::ExecInt64long long ExecInt64(void *address)Definition TClingCallFunc.cxx:1557; TClingCallbacksDefinition TClingCallbacks.h:41; TClingCallbacks::Initializevoid Initialize()Definition TClingCallbacks.cxx:1016; TClingCallbacks::IsAutoLoadingEnabledbool IsAutoLoadingEnabled() constDefinition TClingCallbacks.h:61; TClingCallbacks::SetAutoParsingSuspendedvoid SetAutoParsingSuspended(bool val=true)Definition TClingCallbacks.h:63; TClingCallbacks::SetAutoLoadingEnabledvoid SetAutoLoadingEnabled(bool val=true)Definition TClingCallbacks.h:60; TClingClassInfoEmulation of the CINT ClassInfo class.Definition TClingClassInfo.h:59; TClingClassInfo::Titleconst char * Title()Definition TClingClassInfo.cxx:1398; TClingClassInfo::IsEnumstatic boo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:416545,Integrability,interface,interface,416545,"rrent typedef.Definition TClingTypedefInfo.cxx:255; TClingTypedefInfo::Initvoid Init(const char *name)Lookup named typedef and reset the iterator to point to it.Definition TClingTypedefInfo.cxx:58; TClingTypedefInfo::Nextint Next()Increment the iterator.Definition TClingTypedefInfo.cxx:173; TClingTypedefInfo::Sizeint Size() constReturn the size in bytes of the underlying type of the current typedef.Definition TClingTypedefInfo.cxx:196; TClingValueBridge between cling::Value and ROOT.Definition TClingValue.h:36; TCling::SuspendAutoLoadingRAIIDefinition TCling.h:602; TCling::TUniqueStringDefinition TCling.h:611; TCling::TUniqueString::Dataconst char * Data()Definition TCling.cxx:1006; TCling::TUniqueString::Appendbool Append(const std::string &str)Append string to the storage if not added already.Definition TCling.cxx:1014; TCling::TUniqueString::TUniqueStringTUniqueString()=delete; TCling::TUniqueString::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TCling::LoadEnumsvoid LoadEnums(TListOfEnums &cl) const finalCreate list of pointers to enums for TClass cl.Definition TCling.cxx:4395; TCling::UpdateListOfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TC",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:422187,Integrability,depend,depends,422187,"Info_t *info) const finalDefinition TCling.cxx:8328; TCling::UpdateListsOnCommittedvoid UpdateListsOnCommitted(const cling::Transaction &T)Definition TCling.cxx:6765; TCling::TypeInfo_RefTypeint TypeInfo_RefType(TypeInfo_t *) const finalDefinition TCling.cxx:9404; TCling::CreateListOfBaseClassesvoid CreateListOfBaseClasses(TClass *cl) const finalCreate list of pointers to base class(es) for TClass cl.Definition TCling.cxx:4371; TCling::ClassInfo_FactoryClassInfo_t * ClassInfo_Factory(Bool_t all=kTRUE) const finalDefinition TCling.cxx:8215; TCling::MethodInfo_Nameconst char * MethodInfo_Name(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9138; TCling::BaseClassInfo_FactoryBaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *info) const finalDefinition TCling.cxx:8472; TCling::LoadTextBool_t LoadText(const char *text) const finalLoad the declarations from text into the interpreter.Definition TCling.cxx:7515; TCling::GetSharedLibDepsconst char * GetSharedLibDeps(const char *lib, bool tryDyld=false) finalGet the list a libraries on which the specified lib depends.Definition TCling.cxx:7289; TCling::MethodInfo_MethodCallReturnTypeEReturnType MethodInfo_MethodCallReturnType(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9188; TCling::GetObjectAddressTObject * GetObjectAddress(const char *Name, void *&LookupCtx)If the interpreter encounters Name, check whether that is an object ROOT could retrieve.Definition TCling.cxx:7714; TCling::ProcessLineAsynchLongptr_t ProcessLineAsynch(const char *line, EErrorCode *error=nullptr)Let cling process a command line asynch.Definition TCling.cxx:3560; TCling::MethodInfo_IsValidbool MethodInfo_IsValid(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9059; TCling::TClingTCling(); TCling::FuncTempInfo_FactoryFuncTempInfo_t * FuncTempInfo_Factory(DeclId_t declid) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8815; TCling::TypeInfo_FactoryTypeInfo_t * TypeInfo_Factory() const finalDefinition TCling.cxx:9348; T",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:425027,Integrability,interface,interface,425027,"*func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_Res",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:427653,Integrability,rout,routines,427653,"nterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const finalReturn true if the entity pointed to by 'declid' is declared in the context described by 'info'.Definition TCling.cxx:8131; TCling::IsLibraryLoadedBool_t IsLibraryLoaded(const char *libname) const finalDefinition TCling.cxx:3138; TCling::GetExecByteCodeLong_t GetExecByteCode() const finalThis routines used to return the address of the internal wrapper function (of the interpreter) that w...Definition TCling.cxx:7479; TCling::DataMemberInfo_ArrayDimint DataMemberInfo_ArrayDim(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLook",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:427705,Integrability,wrap,wrapper,427705,"nterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const finalReturn true if the entity pointed to by 'declid' is declared in the context described by 'info'.Definition TCling.cxx:8131; TCling::IsLibraryLoadedBool_t IsLibraryLoaded(const char *libname) const finalDefinition TCling.cxx:3138; TCling::GetExecByteCodeLong_t GetExecByteCode() const finalThis routines used to return the address of the internal wrapper function (of the interpreter) that w...Definition TCling.cxx:7479; TCling::DataMemberInfo_ArrayDimint DataMemberInfo_ArrayDim(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLook",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:428937,Integrability,message,messages,428937," TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunc",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:430106,Integrability,interface,interface,430106,"nfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * TypedefInfo_Factory() const finalDefinition TCling.cxx:9449; TCling::fRootmapFilesTObjArray * fRootmapFilesDefinition TCling.h:126; TCling::IsVoidPointerTypebool IsVoidPointerType(const void *QualTypePtr) constDefinition TCling.cxx:9587; TCling::ProcessLineLongptr_t ProcessLine(const char *line, EErrorCode *error=nullptr) finalDefinition TCling.cxx:2453; TCling::ClassInfo_Sizeint ClassInfo_Size(ClassInfo_t *info) const finalDefinition TCling.cxx:8400; TCling::MethodArgInfo_TypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nu",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:434545,Integrability,message,messages,434545,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:434625,Integrability,message,messages,434625,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:437248,Integrability,interface,interface,437248,"ptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::fSharedLibsTString fSharedLibsDefinition TCling.h:113; TCling::fPendingRdictsstd::map< std::string, llvm::StringRef > fPendingRdictsDefinition TCling.h:634; TCling::UpdateClassInfoWorkstatic void UpdateClassInfoWork(const char *name)Definition TCling.cxx:6745; TCling::LoadInt_t Load(const char *filenam, Bool_t system=kFALSE) finalLoad a library file in cling's memory.Definition TCling.cxx:3515; TCling::TypedefInfo_Nextint TypedefInfo_Next(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9490; TCling::GetInterfaceMethodvoid * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE) finalReturn pointer to cling interface function for a method of a class with parameters params (params is ...Definition TCling.cxx:5007; TCling::TypeInfo_Initvoid TypeInfo_Init(TypeInfo_t *tinfo, const char *funcname) const finalDefinition TCling.cxx:9371; TCling::SetSuspendAutoParsingBool_t SetSuspendAutoParsing(Bool_t value) finalSuspend the Autoparsing of headers.Definition TCling.cxx:7596; TCling::DataMemberInfo_TypeSizeint DataMemberInfo_TypeSize(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8674; TCling::fgSetOfSpecialsstatic void * fgSetOfSpecialsDefinition TCling.h:105; TCling::ClassInfo_Titleconst char * ClassInfo_Title(ClassInfo_t *info) const finalDefinition TCling.cxx:8442; TCling::DataMemberInfo_Nameconst char * DataMemberInfo_Name(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8698; TCling::TypeNameconst char * TypeName(const char *typeDesc) finalReturn the absolute type of typeDesc.Definition TCling.cxx:5478; TCling::fNormalized",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:439493,Integrability,interface,interface,439493,"tMutexStatevoid ForgetMutexState() finalDefinition TCling.cxx:9618; TCling::MethodInfo_Nextint MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:440945,Integrability,message,messages,440945,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:441025,Integrability,message,messages,441025,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:446056,Integrability,interface,interface,446056,"st cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const finalCreate list of pointers to method arguments for TMethod m.Definition TCling.cxx:4523; TCling::GetSTLIncludePathvirtual const char * GetSTLIncludePath() const finalReturn the directory containing CINT's stl cintdlls.Definition TCling.cxx:7401; TCling::MethodArgInfo_FactoryCopyMethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t *marginfo) const finalDefinition TCli",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:455932,Integrability,interface,interface,455932,"ector &, const void *obj, const TClass *cl, Bool_t isTransient) finalVisit all members over members, recursing over base classes.Definition TCling.cxx:2684; TCling::SetClassSharedLibsInt_t SetClassSharedLibs(const char *cls, const char *libs) finalRegister the AutoLoading information for a class.Definition TCling.cxx:6078; TCling::MethodInfo_FactoryCopyMethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9043; TCling::fParsedPayloadsAddressesstd::set< const char * > fParsedPayloadsAddressesDefinition TCling.h:123; TCling::CallFunc_IFacePtrCallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *func) const finalDefinition TCling.cxx:7958; TCling::MethodArgInfo_FactoryMethodArgInfo_t * MethodArgInfo_Factory() const finalDefinition TCling.cxx:9248; TCling::UpdateClassInfostatic void UpdateClassInfo(char *name, Long_t tagnum)No op: see TClingCallbacks.Definition TCling.cxx:6739; TCling::GetFunctionDeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5029; TCling::ClassInfo_Deletevoid ClassInfo_Delete(ClassInfo_t *info) const finalDefinition TCling.cxx:8184; TCling::fInterpreterstd::unique_ptr< cling::Interpreter > fInterpreterDefinition TCling.h:130; TCling::ClassInfo_GetUnderlyingTypeEDataType ClassInfo_GetUnderlyingType(ClassInfo_t *info) const finalDefinition TCling.cxx:8311; TCling::FuncTempInfo_Deletevoid FuncTempInfo_Delete(FuncTempInfo_t *) const finalDelete the FuncTempInfo_t.Definition TCling.cxx:8806; TCling::GetFunctionTemplateDeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5177; TCling::DeleteVariableInt_t DeleteVariable(const char *name) finalUndeclare obj called name.Definition TCling.cxx:3798; TCling::GetClassSharedLibsconst char * GetClassSharedLibs(const char *cls, bool sk",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:456612,Integrability,interface,interface,456612,"7958; TCling::MethodArgInfo_FactoryMethodArgInfo_t * MethodArgInfo_Factory() const finalDefinition TCling.cxx:9248; TCling::UpdateClassInfostatic void UpdateClassInfo(char *name, Long_t tagnum)No op: see TClingCallbacks.Definition TCling.cxx:6739; TCling::GetFunctionDeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5029; TCling::ClassInfo_Deletevoid ClassInfo_Delete(ClassInfo_t *info) const finalDefinition TCling.cxx:8184; TCling::fInterpreterstd::unique_ptr< cling::Interpreter > fInterpreterDefinition TCling.h:130; TCling::ClassInfo_GetUnderlyingTypeEDataType ClassInfo_GetUnderlyingType(ClassInfo_t *info) const finalDefinition TCling.cxx:8311; TCling::FuncTempInfo_Deletevoid FuncTempInfo_Delete(FuncTempInfo_t *) const finalDelete the FuncTempInfo_t.Definition TCling.cxx:8806; TCling::GetFunctionTemplateDeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5177; TCling::DeleteVariableInt_t DeleteVariable(const char *name) finalUndeclare obj called name.Definition TCling.cxx:3798; TCling::GetClassSharedLibsconst char * GetClassSharedLibs(const char *cls, bool skipCore=true) finalGet the list of shared libraries containing the code for class cls.Definition TCling.cxx:7095; TCling::DataMemberInfo_OffsetLongptr_t DataMemberInfo_Offset(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8650; TCling::CallFunc_FactoryCallFunc_t * CallFunc_Factory() const finalDefinition TCling.cxx:7909; TCling::MethodInfo_FactoryMethodInfo_t * MethodInfo_Factory() const finalDefinition TCling.cxx:9018; TCling::DataMemberInfo_TypePropertyLong_t DataMemberInfo_TypeProperty(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8666; TCling::ClearFileBusyvoid ClearFileBusy() finalReset the interpreter internal state in case a previous",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:458977,Integrability,rout,routine,458977,"r Mutex Unlock] Provide the interpreter with a way to release a lock used to protect ...Definition TCling.cxx:7546; TCling::fLookedUpClassesstd::set< size_t > fLookedUpClassesDefinition TCling.h:121; TCling::AddAvailableIndentifiersvirtual void AddAvailableIndentifiers(TSeqCollection &Idents) finalDefinition TCling.cxx:2358; TCling::TypedefInfo_Deletevoid TypedefInfo_Delete(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9442; TCling::Resetvoid Reset() finalPressing Ctrl+C should forward here.Definition TCling.cxx:3708; TCling::TypedefInfo_TrueNameconst char * TypedefInfo_TrueName(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9514; TCling::SetClassAutoLoadingint SetClassAutoLoading(int) const finalEnable/Disable the AutoLoading of libraries.Definition TCling.cxx:7567; TCling::ClassInfo_FullNameconst char * ClassInfo_FullName(ClassInfo_t *info) const finalDefinition TCling.cxx:8424; TCling::AutoParseImplRecurseUInt_t AutoParseImplRecurse(const char *cls, bool topLevel)Helper routine for TCling::AutoParse implementing the actual call to the parser and looping over temp...Definition TCling.cxx:6381; TCling::MethodInfo_TypeNameconst char * MethodInfo_TypeName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9147; TCling::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Long_t param) const finalDefinition TCling.cxx:7974; TCling::GetIncludePathconst char * GetIncludePath() finalRefresh the list of include paths known to the interpreter and return it with -I prepended.Definition TCling.cxx:7370; TCling::UpdateListsOnUnloadedvoid UpdateListsOnUnloaded(const cling::Transaction &T)Invalidate stored TCling state for declarations included in transaction ‘T’.Definition TCling.cxx:6849; TCling::UpdateClassInfoWithDeclvoid UpdateClassInfoWithDecl(const clang::NamedDecl *ND)Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.Definition TCling.cxx:6681; TCling::IsSameTypebool IsSameType(const void *QualTypePtr1, const void *QualTypePtr",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:461971,Integrability,synchroniz,synchronize,461971,"nfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:8434; TCling::GenerateTClassTClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE) finalGenerate a TClass for the given class.Definition TCling.cxx:4554; TCling::fTransactionCountULong64_t fTransactionCountDefinition TCling.h:148; TCling::ClassInfo_HasDefaultConstructorbool ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalDefinition TCling.cxx:8253; TCling::EndOfLineActionvoid EndOfLineAction() finalIt calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line.Definition TCling.cxx:3121; TCling::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCall",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:468415,Integrability,interface,interface,468415,"onst char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoadCallBack_tint(* AutoLoadCallBack_t)(const char *)Definition TInterpreter.h:132; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::GetClassSharedLibsvirtual const char * GetClassSharedLibs(const char *cls, bool skipCore=true)=0; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::kKnown@ kKnownDefinition TInterpreter.h:215; TInterpreter::kUnknown@ kUnknownDefinition TInterpreter.h:214; TInterpreter::kWithClassDefInline@ kWithClassDe",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:476206,Integrability,message,message,476206,"x:334; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TCl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:476511,Integrability,message,message,476511,"ObjArray.cxx:719; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:476647,Integrability,message,message,476647,"ts name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::IsOnHeapR__ALWAYS_INLINE Bool_t IsOnHeap() constDefinition TObject.h:152; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::str",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:477126,Integrability,message,message,477126,"gvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::GetSharedLibDirstatic ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:478008,Integrability,inject,inject,478008,"cceeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::LastIndexInt_t LastIndex() constDefinition TSeqCollection.h:55; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & Repla",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:478049,Integrability,interface,interface,478049,"cceeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::LastIndexInt_t LastIndex() constDefinition TSeqCollection.h:55; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & Repla",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:487031,Integrability,rout,routine,487031,"r ROOT, keeping only the ROOT opaque typedef (Double32_t,...Definition TClingUtils.cxx:4049; ROOT::TMetaUtils::GetModuleFileNamestd::string GetModuleFileName(const char *moduleName)Return the dictionary file name for a module.Definition TClingUtils.cxx:4165; ROOT::TMetaUtils::ReSubstTemplateArgclang::QualType ReSubstTemplateArg(clang::QualType input, const clang::Type *instance)Check if 'input' or any of its template parameter was substituted when instantiating the class templa...Definition TClingUtils.cxx:4612; ROOT::TMetaUtils::DemangleNameForDlsymstatic std::string DemangleNameForDlsym(const std::string &name)Definition TClingUtils.h:597; ROOT::TMetaUtils::GetCppNamevoid GetCppName(std::string &output, const char *input)Return (in the argument 'output') a valid name of the C++ symbol/type (pass as 'input') that can be u...Definition TClingUtils.cxx:3269; ROOT::TMetaUtils::GetTrivialIntegralReturnValuestd::pair< bool, int > GetTrivialIntegralReturnValue(const clang::FunctionDecl *funcCV, const cling::Interpreter &interp)If the function contains 'just': return SomeValue; this routine will extract this value and return it...Definition TClingUtils.cxx:2599; ROOT::TMetaUtils::GetRealPathstd::string GetRealPath(const std::string &path)Definition TClingUtils.cxx:72; ROOT::TMetaUtils::GetQualifiedNamevoid GetQualifiedName(std::string &qual_name, const clang::QualType &type, const clang::NamedDecl &forcontext)Main implementation relying on GetFullyQualifiedTypeName All other GetQualifiedName functions leverag...Definition TClingUtils.cxx:1359; ROOT::TMetaUtils::GetCommentllvm::StringRef GetComment(const clang::Decl &decl, clang::SourceLocation *loc=nullptr)Returns the comment (// striped away), annotating declaration in a meaningful for ROOT IO way.Definition TClingUtils.cxx:4197; ROOT::TMetaUtils::SetPathsForRelocatabilityvoid SetPathsForRelocatability(std::vector< std::string > &clingArgs)Organise the parameters for cling in order to guarantee relocatability It treats t",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:488565,Integrability,rout,routine,488565,"taUtils::GetCommentllvm::StringRef GetComment(const clang::Decl &decl, clang::SourceLocation *loc=nullptr)Returns the comment (// striped away), annotating declaration in a meaningful for ROOT IO way.Definition TClingUtils.cxx:4197; ROOT::TMetaUtils::SetPathsForRelocatabilityvoid SetPathsForRelocatability(std::vector< std::string > &clingArgs)Organise the parameters for cling in order to guarantee relocatability It treats the gcc toolchain an...Definition TClingUtils.cxx:5078; ROOT::TMetaUtils::GetUnderlyingTypeconst clang::Type * GetUnderlyingType(clang::QualType type)Return the base/underlying type of a chain of array or pointers type.Definition TClingUtils.cxx:4380; ROOT::TMetaUtils::IsSTLContROOT::ESTLType IsSTLCont(const clang::RecordDecl &cl)type : type name: vector<list<classA,allocator>,allocator> result: 0 : not stl container abs(result):...Definition TClingUtils.cxx:4530; ROOT::TMetaUtils::ExtractAttrPropertyFromNamebool ExtractAttrPropertyFromName(const clang::Decl &decl, const std::string &propName, std::string &propValue)This routine counts on the ""propName<separator>propValue"" format.Definition TClingUtils.cxx:1689; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kExactMatch@ kExactMatchDefinition TDictionary.h:162; TClassEdit::IsStdPairBasebool IsStdPairBase(std::string_view name)Definition TClassEdit.h:188; TClassEdit::EComplexType::kInt@ kInt; TClassEdit::EComplexType::kNone@ kNone; TClassEdit::EComplexType::kLong@ kLong; TClassEdit::EComplexType::kDouble@ kDouble; TClassEdit::EComplexType::kFloat@ kFloat; TClassEdit::IsStdArraybool IsStdArray(std::string_view name)Definition TClassEdit.h:183; TClassEdit::IsStdClassbool IsStdClass(const char *type)return true if the class belongs to the std nam",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:2518,Modifiability,plugin,plugin,2518,"; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversionRuleParser.h""; 63#include ""RConfigure.h""; 64#include ""compiledata.h""; 65#include ""strlcpy.h""; 66#include ""snprintf.h""; 67#include ""TClingUtils.h""; 68#include ""TVirtualCollectionProxy.h""; 69#include ""TVirtualStreamerInfo.h""; 70#include ""TListOfDataMembers.h""; 71#include ""TListOfEnums.h""; 72#include ""TListOfEnumsWithLock.h""; 73#include ""TListOfFunctions.h""; 74#include ""TListOfFunctionTemplates.h""; 75#include ""TMemFile.h""; 76#include ""TProtoClass.h""; 77#include ""TStreamerInfo.h"" // This is here to avoid to use the plugin manager; 78#include ""ThreadLocalStorage.h""; 79#include ""TFile.h""; 80#include ""TKey.h""; 81#include ""ClingRAII.h""; 82 ; 83#include ""clang/AST/ASTContext.h""; 84#include ""clang/AST/Decl.h""; 85#include ""clang/AST/DeclarationName.h""; 86#include ""clang/AST/GlobalDecl.h""; 87#include ""clang/AST/RecordLayout.h""; 88#include ""clang/AST/DeclVisitor.h""; 89#include ""clang/AST/RecursiveASTVisitor.h""; 90#include ""clang/AST/Type.h""; 91#include ""clang/Basic/SourceLocation.h""; 92#include ""clang/Basic/Specifiers.h""; 93#include ""clang/Basic/TargetInfo.h""; 94#include ""clang/CodeGen/ModuleBuilder.h""; 95#include ""clang/Frontend/CompilerInstance.h""; 96#include ""clang/Frontend/FrontendDiagnostic.h""; 97#include ""clang/Lex/HeaderSearch.h""; 98#include ""clang/Lex/Preprocessor.h""; 99#include ""clang/Lex/PreprocessorOptions.h""; 100#include ""clang/Parse/Parser.h""; 101#include ""clang/Sema/Lookup.h""; 102#include ""clang/Sema/Sema.h""; 103#include ""clang/Serialization/ASTReader.h""; 104#include ""clang/Serialization/GlobalM",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:49883,Modifiability,plugin,plugins,49883,"ES; 1348 fCxxModulesEnabled = true;; 1349#endif; 1350 ; 1351 llvm::install_fatal_error_handler(&exceptionErrorHandler);; 1352 ; 1353 fTemporaries = new std::vector<cling::Value>();; 1354 ; 1355 std::vector<std::string> clingArgsStorage;; 1356 clingArgsStorage.push_back(""cling4root"");; 1357 for (const char* const* arg = argv; *arg; ++arg); 1358 clingArgsStorage.push_back(*arg);; 1359 ; 1360 // rootcling sets its arguments through TROOT::GetExtraInterpreterArgs().; 1361 if (!fromRootCling) {; 1362 ROOT::TMetaUtils::SetPathsForRelocatability(clingArgsStorage);; 1363 ; 1364 // Add -I early so ASTReader can find the headers.; 1365 std::string interpInclude(TROOT::GetEtcDir().Data());; 1366 clingArgsStorage.push_back(""-I"" + interpInclude);; 1367 ; 1368 // Add include path to etc/cling.; 1369 clingArgsStorage.push_back(""-I"" + interpInclude + ""/cling"");; 1370 ; 1371 // Add include path to etc/cling.; 1372 clingArgsStorage.push_back(""-I"" + interpInclude + ""/cling/plugins/include"");; 1373 ; 1374 // Add the root include directory and etc/ to list searched by default.; 1375 clingArgsStorage.push_back(std::string((""-I"" + TROOT::GetIncludeDir()).Data()));; 1376 ; 1377 // Add the current path to the include path; 1378 // TCling::AddIncludePath(""."");; 1379 ; 1380 // Attach the PCH (unless we have C++ modules enabled which provide the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:62636,Modifiability,variab,variable,62636,"to loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; ret",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:68590,Modifiability,plugin,plugin,68590,"; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:144975,Modifiability,variab,variables,144975,"3706/// continuation requested we must reset it.; 3707 ; 3708void TCling::Reset(); 3709{; 3710 fMetaProcessor->cancelContinuation();; 3711 // Reset the Cling state to the state saved by the last call to; 3712 // TCling::SaveContext().; 3713#if defined(R__MUST_REVISIT); 3714#if R__MUST_REVISIT(6,2); 3715 R__LOCKGUARD(gInterpreterMutex);; 3716 Warning(""Reset"",""Cling should support the equivalent of scratch_upto(&fDictPos)"");; 3717#endif; 3718#endif; 3719}; 3720 ; 3721////////////////////////////////////////////////////////////////////////////////; 3722/// Reset the Cling state to its initial state.; 3723 ; 3724void TCling::ResetAll(); 3725{; 3726#if defined(R__MUST_REVISIT); 3727#if R__MUST_REVISIT(6,2); 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 Warning(""ResetAll"",""Cling should support the equivalent of complete reset (unload everything but the startup decls."");; 3730#endif; 3731#endif; 3732}; 3733 ; 3734////////////////////////////////////////////////////////////////////////////////; 3735/// Reset in Cling the list of global variables to the state saved by the last; 3736/// call to TCling::SaveGlobalsContext().; 3737///; 3738/// Note: Right now, all we do is run the global destructors.; 3739 ; 3740void TCling::ResetGlobals(); 3741{; 3742 R__LOCKGUARD(gInterpreterMutex);; 3743 // TODO:; 3744 // Here we should iterate over the transactions (N-3) and revert.; 3745 // N-3 because the first three internal to cling.; 3746 ; 3747 fInterpreter->runAndRemoveStaticDestructors();; 3748}; 3749 ; 3750////////////////////////////////////////////////////////////////////////////////; 3751/// Reset the Cling 'user' global objects/variables state to the state saved by the last; 3752/// call to TCling::SaveGlobalsContext().; 3753 ; 3754void TCling::ResetGlobalVar(void* obj); 3755{; 3756#if defined(R__MUST_REVISIT); 3757#if R__MUST_REVISIT(6,2); 3758 R__LOCKGUARD(gInterpreterMutex);; 3759 Warning(""ResetGlobalVar"",""Cling should support the equivalent of resetglobalvar(obj)"");; 3760#end",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:145575,Modifiability,variab,variables,145575," its initial state.; 3723 ; 3724void TCling::ResetAll(); 3725{; 3726#if defined(R__MUST_REVISIT); 3727#if R__MUST_REVISIT(6,2); 3728 R__LOCKGUARD(gInterpreterMutex);; 3729 Warning(""ResetAll"",""Cling should support the equivalent of complete reset (unload everything but the startup decls."");; 3730#endif; 3731#endif; 3732}; 3733 ; 3734////////////////////////////////////////////////////////////////////////////////; 3735/// Reset in Cling the list of global variables to the state saved by the last; 3736/// call to TCling::SaveGlobalsContext().; 3737///; 3738/// Note: Right now, all we do is run the global destructors.; 3739 ; 3740void TCling::ResetGlobals(); 3741{; 3742 R__LOCKGUARD(gInterpreterMutex);; 3743 // TODO:; 3744 // Here we should iterate over the transactions (N-3) and revert.; 3745 // N-3 because the first three internal to cling.; 3746 ; 3747 fInterpreter->runAndRemoveStaticDestructors();; 3748}; 3749 ; 3750////////////////////////////////////////////////////////////////////////////////; 3751/// Reset the Cling 'user' global objects/variables state to the state saved by the last; 3752/// call to TCling::SaveGlobalsContext().; 3753 ; 3754void TCling::ResetGlobalVar(void* obj); 3755{; 3756#if defined(R__MUST_REVISIT); 3757#if R__MUST_REVISIT(6,2); 3758 R__LOCKGUARD(gInterpreterMutex);; 3759 Warning(""ResetGlobalVar"",""Cling should support the equivalent of resetglobalvar(obj)"");; 3760#endif; 3761#endif; 3762}; 3763 ; 3764////////////////////////////////////////////////////////////////////////////////; 3765/// Rewind Cling dictionary to the point where it was before executing; 3766/// the current macro. This function is typically called after SEGV or; 3767/// ctlr-C after doing a longjmp back to the prompt.; 3768 ; 3769void TCling::RewindDictionary(); 3770{; 3771#if defined(R__MUST_REVISIT); 3772#if R__MUST_REVISIT(6,2); 3773 R__LOCKGUARD(gInterpreterMutex);; 3774 Warning(""RewindDictionary"",""Cling should provide a way to revert transaction similar to rewinddictio",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:148124,Modifiability,variab,variable,148124,"/ Undeclare obj called name.; 3796/// Returns 1 in case of success, 0 for failure.; 3797 ; 3798Int_t TCling::DeleteVariable(const char* name); 3799{; 3800#if defined(R__MUST_REVISIT); 3801#if R__MUST_REVISIT(6,2); 3802 Warning(""DeleteVariable"",""should do more that just reseting the value to zero"");; 3803#endif; 3804#endif; 3805 ; 3806 R__LOCKGUARD(gInterpreterMutex);; 3807 llvm::StringRef srName(name);; 3808 const char* unscopedName = name;; 3809 llvm::StringRef::size_type posScope = srName.rfind(""::"");; 3810 const clang::DeclContext* declCtx = nullptr;; 3811 if (posScope != llvm::StringRef::npos) {; 3812 const cling::LookupHelper& lh = fInterpreter->getLookupHelper();; 3813 const clang::Decl* scopeDecl; 3814 = lh.findScope(srName.substr(0, posScope),; 3815 cling::LookupHelper::WithDiagnostics);; 3816 if (!scopeDecl) {; 3817 Error(""DeleteVariable"", ""Cannot find enclosing scope for variable %s"",; 3818 name);; 3819 return 0;; 3820 }; 3821 declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);; 3822 if (!declCtx) {; 3823 Error(""DeleteVariable"",; 3824 ""Enclosing scope for variable %s is not a declaration context"",; 3825 name);; 3826 return 0;; 3827 }; 3828 unscopedName += posScope + 2;; 3829 }; 3830 // Could trigger deserialization of decls.; 3831 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 3832 clang::NamedDecl* nVarDecl; 3833 = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);; 3834 if (!nVarDecl) {; 3835 Error(""DeleteVariable"", ""Unknown variable %s"", name);; 3836 return 0;; 3837 }; 3838 clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);; 3839 if (!varDecl) {; 3840 Error(""DeleteVariable"", ""Entity %s is not a variable"", name);; 3841 return 0;; 3842 }; 3843 ; 3844 clang::QualType qType = varDecl->getType();; 3845 const clang::Type* type = qType->getUnqualifiedDesugaredType();; 3846 // Cannot set a reference's address to nullptr; the JIT can place it; 3847 // into read-only memory (ROOT-7100).; 3848 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:148317,Modifiability,variab,variable,148317,"/ Undeclare obj called name.; 3796/// Returns 1 in case of success, 0 for failure.; 3797 ; 3798Int_t TCling::DeleteVariable(const char* name); 3799{; 3800#if defined(R__MUST_REVISIT); 3801#if R__MUST_REVISIT(6,2); 3802 Warning(""DeleteVariable"",""should do more that just reseting the value to zero"");; 3803#endif; 3804#endif; 3805 ; 3806 R__LOCKGUARD(gInterpreterMutex);; 3807 llvm::StringRef srName(name);; 3808 const char* unscopedName = name;; 3809 llvm::StringRef::size_type posScope = srName.rfind(""::"");; 3810 const clang::DeclContext* declCtx = nullptr;; 3811 if (posScope != llvm::StringRef::npos) {; 3812 const cling::LookupHelper& lh = fInterpreter->getLookupHelper();; 3813 const clang::Decl* scopeDecl; 3814 = lh.findScope(srName.substr(0, posScope),; 3815 cling::LookupHelper::WithDiagnostics);; 3816 if (!scopeDecl) {; 3817 Error(""DeleteVariable"", ""Cannot find enclosing scope for variable %s"",; 3818 name);; 3819 return 0;; 3820 }; 3821 declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);; 3822 if (!declCtx) {; 3823 Error(""DeleteVariable"",; 3824 ""Enclosing scope for variable %s is not a declaration context"",; 3825 name);; 3826 return 0;; 3827 }; 3828 unscopedName += posScope + 2;; 3829 }; 3830 // Could trigger deserialization of decls.; 3831 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 3832 clang::NamedDecl* nVarDecl; 3833 = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);; 3834 if (!nVarDecl) {; 3835 Error(""DeleteVariable"", ""Unknown variable %s"", name);; 3836 return 0;; 3837 }; 3838 clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);; 3839 if (!varDecl) {; 3840 Error(""DeleteVariable"", ""Entity %s is not a variable"", name);; 3841 return 0;; 3842 }; 3843 ; 3844 clang::QualType qType = varDecl->getType();; 3845 const clang::Type* type = qType->getUnqualifiedDesugaredType();; 3846 // Cannot set a reference's address to nullptr; the JIT can place it; 3847 // into read-only memory (ROOT-7100).; 3848 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:148745,Modifiability,variab,variable,148745,"LookupHelper& lh = fInterpreter->getLookupHelper();; 3813 const clang::Decl* scopeDecl; 3814 = lh.findScope(srName.substr(0, posScope),; 3815 cling::LookupHelper::WithDiagnostics);; 3816 if (!scopeDecl) {; 3817 Error(""DeleteVariable"", ""Cannot find enclosing scope for variable %s"",; 3818 name);; 3819 return 0;; 3820 }; 3821 declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);; 3822 if (!declCtx) {; 3823 Error(""DeleteVariable"",; 3824 ""Enclosing scope for variable %s is not a declaration context"",; 3825 name);; 3826 return 0;; 3827 }; 3828 unscopedName += posScope + 2;; 3829 }; 3830 // Could trigger deserialization of decls.; 3831 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 3832 clang::NamedDecl* nVarDecl; 3833 = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);; 3834 if (!nVarDecl) {; 3835 Error(""DeleteVariable"", ""Unknown variable %s"", name);; 3836 return 0;; 3837 }; 3838 clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);; 3839 if (!varDecl) {; 3840 Error(""DeleteVariable"", ""Entity %s is not a variable"", name);; 3841 return 0;; 3842 }; 3843 ; 3844 clang::QualType qType = varDecl->getType();; 3845 const clang::Type* type = qType->getUnqualifiedDesugaredType();; 3846 // Cannot set a reference's address to nullptr; the JIT can place it; 3847 // into read-only memory (ROOT-7100).; 3848 if (type->isPointerType()) {; 3849 int** ppInt = (int**)fInterpreter->getAddressOfGlobal(GlobalDecl(varDecl));; 3850 // set pointer to invalid.; 3851 if (ppInt) *ppInt = nullptr;; 3852 }; 3853 return 1;; 3854}; 3855 ; 3856////////////////////////////////////////////////////////////////////////////////; 3857/// Save the current Cling state.; 3858 ; 3859void TCling::SaveContext(); 3860{; 3861#if defined(R__MUST_REVISIT); 3862#if R__MUST_REVISIT(6,2); 3863 R__LOCKGUARD(gInterpreterMutex);; 3864 Warning(""SaveContext"",""Cling should provide a way to record a state watermark similar to store_dictposition(&fDictPos)"");; 3865#e",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:148936,Modifiability,variab,variable,148936,"LookupHelper& lh = fInterpreter->getLookupHelper();; 3813 const clang::Decl* scopeDecl; 3814 = lh.findScope(srName.substr(0, posScope),; 3815 cling::LookupHelper::WithDiagnostics);; 3816 if (!scopeDecl) {; 3817 Error(""DeleteVariable"", ""Cannot find enclosing scope for variable %s"",; 3818 name);; 3819 return 0;; 3820 }; 3821 declCtx = llvm::dyn_cast<clang::DeclContext>(scopeDecl);; 3822 if (!declCtx) {; 3823 Error(""DeleteVariable"",; 3824 ""Enclosing scope for variable %s is not a declaration context"",; 3825 name);; 3826 return 0;; 3827 }; 3828 unscopedName += posScope + 2;; 3829 }; 3830 // Could trigger deserialization of decls.; 3831 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 3832 clang::NamedDecl* nVarDecl; 3833 = cling::utils::Lookup::Named(&fInterpreter->getSema(), unscopedName, declCtx);; 3834 if (!nVarDecl) {; 3835 Error(""DeleteVariable"", ""Unknown variable %s"", name);; 3836 return 0;; 3837 }; 3838 clang::VarDecl* varDecl = llvm::dyn_cast<clang::VarDecl>(nVarDecl);; 3839 if (!varDecl) {; 3840 Error(""DeleteVariable"", ""Entity %s is not a variable"", name);; 3841 return 0;; 3842 }; 3843 ; 3844 clang::QualType qType = varDecl->getType();; 3845 const clang::Type* type = qType->getUnqualifiedDesugaredType();; 3846 // Cannot set a reference's address to nullptr; the JIT can place it; 3847 // into read-only memory (ROOT-7100).; 3848 if (type->isPointerType()) {; 3849 int** ppInt = (int**)fInterpreter->getAddressOfGlobal(GlobalDecl(varDecl));; 3850 // set pointer to invalid.; 3851 if (ppInt) *ppInt = nullptr;; 3852 }; 3853 return 1;; 3854}; 3855 ; 3856////////////////////////////////////////////////////////////////////////////////; 3857/// Save the current Cling state.; 3858 ; 3859void TCling::SaveContext(); 3860{; 3861#if defined(R__MUST_REVISIT); 3862#if R__MUST_REVISIT(6,2); 3863 R__LOCKGUARD(gInterpreterMutex);; 3864 Warning(""SaveContext"",""Cling should provide a way to record a state watermark similar to store_dictposition(&fDictPos)"");; 3865#e",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:150294,Modifiability,variab,variable,150294,"ned(R__MUST_REVISIT); 3862#if R__MUST_REVISIT(6,2); 3863 R__LOCKGUARD(gInterpreterMutex);; 3864 Warning(""SaveContext"",""Cling should provide a way to record a state watermark similar to store_dictposition(&fDictPos)"");; 3865#endif; 3866#endif; 3867}; 3868 ; 3869////////////////////////////////////////////////////////////////////////////////; 3870/// Save the current Cling state of global objects.; 3871 ; 3872void TCling::SaveGlobalsContext(); 3873{; 3874#if defined(R__MUST_REVISIT); 3875#if R__MUST_REVISIT(6,2); 3876 R__LOCKGUARD(gInterpreterMutex);; 3877 Warning(""SaveGlobalsContext"",""Cling should provide a way to record a watermark for the list of global variable similar to store_dictposition(&fDictPosGlobals)"");; 3878#endif; 3879#endif; 3880}; 3881 ; 3882////////////////////////////////////////////////////////////////////////////////; 3883/// No op: see TClingCallbacks (used to update the list of globals); 3884 ; 3885void TCling::UpdateListOfGlobals(); 3886{; 3887}; 3888 ; 3889////////////////////////////////////////////////////////////////////////////////; 3890/// No op: see TClingCallbacks (used to update the list of global functions); 3891 ; 3892void TCling::UpdateListOfGlobalFunctions(); 3893{; 3894}; 3895 ; 3896////////////////////////////////////////////////////////////////////////////////; 3897/// No op: see TClingCallbacks (used to update the list of types); 3898 ; 3899void TCling::UpdateListOfTypes(); 3900{; 3901}; 3902 ; 3903////////////////////////////////////////////////////////////////////////////////; 3904/// Check in what order the member of a tuple are layout.; 3905enum class ETupleOrdering {; 3906 kAscending,; 3907 kDescending,; 3908 kUnexpected; 3909};; 3910 ; 3911struct AlternateTupleIntDoubleAsc; 3912{; 3913 Int_t _0;; 3914 Double_t _1;; 3915};; 3916 ; 3917struct AlternateTupleIntDoubleDes; 3918{; 3919 Double_t _1;; 3920 Int_t _0;; 3921};; 3922 ; 3923static ETupleOrdering IsTupleAscending(); 3924{; 3925 std::tuple<int,double> value;; 3926 Alterna",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:185459,Modifiability,variab,variable,185459,"onst char* current = classes, *prev = classes;; 4733 *current != 0;; 4734 ++current; 4735 ) {; 4736 if (*current == ';') {; 4737 listClasses.push_back(std::string(prev, current - prev));; 4738 prev = current + 1;; 4739 }; 4740 else if (*(current + 1) == 0) {; 4741 listClasses.push_back(std::string(prev, current + 1 - prev));; 4742 prev = current + 1;; 4743 }; 4744 }; 4745 std::vector<std::string> listIncludes;; 4746 if (!includes); 4747 includes = """";; 4748 for (; 4749 const char* current = includes, *prev = includes;; 4750 *current != 0;; 4751 ++current; 4752 ) {; 4753 if (*current == ';') {; 4754 listIncludes.push_back(std::string(prev, current - prev));; 4755 prev = current + 1;; 4756 }; 4757 else if (*(current + 1) == 0) {; 4758 listIncludes.push_back(std::string(prev, current + 1 - prev));; 4759 prev = current + 1;; 4760 }; 4761 }; 4762 // Generate the temporary dictionary file; 4763 return !TCling_GenerateDictionary(listClasses, listIncludes,; 4764 std::vector<std::string>(), std::vector<std::string>());; 4765}; 4766 ; 4767////////////////////////////////////////////////////////////////////////////////; 4768/// Return pointer to cling Decl of global/static variable that is located; 4769/// at the address given by addr.; 4770 ; 4771TInterpreter::DeclId_t TCling::GetDataMember(ClassInfo_t *opaque_cl, const char *name) const; 4772{; 4773 R__LOCKGUARD(gInterpreterMutex);; 4774 DeclId_t d;; 4775 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 4776 ; 4777 // Could trigger deserialization of decls.; 4778 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4779 ; 4780 if (cl) {; 4781 d = cl->GetDataMember(name);; 4782 // We check if the decl of the data member has an annotation which indicates; 4783 // an ioname.; 4784 // In case this is true, if the name requested is not the ioname, we; 4785 // return 0, as if the member did not exist. In some sense we override; 4786 // the information in the TClassInfo instance, isolating the typesystem in; 4787",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:188225,Modifiability,variab,variable,188225,"erstanding for a Data Member.; 4801 // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something; 4802 // similar as below.; 4803 using namespace clang;; 4804 Sema& SemaR = fInterpreter->getSema();; 4805 DeclarationName DName = &SemaR.Context.Idents.get(name);; 4806 ; 4807 LookupResult R(SemaR, DName, SourceLocation(), Sema::LookupOrdinaryName,; 4808 Sema::ForExternalRedeclaration);; 4809 ; 4810 cling::utils::Lookup::Named(&SemaR, R);; 4811 ; 4812 LookupResult::Filter F = R.makeFilter();; 4813 // Filter the data-member looking decls.; 4814 while (F.hasNext()) {; 4815 NamedDecl *D = F.next();; 4816 if (isa<VarDecl>(D) || isa<FieldDecl>(D) || isa<EnumConstantDecl>(D) ||; 4817 isa<IndirectFieldDecl>(D)); 4818 continue;; 4819 F.erase();; 4820 }; 4821 F.done();; 4822 ; 4823 if (R.isSingleResult()); 4824 return R.getFoundDecl();; 4825 return nullptr;; 4826}; 4827 ; 4828////////////////////////////////////////////////////////////////////////////////; 4829/// Return pointer to cling Decl of global/static variable that is located; 4830/// at the address given by addr.; 4831 ; 4832TInterpreter::DeclId_t TCling::GetEnum(TClass *cl, const char *name) const; 4833{; 4834 R__LOCKGUARD(gInterpreterMutex);; 4835 ; 4836 const clang::Decl* possibleEnum = nullptr;; 4837 // FInd the context of the decl.; 4838 if (cl) {; 4839 TClingClassInfo *cci = (TClingClassInfo*)cl->GetClassInfo();; 4840 if (cci) {; 4841 const clang::DeclContext* dc = nullptr;; 4842 if (const clang::Decl* D = cci->GetDecl()) {; 4843 if (!(dc = dyn_cast<clang::NamespaceDecl>(D))) {; 4844 dc = dyn_cast<clang::RecordDecl>(D);; 4845 }; 4846 }; 4847 if (dc) {; 4848 // If it is a data member enum.; 4849 // Could trigger deserialization of decls.; 4850 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4851 possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name, dc);; 4852 } else {; 4853 Error(""TCling::GetEnum"", ""DeclContext not found fo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:203435,Modifiability,enhance,enhance,203435," ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can report; 5231/// compilation and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance the",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:204462,Modifiability,enhance,enhance,204462,"on and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance these interfaces so that we can report; 5255/// compilation and runtime errors properly.; 5256 ; 5257void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5258 const char* params, Bool_t objectIsConst, int* error); 5259{; 5260 R__LOCKGUARD_CLING(gInterpreterMutex);; 5261 if (error) {; 5262 *error = TInterpreter::kNoError;; 5263 }; 5264 // If the actual class of this object inherits 2nd (or more) from TObject,; 5265 // 'obj' is unlikely to be the start of the object (as described by IsA()),; 5266 // hence gInterpreter->Execute will improperly correct the offset.; 5267 void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);; 5268 Longptr_t offset = 0L;; 5269 TClingCallFunc func(GetInterpreterImpl());; 5270 func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);; 5271 void* address = (void*)((Longptr_t)addr + offset);; 5272 func.Exec(address);; 5273}; 5274 ; 5275////////////////////////////////////////////////////////////////////////////////; 5276 ; 5277void TClin",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:204860,Modifiability,inherit,inherits,204860,"set = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance these interfaces so that we can report; 5255/// compilation and runtime errors properly.; 5256 ; 5257void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5258 const char* params, Bool_t objectIsConst, int* error); 5259{; 5260 R__LOCKGUARD_CLING(gInterpreterMutex);; 5261 if (error) {; 5262 *error = TInterpreter::kNoError;; 5263 }; 5264 // If the actual class of this object inherits 2nd (or more) from TObject,; 5265 // 'obj' is unlikely to be the start of the object (as described by IsA()),; 5266 // hence gInterpreter->Execute will improperly correct the offset.; 5267 void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);; 5268 Longptr_t offset = 0L;; 5269 TClingCallFunc func(GetInterpreterImpl());; 5270 func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);; 5271 void* address = (void*)((Longptr_t)addr + offset);; 5272 func.Exec(address);; 5273}; 5274 ; 5275////////////////////////////////////////////////////////////////////////////////; 5276 ; 5277void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5278 const char* params, int* error); 5279{; 5280 Execute(obj,cl,method,params,false,error);; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Execute a method from class cl with the argum",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:208876,Modifiability,inherit,inherits,208876," Create a character string of parameters from TObjArray; 5339 TIter next(params);; 5340 for (Int_t i = 0; i < argc; i ++) {; 5341 TMethodArg* arg = (TMethodArg*) argList->At(i);; 5342 TClingTypeInfo type(GetInterpreterImpl(), arg->GetFullTypeName());; 5343 TObjString* nxtpar = (TObjString*) next();; 5344 if (i) {; 5345 complete += ',';; 5346 }; 5347 if (strstr(type.TrueName(*fNormalizedCtxt), ""char"")) {; 5348 TString chpar('\""');; 5349 chpar += (nxtpar->String()).ReplaceAll(""\"""", ""\\\"""");; 5350 // At this point we have to check if string contains \\""; 5351 // and apply some more sophisticated parser. Not implemented yet!; 5352 complete += chpar;; 5353 complete += '\""';; 5354 }; 5355 else {; 5356 complete += nxtpar->String();; 5357 }; 5358 }; 5359 listpar = complete.Data();; 5360 }; 5361 ; 5362 // And now execute it.; 5363 R__LOCKGUARD_CLING(gInterpreterMutex);; 5364 if (error) {; 5365 *error = TInterpreter::kNoError;; 5366 }; 5367 // If the actual class of this object inherits 2nd (or more) from TObject,; 5368 // 'obj' is unlikely to be the start of the object (as described by IsA()),; 5369 // hence gInterpreter->Execute will improperly correct the offset.; 5370 void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);; 5371 TClingCallFunc func(GetInterpreterImpl());; 5372 TClingMethodInfo *minfo = (TClingMethodInfo*)method->fInfo;; 5373 func.Init(*minfo);; 5374 func.SetArgs(listpar);; 5375 // Now calculate the 'this' pointer offset for the method; 5376 // when starting from the class described by cl.; 5377 const CXXMethodDecl * mdecl = dyn_cast<CXXMethodDecl>(minfo->GetTargetFunctionDecl());; 5378 Longptr_t offset = ((TClingClassInfo*)cl->GetClassInfo())->GetOffset(mdecl);; 5379 void* address = (void*)((Longptr_t)addr + offset);; 5380 func.Exec(address);; 5381}; 5382 ; 5383////////////////////////////////////////////////////////////////////////////////; 5384 ; 5385void TCling::ExecuteWithArgsAndReturn(TMethod* method, void* address,; 5386 const void* args[] /*=0*",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:219977,Modifiability,variab,variable,219977,"ted to %s"",; 5628 rootmapfile, line.substr(0, keyLen - 1).c_str(), keyname, lib_name.c_str(),; 5629 isThere->GetValue());; 5630 }; 5631 } else { // the same key for the same lib; 5632 if (gDebug > 3); 5633 Info(""ReadRootmapFile"", ""While processing %s, key %s was found to be already defined for %s"",; 5634 rootmapfile, keyname, lib_name.c_str());; 5635 }; 5636 } else {; 5637 fMapfile->SetValue(keyname, lib_name.c_str());; 5638 }; 5639 }; 5640 }; 5641 file.close();; 5642 return 0;; 5643}; 5644 ; 5645////////////////////////////////////////////////////////////////////////////////; 5646/// Create a resource table and read the (possibly) three resource files,; 5647/// i.e. `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`), `$HOME/<name>`; 5648/// and `$PWD/<name>`. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You; 5649/// can read additional user defined resource files by creating additional TEnv; 5650/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 5651/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 5652/// case the home directory resides on an automounted remote file system; 5653/// and one wants to avoid the file system from being mounted.; 5654 ; 5655void TCling::InitRootmapFile(const char *name); 5656{; 5657 assert(requiresRootMap(name) && ""We have a module!"");; 5658 ; 5659 if (!requiresRootMap(name)); 5660 return;; 5661 ; 5662 Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);; 5663 ; 5664 fMapfile->SetRcName(name);; 5665 ; 5666 TString sname = ""system"";; 5667 sname += name;; 5668 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 5669 ; 5670 Int_t ret = ReadRootmapFile(s);; 5671 if (ret == -3) // old format; 5672 fMapfile->ReadFile(s, kEnvGlobal);; 5673 delete [] s;; 5674 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 5675 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 5676 ret = ReadRootmapFile(s);; 5677 if (ret == -3) // old format; 5678 fMapfile->ReadFile(s, kEn",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:300179,Modifiability,extend,extending,300179,"void TCling::CodeComplete(const std::string& line, size_t& cursor,; 7671 std::vector<std::string>& completions); 7672{; 7673 fInterpreter->codeComplete(line, cursor, completions);; 7674}; 7675 ; 7676////////////////////////////////////////////////////////////////////////////////; 7677/// Get the interpreter value corresponding to the statement.; 7678int TCling::Evaluate(const char* code, TInterpreterValue& value); 7679{; 7680 auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());; 7681 auto compRes = fInterpreter->evaluate(code, *V);; 7682 return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;; 7683}; 7684 ; 7685////////////////////////////////////////////////////////////////////////////////; 7686 ; 7687void TCling::RegisterTemporary(const TInterpreterValue& value); 7688{; 7689 using namespace cling;; 7690 const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());; 7691 RegisterTemporary(*V);; 7692}; 7693 ; 7694////////////////////////////////////////////////////////////////////////////////; 7695/// Register value as a temporary, extending its lifetime to that of the; 7696/// interpreter. This is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 77",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:435725,Modifiability,variab,variable,435725,"ctoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::fSharedLibsTString fSharedLibsDefinition TCling.h:113; TCling::fPendingRdictsstd::map< std::string, llvm::",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:453133,Modifiability,variab,variables,453133,"d::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TString &name) const finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:453494,Modifiability,variab,variables,453494," finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelM",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:460520,Modifiability,variab,variable,460520," prepended.Definition TCling.cxx:7370; TCling::UpdateListsOnUnloadedvoid UpdateListsOnUnloaded(const cling::Transaction &T)Invalidate stored TCling state for declarations included in transaction ‘T’.Definition TCling.cxx:6849; TCling::UpdateClassInfoWithDeclvoid UpdateClassInfoWithDecl(const clang::NamedDecl *ND)Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.Definition TCling.cxx:6681; TCling::IsSameTypebool IsSameType(const void *QualTypePtr1, const void *QualTypePtr2) constDefinition TCling.cxx:9538; TCling::Initializevirtual void Initialize() finalInitialize the interpreter, once TROOT::fInterpreter is set.Definition TCling.cxx:1636; TCling::ClassInfo_GetMethodNArgint ClassInfo_GetMethodNArg(ClassInfo_t *info, const char *method, const char *proto, Bool_t objectIsConst=false, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8245; TCling::GetDataMemberDeclId_t GetDataMember(ClassInfo_t *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4771; TCling::fAutoLoadCallBackvoid * fAutoLoadCallBackDefinition TCling.h:147; TCling::FuncTempInfo_Namevoid FuncTempInfo_Name(FuncTempInfo_t *, TString &name) const finalReturn the name of this function template.Definition TCling.cxx:8957; TCling::fMetaProcessorstd::unique_ptr< cling::MetaProcessor > fMetaProcessorDefinition TCling.h:131; TCling::TypeInfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:843",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:466671,Modifiability,config,config,466671,"KeysTList * GetListOfKeys() const overrideDefinition TDirectoryFile.h:94; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TEnumConstantThe TEnumConstant class implements the constants of the enum type.Definition TEnumConstant.h:29; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnum::GetConstantsconst TSeqCollection * GetConstants() constDefinition TEnum.h:63; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::GetDeclIdDeclId_t GetDeclId() constDefinition TEnum.cxx:146; TEnum::kNone@ kNoneDefinition TEnum.h:48; TEnum::kAutoload@ kAutoloadDefinition TEnum.h:49; TEnvRecDefinition TEnv.h:86; TEnvRec::GetValueconst char * GetValue() constDefinition TEnv.h:110; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TEnv::IgnoreDuplicatesBool_t IgnoreDuplicates(Bool_t ignore)If set to true, no warnings in case of duplicates are issued.Definition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal funct",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:467828,Modifiability,variab,variables,467828,"l_t ignore)If set to true, no warnings in case of duplicates are issued.Definition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoad",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:467852,Modifiability,variab,variables,467852,"l_t ignore)If set to true, no warnings in case of duplicates are issued.Definition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoad",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:480585,Modifiability,variab,variable,480585,"; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::GetIncludePathvirtual const char * GetIncludePath()Get the list of include path.Definition TSystem.cxx:3973; TSystem::SplitAclicModevirtual TString SplitAclicMode(const char *filename, TString &mode, TString &args, TString &io) constThis method split a filename of the form:Definition TSystem.cxx:4258; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:483563,Modifiability,variab,variable,483563,"GetDynamicPath()Return the dynamic path (used to find shared libraries).Definition TSystem.cxx:1795; TSystem::FindDynamicLibraryvirtual const char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE)Find a dynamic library using the system search paths.Definition TSystem.cxx:2034; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::DynamicPathNamechar * DynamicPathName(const char *lib, Bool_t quiet=kFALSE)Find a dynamic library called lib using the system search paths.Definition TSystem.cxx:2020; TVirtualMutex::UnLockvirtual Int_t UnLock()=0; TVirtualMutex::Lockvirtual Int_t Lock()=0; TVirtualMutex::Factoryvirtual TVirtualMutex * Factory(Bool_t=kFALSE)=0; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Updatevirtual void Update()=0; TVirtualStreamerInfo::SetFactorystatic void SetFactor",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:490019,Modifiability,portab,portable,490019,"tch@ kExactMatchDefinition TDictionary.h:162; TClassEdit::IsStdPairBasebool IsStdPairBase(std::string_view name)Definition TClassEdit.h:188; TClassEdit::EComplexType::kInt@ kInt; TClassEdit::EComplexType::kNone@ kNone; TClassEdit::EComplexType::kLong@ kLong; TClassEdit::EComplexType::kDouble@ kDouble; TClassEdit::EComplexType::kFloat@ kFloat; TClassEdit::IsStdArraybool IsStdArray(std::string_view name)Definition TClassEdit.h:183; TClassEdit::IsStdClassbool IsStdClass(const char *type)return true if the class belongs to the std namespaceDefinition TClassEdit.cxx:1418; TClassEdit::IsStdPairbool IsStdPair(std::string_view name)Definition TClassEdit.h:184; TClassEdit::InsertStdstd::string InsertStd(const char *tname)Definition TClassEdit.cxx:1784; TClassEdit::GetLong64_Namestd::string GetLong64_Name(const char *original)Replace 'long long' and 'unsigned long long' by 'Long64_t' and 'ULong64_t'.Definition TClassEdit.cxx:908; TClassEdit::DemangleTypeIdNamechar * DemangleTypeIdName(const std::type_info &ti, int &errorCode)Demangle in a portable way the type id name.Definition TClassEdit.cxx:2148; TClassEdit::GetUnqualifiedNameconst char * GetUnqualifiedName(const char *name)Return the start of the unqualified name include in 'original'.Definition TClassEdit.cxx:942; TClassEdit::Initvoid Init(TClassEdit::TInterpreterLookupHelper *helper)Definition TClassEdit.cxx:171; TClassEdit::IsSTLContROOT::ESTLType IsSTLCont(std::string_view type)type : type name: vector<list<classA,allocator>,allocator> result: 0 : not stl container code of cont...Definition TClassEdit.cxx:1378; TClassEdit::DemangleNamechar * DemangleName(const char *mangled_name, int &errorCode)Definition TClassEdit.h:208; TClassEdit::GetSplitint GetSplit(const char *type, std::vector< std::string > &output, int &nestedLoc, EModType mode=TClassEdit::kNone)Stores in output (after emptying it) the split type.Definition TClassEdit.cxx:1029; TClassEdit::IsUniquePtrbool IsUniquePtr(std::string_view name)Definition TClassEd",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:5198,Performance,load,loader,5198,"#include ""llvm/Support/raw_ostream.h""; 123#include ""llvm/Support/Path.h""; 124#include ""llvm/Support/Process.h""; 125#include ""llvm/Object/ELFObjectFile.h""; 126#include ""llvm/Object/ObjectFile.h""; 127#include ""llvm/Object/SymbolicFile.h""; 128#include ""llvm/Support/FileSystem.h""; 129 ; 130#include <algorithm>; 131#include <iostream>; 132#include <cassert>; 133#include <map>; 134#include <set>; 135#include <stdexcept>; 136#include <stdint.h>; 137#include <fstream>; 138#include <sstream>; 139#include <string>; 140#include <tuple>; 141#include <typeinfo>; 142#include <unordered_map>; 143#include <unordered_set>; 144#include <utility>; 145#include <vector>; 146#include <functional>; 147#include <optional>; 148 ; 149#ifndef R__WIN32; 150#include <cxxabi.h>; 151#define R__DLLEXPORT __attribute__ ((visibility (""default""))); 152#include <sys/stat.h>; 153#endif; 154#include <limits.h>; 155#include <stdio.h>; 156 ; 157#ifdef __APPLE__; 158#include <dlfcn.h>; 159#include <mach-o/dyld.h>; 160#include <mach-o/loader.h>; 161#endif // __APPLE__; 162 ; 163#ifdef R__UNIX; 164#include <dlfcn.h>; 165#endif; 166 ; 167#if defined(R__LINUX) || defined(R__FBSD); 168# ifndef _GNU_SOURCE; 169# define _GNU_SOURCE; 170# endif; 171# include <link.h> // dl_iterate_phdr(); 172#endif; 173 ; 174#if defined(__CYGWIN__); 175#include <sys/cygwin.h>; 176#define HMODULE void *; 177extern ""C"" {; 178 __declspec(dllimport) void * __stdcall GetCurrentProcess();; 179 __declspec(dllimport) bool __stdcall EnumProcessModules(void *, void **, unsigned long, unsigned long *);; 180 __declspec(dllimport) unsigned long __stdcall GetModuleFileNameExW(void *, void *, wchar_t *, unsigned long);; 181}; 182#endif; 183 ; 184// Fragment copied from LLVM's raw_ostream.cpp; 185#if defined(_MSC_VER); 186#ifndef STDIN_FILENO; 187# define STDIN_FILENO 0; 188#endif; 189#ifndef STDOUT_FILENO; 190# define STDOUT_FILENO 1; 191#endif; 192#ifndef STDERR_FILENO; 193# define STDERR_FILENO 2; 194#endif; 195#ifndef R__WIN32; 196//#if define",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:14174,Performance,load,loading,14174,"///////////////////////////////////////////////////; 366/// Lock the interpreter.; 367 ; 368extern ""C"" void *TCling__LockCompilationDuringUserCodeExecution(); 369{; 370 if (gInterpreterMutex) {; 371 gInterpreterMutex->Lock();; 372 }; 373 return nullptr;; 374}; 375 ; 376////////////////////////////////////////////////////////////////////////////////; 377/// Unlock the interpreter.; 378 ; 379extern ""C"" void TCling__UnlockCompilationDuringUserCodeExecution(void* /*state*/); 380{; 381 if (gInterpreterMutex) {; 382 gInterpreterMutex->UnLock();; 383 }; 384}; 385 ; 386////////////////////////////////////////////////////////////////////////////////; 387/// Update TClingClassInfo for a class (e.g. upon seeing a definition).; 388 ; 389static void TCling__UpdateClassInfo(const NamedDecl* TD); 390{; 391 static Bool_t entered = kFALSE;; 392 static vector<const NamedDecl*> updateList;; 393 Bool_t topLevel;; 394 ; 395 if (entered) topLevel = kFALSE;; 396 else {; 397 entered = kTRUE;; 398 topLevel = kTRUE;; 399 }; 400 if (topLevel) {; 401 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(TD);; 402 } else {; 403 // If we are called indirectly from within another call to; 404 // TCling::UpdateClassInfo, we delay the update until the dictionary loading; 405 // is finished (i.e. when we return to the top level TCling::UpdateClassInfo).; 406 // This allows for the dictionary to be fully populated when we actually; 407 // update the TClass object. The updating of the TClass sometimes; 408 // (STL containers and when there is an emulated class) forces the building; 409 // of the TClass object's real data (which needs the dictionary info).; 410 updateList.push_back(TD);; 411 }; 412 if (topLevel) {; 413 while (!updateList.empty()) {; 414 ((TCling*)gInterpreter)->UpdateClassInfoWithDecl(updateList.back());; 415 updateList.pop_back();; 416 }; 417 entered = kFALSE;; 418 }; 419}; 420 ; 421void TCling::UpdateEnumConstants(TEnum* enumObj, TClass* cl) const {; 422 const clang::Decl* D = static_cast",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:26526,Performance,queue,queue,26526,"| *sIt == '>' ||; 718 *sIt == ' ' || *sIt == '*' ||; 719 *sIt == ',' || *sIt == '&' ||; 720 *sIt == ':') {; 721 fileName += '_';; 722 }; 723 else {; 724 fileName += *sIt;; 725 }; 726 }; 727 if (classes.size() > 1) {; 728 Int_t chk = 0;; 729 std::vector<std::string>::const_iterator it = classes.begin();; 730 while ((++it) != classes.end()) {; 731 for (UInt_t cursor = 0; cursor != it->length(); ++cursor) {; 732 chk = chk * 3 + it->at(cursor);; 733 }; 734 }; 735 fileName += TString::Format(""_%u"", chk);; 736 }; 737 fileName += "".cxx"";; 738 if (gSystem->AccessPathName(fileName) != 0) {; 739 //file does not exist; 740 //(1) prepare file data; 741 // If STL, also request iterators' operators.; 742 // vector is special: we need to check whether; 743 // vector::iterator is a typedef to pointer or a; 744 // class.; 745 static const std::set<std::string> sSTLTypes {; 746 ""vector"",""list"",""forward_list"",""deque"",""map"",""unordered_map"",""multimap"",; 747 ""unordered_multimap"",""set"",""unordered_set"",""multiset"",""unordered_multiset"",; 748 ""queue"",""priority_queue"",""stack"",""iterator""};; 749 std::vector<std::string>::const_iterator it;; 750 std::string fileContent("""");; 751 for (it = headers.begin(); it != headers.end(); ++it) {; 752 fileContent += ""#include \"""" + *it + ""\""\n"";; 753 }; 754 for (it = unknown.begin(); it != unknown.end(); ++it) {; 755 TClass* cl = TClass::GetClass(it->c_str());; 756 if (cl && cl->GetDeclFileName()) {; 757 TString header = gSystem->BaseName(cl->GetDeclFileName());; 758 TString dir = gSystem->GetDirName(cl->GetDeclFileName());; 759 TString dirbase(gSystem->BaseName(dir));; 760 while (dirbase.Length() && dirbase != "".""; 761 && dirbase != ""include"" && dirbase != ""inc""; 762 && dirbase != ""prec_stl"") {; 763 gSystem->PrependPathName(dirbase, header);; 764 dir = gSystem->GetDirName(dir);; 765 }; 766 fileContent += TString(""#include \"""") + header + ""\""\n"";; 767 }; 768 }; 769 for (it = fwdDecls.begin(); it != fwdDecls.end(); ++it) {; 770 fileContent += ""class "" + *it + ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:33197,Performance,load,loaded,33197,"5{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offset;; 927 }; 928 ; 929 //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,""DEBUG: checking on %s vs %s %lu %lu\n"",tname.c_str(),inner,offset,end);; 930 if (gROOT->GetListOfClasses()->FindObject(inner); 931 || TClassTable::Check(inner,result) ) {; 932 // This is a known class.; 933 return true;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );; 938 if (type) {; 939 // This is a raw type and an already loaded typedef.; 940 const char *newname = type->GetFullTypeName();; 941 if (type->GetType() == kLong64_t) {; 942 newname = ""Long64_t"";; 943 } else if (type->GetType() == kULong64_t) {; 944 newname = ""ULong64_t"";; 945 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:34471,Performance,load,loaded,34471,"5 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{inner, scopeNameSize};; 966 // Check if the scope is in the list of classes; 967 if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName.c_str()))) {; 968 auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));; 969 if (enumTable && enumTable->THashList::FindObject(enName)); 970 return true;; 971 }; 972 // It may still be in one of the loaded protoclasses; 973 else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName.c_str()))) {; 974 auto listOfEnums = scope->GetListOfEnums();; 975 if (listOfEnums) { // it could be null: no enumerators in the protoclass; 976 auto enumTable = dynamic_cast<const THashList *>(listOfEnums);; 977 if (enumTable && enumTable->THashList::FindObject(enName)); 978 return true;; 979 }; 980 }; 981 } else; 982 {; 983 // We don't have any scope: this could only be a global enum; 984 auto enumTable = dynamic_cast<const THashList *>(gROOT->GetListOfEnums());; 985 if (enumTable && enumTable->THashList::FindObject(inner)) return true;; 986 }; 987 ; 988 if (gCling->GetClassSharedLibs(inner)); 989 {; 990 // This is a class name.; 991 return true;; 992 }; 993 ; 994 return false;; 995}; 996 ; 997////////////////////////////////////////////////////////////////////////////////; 998 ; 999TCling::TUniqueString::TUniqueString(",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:36329,Performance,load,loaded,36329,"->GetClassSharedLibs(inner)); 989 {; 990 // This is a class name.; 991 return true;; 992 }; 993 ; 994 return false;; 995}; 996 ; 997////////////////////////////////////////////////////////////////////////////////; 998 ; 999TCling::TUniqueString::TUniqueString(Long64_t size); 1000{; 1001 fContent.reserve(size);; 1002}; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005 ; 1006inline const char *TCling::TUniqueString::Data(); 1007{; 1008 return fContent.c_str();; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName,",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:36475,Performance,load,load,36475,"0{; 1001 fContent.reserve(size);; 1002}; 1003 ; 1004////////////////////////////////////////////////////////////////////////////////; 1005 ; 1006inline const char *TCling::TUniqueString::Data(); 1007{; 1008 return fContent.c_str();; 1009}; 1010 ; 1011////////////////////////////////////////////////////////////////////////////////; 1012/// Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:36743,Performance,load,loading,36743,"/ Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const stat",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:36804,Performance,load,loading,36804,"/ Append string to the storage if not added already.; 1013 ; 1014inline bool TCling::TUniqueString::Append(const std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const stat",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:37132,Performance,load,loadModule,37132,"/////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:38623,Performance,load,loadGlobalModuleIndex,38623,", interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:39202,Performance,load,loads,39202,"leName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 // We want the index only of the prebuilt modules.; 1105 if (!HasASTFileOnDisk(TheModule, PP)); 1106 continue;; 1107 LoadModule(TheModule->Name, interp);; 1108 RecreateIndex = true;; 1109 }; 1110 if (RecreateIndex) {; 1111 cling::Interpreter::PushTransactionRAII deserRAII(&interp);; 1112 clang::GlobalModuleIndex::UserDefinedInterestingIDs IDs;; 1113 ; 1114 struct Defin",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:39226,Performance,load,loaded,39226,"leName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 // We want the index only of the prebuilt modules.; 1105 if (!HasASTFileOnDisk(TheModule, PP)); 1106 continue;; 1107 LoadModule(TheModule->Name, interp);; 1108 RecreateIndex = true;; 1109 }; 1110 if (RecreateIndex) {; 1111 cling::Interpreter::PushTransactionRAII deserRAII(&interp);; 1112 clang::GlobalModuleIndex::UserDefinedInterestingIDs IDs;; 1113 ; 1114 struct Defin",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:39294,Performance,load,loadGlobalIndex,39294,"ebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 // We want the index only of the prebuilt modules.; 1105 if (!HasASTFileOnDisk(TheModule, PP)); 1106 continue;; 1107 LoadModule(TheModule->Name, interp);; 1108 RecreateIndex = true;; 1109 }; 1110 if (RecreateIndex) {; 1111 cling::Interpreter::PushTransactionRAII deserRAII(&interp);; 1112 clang::GlobalModuleIndex::UserDefinedInterestingIDs IDs;; 1113 ; 1114 struct DefinitionFinder : public RecursiveASTVisitor<DefinitionFinder> {; 1115 DefinitionFinder(clang::GlobalModuleIndex::UserDefinedInterestingIDs& IDs,; 1116 clang::TranslationUnitDecl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:42675,Performance,load,loadGlobalIndex,42675,"nput_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 GlobalIndex = ModuleManager->getGlobalIndex();; 1177 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181}; 1182 ; 1183static void RegisterCxxModules(cling::Interpreter &clingInterp); 1184{; 1185 if (!clingInterp.getCI()->getLangOpts().Modules); 1186 return;; 1187 ; 1188 // Loading of a module might deserialize.; 1189 cling::Interpreter::PushTransactionRAII deserRAII(&clingInterp);; 1190 ; 1191 // Setup core C++ modules if we have any to setup.; 1192 ; 1193 // Load libc and stl first.; 1194 // Load vcruntime module for windows; 1195#ifdef R__WIN32; 1196 LoadModule(""vcruntime"", clingInterp);; 1197 LoadModule(""services"", clingInterp);; 1198#endif; 1199 ; 1200#ifdef R__MACOSX; 1201 LoadModule(""Darwin"", clingInterp);; 1202#else; 1203 LoadModule(""libc"", clingInterp);; 1204#endif; 1205 LoadModule(""std"", clingInterp);; 1206 ; 1207 LoadModule(""_Builtin_intrinsics"", clingInterp);; 1208 ; 1209 // Load core modules; 1210 // This should be vector in order to be able to pass it to LoadModules; 1211 std::vector<std::s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:44819,Performance,load,loadGlobalModuleIndex,44819,"14 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clingInterp);; 1225 ; 1226 // These modules should not be preloaded but they fix issues.; 1227 // FIXME: Hist is not a core module but is very entangled to MathCore and; 1228 // causes issues.; 1229 std::vector<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be ab",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:44897,Performance,load,loadGlobalIndex,44897,"14 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clingInterp);; 1225 ; 1226 // These modules should not be preloaded but they fix issues.; 1227 // FIXME: Hist is not a core module but is very entangled to MathCore and; 1228 // causes issues.; 1229 std::vector<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be ab",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:44917,Performance,load,loads,44917,"14 ""ROOT_Foundation_Stage1_NoRTTI"",; 1215 ""Core"",; 1216 ""Rint"",; 1217 ""RIO""};; 1218 ; 1219 LoadModules(CoreModules, clingInterp);; 1220 ; 1221 // Take this branch only from ROOT because we don't need to preload modules in rootcling; 1222 if (!IsFromRootCling()) {; 1223 std::vector<std::string> CommonModules = {""MathCore""};; 1224 LoadModules(CommonModules, clingInterp);; 1225 ; 1226 // These modules should not be preloaded but they fix issues.; 1227 // FIXME: Hist is not a core module but is very entangled to MathCore and; 1228 // causes issues.; 1229 std::vector<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be ab",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:45441,Performance,load,load,45441,"r<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:45873,Performance,load,loadModule,45873,"eIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:45923,Performance,load,loaded,45923,"eIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:46081,Performance,load,loaded,46081," 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:46180,Performance,load,loaded,46180,">getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does n",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:46523,Performance,load,load,46523,"ntinue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes += gClassDefInterpMacro + ""\n""; 1314 + gInterpreterClassDef + ""\n""; 1315 ""#undef ClassImp\n""; 1316 ""#define ClassImp(X);\n"";; 1317 }; 1318 if (!hasCxxModules); 1319 PreIncludes += ""#include <s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:46586,Performance,load,loading,46586,"ntinue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes += gClassDefInterpMacro + ""\n""; 1314 + gInterpreterClassDef + ""\n""; 1315 ""#undef ClassImp\n""; 1316 ""#define ClassImp(X);\n"";; 1317 }; 1318 if (!hasCxxModules); 1319 PreIncludes += ""#include <s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:50729,Performance,optimiz,optimization,50729,"; 1372 clingArgsStorage.push_back(""-I"" + interpInclude + ""/cling/plugins/include"");; 1373 ; 1374 // Add the root include directory and etc/ to list searched by default.; 1375 clingArgsStorage.push_back(std::string((""-I"" + TROOT::GetIncludeDir()).Data()));; 1376 ; 1377 // Add the current path to the include path; 1378 // TCling::AddIncludePath(""."");; 1379 ; 1380 // Attach the PCH (unless we have C++ modules enabled which provide the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#ifndef _MSC_VER; 1398 clingArgsStorage.push_back(""-O1"");; 1399 // Disable optimized register allocation which is turned on automatically; 1400 // by -O1, but seems to require -O2 to not explode in run time.; 1401 clingArgsStorage.push_back(""-mllvm"");; 1402 clingArgsStorage.push_back(""-optimize-regalloc=0"");; 1403#endif; 1404 }; 1405 ; 1406 // Process externally passed arguments if present.; 1407 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(""EXTRA_CLING_ARGS"");; 1408 if (EnvOpt.has_value()) {; 1409 StringRef Env(*EnvOpt);; 1410 while (!Env.empty()) {; 1411 StringRef Arg;; 1412 std::tie(Arg, Env) = Env.split(' ');; 1413 clingArgsStorage.push_back(Arg.str());; 1414 }; 1415 }; 1416 ; 1417 auto GetEnvVarPath = [](const std::string &EnvVar, std::vector<std::string> &Paths) {; 1418 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);; 1419 if (EnvOpt.has_value())",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:50988,Performance,optimiz,optimized,50988,""" + TROOT::GetIncludeDir()).Data()));; 1376 ; 1377 // Add the current path to the include path; 1378 // TCling::AddIncludePath(""."");; 1379 ; 1380 // Attach the PCH (unless we have C++ modules enabled which provide the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#ifndef _MSC_VER; 1398 clingArgsStorage.push_back(""-O1"");; 1399 // Disable optimized register allocation which is turned on automatically; 1400 // by -O1, but seems to require -O2 to not explode in run time.; 1401 clingArgsStorage.push_back(""-mllvm"");; 1402 clingArgsStorage.push_back(""-optimize-regalloc=0"");; 1403#endif; 1404 }; 1405 ; 1406 // Process externally passed arguments if present.; 1407 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(""EXTRA_CLING_ARGS"");; 1408 if (EnvOpt.has_value()) {; 1409 StringRef Env(*EnvOpt);; 1410 while (!Env.empty()) {; 1411 StringRef Arg;; 1412 std::tie(Arg, Env) = Env.split(' ');; 1413 clingArgsStorage.push_back(Arg.str());; 1414 }; 1415 }; 1416 ; 1417 auto GetEnvVarPath = [](const std::string &EnvVar, std::vector<std::string> &Paths) {; 1418 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);; 1419 if (EnvOpt.has_value()) {; 1420 StringRef Env(*EnvOpt);; 1421 while (!Env.empty()) {; 1422 StringRef Arg;; 1423 std::tie(Arg, Env) = Env.split(ROOT::FoundationUtils::GetEnvPathSeparator());; 1424 if (std::find(Paths.begin(), Paths.end(), Arg",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:51200,Performance,optimiz,optimize-regalloc,51200,"de the; 1381 // same functionality).; 1382 if (!fCxxModulesEnabled) {; 1383 std::string pchFilename = interpInclude + ""/allDict.cxx.pch"";; 1384 if (gSystem->Getenv(""ROOT_PCH"")) {; 1385 pchFilename = gSystem->Getenv(""ROOT_PCH"");; 1386 }; 1387 ; 1388 clingArgsStorage.push_back(""-include-pch"");; 1389 clingArgsStorage.push_back(pchFilename);; 1390 }; 1391 ; 1392 clingArgsStorage.push_back(""-Wno-undefined-inline"");; 1393 clingArgsStorage.push_back(""-fsigned-char"");; 1394 // The -O1 optimization flag has nasty side effects on Windows (32 and 64 bit); 1395 // See the GitHub issues #9809 and #9944; 1396 // TODO: to be reviewed after the upgrade of LLVM & Clang; 1397#ifndef _MSC_VER; 1398 clingArgsStorage.push_back(""-O1"");; 1399 // Disable optimized register allocation which is turned on automatically; 1400 // by -O1, but seems to require -O2 to not explode in run time.; 1401 clingArgsStorage.push_back(""-mllvm"");; 1402 clingArgsStorage.push_back(""-optimize-regalloc=0"");; 1403#endif; 1404 }; 1405 ; 1406 // Process externally passed arguments if present.; 1407 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(""EXTRA_CLING_ARGS"");; 1408 if (EnvOpt.has_value()) {; 1409 StringRef Env(*EnvOpt);; 1410 while (!Env.empty()) {; 1411 StringRef Arg;; 1412 std::tie(Arg, Env) = Env.split(' ');; 1413 clingArgsStorage.push_back(Arg.str());; 1414 }; 1415 }; 1416 ; 1417 auto GetEnvVarPath = [](const std::string &EnvVar, std::vector<std::string> &Paths) {; 1418 std::optional<std::string> EnvOpt = llvm::sys::Process::GetEnv(EnvVar);; 1419 if (EnvOpt.has_value()) {; 1420 StringRef Env(*EnvOpt);; 1421 while (!Env.empty()) {; 1422 StringRef Arg;; 1423 std::tie(Arg, Env) = Env.split(ROOT::FoundationUtils::GetEnvPathSeparator());; 1424 if (std::find(Paths.begin(), Paths.end(), Arg.str()) == Paths.end()); 1425 Paths.push_back(Arg.str());; 1426 }; 1427 }; 1428 };; 1429 ; 1430 if (fCxxModulesEnabled) {; 1431 std::vector<std::string> Paths;; 1432 // ROOT usually knows better where its libra",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:54334,Performance,cache,cache-path,54334,"GetPathSeparator() + ""ROOT.modulemap"";; 1456 ModuleMaps.push_back(TROOT::GetIncludeDir().Data() + ModuleMapSuffix);; 1457 GetEnvVarPath(""CLING_MODULEMAP_FILES"", ModuleMaps);; 1458 ; 1459 std::string cwd = gSystem->WorkingDirectory();; 1460 // Give highest precedence of the modulemap in the cwd if any.; 1461 if (llvm::sys::fs::exists(cwd + ModuleMapSuffix)); 1462 ModuleMaps.push_back(cwd + ModuleMapSuffix);; 1463 ; 1464 for (const std::string& M : ModuleMaps); 1465 clingArgsStorage.push_back(""-fmodule-map-file="" + M);; 1466 ; 1467 std::string ModulesCachePath;; 1468 EnvOpt = llvm::sys::Process::GetEnv(""CLING_MODULES_CACHE_PATH"");; 1469 if (EnvOpt.has_value()){; 1470 StringRef Env(*EnvOpt);; 1471 assert(llvm::sys::fs::exists(Env) && ""Path does not exist!"");; 1472 ModulesCachePath = Env.str();; 1473 } else {; 1474 ModulesCachePath = TROOT::GetSharedLibDir();; 1475 }; 1476 ; 1477 clingArgsStorage.push_back(""-fmodules-cache-path="" + ModulesCachePath);; 1478 }; 1479 ; 1480 std::vector<const char*> interpArgs;; 1481 for (std::vector<std::string>::const_iterator iArg = clingArgsStorage.begin(),; 1482 eArg = clingArgsStorage.end(); iArg != eArg; ++iArg); 1483 interpArgs.push_back(iArg->c_str());; 1484 ; 1485 // Activate C++ modules support. If we are running within rootcling, it's up; 1486 // to rootcling to set this flag depending on whether it wants to produce; 1487 // C++ modules.; 1488 TString vfsArg;; 1489 if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:55493,Performance,load,load,55493,"t_iterator iArg = clingArgsStorage.begin(),; 1482 eArg = clingArgsStorage.end(); iArg != eArg; ++iArg); 1483 interpArgs.push_back(iArg->c_str());; 1484 ; 1485 // Activate C++ modules support. If we are running within rootcling, it's up; 1486 // to rootcling to set this flag depending on whether it wants to produce; 1487 // C++ modules.; 1488 TString vfsArg;; 1489 if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.so"" export * } where ROOT's; 1501 // facilities use the link directive to dynamically load the relevant; 1502 // library. So, we need to suppress clang's default autolink behavior.; 1503 interpArgs.push_back(""-fno-autolink"");; 1504 }; 1505 ; 1506#ifdef R__FAST_MATH; 1507 // Same setting as in rootcling_impl.cxx.; 1508 interpArgs.push_back(""-ffast-math"");; 1509#endif; 1510 ; 1511 TString llvmResourceDir = TROOT::GetEtcDir() + ""/cling"";; 1512 // Add statically injected extra arguments, usually coming from rootcling.; 1513 for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();; 1514 extraArgs && *extraArgs; ++extraArgs) {; 1515 if (!strcmp(*extraArgs, ""-resource-dir"")) {; 1516 // Take the next arg as the llvm resource directory.; 1517 llvmResourceDir = *(++extraArgs);; 1518 } else {; 1519 interpArgs.push_back(*extraArgs);; 1520 }; 1521 }; 1522 ; 1523 std::vector<std::string> _empty;; 1524 auto args = TROOT::AddExtraInterpreterArgs(_empty);; 1525 for (const auto &arg: args); 1526 interpArgs.emplace_back(arg.c_str());; 1527 ; 1528 // Add the",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:58147,Performance,load,loaded,58147,"CHOrModuleValidation =; 1541 DisableValidationForModuleKind::All;; 1542 ; 1543 // Until we can disable AutoLoading during Sema::CorrectTypo() we have; 1544 // to disable spell checking.; 1545 fInterpreter->getCI()->getLangOpts().SpellChecking = false;; 1546 ; 1547 // Sync modules on/off between clang and us: clang turns it on for C++ >= 20.; 1548 auto isModulesArg = [](const char* arg) { return !strcmp(arg, ""-fmodules""); };; 1549 bool hasModulesArg = std::find_if(interpArgs.begin(), interpArgs.end(), isModulesArg) != interpArgs.end();; 1550 fInterpreter->getCI()->getLangOpts().Modules = hasModulesArg;; 1551 ; 1552 // We need stream that doesn't close its file descriptor, thus we are not; 1553 // using llvm::outs. Keeping file descriptor open we will be able to use; 1554 // the results in pipes (Savannah #99234).; 1555 static llvm::raw_fd_ostream fMPOuts (STDOUT_FILENO, /*ShouldClose*/false);; 1556 fMetaProcessor = std::make_unique<cling::MetaProcessor>(*fInterpreter, fMPOuts);; 1557 ; 1558 RegisterCxxModules(*fInterpreter);; 1559 RegisterPreIncludedHeaders(*fInterpreter);; 1560 ; 1561 // We are now ready (enough is loaded) to init the list of opaque typedefs.; 1562 fNormalizedCtxt = new ROOT::TMetaUtils::TNormalizedCtxt(fInterpreter->getLookupHelper());; 1563 fLookupHelper = new ROOT::TMetaUtils::TClingLookupHelper(*fInterpreter, *fNormalizedCtxt,; 1564 TClingLookupHelper__ExistingTypeCheck,; 1565 TClingLookupHelper__AutoParse,; 1566 &fIsShuttingDown);; 1567 TClassEdit::Init(fLookupHelper);; 1568 ; 1569 // Disallow auto-parsing in rootcling; 1570 fIsAutoParsingSuspended = fromRootCling;; 1571 ; 1572 ResetAll();; 1573 ; 1574 // Enable dynamic lookup; 1575 if (!fromRootCling) {; 1576 fInterpreter->enableDynamicLookup();; 1577 }; 1578 ; 1579 // Enable ClinG's DefinitionShadower for ROOT.; 1580 fInterpreter->getRuntimeOptions().AllowRedefinition = 1;; 1581 auto &Policy = const_cast<clang::PrintingPolicy &>(fInterpreter->getCI()->getASTContext().getPrintingPolicy());; 15",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:61542,Performance,load,loading,61542,"611 }; 1612}; 1613 ; 1614 ; 1615////////////////////////////////////////////////////////////////////////////////; 1616/// Destroy the interpreter interface.; 1617 ; 1618TCling::~TCling(); 1619{; 1620 // ROOT's atexit functions require the interepreter to be available.; 1621 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 stati",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:61580,Performance,load,load,61580,"611 }; 1612}; 1613 ; 1614 ; 1615////////////////////////////////////////////////////////////////////////////////; 1616/// Destroy the interpreter interface.; 1617 ; 1618TCling::~TCling(); 1619{; 1620 // ROOT's atexit functions require the interepreter to be available.; 1621 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 stati",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:62794,Performance,load,loading,62794,"les ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; returns true on success.; 1695 ; 1696void TCling::LoadPCMImpl(TFile &pcmFile); 1697{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"")",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:63514,Performance,load,load,63514,"= []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; returns true on success.; 1695 ; 1696void TCling::LoadPCMImpl(TFile &pcmFile); 1697{; 1698 auto listOfKeys = pcmFile.GetListOfKeys();; 1699 ; 1700 // This is an empty pcm; 1701 if (listOfKeys && ((listOfKeys->GetSize() == 0) || // Nothing here, or; 1702 ((listOfKeys->GetSize() == 1) && // only one, and; 1703 !strcmp(((TKey *)listOfKeys->At(0))->GetName(), ""EMPTY"") // name is EMPTY; 1704 ))) {; 1705 return;; 1706 }; 1707 ; 1708 TObjArray *protoClasses;; 1709 if (gDebug > 1); 1710 ::Info(""TCling::LoadPCMImpl"", ""reading protoclasses for %s \n"", pcmFile.GetName());; 1711 ; 1712 TObjArray *enums;; 1713 pcmFile.GetObject(""__Enums"", enums);; 1714 if (enums) {; 1715 // Cache the pointers; 1716 auto listOfGlobals = gROOT->GetListOfGlobals();; 1717 auto listOfEnums = dynamic_cast<THashList *>(gROOT->GetListOfEnums());; 1718 // Loop on enums and then on enum constants; 1719 for (auto selEnum : *enums) {; 1720 c",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:65397,Performance,load,load,65397,");; 1721 const char *enumName = selEnum->GetName();; 1722 if (strcmp(enumScope, """") == 0) {; 1723 // This is a global enum and is added to the; 1724 // list of enums and its constants to the list of globals; 1725 if (!listOfEnums->THashList::FindObject(enumName)) {; 1726 ((TEnum *)selEnum)->SetClass(nullptr);; 1727 listOfEnums->Add(selEnum);; 1728 }; 1729 for (auto enumConstant : *static_cast<TEnum *>(selEnum)->GetConstants()) {; 1730 if (!listOfGlobals->FindObject(enumConstant)) {; 1731 listOfGlobals->Add(enumConstant);; 1732 }; 1733 }; 1734 } else {; 1735 // This enum is in a namespace. A TClass entry is bootstrapped if; 1736 // none exists yet and the enum is added to it; 1737 TClass *nsTClassEntry = TClass::GetClass(enumScope);; 1738 if (!nsTClassEntry) {; 1739 nsTClassEntry = new TClass(enumScope, 0, TClass::kNamespaceForMeta, true);; 1740 }; 1741 auto listOfEnums = nsTClassEntry->fEnums.load();; 1742 if (!listOfEnums) {; 1743 if ((kIsClass | kIsStruct | kIsUnion) & nsTClassEntry->Property()) {; 1744 // For this case, the list will be immutable once constructed; 1745 // (i.e. in this case, by the end of this routine).; 1746 listOfEnums = nsTClassEntry->fEnums = new TListOfEnums(nsTClassEntry);; 1747 } else {; 1748 // namespaces can have enums added to them; 1749 listOfEnums = nsTClassEntry->fEnums = new TListOfEnumsWithLock(nsTClassEntry);; 1750 }; 1751 }; 1752 if (listOfEnums && !listOfEnums->THashList::FindObject(enumName)) {; 1753 ((TEnum *)selEnum)->SetClass(nsTClassEntry);; 1754 listOfEnums->Add(selEnum);; 1755 }; 1756 }; 1757 }; 1758 enums->Clear();; 1759 delete enums;; 1760 }; 1761 ; 1762 pcmFile.GetObject(""__ProtoClasses"", protoClasses);; 1763 ; 1764 if (protoClasses) {; 1765 for (auto obj : *protoClasses) {; 1766 TProtoClass *proto = (TProtoClass *)obj;; 1767 TClassTable::Add(proto);; 1768 }; 1769 // Now that all TClass-es know how to set them up we can update; 1770 // existing TClasses, which might cause the creation of e.g. TBaseClass; 1771 // objects",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:67998,Performance,load,load,67998,"ject. It might be emulated; 1778 // or interpreted; we now have more information available.; 1779 // Make that available.; 1780 if (existingCl->GetState() != TClass::kHasTClassInit) {; 1781 DictFuncPtr_t dict = gClassTable->GetDict(proto->GetName());; 1782 if (!dict) {; 1783 ::Error(""TCling::LoadPCM"", ""Inconsistent TClassTable for %s"", proto->GetName());; 1784 } else {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_f",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:68492,Performance,load,load,68492," }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interprete",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:69946,Performance,load,load,69946,"mlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 1842 std::string RDictFileOpts = pcmFileNameFullPath + ""?filetype=pcm"";; 1843 TMemFile pcmMemFile(RDictFileOpts.c_str(), range);; 1844 ; 1845 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 1846 LoadPCMImpl(pcmMemFile);; 1847 // Currently the module file are never unloaded (even if the library is; 1848 // unloaded) and, of course, never reloaded.; 1849 // Consequently, we must NOT remove the `pendingRdict` from the list; 1850 // of pending dictionary, otherwise if a library is unloaded and then; 1851 // reload we will be unable to update properly the TClass object; 1852 // (because we wont be able to load the rootpcm file by executing the; 1853 // above lines); 1854 ; 1855 return;; 1856 }; 1857 ; 1858 if (!llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1859 ::Error(""TCling::LoadPCM"", ""ROOT PCM %s file does not exist"",; 1860 pcmFileNameFullPath.data());; 1861 if (!fPendingRdicts.empty()); 1862 for (const auto &rdict : fPendingRdicts); 1863 ::Info(""TCling::LoadPCM"", ""In-memory ROOT PCM candidate %s\n"",; 1864 rdict.first.c_str());; 1865 return;; 1866 }; 1867 ; 1868 if (!gROOT->IsRootFile(pcmFileName)) {; 1869 Fatal(""LoadPCM"", ""The file %s is not a ROOT as was expected\n"", pcmFileName.Data());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be consid",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:71697,Performance,load,loaded,71697,"ata());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be considered an helper for autoparsing.; 1883 // It visits the AST and marks all classes (in all of their redeclarations); 1884 // with the setHasExternalLexicalStorage method.; 1885 public:; 1886 bool VisitRecordDecl(clang::RecordDecl* rcd){; 1887 if (gDebug > 2); 1888 Info(""ExtLexicalStorageAdder"",; 1889 ""Adding external lexical storage to class %s"",; 1890 rcd->getNameAsString().c_str());; 1891 auto reDeclPtr = rcd->getMostRecentDecl();; 1892 do {; 1893 reDeclPtr->setHasExternalLexicalStorage();; 1894 } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));; 1895 ; 1896 return false;; 1897 }; 1898 };; 1899 ; 1900 ; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904///\returns true if the module map was loaded, false on error or if the map was; 1905/// already loaded.; 1906bool TCling::RegisterPrebuiltModulePath(const std::string &FullPath,; 1907 const std::string &ModuleMapName /*= ""module.modulemap""*/) const; 1908{; 1909 assert(llvm::sys::path::is_absolute(FullPath));; 1910 Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();; 1911 FileManager &FM = PP.getFileManager();; 1912 // FIXME: In a ROOT session we can add an include path (through .I /inc/path); 1913 // We should look for modulemap files there too.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:71755,Performance,load,loaded,71755,"ata());; 1870 return;; 1871 }; 1872 TFile pcmFile(pcmFileName + ""?filetype=pcm"", ""READ"");; 1873 LoadPCMImpl(pcmFile);; 1874}; 1875 ; 1876//______________________________________________________________________________; 1877 ; 1878namespace {; 1879 using namespace clang;; 1880 ; 1881 class ExtLexicalStorageAdder: public RecursiveASTVisitor<ExtLexicalStorageAdder>{; 1882 // This class is to be considered an helper for autoparsing.; 1883 // It visits the AST and marks all classes (in all of their redeclarations); 1884 // with the setHasExternalLexicalStorage method.; 1885 public:; 1886 bool VisitRecordDecl(clang::RecordDecl* rcd){; 1887 if (gDebug > 2); 1888 Info(""ExtLexicalStorageAdder"",; 1889 ""Adding external lexical storage to class %s"",; 1890 rcd->getNameAsString().c_str());; 1891 auto reDeclPtr = rcd->getMostRecentDecl();; 1892 do {; 1893 reDeclPtr->setHasExternalLexicalStorage();; 1894 } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));; 1895 ; 1896 return false;; 1897 }; 1898 };; 1899 ; 1900 ; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904///\returns true if the module map was loaded, false on error or if the map was; 1905/// already loaded.; 1906bool TCling::RegisterPrebuiltModulePath(const std::string &FullPath,; 1907 const std::string &ModuleMapName /*= ""module.modulemap""*/) const; 1908{; 1909 assert(llvm::sys::path::is_absolute(FullPath));; 1910 Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();; 1911 FileManager &FM = PP.getFileManager();; 1912 // FIXME: In a ROOT session we can add an include path (through .I /inc/path); 1913 // We should look for modulemap files there too.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:73139,Performance,load,loadModuleMapFile,73139,"o.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths.end();; 1919 if (!pathExists); 1920 HSOpts.AddPrebuiltModulePath(FullPath);; 1921 // We cannot use HS.lookupModuleMapFile(DE, /*IsFramework*/ false);; 1922 // because its internal call to getFile has CacheFailure set to true.; 1923 // In our case, modulemaps can appear any time due to ACLiC.; 1924 // Code copied from HS.lookupModuleMapFile.; 1925 llvm::SmallString<256> ModuleMapFileName(DE->getName());; 1926 llvm::sys::path::append(ModuleMapFileName, ModuleMapName);; 1927 if (auto FE = FM.getOptionalFileRef(ModuleMapFileName, /*openFile*/ false,; 1928 /*CacheFailure*/ false)) {; 1929 if (!HS.loadModuleMapFile(*FE, /*IsSystem*/ false)); 1930 return true;; 1931 Error(""RegisterPrebuiltModulePath"", ""Could not load modulemap in %s"", ModuleMapFileName.c_str());; 1932 }; 1933 }; 1934 return false;; 1935}; 1936 ; 1937////////////////////////////////////////////////////////////////////////////////; 1938/// List of dicts that have the PCM information already in the PCH.; 1939static const std::unordered_set<std::string> gIgnoredPCMNames = {""libCore"",; 1940 ""libRint"",; 1941 ""libThread"",; 1942 ""libRIO"",; 1943 ""libImt"",; 1944 ""libMultiProc"",; 1945 ""libcomplexDict"",; 1946 ""libdequeDict"",; 1947 ""liblistDict"",; 1948 ""libforward_listDict"",; 1949 ""libvectorDict"",; 1950 ""libmapDict"",; 1951 ""libmultimap2Dict"",; 1952 ""libmap2Dict"",; 1953 ""libmultimapDict"",; 1954 ""libsetDict"",; 1955 ""libmultisetDict"",; 1956 ""libunordered_setDict"",; 1957 ""libunordered_multisetDict"",; 1958 ""libunordered_mapDict"",; 1959 ""libunordered_multimapDict"",; 1960 ""libvalarrayDict"",; 1961 ""G__GenVector32"",; 1962 ""G__Smatrix32""};; 1963 ; 1964static void PrintDlError(const char *dyLibName, const char *mo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:73255,Performance,load,load,73255,"o.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths.end();; 1919 if (!pathExists); 1920 HSOpts.AddPrebuiltModulePath(FullPath);; 1921 // We cannot use HS.lookupModuleMapFile(DE, /*IsFramework*/ false);; 1922 // because its internal call to getFile has CacheFailure set to true.; 1923 // In our case, modulemaps can appear any time due to ACLiC.; 1924 // Code copied from HS.lookupModuleMapFile.; 1925 llvm::SmallString<256> ModuleMapFileName(DE->getName());; 1926 llvm::sys::path::append(ModuleMapFileName, ModuleMapName);; 1927 if (auto FE = FM.getOptionalFileRef(ModuleMapFileName, /*openFile*/ false,; 1928 /*CacheFailure*/ false)) {; 1929 if (!HS.loadModuleMapFile(*FE, /*IsSystem*/ false)); 1930 return true;; 1931 Error(""RegisterPrebuiltModulePath"", ""Could not load modulemap in %s"", ModuleMapFileName.c_str());; 1932 }; 1933 }; 1934 return false;; 1935}; 1936 ; 1937////////////////////////////////////////////////////////////////////////////////; 1938/// List of dicts that have the PCM information already in the PCH.; 1939static const std::unordered_set<std::string> gIgnoredPCMNames = {""libCore"",; 1940 ""libRint"",; 1941 ""libThread"",; 1942 ""libRIO"",; 1943 ""libImt"",; 1944 ""libMultiProc"",; 1945 ""libcomplexDict"",; 1946 ""libdequeDict"",; 1947 ""liblistDict"",; 1948 ""libforward_listDict"",; 1949 ""libvectorDict"",; 1950 ""libmapDict"",; 1951 ""libmultimap2Dict"",; 1952 ""libmap2Dict"",; 1953 ""libmultimapDict"",; 1954 ""libsetDict"",; 1955 ""libmultisetDict"",; 1956 ""libunordered_setDict"",; 1957 ""libunordered_multisetDict"",; 1958 ""libunordered_mapDict"",; 1959 ""libunordered_multimapDict"",; 1960 ""libvalarrayDict"",; 1961 ""G__GenVector32"",; 1962 ""G__Smatrix32""};; 1963 ; 1964static void PrintDlError(const char *dyLibName, const char *mo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:75029,Performance,load,loaded,75029,",; 1959 ""libunordered_multimapDict"",; 1960 ""libvalarrayDict"",; 1961 ""G__GenVector32"",; 1962 ""G__Smatrix32""};; 1963 ; 1964static void PrintDlError(const char *dyLibName, const char *modulename); 1965{; 1966#ifdef R__WIN32; 1967 char dyLibError[1000];; 1968 FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),; 1969 dyLibError, sizeof(dyLibError), NULL);; 1970#else; 1971 const char *dyLibError = dlerror();; 1972#endif; 1973 ::Error(""TCling::RegisterModule"", ""Cannot open shared library %s for dictionary %s:\n %s"", dyLibName, modulename,; 1974 (dyLibError) ? dyLibError : """");; 1975}; 1976 ; 1977////////////////////////////////////////////////////////////////////////////////; 1978// Update all the TClass registered in fClassesToUpdate; 1979 ; 1980void TCling::ProcessClassesToUpdate(); 1981{; 1982 while (!fClassesToUpdate.empty()) {; 1983 TClass *oldcl = fClassesToUpdate.back().first;; 1984 // If somehow the TClass has already been loaded (maybe it was registered several time),; 1985 // we skip it. Otherwise, the existing TClass is in mode kInterpreted, kEmulated or; 1986 // maybe even kForwardDeclared and needs to replaced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:75874,Performance,load,load,75874,"lass registered in fClassesToUpdate; 1979 ; 1980void TCling::ProcessClassesToUpdate(); 1981{; 1982 while (!fClassesToUpdate.empty()) {; 1983 TClass *oldcl = fClassesToUpdate.back().first;; 1984 // If somehow the TClass has already been loaded (maybe it was registered several time),; 1985 // we skip it. Otherwise, the existing TClass is in mode kInterpreted, kEmulated or; 1986 // maybe even kForwardDeclared and needs to replaced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:75978,Performance,load,loading,75978,"dcl = fClassesToUpdate.back().first;; 1984 // If somehow the TClass has already been loaded (maybe it was registered several time),; 1985 // we skip it. Otherwise, the existing TClass is in mode kInterpreted, kEmulated or; 1986 // maybe even kForwardDeclared and needs to replaced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022 // We need the dictionary initialization but we don't want to inject the; 2023 // declarations into the interpreter, except for those we really need f",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:77890,Performance,load,loaded,77890,"n't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2029 llvm::SaveAndRestore<bool> SaveHeaderParsing(fHeaderParsingOnDemand);; 2030 fHeaderParsingOnDemand = !hasCxxModule;; 2031 ; 2032 // Treat Aclic Libs in a special way. Do not delay the parsing.; 2033 bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;; 2034 bool isACLiC = strstr(modulename, ""_ACLiC_dict"") != nullptr;; 2035 if (hasHeaderParsingOnDemand && isACLiC) {; 2036 if (gDebug>1); 2037 Info(""TCling::RegisterModule"",; 2038 ""Header parsing on demand is active but this is an Aclic library. Disabling it for this library."");; 2039 hasHeaderParsingOnDemand = false;; 2040 }; 2041 ; 2042 ; 2043 // Make sure we relookup symbols that were search for before we loaded; 2044 // their autoparse information. We could be more subtil and remove only; 2045 // the failed one or only the one in this module, but for now this is; 2046 // better than nothing.; 2047 fLookedUpClasses.clear();; 2048 ; 2049 // Make sure we do not set off AutoLoading or autoparsing during the; 2050 // module registration!; 2051 SuspendAutoLoadingRAII autoLoadOff(this);; 2052 ; 2053 for (const char** inclPath = includePaths; *inclPath; ++inclPath) {; 2054 TCling::AddIncludePath(*inclPath);; 2055 }; 2056 cling::Transaction* T = nullptr;; 2057 // Put the template decls and the number of arguments to skip in the TNormalizedCtxt; 2058 for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){; 2059 const std::string& fwdDecl = fwdDeclArgToSkipPair.first;; 2060 const int nArgsToSkip = fwdDeclArgToSkipPair.second;; 2061 auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:87436,Performance,load,loading,87436,"d from the payloadCode; 2241 if (payloadCode == *classesHeader_inner ){; 2242 fPayloads.insert(theHash);; 2243 if (addTemplate) fPayloads.insert(theTemplateHash);; 2244 }; 2245 if (gDebug > 2); 2246 Info(""TCling::RegisterModule"",; 2247 ""Adding a header for %s"", temp.c_str());; 2248 fClassesHeadersMap[theHash].push_back(*classesHeader_inner);; 2249 if (addTemplate) {; 2250 if (fClassesHeadersMap.find(theTemplateHash) == fClassesHeadersMap.end()) {; 2251 fClassesHeadersMap[theTemplateHash].push_back(*classesHeader_inner);; 2252 }; 2253 addTemplate = false;; 2254 }; 2255 }; 2256 }; 2257 }; 2258 ; 2259 clang::Sema &TheSema = fInterpreter->getSema();; 2260 ; 2261 bool ModuleWasSuccessfullyLoaded = false;; 2262 if (hasCxxModule) {; 2263 std::string ModuleName = modulename;; 2264 if (llvm::StringRef(modulename).startswith(""lib"")); 2265 ModuleName = llvm::StringRef(modulename).substr(3).str();; 2266 ; 2267 // In case we are directly loading the library via gSystem->Load() without; 2268 // specifying the relevant include paths we should try loading the; 2269 // modulemap next to the library location.; 2270 clang::Preprocessor &PP = TheSema.getPreprocessor();; 2271 std::string ModuleMapName;; 2272 if (isACLiC); 2273 ModuleMapName = ModuleName + "".modulemap"";; 2274 else; 2275 ModuleMapName = ""module.modulemap"";; 2276 RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName).str(),; 2277 ModuleMapName);; 2278 ; 2279 // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about; 2280 // modules such as GenVector32 because it needs to fall back to GenVector.; 2281 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 2282 ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);; 2283 if (!ModuleWasSuccessfullyLoaded) {; 2284 // Only report if we found the module in the modulemap.; 2285 clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();; 2286 clang::ModuleMap &moduleMap = headerSe",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:87545,Performance,load,loading,87545,"d from the payloadCode; 2241 if (payloadCode == *classesHeader_inner ){; 2242 fPayloads.insert(theHash);; 2243 if (addTemplate) fPayloads.insert(theTemplateHash);; 2244 }; 2245 if (gDebug > 2); 2246 Info(""TCling::RegisterModule"",; 2247 ""Adding a header for %s"", temp.c_str());; 2248 fClassesHeadersMap[theHash].push_back(*classesHeader_inner);; 2249 if (addTemplate) {; 2250 if (fClassesHeadersMap.find(theTemplateHash) == fClassesHeadersMap.end()) {; 2251 fClassesHeadersMap[theTemplateHash].push_back(*classesHeader_inner);; 2252 }; 2253 addTemplate = false;; 2254 }; 2255 }; 2256 }; 2257 }; 2258 ; 2259 clang::Sema &TheSema = fInterpreter->getSema();; 2260 ; 2261 bool ModuleWasSuccessfullyLoaded = false;; 2262 if (hasCxxModule) {; 2263 std::string ModuleName = modulename;; 2264 if (llvm::StringRef(modulename).startswith(""lib"")); 2265 ModuleName = llvm::StringRef(modulename).substr(3).str();; 2266 ; 2267 // In case we are directly loading the library via gSystem->Load() without; 2268 // specifying the relevant include paths we should try loading the; 2269 // modulemap next to the library location.; 2270 clang::Preprocessor &PP = TheSema.getPreprocessor();; 2271 std::string ModuleMapName;; 2272 if (isACLiC); 2273 ModuleMapName = ModuleName + "".modulemap"";; 2274 else; 2275 ModuleMapName = ""module.modulemap"";; 2276 RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName).str(),; 2277 ModuleMapName);; 2278 ; 2279 // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about; 2280 // modules such as GenVector32 because it needs to fall back to GenVector.; 2281 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 2282 ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);; 2283 if (!ModuleWasSuccessfullyLoaded) {; 2284 // Only report if we found the module in the modulemap.; 2285 clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();; 2286 clang::ModuleMap &moduleMap = headerSe",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:88633,Performance,load,load,88633,"library location.; 2270 clang::Preprocessor &PP = TheSema.getPreprocessor();; 2271 std::string ModuleMapName;; 2272 if (isACLiC); 2273 ModuleMapName = ModuleName + "".modulemap"";; 2274 else; 2275 ModuleMapName = ""module.modulemap"";; 2276 RegisterPrebuiltModulePath(llvm::sys::path::parent_path(dyLibName).str(),; 2277 ModuleMapName);; 2278 ; 2279 // FIXME: We should only complain for modules which we know to exist. For example, we should not complain about; 2280 // modules such as GenVector32 because it needs to fall back to GenVector.; 2281 cling::Interpreter::PushTransactionRAII deserRAII(GetInterpreterImpl());; 2282 ModuleWasSuccessfullyLoaded = LoadModule(ModuleName, *fInterpreter);; 2283 if (!ModuleWasSuccessfullyLoaded) {; 2284 // Only report if we found the module in the modulemap.; 2285 clang::HeaderSearch &headerSearch = PP.getHeaderSearchInfo();; 2286 clang::ModuleMap &moduleMap = headerSearch.getModuleMap();; 2287 if (moduleMap.findModule(ModuleName)); 2288 Info(""TCling::RegisterModule"", ""Module %s in modulemap failed to load."", ModuleName.c_str());; 2289 }; 2290 }; 2291 ; 2292 if (gIgnoredPCMNames.find(modulename) == gIgnoredPCMNames.end()) {; 2293 llvm::SmallString<256> pcmFileNameFullPath(dyLibName);; 2294 // The path dyLibName might not be absolute. This can happen if dyLibName; 2295 // is linked to an executable in the same folder.; 2296 llvm::sys::fs::make_absolute(pcmFileNameFullPath);; 2297 llvm::sys::path::remove_filename(pcmFileNameFullPath);; 2298 llvm::sys::path::append(pcmFileNameFullPath,; 2299 ROOT::TMetaUtils::GetModuleFileName(modulename));; 2300 LoadPCM(pcmFileNameFullPath.str().str());; 2301 }; 2302 ; 2303 { // scope within which diagnostics are de-activated; 2304 // For now we disable diagnostics because we saw them already at; 2305 // dictionary generation time. That won't be an issue with the PCMs.; 2306 ; 2307 clangDiagSuppr diagSuppr(TheSema.getDiagnostics());; 2308 ; 2309#if defined(R__MUST_REVISIT); 2310#if R__MUST_REVISIT(6,2); 231",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:90697,Performance,load,loaded,90697,"ion should be gone by now."");; 2312#endif; 2313#endif; 2314 ; 2315 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){; 2316 SuspendAutoParsing autoParseRaii(this);; 2317 ; 2318 const cling::Transaction* watermark = fInterpreter->getLastTransaction();; 2319 cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());; 2320 if (isACLiC) {; 2321 // Register an unload point.; 2322 fMetaProcessor->registerUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; 2347 ""#endif"");; 2348 }; 2349 ; 2350 if (wasDlopened) {; 2351 assert(isSharedLib);; 2352 void* dyLibHandle = fRegisterModuleDyLibs.back();; 2353 fRegisterModuleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 236",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:90784,Performance,load,loading,90784,"ion should be gone by now."");; 2312#endif; 2313#endif; 2314 ; 2315 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){; 2316 SuspendAutoParsing autoParseRaii(this);; 2317 ; 2318 const cling::Transaction* watermark = fInterpreter->getLastTransaction();; 2319 cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());; 2320 if (isACLiC) {; 2321 // Register an unload point.; 2322 fMetaProcessor->registerUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; 2347 ""#endif"");; 2348 }; 2349 ; 2350 if (wasDlopened) {; 2351 assert(isSharedLib);; 2352 void* dyLibHandle = fRegisterModuleDyLibs.back();; 2353 fRegisterModuleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 236",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:90833,Performance,load,loading,90833,"ion should be gone by now."");; 2312#endif; 2313#endif; 2314 ; 2315 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){; 2316 SuspendAutoParsing autoParseRaii(this);; 2317 ; 2318 const cling::Transaction* watermark = fInterpreter->getLastTransaction();; 2319 cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());; 2320 if (isACLiC) {; 2321 // Register an unload point.; 2322 fMetaProcessor->registerUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; 2347 ""#endif"");; 2348 }; 2349 ; 2350 if (wasDlopened) {; 2351 assert(isSharedLib);; 2352 void* dyLibHandle = fRegisterModuleDyLibs.back();; 2353 fRegisterModuleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 236",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:90873,Performance,load,loaded,90873,"ion should be gone by now."");; 2312#endif; 2313#endif; 2314 ; 2315 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){; 2316 SuspendAutoParsing autoParseRaii(this);; 2317 ; 2318 const cling::Transaction* watermark = fInterpreter->getLastTransaction();; 2319 cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());; 2320 if (isACLiC) {; 2321 // Register an unload point.; 2322 fMetaProcessor->registerUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; 2347 ""#endif"");; 2348 }; 2349 ; 2350 if (wasDlopened) {; 2351 assert(isSharedLib);; 2352 void* dyLibHandle = fRegisterModuleDyLibs.back();; 2353 fRegisterModuleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 236",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:92367,Performance,load,loading,92367,"duleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 2363 // FIXME: This is mostly to real with false positives in the TTabCom; 2364 // interface for non-modules.; 2365 if (!fCxxModulesEnabled); 2366 return;; 2367 ; 2368 if (IdentifierInfoLookup *External = C.Idents.getExternalIdentifierLookup()) {; 2369 std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());; 2370 for (llvm::StringRef Ident = Iter->Next(); !Ident.empty(); Ident = Iter->Next()) {; 2371 std::string I = Ident.str();; 2372 if (!Idents.Contains(I.data())); 2373 Idents.Add(new TObjString(I.c_str()));; 2374 }; 2375 }; 2376}; 2377 ; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Register classes that already existed prior to their dictionary loading; 2381/// and that already had a ClassInfo (and thus would not be refresh via; 2382/// UpdateClassInfo.; 2383 ; 2384void TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict); 2385{; 2386 fClassesToUpdate.push_back(std::make_pair(oldcl,dict));; 2387}; 2388 ; 2389////////////////////////////////////////////////////////////////////////////////; 2390/// If the dictionary is loaded, we can remove the class from the list; 2391/// (otherwise the class might be loaded twice).; 2392 ; 2393void TCling::UnRegisterTClassUpdate(const TClass *oldcl); 2394{; 2395 typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;; 2396 iterator stop = fClassesToUpdate.end();; 2397 for(iterator i = fClassesToUpdate.begin();; 2398 i != stop;; 2399 ++i); 2400 {; 2401 if ( i->first == oldcl ) {; 2402 fClassesToUpdate.erase(i);; 2403 return;; 2404 }; 2405 }; 2406}; 2407 ; 2408 ; 2409////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:92757,Performance,load,loaded,92757,"/ interface for non-modules.; 2365 if (!fCxxModulesEnabled); 2366 return;; 2367 ; 2368 if (IdentifierInfoLookup *External = C.Idents.getExternalIdentifierLookup()) {; 2369 std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());; 2370 for (llvm::StringRef Ident = Iter->Next(); !Ident.empty(); Ident = Iter->Next()) {; 2371 std::string I = Ident.str();; 2372 if (!Idents.Contains(I.data())); 2373 Idents.Add(new TObjString(I.c_str()));; 2374 }; 2375 }; 2376}; 2377 ; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Register classes that already existed prior to their dictionary loading; 2381/// and that already had a ClassInfo (and thus would not be refresh via; 2382/// UpdateClassInfo.; 2383 ; 2384void TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict); 2385{; 2386 fClassesToUpdate.push_back(std::make_pair(oldcl,dict));; 2387}; 2388 ; 2389////////////////////////////////////////////////////////////////////////////////; 2390/// If the dictionary is loaded, we can remove the class from the list; 2391/// (otherwise the class might be loaded twice).; 2392 ; 2393void TCling::UnRegisterTClassUpdate(const TClass *oldcl); 2394{; 2395 typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;; 2396 iterator stop = fClassesToUpdate.end();; 2397 for(iterator i = fClassesToUpdate.begin();; 2398 i != stop;; 2399 ++i); 2400 {; 2401 if ( i->first == oldcl ) {; 2402 fClassesToUpdate.erase(i);; 2403 return;; 2404 }; 2405 }; 2406}; 2407 ; 2408 ; 2409////////////////////////////////////////////////////////////////////////////////; 2410/// Let cling process a command line.; 2411///; 2412/// If the command is executed and the error is 0, then the return value; 2413/// is the int value corresponding to the result of the executed command; 2414/// (float and double return values will be truncated).; 2415///; 2416 ; 2417// Method for handling the interpreter exceptions.; 2418// the MetaProcessor is pass",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:92842,Performance,load,loaded,92842,"/ interface for non-modules.; 2365 if (!fCxxModulesEnabled); 2366 return;; 2367 ; 2368 if (IdentifierInfoLookup *External = C.Idents.getExternalIdentifierLookup()) {; 2369 std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());; 2370 for (llvm::StringRef Ident = Iter->Next(); !Ident.empty(); Ident = Iter->Next()) {; 2371 std::string I = Ident.str();; 2372 if (!Idents.Contains(I.data())); 2373 Idents.Add(new TObjString(I.c_str()));; 2374 }; 2375 }; 2376}; 2377 ; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Register classes that already existed prior to their dictionary loading; 2381/// and that already had a ClassInfo (and thus would not be refresh via; 2382/// UpdateClassInfo.; 2383 ; 2384void TCling::RegisterTClassUpdate(TClass *oldcl,DictFuncPtr_t dict); 2385{; 2386 fClassesToUpdate.push_back(std::make_pair(oldcl,dict));; 2387}; 2388 ; 2389////////////////////////////////////////////////////////////////////////////////; 2390/// If the dictionary is loaded, we can remove the class from the list; 2391/// (otherwise the class might be loaded twice).; 2392 ; 2393void TCling::UnRegisterTClassUpdate(const TClass *oldcl); 2394{; 2395 typedef std::vector<std::pair<TClass*,DictFuncPtr_t> >::iterator iterator;; 2396 iterator stop = fClassesToUpdate.end();; 2397 for(iterator i = fClassesToUpdate.begin();; 2398 i != stop;; 2399 ++i); 2400 {; 2401 if ( i->first == oldcl ) {; 2402 fClassesToUpdate.erase(i);; 2403 return;; 2404 }; 2405 }; 2406}; 2407 ; 2408 ; 2409////////////////////////////////////////////////////////////////////////////////; 2410/// Let cling process a command line.; 2411///; 2412/// If the command is executed and the error is 0, then the return value; 2413/// is the int value corresponding to the result of the executed command; 2414/// (float and double return values will be truncated).; 2415///; 2416 ; 2417// Method for handling the interpreter exceptions.; 2418// the MetaProcessor is pass",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:118215,Performance,load,loaded,118215,"ame.c_str(), clname);; 3036 }; 3037 baseOffset = TVirtualStreamerInfo::kNeedObjectForVirtualBaseClass;; 3038 } else {; 3039 // We have an object to determine the vbase offset.; 3040 TClingClassInfo* ci = (TClingClassInfo*)cl->GetClassInfo();; 3041 TClingClassInfo* baseCi = (TClingClassInfo*)baseCl->GetClassInfo();; 3042 if (ci && baseCi) {; 3043 baseOffset = ci->GetBaseOffset(baseCi, const_cast<void*>(obj),; 3044 true /*isDerivedObj*/);; 3045 if (baseOffset == -1) {; 3046 Error(""InspectMembers"",; 3047 ""Error calculating offset of virtual base %s of class %s"",; 3048 sBaseName.c_str(), clname);; 3049 }; 3050 } else {; 3051 Error(""InspectMembers"",; 3052 ""Cannot calculate offset of virtual base %s of class %s"",; 3053 sBaseName.c_str(), clname);; 3054 continue;; 3055 }; 3056 }; 3057 } else {; 3058 baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();; 3059 }; 3060 // TOFIX: baseCl can be null here!; 3061 if (baseCl->IsLoaded()) {; 3062 // For loaded class, CallShowMember will (especially for TObject); 3063 // call the virtual ShowMember rather than the class specific version; 3064 // resulting in an infinite recursion.; 3065 InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);; 3066 } else {; 3067 baseCl->CallShowMembers(cobj + baseOffset,; 3068 insp, isTransient);; 3069 }; 3070 } // loop over bases; 3071}; 3072 ; 3073////////////////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:121522,Performance,load,loading,121522,"nch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling; 3127// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which; 3128// was already taking a lock.; 3129static Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:121825,Performance,load,loaded,121825,"LibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) c",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:121953,Performance,load,load,121953,"(gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See; 3177 // c",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:122158,Performance,load,load,122158,"har* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See; 3177 // cling::DynamicLibraryManager.; 3178 ; 3179 std::string file_name = filename;; 3180 size_t at = std::string::npos;; 3181 while ((at = file_name.find(""/./"")) != std::string::npos); 3182 file_name.replace(at, 3, ""/"");",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:122573,Performance,load,loaded,122573," name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute all this can go away. See; 3177 // cling::DynamicLibraryManager.; 3178 ; 3179 std::string file_name = filename;; 3180 size_t at = std::string::npos;; 3181 while ((at = file_name.find(""/./"")) != std::string::npos); 3182 file_name.replace(at, 3, ""/"");; 3183 ; 3184 std::string filesStr = """";; 3185 llvm::raw_string_ostream filesOS(filesStr);; 3186 clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();; 3187 cling::ClangInternalState::printIncludedFiles(filesOS, SM);; 3188 filesOS.flush();; 3189 ; 3190 llvm::SmallVector<llvm::Str",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:125774,Performance,load,loaded,125774,"incPath.Prepend("".:"");; 3219 sFilename = file_name.c_str();; 3220 if (gSystem->FindFile(incPath, sFilename, kReadPermission); 3221 && fileMap.count(sFilename.Data())) {; 3222 return kTRUE;; 3223 }; 3224 ; 3225 // Check shared library.; 3226 if (s_IsLibraryLoaded(file_name.c_str(), GetInterpreterImpl())); 3227 return kTRUE;; 3228 ; 3229 //FIXME: We must use the cling::Interpreter::lookupFileOrLibrary iface.; 3230 clang::ConstSearchDirIterator *CurDir = nullptr;; 3231 clang::Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();; 3232 clang::HeaderSearch &HS = PP.getHeaderSearchInfo();; 3233 auto FE = HS.LookupFile(file_name.c_str(),; 3234 clang::SourceLocation(),; 3235 /*isAngled*/ false,; 3236 /*FromDir*/ nullptr, CurDir,; 3237 clang::ArrayRef<std::pair<clang::OptionalFileEntryRef,; 3238 clang::DirectoryEntryRef>>(),; 3239 /*SearchPath*/ nullptr,; 3240 /*RelativePath*/ nullptr,; 3241 /*RequestingModule*/ nullptr,; 3242 /*SuggestedModule*/ nullptr,; 3243 /*IsMapped*/ nullptr,; 3244 /*IsFrameworkFound*/ nullptr,; 3245 /*SkipCache*/ false,; 3246 /*BuildSystemModule*/ false,; 3247 /*OpenFile*/ false,; 3248 /*CacheFail*/ false);; 3249 if (FE) {; 3250 // check in the source manager if the file is actually loaded; 3251 clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();; 3252 // this works only with header (and source) files...; 3253 clang::FileID FID = SM.translateFile(*FE);; 3254 if (!FID.isInvalid() && FID.getHashValue() == 0); 3255 return kFALSE;; 3256 else {; 3257 clang::SrcMgr::SLocEntry SLocE = SM.getSLocEntry(FID);; 3258 if (SLocE.isFile() && !SLocE.getFile().getContentCache().getBufferIfLoaded()); 3259 return kFALSE;; 3260 if (!FID.isInvalid()); 3261 return kTRUE;; 3262 }; 3263 // ...then check shared library again, but with full path now; 3264 sFilename = FE->getName().str();; 3265 if (gSystem->FindDynamicLibrary(sFilename, kTRUE); 3266 && fileMap.count(sFilename.Data())) {; 3267 return kTRUE;; 3268 }; 3269 }; 3270 return kFALSE;; 3271}; 32",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:126729,Performance,cache,cache,126729,"/ false,; 3248 /*CacheFail*/ false);; 3249 if (FE) {; 3250 // check in the source manager if the file is actually loaded; 3251 clang::SourceManager &SM = fInterpreter->getCI()->getSourceManager();; 3252 // this works only with header (and source) files...; 3253 clang::FileID FID = SM.translateFile(*FE);; 3254 if (!FID.isInvalid() && FID.getHashValue() == 0); 3255 return kFALSE;; 3256 else {; 3257 clang::SrcMgr::SLocEntry SLocE = SM.getSLocEntry(FID);; 3258 if (SLocE.isFile() && !SLocE.getFile().getContentCache().getBufferIfLoaded()); 3259 return kFALSE;; 3260 if (!FID.isInvalid()); 3261 return kTRUE;; 3262 }; 3263 // ...then check shared library again, but with full path now; 3264 sFilename = FE->getName().str();; 3265 if (gSystem->FindDynamicLibrary(sFilename, kTRUE); 3266 && fileMap.count(sFilename.Data())) {; 3267 return kTRUE;; 3268 }; 3269 }; 3270 return kFALSE;; 3271}; 3272 ; 3273 ; 3274#if defined(R__MACOSX); 3275 ; 3276////////////////////////////////////////////////////////////////////////////////; 3277/// Check if lib is in the dynamic linker cache, returns true if it is, and if so,; 3278/// modifies the library file name parameter `lib` from `/usr/lib/libFOO.dylib`; 3279/// to `-lFOO` such that it can be passed to the linker.; 3280/// This is a unique feature of macOS 11.; 3281 ; 3282static bool R__UpdateLibFileForLinking(TString &lib); 3283{; 3284 const char *mapfile = nullptr;; 3285#if __x86_64__; 3286 mapfile = ""/System/Library/dyld/dyld_shared_cache_x86_64.map"";; 3287#elif __arm64__; 3288 mapfile = ""/System/Library/dyld/dyld_shared_cache_arm64e.map"";; 3289#else; 3290 #error unsupported architecture; 3291#endif; 3292 if (std::ifstream cacheMap{mapfile}) {; 3293 std::string line;; 3294 while (getline(cacheMap, line)) {; 3295 if (line.find(lib) != std::string::npos) {; 3296 lib.ReplaceAll(""/usr/lib/lib"",""-l"");; 3297 lib.ReplaceAll("".dylib"","""");; 3298 return true;; 3299 }; 3300 }; 3301 return false;; 3302 }; 3303 return false;; 3304}; 3305#endif // R__MAC",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:127337,Performance,cache,cacheMap,127337,"ow; 3264 sFilename = FE->getName().str();; 3265 if (gSystem->FindDynamicLibrary(sFilename, kTRUE); 3266 && fileMap.count(sFilename.Data())) {; 3267 return kTRUE;; 3268 }; 3269 }; 3270 return kFALSE;; 3271}; 3272 ; 3273 ; 3274#if defined(R__MACOSX); 3275 ; 3276////////////////////////////////////////////////////////////////////////////////; 3277/// Check if lib is in the dynamic linker cache, returns true if it is, and if so,; 3278/// modifies the library file name parameter `lib` from `/usr/lib/libFOO.dylib`; 3279/// to `-lFOO` such that it can be passed to the linker.; 3280/// This is a unique feature of macOS 11.; 3281 ; 3282static bool R__UpdateLibFileForLinking(TString &lib); 3283{; 3284 const char *mapfile = nullptr;; 3285#if __x86_64__; 3286 mapfile = ""/System/Library/dyld/dyld_shared_cache_x86_64.map"";; 3287#elif __arm64__; 3288 mapfile = ""/System/Library/dyld/dyld_shared_cache_arm64e.map"";; 3289#else; 3290 #error unsupported architecture; 3291#endif; 3292 if (std::ifstream cacheMap{mapfile}) {; 3293 std::string line;; 3294 while (getline(cacheMap, line)) {; 3295 if (line.find(lib) != std::string::npos) {; 3296 lib.ReplaceAll(""/usr/lib/lib"",""-l"");; 3297 lib.ReplaceAll("".dylib"","""");; 3298 return true;; 3299 }; 3300 }; 3301 return false;; 3302 }; 3303 return false;; 3304}; 3305#endif // R__MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:127403,Performance,cache,cacheMap,127403,"ow; 3264 sFilename = FE->getName().str();; 3265 if (gSystem->FindDynamicLibrary(sFilename, kTRUE); 3266 && fileMap.count(sFilename.Data())) {; 3267 return kTRUE;; 3268 }; 3269 }; 3270 return kFALSE;; 3271}; 3272 ; 3273 ; 3274#if defined(R__MACOSX); 3275 ; 3276////////////////////////////////////////////////////////////////////////////////; 3277/// Check if lib is in the dynamic linker cache, returns true if it is, and if so,; 3278/// modifies the library file name parameter `lib` from `/usr/lib/libFOO.dylib`; 3279/// to `-lFOO` such that it can be passed to the linker.; 3280/// This is a unique feature of macOS 11.; 3281 ; 3282static bool R__UpdateLibFileForLinking(TString &lib); 3283{; 3284 const char *mapfile = nullptr;; 3285#if __x86_64__; 3286 mapfile = ""/System/Library/dyld/dyld_shared_cache_x86_64.map"";; 3287#elif __arm64__; 3288 mapfile = ""/System/Library/dyld/dyld_shared_cache_arm64e.map"";; 3289#else; 3290 #error unsupported architecture; 3291#endif; 3292 if (std::ifstream cacheMap{mapfile}) {; 3293 std::string line;; 3294 while (getline(cacheMap, line)) {; 3295 if (line.find(lib) != std::string::npos) {; 3296 lib.ReplaceAll(""/usr/lib/lib"",""-l"");; 3297 lib.ReplaceAll("".dylib"","""");; 3298 return true;; 3299 }; 3300 }; 3301 return false;; 3302 }; 3303 return false;; 3304}; 3305#endif // R__MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:128737,Performance,load,loadLibrary,128737,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:132344,Performance,load,loadLibrary,132344,"s); 3397 RegisterLoadedSharedLibrary(lib.c_str());; 3398#else; 3399 Error(""TCling::UpdateListOfLoadedSharedLibraries"",; 3400 ""Platform not supported!"");; 3401#endif; 3402}; 3403 ; 3404namespace {; 3405template <int N>; 3406static bool StartsWithStrLit(const char *haystack, const char (&needle)[N]) {; 3407 return !strncmp(haystack, needle, N - 1);; 3408}; 3409}; 3410 ; 3411////////////////////////////////////////////////////////////////////////////////; 3412/// Register a new shared library name with the interpreter; add it to; 3413/// fSharedLibs.; 3414 ; 3415void TCling::RegisterLoadedSharedLibrary(const char* filename); 3416{; 3417 // Ignore NULL filenames, aka ""the process"".; 3418 if (!filename) return;; 3419 ; 3420 // Tell the interpreter that this library is available; all libraries can be; 3421 // used to resolve symbols.; 3422 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3423 if (!DLM->isLibraryLoaded(filename)) {; 3424 DLM->loadLibrary(filename, true /*permanent*/, true /*resolved*/);; 3425 }; 3426 ; 3427#if defined(R__MACOSX); 3428 // Check that this is not a system library that does not exist on disk.; 3429 auto lenFilename = strlen(filename);; 3430 auto isInMacOSSystemDir = [](const char *fn) {; 3431 return StartsWithStrLit(fn, ""/usr/lib/"") || StartsWithStrLit(fn, ""/System/Library/"");; 3432 };; 3433 if (!strcmp(filename, ""cl_kernels"") // yepp, no directory; 3434 ; 3435 // These we should not link with (e.g. because they forward to .tbd):; 3436 || StartsWithStrLit(filename, ""/usr/lib/system/""); 3437 || StartsWithStrLit(filename, ""/usr/lib/libc++""); 3438 || StartsWithStrLit(filename, ""/System/Library/Frameworks/""); 3439 || StartsWithStrLit(filename, ""/System/Library/PrivateFrameworks/""); 3440 || StartsWithStrLit(filename, ""/System/Library/CoreServices/""); 3441 || StartsWithStrLit(filename, ""/usr/lib/libSystem""); 3442 || StartsWithStrLit(filename, ""/usr/lib/libstdc++""); 3443 || StartsWithStrLit(filename, ""/usr/lib/libicucore""",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:136700,Performance,load,load,136700,"r) ||; 3488 strstr(filename, ""/usr/bin/cyg"")); 3489 return;; 3490#elif defined(R__WIN32); 3491 if (strstr(filename, ""/Windows/"")); 3492 return;; 3493#elif defined (R__LINUX); 3494 if (strstr(filename, ""/ld-linux""); 3495 || strstr(filename, ""linux-gnu/""); 3496 || strstr(filename, ""/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:137187,Performance,load,loadLibrary,137187,"(!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3538 if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {; 3539 UpdateListOfLoadedSharedLibraries();; 3540 }; 3541 switch (res) {; 3542 case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;; 3543 case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded: return 1;; 3544 default: break;; 3545 };; 3546 return -1;; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Load a macro file in cling's memory.; 3551 ; 3552void TCling::LoadMacro(const char* filen",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:143039,Performance,perform,performance,143039,"_t TCling::HandleNewTransaction(const cling::Transaction &T); 3666{; 3667 R__LOCKGUARD(gInterpreterMutex);; 3668 ; 3669 if ((std::distance(T.decls_begin(), T.decls_end()) != 1); 3670 || T.deserialized_decls_begin() != T.deserialized_decls_end(); 3671 || T.macros_begin() != T.macros_end(); 3672 || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {; 3673 fTransactionCount++;; 3674 return true;; 3675 }; 3676 return false;; 3677}; 3678 ; 3679////////////////////////////////////////////////////////////////////////////////; 3680/// Delete object from cling symbol table so it can not be used anymore.; 3681/// cling objects are always on the heap.; 3682 ; 3683void TCling::RecursiveRemove(TObject* obj); 3684{; 3685 // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**; 3686 // put in place the Read/Write part here. Keeping the write lock; 3687 // here is 'catasptrophic' for scaling as it means that ALL calls; 3688 // to RecursiveRemove will take the write lock and performance; 3689 // of many threads trying to access the write lock at the same; 3690 // time is relatively bad.; 3691 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3692 // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal; 3693 // (but isn't at the moment).; 3694 if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {; 3695 std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);; 3696 if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {; 3697 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3698 DeleteGlobal(obj);; 3699 ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);; 3700 }; 3701 }; 3702}; 3703 ; 3704////////////////////////////////////////////////////////////////////////////////; 3705/// Pressing Ctrl+C should forward here. In the case where we have had; 3706/// continuation requested we must reset it.; 3707 ; 3708void TCling::Reset(); 370",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:161385,Performance,load,loaded,161385," cl->fState = TClass::kEmulated;; 4147 } else {; 4148 cl->fState = TClass::kForwardDeclared;; 4149 }; 4150// }; 4151 }; 4152 }; 4153 if (cl->fClassInfo) {; 4154 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 41",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:161643,Performance,load,loaded,161643,"4 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataTy",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:163041,Performance,load,loading,163041,"; 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );; 4194 ; 4195 if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject; 4196 && fundType->GetType() > 0) {; 4197 // Fundamental type, no a class.; 4198 return kUnknown;; 4199 }; 4200 ; 4201 // Migrated from within TClass::GetClass; 4202 // If we want to know if a class or a namespace with this name exists in the; 4203 // interpreter and this is an enum in the type system, before or after loading; 4204 // according to the autoload function argument, return kUnknown.; 4205 if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone)); 4206 return kUnknown;; 4207 ; 4208 const char *classname = name;; 4209 ; 4210 // RAII to suspend and restore auto-loading and auto-parsing based on some external conditions.; 4211 class MaybeSuspendAutoLoadParse {; 4212 int fStoreAutoLoad = 0;; 4213 int fStoreAutoParse = 0;; 4214 bool fSuspendedAutoParse = false;; 4215 public:; 4216 MaybeSuspendAutoLoadParse(int autoload) {; 4217 fStoreAutoLoad = ((TCling*)gCling)->SetClassAutoLoading(autoload);; 4218 }; 4219 ; 4220 void SuspendAutoParsing() {; 4221 fSuspendedAutoParse = true;; 4222 fStoreAutoParse = ((TCling*)gCling)->SetSuspendAutoParsing(true);; 4223 }; 4224 ; 4225 ~MaybeSuspendAutoLoadParse() {; 4226 if (fSuspendedAutoParse); 4227 ((TCling*)gCling)->SetSuspendAutoParsing",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:163337,Performance,load,loading,163337,"ading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataType *)typeTable->THashTable::FindObject( name );; 4194 ; 4195 if (fundType && fundType->GetType() < TVirtualStreamerInfo::kObject; 4196 && fundType->GetType() > 0) {; 4197 // Fundamental type, no a class.; 4198 return kUnknown;; 4199 }; 4200 ; 4201 // Migrated from within TClass::GetClass; 4202 // If we want to know if a class or a namespace with this name exists in the; 4203 // interpreter and this is an enum in the type system, before or after loading; 4204 // according to the autoload function argument, return kUnknown.; 4205 if (isClassOrNamespaceOnly && TEnum::GetEnum(name, autoload ? TEnum::kAutoload : TEnum::kNone)); 4206 return kUnknown;; 4207 ; 4208 const char *classname = name;; 4209 ; 4210 // RAII to suspend and restore auto-loading and auto-parsing based on some external conditions.; 4211 class MaybeSuspendAutoLoadParse {; 4212 int fStoreAutoLoad = 0;; 4213 int fStoreAutoParse = 0;; 4214 bool fSuspendedAutoParse = false;; 4215 public:; 4216 MaybeSuspendAutoLoadParse(int autoload) {; 4217 fStoreAutoLoad = ((TCling*)gCling)->SetClassAutoLoading(autoload);; 4218 }; 4219 ; 4220 void SuspendAutoParsing() {; 4221 fSuspendedAutoParse = true;; 4222 fStoreAutoParse = ((TCling*)gCling)->SetSuspendAutoParsing(true);; 4223 }; 4224 ; 4225 ~MaybeSuspendAutoLoadParse() {; 4226 if (fSuspendedAutoParse); 4227 ((TCling*)gCling)->SetSuspendAutoParsing(fStoreAutoParse);; 4228 ((TCling*)gCling)->SetClassAutoLoading(fStoreAutoLoad);; 4229 }; 4230 };; 4231 ; 4232 MaybeSuspendAutoLoadParse autoLoadParseRAII( autoload );; 4233 if (TClassEdit::IsStdPair(classname) || TClassEdit::IsStdPairBase(classname)); 4234 autoLoadParseRAII.SuspendAutoParsing();; 42",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:172243,Performance,load,loaded,172243,"C)->collectAllContexts(allDeclContexts);; 4413 for (llvm::SmallVector<DeclContext*, 4>::iterator declIter = allDeclContexts.begin(), declEnd = allDeclContexts.end();; 4414 declIter != declEnd; ++declIter) {; 4415 // Iterate on all decls for each context.; 4416 for (clang::DeclContext::decl_iterator DI = (*declIter)->decls_begin(),; 4417 DE = (*declIter)->decls_end(); DI != DE; ++DI) {; 4418 if (const clang::EnumDecl* ED = dyn_cast<clang::EnumDecl>(*DI)) {; 4419 // Get name of the enum type.; 4420 std::string buf;; 4421 PrintingPolicy Policy(ED->getASTContext().getPrintingPolicy());; 4422 llvm::raw_string_ostream stream(buf);; 4423 // Don't trigger fopen of the source file to count lines:; 4424 Policy.AnonymousTagLocations = false;; 4425 ED->getNameForDiagnostic(stream, Policy, /*Qualified=*/false);; 4426 stream.flush();; 4427 // If the enum is unnamed we do not add it to the list of enums i.e unusable.; 4428 if (!buf.empty()) {; 4429 const char* name = buf.c_str();; 4430 // Add the enum to the list of loaded enums.; 4431 enumList.Get(ED, name);; 4432 }; 4433 }; 4434 }; 4435 }; 4436 }; 4437}; 4438 ; 4439////////////////////////////////////////////////////////////////////////////////; 4440/// Create list of pointers to function templates for TClass cl.; 4441 ; 4442void TCling::LoadFunctionTemplates(TClass* cl) const; 4443{; 4444 R__LOCKGUARD(gInterpreterMutex);; 4445 ; 4446 const Decl * D;; 4447 TListOfFunctionTemplates* funcTempList;; 4448 if (cl) {; 4449 D = ((TClingClassInfo*)cl->GetClassInfo())->GetDecl();; 4450 funcTempList = (TListOfFunctionTemplates*)cl->GetListOfFunctionTemplates(false);; 4451 }; 4452 else {; 4453 D = fInterpreter->getCI()->getASTContext().getTranslationUnitDecl();; 4454 funcTempList = (TListOfFunctionTemplates*)gROOT->GetListOfFunctionTemplates();; 4455 }; 4456 // Iterate on the decl of the class and get the enums.; 4457 if (const clang::DeclContext* DC = dyn_cast<clang::DeclContext>(D)) {; 4458 cling::Interpreter::PushTransactionRAII deserRAI",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:218702,Performance,load,loaded,218702,"ile"", ""%s: Section for %s (library does not exist)"", rootmapfile, lib_nameTstr.Data());; 5598 }; 5599 delete[] wlib;; 5600 delete tokens;; 5601 }; 5602 } else {; 5603 auto keyLenIt = keyLenMap.find(firstChar);; 5604 if (keyLenIt == keyLenMap.end()); 5605 continue;; 5606 unsigned int keyLen = keyLenIt->second;; 5607 // Do not make a copy, just start after the key; 5608 const char *keyname = line.c_str() + keyLen;; 5609 if (gDebug > 6); 5610 Info(""ReadRootmapFile"", ""%s: class %s in %s"", rootmapfile, keyname, lib_name.c_str());; 5611 TEnvRec *isThere = fMapfile->Lookup(keyname);; 5612 if (isThere) {; 5613 if (lib_name != isThere->GetValue()) { // the same key for two different libs; 5614 if (firstChar == 'n') {; 5615 if (gDebug > 3); 5616 Info(""ReadRootmapFile"",; 5617 ""While processing %s, namespace %s was found to be associated to %s although it is already ""; 5618 ""associated to %s"",; 5619 rootmapfile, keyname, lib_name.c_str(), isThere->GetValue());; 5620 } else if (firstChar == 'h') { // it is a header: add the libname to the list of libs to be loaded.; 5621 lib_name += "" "";; 5622 lib_name += isThere->GetValue();; 5623 fMapfile->SetValue(keyname, lib_name.c_str());; 5624 } else if (!TClassEdit::IsSTLCont(keyname)) {; 5625 Warning(""ReadRootmapFile"",; 5626 ""While processing %s, %s %s was found to be associated to %s although it is already ""; 5627 ""associated to %s"",; 5628 rootmapfile, line.substr(0, keyLen - 1).c_str(), keyname, lib_name.c_str(),; 5629 isThere->GetValue());; 5630 }; 5631 } else { // the same key for the same lib; 5632 if (gDebug > 3); 5633 Info(""ReadRootmapFile"", ""While processing %s, key %s was found to be already defined for %s"",; 5634 rootmapfile, keyname, lib_name.c_str());; 5635 }; 5636 } else {; 5637 fMapfile->SetValue(keyname, lib_name.c_str());; 5638 }; 5639 }; 5640 }; 5641 file.close();; 5642 return 0;; 5643}; 5644 ; 5645////////////////////////////////////////////////////////////////////////////////; 5646/// Create a resource table and read ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:222822,Performance,load,loading,222822,"nd to set the external visible; 5701 // storage flag for them.; 5702 public:; 5703 ExtVisibleStorageAdder(std::unordered_set<const NamespaceDecl*>& nsSet): fNSSet(nsSet) {};; 5704 bool VisitNamespaceDecl(NamespaceDecl* nsDecl) {; 5705 // We want to enable the external lookup for this namespace; 5706 // because it may shadow the lookup of other names contained; 5707 // in that namespace; 5708 ; 5709 nsDecl->setHasExternalVisibleStorage();; 5710 fNSSet.insert(nsDecl);; 5711 return true;; 5712 }; 5713 bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl* specDecl) {; 5714 // We want to enable the external lookup for this specialization; 5715 // because we can provide a definition for it!; 5716 if (specDecl->getTemplateSpecializationKind() == TSK_ExplicitSpecialization); 5717 //SpecSet.insert(specDecl);; 5718 specDecl->setHasExternalLexicalStorage();; 5719 ; 5720 // No need to recurse. On the contrary, recursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:223079,Performance,load,loading,223079,"nsDecl);; 5711 return true;; 5712 }; 5713 bool VisitClassTemplateSpecializationDecl(ClassTemplateSpecializationDecl* specDecl) {; 5714 // We want to enable the external lookup for this specialization; 5715 // because we can provide a definition for it!; 5716 if (specDecl->getTemplateSpecializationKind() == TSK_ExplicitSpecialization); 5717 //SpecSet.insert(specDecl);; 5718 specDecl->setHasExternalLexicalStorage();; 5719 ; 5720 // No need to recurse. On the contrary, recursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:223705,Performance,load,load,223705,"ursing is actively harmful:; 5721 // NOTE: must not recurse to prevent this visitor from triggering loading from; 5722 // the external AST source (i.e. autoloading). This would be triggered right here,; 5723 // before autoloading is even set up, as rootmap file parsing happens before that.; 5724 // Even if autoloading is off and has no effect, triggering loading from external; 5725 // AST source resets the flag setHasExternalLexicalStorage(), hiding this specialization; 5726 // from subsequent autoloads!; 5727 return false;; 5728 }; 5729 private:; 5730 std::unordered_set<const NamespaceDecl*>& fNSSet;; 5731 };; 5732}; 5733 ; 5734////////////////////////////////////////////////////////////////////////////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:224550,Performance,load,load,224550,"6/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 }; 5790 const char* f1;; 5791 while ((f1 = gSystem->GetDirEntry(dirp))) {; 5792 TString f = ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:229953,Performance,load,loaded,229953," compRes= fInterpreter->declare(uniqueString.Data(), &T);; 5894 assert(cling::Interpreter::kSuccess == compRes && ""A declaration in a rootmap could not be compiled"");; 5895 ; 5896 if (compRes!=cling::Interpreter::kSuccess){; 5897 Warning(""LoadLibraryMap"",; 5898 ""Problems in %s declaring '%s' were encountered."", rootmapfile, uniqueString.Data()) ;; 5899 }; 5900 ; 5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {; 5904 if (declIt->m_DGR.isSingleDecl()) {; 5905 if (Decl* D = declIt->m_DGR.getSingleDecl()) {; 5906 if (clang::isa<TagDecl>(D) || clang::isa<NamespaceDecl>(D)) {; 5907 evsAdder.TraverseDecl(D);; 5908 }; 5909 }; 5910 }; 5911 }; 5912 }; 5913 ; 5914 // clear duplicates; 5915 ; 5916 return 0;; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Scan again along the dynamic path for library maps. Entries for the loaded; 5921/// shared libraries are unloaded first. This can be useful after reseting; 5922/// the dynamic path through TSystem::SetDynamicPath(); 5923/// In case of error -1 is returned, 0 otherwise.; 5924 ; 5925Int_t TCling::RescanLibraryMap(); 5926{; 5927 UnloadAllSharedLibraryMaps();; 5928 LoadLibraryMap();; 5929 return 0;; 5930}; 5931 ; 5932////////////////////////////////////////////////////////////////////////////////; 5933/// Reload the library map entries coming from all the loaded shared libraries,; 5934/// after first unloading the current ones.; 5935/// In case of error -1 is returned, 0 otherwise.; 5936 ; 5937Int_t TCling::ReloadAllSharedLibraryMaps(); 5938{; 5939 const TString sharedLibLStr = GetSharedLibs();; 5940 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 5941 const Int_t nrSharedLibs = sharedLibL->GetEntriesFast();; 5942 for (Int_t ilib = 0; ilib < nrSharedLibs; ilib++) {; 5943 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 5944 const T",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:230443,Performance,load,loaded,230443,"5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {; 5904 if (declIt->m_DGR.isSingleDecl()) {; 5905 if (Decl* D = declIt->m_DGR.getSingleDecl()) {; 5906 if (clang::isa<TagDecl>(D) || clang::isa<NamespaceDecl>(D)) {; 5907 evsAdder.TraverseDecl(D);; 5908 }; 5909 }; 5910 }; 5911 }; 5912 }; 5913 ; 5914 // clear duplicates; 5915 ; 5916 return 0;; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Scan again along the dynamic path for library maps. Entries for the loaded; 5921/// shared libraries are unloaded first. This can be useful after reseting; 5922/// the dynamic path through TSystem::SetDynamicPath(); 5923/// In case of error -1 is returned, 0 otherwise.; 5924 ; 5925Int_t TCling::RescanLibraryMap(); 5926{; 5927 UnloadAllSharedLibraryMaps();; 5928 LoadLibraryMap();; 5929 return 0;; 5930}; 5931 ; 5932////////////////////////////////////////////////////////////////////////////////; 5933/// Reload the library map entries coming from all the loaded shared libraries,; 5934/// after first unloading the current ones.; 5935/// In case of error -1 is returned, 0 otherwise.; 5936 ; 5937Int_t TCling::ReloadAllSharedLibraryMaps(); 5938{; 5939 const TString sharedLibLStr = GetSharedLibs();; 5940 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 5941 const Int_t nrSharedLibs = sharedLibL->GetEntriesFast();; 5942 for (Int_t ilib = 0; ilib < nrSharedLibs; ilib++) {; 5943 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 5944 const TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);; 5945 const Int_t ret = UnloadLibraryMap(sharedLibBaseStr);; 5946 if (ret < 0) {; 5947 continue;; 5948 }; 5949 TString rootMapBaseStr = sharedLibBaseStr;; 5950 if (sharedLibBaseStr.EndsWith("".dll"")) {; 5951 rootMapBaseStr.ReplaceAll("".dll"", """");; 5952 }; 5953 else if (sharedLibBaseStr.EndsWith("".DLL"")) {",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:232404,Performance,load,loading,232404,""""");; 5958 }; 5959 else if (sharedLibBaseStr.EndsWith("".sl"")) {; 5960 rootMapBaseStr.ReplaceAll("".sl"", """");; 5961 }; 5962 else if (sharedLibBaseStr.EndsWith("".dl"")) {; 5963 rootMapBaseStr.ReplaceAll("".dl"", """");; 5964 }; 5965 else if (sharedLibBaseStr.EndsWith("".a"")) {; 5966 rootMapBaseStr.ReplaceAll("".a"", """");; 5967 }; 5968 else {; 5969 Error(""ReloadAllSharedLibraryMaps"", ""Unknown library type %s"", sharedLibBaseStr.Data());; 5970 delete sharedLibL;; 5971 return -1;; 5972 }; 5973 rootMapBaseStr += "".rootmap"";; 5974 const char* rootMap = gSystem->Which(gSystem->GetDynamicPath(), rootMapBaseStr);; 5975 if (!rootMap) {; 5976 Error(""ReloadAllSharedLibraryMaps"", ""Could not find rootmap %s in path"", rootMapBaseStr.Data());; 5977 delete[] rootMap;; 5978 delete sharedLibL;; 5979 return -1;; 5980 }; 5981 const Int_t status = LoadLibraryMap(rootMap);; 5982 if (status < 0) {; 5983 Error(""ReloadAllSharedLibraryMaps"", ""Error loading map %s"", rootMap);; 5984 delete[] rootMap;; 5985 delete sharedLibL;; 5986 return -1;; 5987 }; 5988 delete[] rootMap;; 5989 }; 5990 delete sharedLibL;; 5991 return 0;; 5992}; 5993 ; 5994////////////////////////////////////////////////////////////////////////////////; 5995/// Unload the library map entries coming from all the loaded shared libraries.; 5996/// Returns 0 if succesful; 5997 ; 5998Int_t TCling::UnloadAllSharedLibraryMaps(); 5999{; 6000 const TString sharedLibLStr = GetSharedLibs();; 6001 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 6002 for (Int_t ilib = 0; ilib < sharedLibL->GetEntriesFast(); ilib++) {; 6003 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 6004 const TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);; 6005 UnloadLibraryMap(sharedLibBaseStr);; 6006 }; 6007 delete sharedLibL;; 6008 return 0;; 6009}; 6010 ; 6011////////////////////////////////////////////////////////////////////////////////; 6012/// Unload library map entries coming from the specified library.; 6013/// Re",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:232738,Performance,load,loaded,232738,""""");; 5958 }; 5959 else if (sharedLibBaseStr.EndsWith("".sl"")) {; 5960 rootMapBaseStr.ReplaceAll("".sl"", """");; 5961 }; 5962 else if (sharedLibBaseStr.EndsWith("".dl"")) {; 5963 rootMapBaseStr.ReplaceAll("".dl"", """");; 5964 }; 5965 else if (sharedLibBaseStr.EndsWith("".a"")) {; 5966 rootMapBaseStr.ReplaceAll("".a"", """");; 5967 }; 5968 else {; 5969 Error(""ReloadAllSharedLibraryMaps"", ""Unknown library type %s"", sharedLibBaseStr.Data());; 5970 delete sharedLibL;; 5971 return -1;; 5972 }; 5973 rootMapBaseStr += "".rootmap"";; 5974 const char* rootMap = gSystem->Which(gSystem->GetDynamicPath(), rootMapBaseStr);; 5975 if (!rootMap) {; 5976 Error(""ReloadAllSharedLibraryMaps"", ""Could not find rootmap %s in path"", rootMapBaseStr.Data());; 5977 delete[] rootMap;; 5978 delete sharedLibL;; 5979 return -1;; 5980 }; 5981 const Int_t status = LoadLibraryMap(rootMap);; 5982 if (status < 0) {; 5983 Error(""ReloadAllSharedLibraryMaps"", ""Error loading map %s"", rootMap);; 5984 delete[] rootMap;; 5985 delete sharedLibL;; 5986 return -1;; 5987 }; 5988 delete[] rootMap;; 5989 }; 5990 delete sharedLibL;; 5991 return 0;; 5992}; 5993 ; 5994////////////////////////////////////////////////////////////////////////////////; 5995/// Unload the library map entries coming from all the loaded shared libraries.; 5996/// Returns 0 if succesful; 5997 ; 5998Int_t TCling::UnloadAllSharedLibraryMaps(); 5999{; 6000 const TString sharedLibLStr = GetSharedLibs();; 6001 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 6002 for (Int_t ilib = 0; ilib < sharedLibL->GetEntriesFast(); ilib++) {; 6003 const TString sharedLibStr = ((TObjString*)sharedLibL->At(ilib))->GetString();; 6004 const TString sharedLibBaseStr = gSystem->BaseName(sharedLibStr);; 6005 UnloadLibraryMap(sharedLibBaseStr);; 6006 }; 6007 delete sharedLibL;; 6008 return 0;; 6009}; 6010 ; 6011////////////////////////////////////////////////////////////////////////////////; 6012/// Unload library map entries coming from the specified library.; 6013/// Re",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:236776,Performance,load,load,236776,"::"", ""@@"");; 6087 // convert ""-"" to "" "", since class names may have; 6088 // blanks and TEnv considers a blank a terminator; 6089 key.ReplaceAll("" "", ""-"");; 6090 ; 6091 R__LOCKGUARD(gInterpreterMutex);; 6092 if (!fMapfile) {; 6093 fMapfile = new TEnv();; 6094 fMapfile->IgnoreDuplicates(kTRUE);; 6095 ; 6096 fRootmapFiles = new TObjArray;; 6097 fRootmapFiles->SetOwner();; 6098 ; 6099 InitRootmapFile("".rootmap"");; 6100 }; 6101 //fMapfile->SetValue(key, libs);; 6102 fMapfile->SetValue(cls, libs);; 6103 return 1;; 6104}; 6105 ; 6106////////////////////////////////////////////////////////////////////////////////; 6107/// Demangle the name (from the typeinfo) and then request the class; 6108/// via the usual name based interface (TClass::GetClass).; 6109 ; 6110TClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const; 6111{; 6112 int err = 0;; 6113 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6114 if (err) return nullptr;; 6115 TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);; 6116 free(demangled_name);; 6117 return theClass;; 6118}; 6119 ; 6120////////////////////////////////////////////////////////////////////////////////; 6121/// Load library containing the specified class. Returns 0 in case of error; 6122/// and 1 in case if success.; 6123 ; 6124Int_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */); 6125{; 6126 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6127 ; 6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 sp",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:236979,Performance,load,load,236979,"::"", ""@@"");; 6087 // convert ""-"" to "" "", since class names may have; 6088 // blanks and TEnv considers a blank a terminator; 6089 key.ReplaceAll("" "", ""-"");; 6090 ; 6091 R__LOCKGUARD(gInterpreterMutex);; 6092 if (!fMapfile) {; 6093 fMapfile = new TEnv();; 6094 fMapfile->IgnoreDuplicates(kTRUE);; 6095 ; 6096 fRootmapFiles = new TObjArray;; 6097 fRootmapFiles->SetOwner();; 6098 ; 6099 InitRootmapFile("".rootmap"");; 6100 }; 6101 //fMapfile->SetValue(key, libs);; 6102 fMapfile->SetValue(cls, libs);; 6103 return 1;; 6104}; 6105 ; 6106////////////////////////////////////////////////////////////////////////////////; 6107/// Demangle the name (from the typeinfo) and then request the class; 6108/// via the usual name based interface (TClass::GetClass).; 6109 ; 6110TClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const; 6111{; 6112 int err = 0;; 6113 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6114 if (err) return nullptr;; 6115 TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);; 6116 free(demangled_name);; 6117 return theClass;; 6118}; 6119 ; 6120////////////////////////////////////////////////////////////////////////////////; 6121/// Load library containing the specified class. Returns 0 in case of error; 6122/// and 1 in case if success.; 6123 ; 6124Int_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */); 6125{; 6126 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6127 ; 6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 sp",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:238577,Performance,load,load,238577,"6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 splitname.ShortType(demangled_name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd);; 6141 ; 6142 // No need to worry about typedef, they aren't any ... but there are; 6143 // inlined namespaces ...; 6144 ; 6145 Int_t result = AutoLoad(demangled_name.c_str());; 6146 if (result == 0) {; 6147 demangled_name = TClassEdit::GetLong64_Name(demangled_name);; 6148 result = AutoLoad(demangled_name.c_str(), knowDictNotLoaded);; 6149 }; 6150 ; 6151 return result;; 6152}; 6153 ; 6154////////////////////////////////////////////////////////////////////////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:239158,Performance,load,loaded,239158,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:239293,Performance,load,loading,239293,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:239574,Performance,load,loaded,239574,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:239714,Performance,load,loading,239714,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:240067,Performance,load,loading,240067,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:240482,Performance,load,load,240482,"me();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:240925,Performance,load,load,240925,"te `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end up in a situation where the library and thus; 6229 // the dictionary is loaded for ""cls"" but the TClass is; 6230 // not created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMem",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:241295,Performance,load,load,241295,"te `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end up in a situation where the library and thus; 6229 // the dictionary is loaded for ""cls"" but the TClass is; 6230 // not created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMem",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:241338,Performance,load,load,241338,"te `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this class; 6209 // and we are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end up in a situation where the library and thus; 6229 // the dictionary is loaded for ""cls"" but the TClass is; 6230 // not created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMem",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:241499,Performance,load,loaded,241499,"e are done, whether success or not, as it won't work better now than before,; 6210 // because there is no additional information now compared to before.; 6211 if (!visited.insert(std::string(cls)).second); 6212 return 1;; 6213 ; 6214 if (ShallowAutoLoadImpl(cls) == 0) {; 6215 // If ShallowAutoLoadImpl() has an error, we have an error.; 6216 return 0;; 6217 }; 6218 ; 6219 // Now look through the TProtoClass to load the required library/dictionary; 6220 if (TProtoClass *proto = nameIsNormalized ? TClassTable::GetProtoNorm(cls) : TClassTable::GetProto(cls)) {; 6221 for (auto element : proto->GetData()) {; 6222 if (element->IsBasic()); 6223 continue;; 6224 const char *subtypename = element->GetTypeName();; 6225 if (!TClassTable::GetDictNorm(subtypename)) {; 6226 // Failure to load a dictionary is not (quite) a failure load; 6227 // the top-level library. If we return false here, then; 6228 // we would end up in a situation where the library and thus; 6229 // the dictionary is loaded for ""cls"" but the TClass is; 6230 // not created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMemberSelection::kNoUsingDecls);; 6244 while (gInterpreter->DataMemberInfo_Next(memberinfo)) {; 6245 if (gInterpreter->DataMemberInfo_TypeProperty(memberinfo) & ::kIsFundamental); 6246 continue;; 6247 auto membertypename = TClassEdit::GetLong64_Name(gInterpreter->TypeName(gInterpreter->DataMemberInfo_TypeTrueName(memberinfo)));; 6248 if (!TClassTable::GetDictNorm(membertypename.c_str())) {; 6249 // Fa",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:242521,Performance,load,load,242521,"ot created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMemberSelection::kNoUsingDecls);; 6244 while (gInterpreter->DataMemberInfo_Next(memberinfo)) {; 6245 if (gInterpreter->DataMemberInfo_TypeProperty(memberinfo) & ::kIsFundamental); 6246 continue;; 6247 auto membertypename = TClassEdit::GetLong64_Name(gInterpreter->TypeName(gInterpreter->DataMemberInfo_TypeTrueName(memberinfo)));; 6248 if (!TClassTable::GetDictNorm(membertypename.c_str())) {; 6249 // Failure to load a dictionary is not (quite) a failure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:242564,Performance,load,load,242564,"ot created and/or marked as unavailable (in case where; 6231 // AutoLoad is called from TClass::GetClass).; 6232 DeepAutoLoadImpl(subtypename, visited, true /*normalized*/);; 6233 }; 6234 }; 6235 return 1;; 6236 }; 6237 ; 6238 // We found no TProtoClass for cls.; 6239 auto classinfo = gInterpreter->ClassInfo_Factory(cls);; 6240 if (classinfo && gInterpreter->ClassInfo_IsValid(classinfo); 6241 && !(gInterpreter->ClassInfo_Property(classinfo) & kIsEnum)); 6242 {; 6243 DataMemberInfo_t *memberinfo = gInterpreter->DataMemberInfo_Factory(classinfo, TDictionary::EMemberSelection::kNoUsingDecls);; 6244 while (gInterpreter->DataMemberInfo_Next(memberinfo)) {; 6245 if (gInterpreter->DataMemberInfo_TypeProperty(memberinfo) & ::kIsFundamental); 6246 continue;; 6247 auto membertypename = TClassEdit::GetLong64_Name(gInterpreter->TypeName(gInterpreter->DataMemberInfo_TypeTrueName(memberinfo)));; 6248 if (!TClassTable::GetDictNorm(membertypename.c_str())) {; 6249 // Failure to load a dictionary is not (quite) a failure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:243684,Performance,load,load,243684,"d)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:244109,Performance,load,loaded,244109,"///////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoading",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:244907,Performance,load,loaded,244907," // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoadingRAII autoLoadOff(this);; 6310 // Try using externally provided callback first.; 6311 if (fAutoLoadCallBack) {; 6312 int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);; 6313 if (success); 6314 return success;; 6315 }; 6316 ; 6317 // During the 'Deep' part of the search we will call GetClassSharedLibsForModule; 6318 // (when module are enabled) which might end up calling AutoParsing but; 6319 // that should only be for the cases where the library has no generated pcm; 6320 // and in that case a rootmap should be available.; 6321 // This avoids a very costly operation (for generally no gain) but reduce the; 6322 // quality of the search (i.e. bad in case of library with no pcm and no rootmap; 6323 // file).; 6324 TInte",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:253274,Performance,load,load,253274,"ersParsed++;; 6480 if (gDebug > 0){; 6481 ProcInfo_t info;; 6482 gSystem->GetProcInfo(&info);; 6483 float endRSSval = 1e-3*info.fMemResident;; 6484 float endVSIZEval = 1e-3*info.fMemVirtual;; 6485 Info(""Autoparse"", "">>> RSS key %s - before %.3f MB - after %.3f MB - delta %.3f MB"", apKey, initRSSval, endRSSval, endRSSval-initRSSval);; 6486 Info(""Autoparse"", "">>> VSIZE key %s - before %.3f MB - after %.3f MB - delta %.3f MB"", apKey, initVSIZEval, endVSIZEval, endVSIZEval-initVSIZEval);; 6487 }; 6488 }; 6489 } else if (!IsLoaded(hName)) {; 6490 if (gDebug > 0) {; 6491 Info(""AutoParse"",; 6492 ""Parsing single header %s"", hName);; 6493 }; 6494 auto cRes = ExecAutoParse(hName, kTRUE, GetInterpreterImpl());; 6495 if (cRes != cling::Interpreter::kSuccess) {; 6496 Error(""AutoParse"", ""Error parsing headerfile %s for class %s."", hName, apKey);; 6497 } else {; 6498 nHheadersParsed++;; 6499 }; 6500 }; 6501 }; 6502 }; 6503 else {; 6504 // There is no header registered for this class, if this a; 6505 // template, it will be instantiated if/when it is requested; 6506 // and if we do no load/parse its components we might end up; 6507 // not using an eventual specialization.; 6508 if (strchr(apKey, '<')) {; 6509 nHheadersParsed += AutoParseImplRecurse(apKey, false);; 6510 }; 6511 }; 6512 }; 6513 }; 6514 ; 6515 return nHheadersParsed;; 6516 ; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Parse the headers relative to the class; 6521/// Returns 1 in case of success, 0 in case of failure; 6522 ; 6523Int_t TCling::AutoParse(const char *cls); 6524{; 6525 if (llvm::StringRef(cls).contains(""(lambda)"")); 6526 return 0;; 6527 ; 6528 if (!fHeaderParsingOnDemand || fIsAutoParsingSuspended) {; 6529 if (fClingCallbacks->IsAutoLoadingEnabled()) {; 6530 return AutoLoad(cls);; 6531 } else {; 6532 return 0;; 6533 }; 6534 }; 6535 ; 6536 R__LOCKGUARD(gInterpreterMutex);; 6537 ; 6538 if (gDebug > 1) {; 6539 Info(""TCling::AutoParse"",; 6540 ""Try",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:254704,Performance,load,loaded,254704,"/////////////////////////////////////////////; 6520/// Parse the headers relative to the class; 6521/// Returns 1 in case of success, 0 in case of failure; 6522 ; 6523Int_t TCling::AutoParse(const char *cls); 6524{; 6525 if (llvm::StringRef(cls).contains(""(lambda)"")); 6526 return 0;; 6527 ; 6528 if (!fHeaderParsingOnDemand || fIsAutoParsingSuspended) {; 6529 if (fClingCallbacks->IsAutoLoadingEnabled()) {; 6530 return AutoLoad(cls);; 6531 } else {; 6532 return 0;; 6533 }; 6534 }; 6535 ; 6536 R__LOCKGUARD(gInterpreterMutex);; 6537 ; 6538 if (gDebug > 1) {; 6539 Info(""TCling::AutoParse"",; 6540 ""Trying to autoparse for %s"", cls);; 6541 }; 6542 ; 6543 // The catalogue of headers is in the dictionary; 6544 if (fClingCallbacks->IsAutoLoadingEnabled(); 6545 && !gClassTable->GetDictNorm(cls)) {; 6546 // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).; 6547 ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),; 6548 fInterpreter->getSema());; 6549 AutoLoad(cls, true /*knowDictNotLoaded*/);; 6550 }; 6551 ; 6552 // Prevent the recursion when the library dictionary are loaded.; 6553 SuspendAutoLoadingRAII autoLoadOff(this);; 6554 ; 6555 // No recursive header parsing on demand; we require headers to be standalone.; 6556 SuspendAutoParsing autoParseRAII(this);; 6557 ; 6558 Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);; 6559 ; 6560 ProcessClassesToUpdate();; 6561 ; 6562 return nHheadersParsed > 0 ? 1 : 0;; 6563}; 6564 ; 6565// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the cal",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:255169,Performance,load,loadLibrary,255169," } else {; 6532 return 0;; 6533 }; 6534 }; 6535 ; 6536 R__LOCKGUARD(gInterpreterMutex);; 6537 ; 6538 if (gDebug > 1) {; 6539 Info(""TCling::AutoParse"",; 6540 ""Trying to autoparse for %s"", cls);; 6541 }; 6542 ; 6543 // The catalogue of headers is in the dictionary; 6544 if (fClingCallbacks->IsAutoLoadingEnabled(); 6545 && !gClassTable->GetDictNorm(cls)) {; 6546 // Need RAII against recursive (dictionary payload) parsing (ROOT-8445).; 6547 ROOT::Internal::ParsingStateRAII parsingStateRAII(fInterpreter->getParser(),; 6548 fInterpreter->getSema());; 6549 AutoLoad(cls, true /*knowDictNotLoaded*/);; 6550 }; 6551 ; 6552 // Prevent the recursion when the library dictionary are loaded.; 6553 SuspendAutoLoadingRAII autoLoadOff(this);; 6554 ; 6555 // No recursive header parsing on demand; we require headers to be standalone.; 6556 SuspendAutoParsing autoParseRAII(this);; 6557 ; 6558 Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);; 6559 ; 6560 ProcessClassesToUpdate();; 6561 ; 6562 return nHheadersParsed > 0 ? 1 : 0;; 6563}; 6564 ; 6565// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:255624,Performance,load,loadLibrary,255624,"ue /*knowDictNotLoaded*/);; 6550 }; 6551 ; 6552 // Prevent the recursion when the library dictionary are loaded.; 6553 SuspendAutoLoadingRAII autoLoadOff(this);; 6554 ; 6555 // No recursive header parsing on demand; we require headers to be standalone.; 6556 SuspendAutoParsing autoParseRAII(this);; 6557 ; 6558 Int_t nHheadersParsed = AutoParseImplRecurse(cls,/*topLevel=*/ true);; 6559 ; 6560 ProcessClassesToUpdate();; 6561 ; 6562 return nHheadersParsed > 0 ? 1 : 0;; 6563}; 6564 ; 6565// This is a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return success when LazyFunctionCreatorAutoload could find mangled_name; 6578 return true;; 6579 } else {; 6580 // The callback is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_ma",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:255919,Performance,load,loadLibrary,255919,"a function which gets callback from cling when DynamicLibraryManager->loadLibrary failed for some reason.; 6566// Try to solve the problem by AutoLoading. Return true when AutoLoading success, return; 6567// false if not.; 6568bool TCling::LibraryLoadingFailed(const std::string& errmessage, const std::string& libStem, bool permanent, bool resolved); 6569{; 6570 StringRef errMsg(errmessage);; 6571 if (errMsg.contains(""undefined symbol: "")) {; 6572 // This branch is taken when the callback was from DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return success when LazyFunctionCreatorAutoload could find mangled_name; 6578 return true;; 6579 } else {; 6580 // The callback is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false)",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:256698,Performance,load,loaded,256698," DynamicLibraryManager::loadLibrary; 6573 std::string mangled_name = std::string(errMsg.split(""undefined symbol: "").second);; 6574 void* res = ((TCling*)gCling)->LazyFunctionCreatorAutoload(mangled_name);; 6575 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 6576 if (res && DLM && (DLM->loadLibrary(libStem, permanent, resolved) == cling::DynamicLibraryManager::kLoadLibSuccess)); 6577 // Return success when LazyFunctionCreatorAutoload could find mangled_name; 6578 return true;; 6579 } else {; 6580 // The callback is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false) < 0) {; 6603 ::Error(""TCling__LazyFunctionCreatorAutoloadForModule"",; 6604 ""Failed to load library %s"", LibName.c_str());; 6605 return false;; 6606 }; 6607 return true; //success.; 6608 };; 6609 ; 6610 std::string libName = DLM.searchLibrariesForSymbol(mangled_name,; 6611 /*searchSystem=*/ true);; 6612 ; 6613 assert(!llvm::StringRef(libName).startswith(""libNew"") &&; 6614 ""We must not resolve symbols from libNew!"");; 6615 ; 6616 if (libName.empty()); 6617 return nullptr;; 6618 ; 6619 if (!LibLoa",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:257187,Performance,load,load,257187,"k is from IncrementalExecutor::diagnoseUnresolvedSymbols; 6581 if ( ((TCling*)gCling)->LazyFunctionCreatorAutoload(errmessage)); 6582 return true;; 6583 }; 6584 ; 6585 return false;; 6586}; 6587 ; 6588////////////////////////////////////////////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false) < 0) {; 6603 ::Error(""TCling__LazyFunctionCreatorAutoloadForModule"",; 6604 ""Failed to load library %s"", LibName.c_str());; 6605 return false;; 6606 }; 6607 return true; //success.; 6608 };; 6609 ; 6610 std::string libName = DLM.searchLibrariesForSymbol(mangled_name,; 6611 /*searchSystem=*/ true);; 6612 ; 6613 assert(!llvm::StringRef(libName).startswith(""libNew"") &&; 6614 ""We must not resolve symbols from libNew!"");; 6615 ; 6616 if (libName.empty()); 6617 return nullptr;; 6618 ; 6619 if (!LibLoader(libName)); 6620 return nullptr;; 6621 ; 6622 return llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name);; 6623}; 6624 ; 6625////////////////////////////////////////////////////////////////////////////////; 6626 ; 6627Bool_t TCling::IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl); 6628{; 6629 return fNSFromRootmaps.count(nsDecl) != 0;; 6630}; 6631 ; 6632////////////////////////////////////////////////////////////////////////////////; 6633/// Internal function. Actually do the update of the ClassInfo wh",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:262080,Performance,load,loaded,262080," Ignore declaration within a function.; 6697 return;; 6698 }; 6699 ; 6700 auto declName = tdDef->getNameAsString();; 6701 // Check if we have registered the unqualified name into the list; 6702 // of TClass that are in kNoInfo, kEmulated or kFwdDeclaredState.; 6703 // Since this is used as heureutistic to avoid spurrious calls to GetNormalizedName; 6704 // the unqualified name is sufficient (and the fully qualified name might be; 6705 // 'wrong' if there is difference in spelling in the template paramters (for example); 6706 if (!TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(declName.c_str())){; 6707 // fprintf (stderr,""WARNING: Impossible to find a TClassEntry in kNoInfo or kEmulated the decl of which would be called %s. Skip w/o building the normalized name.\n"",declName.c_str() );; 6708 return;; 6709 }; 6710 ; 6711 clang::QualType type(tdDef->getTypeForDecl(), 0);; 6712 ROOT::TMetaUtils::GetNormalizedName(name, type, *fInterpreter, *fNormalizedCtxt);; 6713 } else if (ns) {; 6714 canon = ns->getCanonicalDecl();; 6715 name = ND->getQualifiedNameAsString();; 6716 } else {; 6717 name = ND->getQualifiedNameAsString();; 6718 }; 6719 ; 6720 // Supposedly we are being called while something is being; 6721 // loaded ... let's now tell the autoloader to do the work; 6722 // yet another time.; 6723 SuspendAutoLoadingRAII autoLoadOff(this);; 6724 // FIXME: There can be more than one TClass for a single decl.; 6725 // for example vector<double> and vector<Double32_t>; 6726 TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(name.c_str());; 6727 if (cl && GetModTClasses().find(cl) == GetModTClasses().end()) {; 6728 RefreshClassInfo(cl, canon, false);; 6729 }; 6730 // And here we should find the other 'aliases' (eg. vector<Double32_t>); 6731 // and update them too:; 6732 // foreach(aliascl in gROOT->GetListOfClasses()->FindAliasesOf(name.c_str())); 6733 // RefreshClassInfo(cl, tdDef, true);; 6734}; 6735 ; 6736/////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:266103,Performance,cache,caches,266103,"4 TransactionDeclSet.insert(*DI);; 6795 ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);; 6796 }; 6797 }; 6798 }; 6799 ; 6800 // The above might trigger more decls to be deserialized.; 6801 // Thus the iteration over the deserialized decls must be last.; 6802 for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),; 6803 E = T.deserialized_decls_end(); I != E; ++I) {; 6804 for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),; 6805 DE = I->m_DGR.end(); DI != DE; ++DI); 6806 if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {; 6807 //FIXME: HandleNewDecl should take DeclGroupRef; 6808 ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,; 6809 modifiedTClasses);; 6810 }; 6811 }; 6812 ; 6813 ; 6814 // When fully building the reflection info in TClass, a deserialization; 6815 // could be triggered, which may result in request for building the; 6816 // reflection info for the same TClass. This in turn will clear the caches; 6817 // for the TClass in-flight and cause null ptr derefs.; 6818 // FIXME: This is a quick fix, solving most of the issues. The actual; 6819 // question is: Shouldn't TClass provide a lock mechanism on update or lock; 6820 // itself until the update is done.; 6821 //; 6822 std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());; 6823 std::vector<TClass*>::iterator it;; 6824 it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),; 6825 ((TCling*)gCling)->GetModTClasses().begin(),; 6826 ((TCling*)gCling)->GetModTClasses().end(),; 6827 modifiedTClassesDiff.begin());; 6828 modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());; 6829 ; 6830 // Lock the TClass for updates; 6831 ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),; 6832 modifiedTClassesDiff.end());; 6833 for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),; 6834 E = modifiedTClassesDiff.end(); I != E; ++I) {; 6835 // Make sure the TClass has not been deleted.",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:268455,Performance,cache,cached,268455,"RAII(GetInterpreterImpl());; 6841 // Unlock the TClass for updates; 6842 ((TCling*)gCling)->GetModTClasses().erase(*I);; 6843 ; 6844 }; 6845}; 6846 ; 6847///\brief Invalidate stored TCling state for declarations included in transaction `T'.; 6848///; 6849void TCling::UpdateListsOnUnloaded(const cling::Transaction &T); 6850{; 6851 HandleNewTransaction(T);; 6852 ; 6853 auto Lists = std::make_tuple((TListOfDataMembers *)gROOT->GetListOfGlobals(),; 6854 (TListOfFunctions *)gROOT->GetListOfGlobalFunctions(),; 6855 (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),; 6856 (TListOfEnums *)gROOT->GetListOfEnums());; 6857 ; 6858 cling::Transaction::const_nested_iterator iNested = T.nested_begin();; 6859 for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();; 6860 I != E; ++I) {; 6861 if (I->m_Call == cling::Transaction::kCCIHandleVTable); 6862 continue;; 6863 if (I->m_Call == cling::Transaction::kCCINone) {; 6864 UpdateListsOnUnloaded(*(*iNested));; 6865 ++iNested;; 6866 continue;; 6867 }; 6868 ; 6869 for (auto &D : I->m_DGR); 6870 InvalidateCachedDecl(Lists, D);; 6871 }; 6872}; 6873 ; 6874///\brief Invalidate cached TCling information for the given global declaration.; 6875///; 6876void TCling::InvalidateGlobal(const Decl *D) {; 6877 auto Lists = std::make_tuple((TListOfDataMembers *)gROOT->GetListOfGlobals(),; 6878 (TListOfFunctions *)gROOT->GetListOfGlobalFunctions(),; 6879 (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),; 6880 (TListOfEnums *)gROOT->GetListOfEnums());; 6881 InvalidateCachedDecl(Lists, D);; 6882}; 6883 ; 6884///\brief Invalidate cached TCling information for the given declaration, and; 6885/// removed it from the appropriate object list.; 6886///\param[in] Lists - std::tuple<TListOfDataMembers&, TListOfFunctions&,; 6887/// TListOfFunctionTemplates&, TListOfEnums&>; 6888/// of pointers to the (global/class) object lists.; 6889///\param[in] D - Decl to discard.; 6890///; 6891void TCling::InvalidateCached",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:268918,Performance,cache,cached,268918,")gROOT->GetListOfGlobalFunctions(),; 6855 (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),; 6856 (TListOfEnums *)gROOT->GetListOfEnums());; 6857 ; 6858 cling::Transaction::const_nested_iterator iNested = T.nested_begin();; 6859 for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();; 6860 I != E; ++I) {; 6861 if (I->m_Call == cling::Transaction::kCCIHandleVTable); 6862 continue;; 6863 if (I->m_Call == cling::Transaction::kCCINone) {; 6864 UpdateListsOnUnloaded(*(*iNested));; 6865 ++iNested;; 6866 continue;; 6867 }; 6868 ; 6869 for (auto &D : I->m_DGR); 6870 InvalidateCachedDecl(Lists, D);; 6871 }; 6872}; 6873 ; 6874///\brief Invalidate cached TCling information for the given global declaration.; 6875///; 6876void TCling::InvalidateGlobal(const Decl *D) {; 6877 auto Lists = std::make_tuple((TListOfDataMembers *)gROOT->GetListOfGlobals(),; 6878 (TListOfFunctions *)gROOT->GetListOfGlobalFunctions(),; 6879 (TListOfFunctionTemplates *)gROOT->GetListOfFunctionTemplates(),; 6880 (TListOfEnums *)gROOT->GetListOfEnums());; 6881 InvalidateCachedDecl(Lists, D);; 6882}; 6883 ; 6884///\brief Invalidate cached TCling information for the given declaration, and; 6885/// removed it from the appropriate object list.; 6886///\param[in] Lists - std::tuple<TListOfDataMembers&, TListOfFunctions&,; 6887/// TListOfFunctionTemplates&, TListOfEnums&>; 6888/// of pointers to the (global/class) object lists.; 6889///\param[in] D - Decl to discard.; 6890///; 6891void TCling::InvalidateCachedDecl(const std::tuple<TListOfDataMembers*,; 6892 TListOfFunctions*,; 6893 TListOfFunctionTemplates*,; 6894 TListOfEnums*> &Lists, const Decl *D) {; 6895 if (D->isFromASTFile()) // `D' came from the PCH; ignore; 6896 return;; 6897 ; 6898 TListOfDataMembers &LODM = *(std::get<0>(Lists));; 6899 TListOfFunctions &LOF = *(std::get<1>(Lists));; 6900 TListOfFunctionTemplates &LOFT = *(std::get<2>(Lists));; 6901 TListOfEnums &LOE = *(std::get<3>(Lists));; 6902 ; 6903 if (isa<V",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:273207,Performance,load,loaded,273207,"id TCling::TransactionRollback(const cling::Transaction &T) {; 6952 auto const &triter = fTransactionHeadersMap.find(&T);; 6953 if (triter != fTransactionHeadersMap.end()) {; 6954 std::size_t normNameHash = triter->second;; 6955 ; 6956 fLookedUpClasses.erase(normNameHash);; 6957 ; 6958 auto const &iter = fClassesHeadersMap.find(normNameHash);; 6959 if (iter != fClassesHeadersMap.end()) {; 6960 auto const &hNamesPtrs = iter->second;; 6961 for (auto &hName : hNamesPtrs) {; 6962 if (gDebug > 0) {; 6963 Info(""TransactionRollback"",; 6964 ""Restoring ability to autoaparse: %s"", hName);; 6965 }; 6966 fParsedPayloadsAddresses.erase(hName);; 6967 }; 6968 }; 6969 }; 6970}; 6971 ; 6972////////////////////////////////////////////////////////////////////////////////; 6973 ; 6974void TCling::LibraryLoaded(const void* dyLibHandle, const char* canonicalName) {; 6975// R__LOCKGUARD_CLING(gInterpreterMutex);; 6976// UpdateListOfLoadedSharedLibraries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980 ; 6981void TCling::LibraryUnloaded(const void* dyLibHandle, const char* canonicalName) {; 6982 fPrevLoadedDynLibInfo = nullptr;; 6983 fSharedLibs = """";; 6984}; 6985 ; 6986////////////////////////////////////////////////////////////////////////////////; 6987/// Return the list of shared libraries loaded into the process.; 6988 ; 6989const char* TCling::GetSharedLibs(); 6990{; 6991 R__LOCKGUARD_CLING(gInterpreterMutex);; 6992 UpdateListOfLoadedSharedLibraries();; 6993 return fSharedLibs;; 6994}; 6995 ; 6996static std::string GetClassSharedLibsForModule(const char *cls, cling::LookupHelper &LH, bool skipCore); 6997{; 6998 if (!cls || !*cls); 6999 return {};; 7000 ; 7001 using namespace clang;; 7002 if (const Decl *D = LH.findScope(cls, cling::LookupHelper::NoDiagnostics,; 7003 /*type*/ nullptr, /*instantiate*/ false)) {; 7004 if (!D->isFromASTFile()) {; 7005 if (gDebug > 5); 7006 Warning(""GetClassSharedLibsForModule"", ""Decl found for %",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:279904,Performance,load,loaded,279904,"ing(""Library."") + cls;; 7135 // convert ""::"" to ""@@"", we used ""@@"" because TEnv; 7136 // considers ""::"" a terminator; 7137 c.ReplaceAll(""::"", ""@@"");; 7138 // convert ""-"" to "" "", since class names may have; 7139 // blanks and TEnv considers a blank a terminator; 7140 c.ReplaceAll("" "", ""-"");; 7141 // Use TEnv::Lookup here as the rootmap file must start with Library.; 7142 // and do not support using any stars (so we do not need to waste time; 7143 // with the search made by TEnv::GetValue).; 7144 TEnvRec* libs_record = nullptr;; 7145 libs_record = fMapfile->Lookup(c);; 7146 if (libs_record) {; 7147 const char* libs = libs_record->GetValue();; 7148 return (*libs) ? libs : nullptr;; 7149 }; 7150 }; 7151 }; 7152 return nullptr;; 7153}; 7154 ; 7155/// This interface returns a list of dependent libraries in the form:; 7156/// lib libA.so libB.so libC.so. The first library is the library we are; 7157/// searching dependencies for.; 7158/// Note: In order to speed up the search, we display the dependencies of the; 7159/// libraries which are not yet loaded. For instance, if libB.so was already; 7160/// loaded the list would contain: lib libA.so libC.so.; 7161static std::string GetSharedLibImmediateDepsSlow(std::string lib,; 7162 cling::Interpreter *interp,; 7163 bool skipLoadedLibs = true); 7164{; 7165 TString LibFullPath(lib);; 7166 if (!llvm::sys::path::is_absolute(lib)) {; 7167 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 7168 Error(""TCling__GetSharedLibImmediateDepsSlow"", ""Cannot find library '%s'"", lib.c_str());; 7169 return """";; 7170 }; 7171 } else {; 7172 assert(llvm::sys::fs::exists(lib) && ""Must exist!"");; 7173 lib = llvm::sys::path::filename(lib).str();; 7174 }; 7175 ; 7176 auto ObjF = llvm::object::ObjectFile::createObjectFile(LibFullPath.Data());; 7177 if (!ObjF) {; 7178 Warning(""TCling__GetSharedLibImmediateDepsSlow"", ""Failed to read object file %s"", lib.c_str());; 7179 return """";; 7180 }; 7181 ; 7182 llvm::object::ObjectFile *BinObjFile = O",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:279958,Performance,load,loaded,279958,"137 c.ReplaceAll(""::"", ""@@"");; 7138 // convert ""-"" to "" "", since class names may have; 7139 // blanks and TEnv considers a blank a terminator; 7140 c.ReplaceAll("" "", ""-"");; 7141 // Use TEnv::Lookup here as the rootmap file must start with Library.; 7142 // and do not support using any stars (so we do not need to waste time; 7143 // with the search made by TEnv::GetValue).; 7144 TEnvRec* libs_record = nullptr;; 7145 libs_record = fMapfile->Lookup(c);; 7146 if (libs_record) {; 7147 const char* libs = libs_record->GetValue();; 7148 return (*libs) ? libs : nullptr;; 7149 }; 7150 }; 7151 }; 7152 return nullptr;; 7153}; 7154 ; 7155/// This interface returns a list of dependent libraries in the form:; 7156/// lib libA.so libB.so libC.so. The first library is the library we are; 7157/// searching dependencies for.; 7158/// Note: In order to speed up the search, we display the dependencies of the; 7159/// libraries which are not yet loaded. For instance, if libB.so was already; 7160/// loaded the list would contain: lib libA.so libC.so.; 7161static std::string GetSharedLibImmediateDepsSlow(std::string lib,; 7162 cling::Interpreter *interp,; 7163 bool skipLoadedLibs = true); 7164{; 7165 TString LibFullPath(lib);; 7166 if (!llvm::sys::path::is_absolute(lib)) {; 7167 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 7168 Error(""TCling__GetSharedLibImmediateDepsSlow"", ""Cannot find library '%s'"", lib.c_str());; 7169 return """";; 7170 }; 7171 } else {; 7172 assert(llvm::sys::fs::exists(lib) && ""Must exist!"");; 7173 lib = llvm::sys::path::filename(lib).str();; 7174 }; 7175 ; 7176 auto ObjF = llvm::object::ObjectFile::createObjectFile(LibFullPath.Data());; 7177 if (!ObjF) {; 7178 Warning(""TCling__GetSharedLibImmediateDepsSlow"", ""Failed to read object file %s"", lib.c_str());; 7179 return """";; 7180 }; 7181 ; 7182 llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();; 7183 ; 7184 std::set<string> DedupSet;; 7185 std::string Result = lib + ' ';; 7186 for (const a",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:282776,Performance,load,loaded,282776,"9 }; 7200 llvm::StringRef SymName = SymNameErr.get();; 7201 if (SymName.empty()); 7202 continue;; 7203 ; 7204 if (BinObjFile->isELF()) {; 7205 // Skip the symbols which are part of the C/C++ runtime and have a; 7206 // fixed library version. See binutils ld VERSION. Those reside in; 7207 // 'system' libraries, which we avoid in FindLibraryForSymbol.; 7208 if (SymName.contains(""@GLIBCXX"") || SymName.contains(""@CXXABI"") ||; 7209 SymName.contains(""@GLIBC"") || SymName.contains(""@GCC"")); 7210 continue;; 7211 ; 7212 // Those are 'weak undefined' symbols produced by gcc. We can; 7213 // ignore them.; 7214 // FIXME: It is unclear whether we can ignore all weak undefined; 7215 // symbols:; 7216 // http://lists.llvm.org/pipermail/llvm-dev/2017-October/118177.html; 7217 static constexpr llvm::StringRef RegisterClasses(""_Jv_RegisterClasses"");; 7218 static constexpr llvm::StringRef RegisterCloneTable(""_ITM_registerTMCloneTable"");; 7219 static constexpr llvm::StringRef DeregisterCloneTable(""_ITM_deregisterTMCloneTable"");; 7220 if (SymName == RegisterClasses ||; 7221 SymName == RegisterCloneTable ||; 7222 SymName == DeregisterCloneTable); 7223 continue;; 7224 }; 7225 ; 7226 // If we can find the address of the symbol, we have loaded it. Skip.; 7227 if (skipLoadedLibs) {; 7228 std::string SymNameForDlsym = ROOT::TMetaUtils::DemangleNameForDlsym(SymName.str());; 7229 if (llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(SymNameForDlsym)); 7230 continue;; 7231 }; 7232 ; 7233 R__LOCKGUARD(gInterpreterMutex);; 7234 std::string found = interp->getDynamicLibraryManager()->searchLibrariesForSymbol(SymName, /*searchSystem*/false);; 7235 // The expected output is just filename without the full path, which; 7236 // is not very accurate, because our Dyld implementation might find; 7237 // a match in location a/b/c.so and if we return just c.so ROOT might; 7238 // resolve it to y/z/c.so and there we might not be ABI compatible.; 7239 // FIXME: Teach the users of GetSharedLibDeps to work with",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:285679,Performance,load,loading,285679,"Files()->FindObject(rootmapNameNoLib.data());; 7269 ; 7270 return false;; 7271}; 7272 ; 7273static bool hasPrecomputedLibraryDeps(llvm::StringRef lib); 7274{; 7275 if (gCling->HasPCMForLibrary(lib.data())); 7276 return true;; 7277 ; 7278 return hasParsedRootmapForLibrary(lib);; 7279}; 7280 ; 7281////////////////////////////////////////////////////////////////////////////////; 7282/// Get the list a libraries on which the specified lib depends. The; 7283/// returned string contains as first element the lib itself.; 7284/// Returns 0 in case the lib does not exist or does not have; 7285/// any dependencies. If useDyld is true, we iterate through all available; 7286/// libraries and try to construct the dependency chain by resolving each; 7287/// symbol.; 7288 ; 7289const char* TCling::GetSharedLibDeps(const char* lib, bool useDyld/* = false*/); 7290{; 7291 if (llvm::sys::path::is_absolute(lib) && !llvm::sys::fs::exists(lib)); 7292 return nullptr;; 7293 ; 7294 if (!hasParsedRootmapForLibrary(lib)) {; 7295 llvm::SmallString<512> rootmapName(lib);; 7296 llvm::sys::path::replace_extension(rootmapName, ""rootmap"");; 7297 if (llvm::sys::fs::exists(rootmapName)) {; 7298 if (gDebug > 0); 7299 Info(""Load"", ""loading %s"", rootmapName.c_str());; 7300 gInterpreter->LoadLibraryMap(rootmapName.c_str());; 7301 }; 7302 }; 7303 ; 7304 if (hasPrecomputedLibraryDeps(lib) && useDyld) {; 7305 if (gDebug > 0); 7306 Warning(""TCling::GetSharedLibDeps"", ""Precomputed dependencies available but scanning '%s'"", lib);; 7307 }; 7308 ; 7309 if (useDyld) {; 7310 std::string libs = GetSharedLibImmediateDepsSlow(lib, GetInterpreterImpl());; 7311 if (!libs.empty()) {; 7312 fAutoLoadLibStorage.push_back(libs);; 7313 return fAutoLoadLibStorage.back().c_str();; 7314 }; 7315 }; 7316 ; 7317 if (!fMapfile || !lib || !lib[0]) {; 7318 return nullptr;; 7319 }; 7320 TString libname(lib);; 7321 Ssiz_t idx = libname.Last('.');; 7322 if (idx != kNPOS) {; 7323 libname.Remove(idx);; 7324 }; 7325 TEnvRec* rec;; 7326 TIte",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:300973,Performance,cache,cache,300973,"ue*>(value.GetValAddr());; 7691 RegisterTemporary(*V);; 7692}; 7693 ; 7694////////////////////////////////////////////////////////////////////////////////; 7695/// Register value as a temporary, extending its lifetime to that of the; 7696/// interpreter. This is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are in the middle of parsing, so let's make; 7719 // sure to save the state and then restore it.; 7720 ; 7721 if (gDirectory) {; 7722 auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);; 7723 if (iSpecObjMap != fSpecialObjectMaps.end()) {; 7724 auto iSpecObj = iSpecObjMap->second.find(Name);; 7725 if (iSpecObj != iSpecObjMap->second.end()) {; 7726 LookupCtx = gDirectory;; 7727 return iSpecObj->second;; 7728 }; 7729 }; 7730 }; 7731 ; 7732 // Save state of the PP; 7733 Sema &SemaR = fInterpreter->getSema();; 7734 ASTContext& C = SemaR.getASTContext();; 7735 Preprocessor &PP = SemaR.getPreprocessor();; 7736 Parser& P = const_cast<Parser&>(fInterpreter->getParser());; 7737 Preproces",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:301231,Performance,load,loading,301231,"is is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are in the middle of parsing, so let's make; 7719 // sure to save the state and then restore it.; 7720 ; 7721 if (gDirectory) {; 7722 auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);; 7723 if (iSpecObjMap != fSpecialObjectMaps.end()) {; 7724 auto iSpecObj = iSpecObjMap->second.find(Name);; 7725 if (iSpecObj != iSpecObjMap->second.end()) {; 7726 LookupCtx = gDirectory;; 7727 return iSpecObj->second;; 7728 }; 7729 }; 7730 }; 7731 ; 7732 // Save state of the PP; 7733 Sema &SemaR = fInterpreter->getSema();; 7734 ASTContext& C = SemaR.getASTContext();; 7735 Preprocessor &PP = SemaR.getPreprocessor();; 7736 Parser& P = const_cast<Parser&>(fInterpreter->getParser());; 7737 Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);; 7738 Parser::ParserCurTokRestoreRAII savedCurToken(P);; 7739 // After we have saved the token reset the current one to something which; 7740 // is safe (semi colon usually means empty decl); 7741 Token& Tok ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:373523,Performance,race condition,race condition,373523,", update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 std::swap(uniqueP->fInitialState, fInitialMutex);; 9670 uniqueP->fDelta = gCoreMutex->Rewind(*uniqueP->fInitialState.fState);; 9671 return uniqueP.release();; 9672 }; 9673 R__ASSERT(fInitialMutex.fRecurseCount == 0);; 9674 return nullptr;; 9675}; ClingRAII.h; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; RConversionRuleP",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:378675,Performance,load,loadGlobalModuleIndexstatic,378675," ETupleOrderingETupleOrderingCheck in what order the member of a tuple are layout.Definition TCling.cxx:3905; ETupleOrdering::kAscending@ kAscending; ETupleOrdering::kDescending@ kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassSharedLibsconst char * TCling__GetClassSharedLibs(const char *className, bool skipCore)Definition TCling.cxx:633; loadGlobalModuleIndexstatic GlobalModuleIndex * loadGlobalModuleIndex(cling::Interpreter &interp)Definition TCling.cxx:1080; TClingLookupHelper__ExistingTypeCheckbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname, std::string &result)Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing.Definition TCling.cxx:903; HasASTFileOnDiskstatic bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr)Checks if there is an ASTFile on disk for the given module M.Definition TCling.cxx:1065; TCling__UnlockCompilationDuringUserCodeExecutionvoid TCling__UnlockCompilationDuringUserCodeExecution(void *)Unlock the interpreter.Definition TCling.cxx:379; AlternateTuplestatic std::string AlternateTuple(const char *classname, const cling::LookupHelper &lh, Bool_t silent)Definition TCling.cxx:3947; R__InitStreamerInfoFactorystatic bool R__InitStreamerInfoFactory()Helper to initialize TVirtualStreamerInfo's factor early.Definition TCling.cxx:1664; TCling__",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:378723,Performance,load,loadGlobalModuleIndex,378723," ETupleOrderingETupleOrderingCheck in what order the member of a tuple are layout.Definition TCling.cxx:3905; ETupleOrdering::kAscending@ kAscending; ETupleOrdering::kDescending@ kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassSharedLibsconst char * TCling__GetClassSharedLibs(const char *className, bool skipCore)Definition TCling.cxx:633; loadGlobalModuleIndexstatic GlobalModuleIndex * loadGlobalModuleIndex(cling::Interpreter &interp)Definition TCling.cxx:1080; TClingLookupHelper__ExistingTypeCheckbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname, std::string &result)Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing.Definition TCling.cxx:903; HasASTFileOnDiskstatic bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr)Checks if there is an ASTFile on disk for the given module M.Definition TCling.cxx:1065; TCling__UnlockCompilationDuringUserCodeExecutionvoid TCling__UnlockCompilationDuringUserCodeExecution(void *)Unlock the interpreter.Definition TCling.cxx:379; AlternateTuplestatic std::string AlternateTuple(const char *classname, const cling::LookupHelper &lh, Bool_t silent)Definition TCling.cxx:3947; R__InitStreamerInfoFactorystatic bool R__InitStreamerInfoFactory()Helper to initialize TVirtualStreamerInfo's factor early.Definition TCling.cxx:1664; TCling__",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:399256,Performance,load,load,399256,"s is a static function).Definition TClassTable.cxx:398; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3465; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassst",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:401161,Performance,cache,caches,401161,"ne after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::kLoading@ kLoadingDefinition TClass.h:332; TClass::kUnloading@ kUnloadingDefinition TClass.h:332; TClass::fStreamerInfoTObjArray * fStreamerInfoDefinition TClass.h:198; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::GetClassInfoClassInfo_t * GetClassInfo() constDefinition TClass.h:433; TClass::fClassInfoClassInfo_t * fClassInfoDefinition TClass.h:222; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::ResetCachesvoid ResetCaches()To clean out all caches.Definition TClass.cxx:4282; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:402286,Performance,load,load,402286,"d as a Long_t value.Definition TClass.cxx:6153; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::fHasRootPcmInfostd::atomic< Bool_t > fHasRootPcmInfoC++ Property of the class (is abstract, has virtual table, etc.)Definition TClass.h:259; TClass::GetDeclFileNameconst char * GetDeclFileName() constReturn name of the file containing the declaration of this class.Definition TClass.cxx:3530; TClass::kIsTObject@ kIsTObjectDefinition TClass.h:100; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClingBaseClassInfoEmulation of the CINT BaseClassInfo class.Definition TClingBaseClassInfo.h:43; TClingBaseClassInfo::TmpltNameconst char * TmpltName() constDefinition TClingBaseClassInfo.cxx:578; TClingBaseClassInfo::Nameconst char * Name() constDefinition TClingBaseClassInfo.cxx:570; TClingBaseClassInfo::Offsetptrdiff_t Offset(void *address=0, bool isDerivedObject=true) constDefinition TClingBaseClassInfo.cxx:411; TClingBaseClassInfo::IsValidbool IsValid() constDefinition TClingBaseClassInfo.cxx:244; TClingBaseClassInfo::Nextint Next()Definition TClingBaseClassInfo.cxx:353; TClingBaseClassInfo::Tagnumlong Tagnum() constDefinition TClingBaseClassInfo.cxx:553; TClingBaseClassInfo::Propertylong Property() constDefinition TClingBaseClassInfo.cxx:488; TClingBaseClassInfo::FullNamevoid FullName(std::string &output, const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt) constDefi",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:419736,Performance,cache,cached,419736,"nfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrvoid SetDeclAttr(DeclId_t, const char *) finalDefinition TCling.cxx:8725; TCling::HandleNewDeclvoid HandleNewDecl(const void *DV, bool isDeserialized, std::set< TClass * > &modifiedClasses)Definition TCling.cxx:496; TCling::InvalidateCachedDeclvoid InvalidateCachedDecl(const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D)Invalidate cached TCling information for the given declaration, and removed it from the appropriate o...Definition TCling.cxx:6891; TCling::MethodInfo_PropertyLong_t MethodInfo_Property(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9091; TCling::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const finalCreate list of pointers to function templates for TClass cl.Definition TCling.cxx:4442; TCling::ClassInfo_IsValidMethodbool ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8336; TCling::DataMemberInfo_PropertyLong_t DataMemberInfo_Property(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8658; TCling::SetClassAutoparsingint SetClassAutoparsing(int) finalEnable/Disable the Autoparsing of headers.Definition TCling.cxx:7585; TCling::fCurExecutingMacrosstd::vector< const cha",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:423338,Performance,cache,cached,423338,"fo) const finalDefinition TCling.cxx:9188; TCling::GetObjectAddressTObject * GetObjectAddress(const char *Name, void *&LookupCtx)If the interpreter encounters Name, check whether that is an object ROOT could retrieve.Definition TCling.cxx:7714; TCling::ProcessLineAsynchLongptr_t ProcessLineAsynch(const char *line, EErrorCode *error=nullptr)Let cling process a command line asynch.Definition TCling.cxx:3560; TCling::MethodInfo_IsValidbool MethodInfo_IsValid(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9059; TCling::TClingTCling(); TCling::FuncTempInfo_FactoryFuncTempInfo_t * FuncTempInfo_Factory(DeclId_t declid) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8815; TCling::TypeInfo_FactoryTypeInfo_t * TypeInfo_Factory() const finalDefinition TCling.cxx:9348; TCling::IsClassAutoLoadingEnabledbool IsClassAutoLoadingEnabled() constReturns if class AutoLoading is currently enabled.Definition TCling.cxx:7554; TCling::InvalidateGlobalvoid InvalidateGlobal(const clang::Decl *D)Invalidate cached TCling information for the given global declaration.Definition TCling.cxx:6876; TCling::Evaluateint Evaluate(const char *, TInterpreterValue &) finalGet the interpreter value corresponding to the statement.Definition TCling.cxx:7678; TCling::MakeInterpreterValuestd::unique_ptr< TInterpreterValue > MakeInterpreterValue() const finalDefinition TCling.cxx:7663; TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resou",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:424721,Performance,load,load,424721,"TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:66",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:426341,Performance,load,loaded,426341,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:435344,Performance,load,loaded,435344,"nal[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:435420,Performance,load,load,435420,"nal[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::s",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:439386,Performance,load,load,439386,"tMutexStatevoid ForgetMutexState() finalDefinition TCling.cxx:9618; TCling::MethodInfo_Nextint MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:439660,Performance,load,loaded,439660,"tyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(T",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:442185,Performance,load,loaded,442185,"IncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTemporary(const TInterpreterValue &value)Definition TCling.cxx:7687; TCling::fInitialMutexMutexStateAndRecurseCount fInitialMutexDefinition TCling.h:174; TCling::GetSharedLibsconst char * GetSharedLibs() finalReturn the list of shared libraries loaded into the process.Definition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template described by ft_info.Definition TCling.cxx:8860; TCling::fTemporariesstd::vector< cling::Value > * fTemporariesDefinition TCling.h:133; TCling::RegisterModulevoid RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *paylo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:443401,Performance,load,load,443401,"nition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template described by ft_info.Definition TCling.cxx:8860; TCling::fTemporariesstd::vector< cling::Value > * fTemporariesDefinition TCling.h:133; TCling::RegisterModulevoid RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) finalInject the module named ""modulename"" into cling; load all headers.Definition TCling.cxx:2010; TCling::ShallowAutoLoadImplstatic Int_t ShallowAutoLoadImpl(const char *cls)Definition TCling.cxx:6156; TCling::MethodInfo_CreateSignaturevoid MethodInfo_CreateSignature(MethodInfo_t *minfo, TString &signature) const finalDefinition TCling.cxx:9009; TCling::CheckClassTemplateBool_t CheckClassTemplate(const char *name) finalReturn true if there is a class template by the given name ...Definition TCling.cxx:4349; TCling::LibraryLoadedvoid LibraryLoaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6974; TCling::RegisterTClassUpdatevoid RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict) finalRegister classes that already existed prior to their dictionary loading and that already had a ClassI...Definition TCling.cxx:2384; TCling::",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:444138,Performance,load,loading,444138,"ulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) finalInject the module named ""modulename"" into cling; load all headers.Definition TCling.cxx:2010; TCling::ShallowAutoLoadImplstatic Int_t ShallowAutoLoadImpl(const char *cls)Definition TCling.cxx:6156; TCling::MethodInfo_CreateSignaturevoid MethodInfo_CreateSignature(MethodInfo_t *minfo, TString &signature) const finalDefinition TCling.cxx:9009; TCling::CheckClassTemplateBool_t CheckClassTemplate(const char *name) finalReturn true if there is a class template by the given name ...Definition TCling.cxx:4349; TCling::LibraryLoadedvoid LibraryLoaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6974; TCling::RegisterTClassUpdatevoid RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict) finalRegister classes that already existed prior to their dictionary loading and that already had a ClassI...Definition TCling.cxx:2384; TCling::GetRootMapFilesTObjArray * GetRootMapFiles() const finalDefinition TCling.h:223; TCling::DataMemberInfo_IsValidbool DataMemberInfo_IsValid(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8626; TCling::ClassInfo_IsEnumbool ClassInfo_IsEnum(const char *name) const finalDefinition TCling.cxx:8295; TCling::MethodInfo_NDefaultArgint MethodInfo_NDefaultArg(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9075; TCling::CreateListOfMethodsvoid CreateListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsT",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:452844,Performance,load,load,452844,"rty(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8529; TCling::CallFunc_SetFuncvoid CallFunc_SetFunc(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *params, Longptr_t *Offset) const finalDefinition TCling.cxx:8038; TCling::GetUsingNamespacesstd::vector< std::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TString &name) const finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:453987,Performance,load,loaded,453987,"eCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelMacroName() const finalReturn the file name of the current un-included interpreted file.Definition TCling.cxx:5416; TCling::fPrevLoadedDynLibInfovoid * fPrevLoadedDynLibInfoDefinition TCling.h:137; TCling::UpdateListOfDataMembersvoid UpdateListOfDataMembers(TClass *cl) constUpdate the list of pointers to data members for TClass cl This is now a nop.Definition TCling.cxx:4516; TCling::InspectMembersvoid InspectMembers(TMemberInspector &, const void *obj, const TClass *c",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:463296,Performance,load,loading,463296,"r(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnu",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:483092,Performance,load,loads,483092,"tual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetDynamicPathvirtual const char * GetDynamicPath()Return the dynamic path (used to find shared libraries).Definition TSystem.cxx:1795; TSystem::FindDynamicLibraryvirtual const char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE)Find a dynamic library using the system search paths.Definition TSystem.cxx:2034; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::DynamicPathNamechar * DynamicPathName(const cha",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:2501,Safety,avoid,avoid,2501,"; 45#include ""TDataMember.h""; 46#include ""TMemberInspector.h""; 47#include ""TMethod.h""; 48#include ""TMethodArg.h""; 49#include ""TFunctionTemplate.h""; 50#include ""TObjArray.h""; 51#include ""TObjString.h""; 52#include ""TString.h""; 53#include ""THashList.h""; 54#include ""TVirtualPad.h""; 55#include ""TSystem.h""; 56#include ""TVirtualMutex.h""; 57#include ""TError.h""; 58#include ""TEnv.h""; 59#include ""TEnum.h""; 60#include ""TEnumConstant.h""; 61#include ""THashTable.h""; 62#include ""RConversionRuleParser.h""; 63#include ""RConfigure.h""; 64#include ""compiledata.h""; 65#include ""strlcpy.h""; 66#include ""snprintf.h""; 67#include ""TClingUtils.h""; 68#include ""TVirtualCollectionProxy.h""; 69#include ""TVirtualStreamerInfo.h""; 70#include ""TListOfDataMembers.h""; 71#include ""TListOfEnums.h""; 72#include ""TListOfEnumsWithLock.h""; 73#include ""TListOfFunctions.h""; 74#include ""TListOfFunctionTemplates.h""; 75#include ""TMemFile.h""; 76#include ""TProtoClass.h""; 77#include ""TStreamerInfo.h"" // This is here to avoid to use the plugin manager; 78#include ""ThreadLocalStorage.h""; 79#include ""TFile.h""; 80#include ""TKey.h""; 81#include ""ClingRAII.h""; 82 ; 83#include ""clang/AST/ASTContext.h""; 84#include ""clang/AST/Decl.h""; 85#include ""clang/AST/DeclarationName.h""; 86#include ""clang/AST/GlobalDecl.h""; 87#include ""clang/AST/RecordLayout.h""; 88#include ""clang/AST/DeclVisitor.h""; 89#include ""clang/AST/RecursiveASTVisitor.h""; 90#include ""clang/AST/Type.h""; 91#include ""clang/Basic/SourceLocation.h""; 92#include ""clang/Basic/Specifiers.h""; 93#include ""clang/Basic/TargetInfo.h""; 94#include ""clang/CodeGen/ModuleBuilder.h""; 95#include ""clang/Frontend/CompilerInstance.h""; 96#include ""clang/Frontend/FrontendDiagnostic.h""; 97#include ""clang/Lex/HeaderSearch.h""; 98#include ""clang/Lex/Preprocessor.h""; 99#include ""clang/Lex/PreprocessorOptions.h""; 100#include ""clang/Parse/Parser.h""; 101#include ""clang/Sema/Lookup.h""; 102#include ""clang/Sema/Sema.h""; 103#include ""clang/Serialization/ASTReader.h""; 104#include ""clang/Serialization/GlobalM",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:31876,Safety,avoid,avoid,31876," std::runtime_error(std::string("">>> Interpreter compilation error:\n"") + reason);; 862 }; 863}; 864 ; 865//______________________________________________________________________________; 866//; 867//; 868//; 869 ; 870////////////////////////////////////////////////////////////////////////////////; 871 ; 872namespace{; 873 // An instance of this class causes the diagnostics of clang to be suppressed; 874 // during its lifetime; 875 class clangDiagSuppr {; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offse",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:62623,Safety,avoid,avoid,62623,"to loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void TCling::RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent); 1679{; 1680 if (IsFromRootCling()); 1681 return;; 1682 ; 1683 if (llvm::sys::fs::exists(pcmFileNameFullPath)) {; 1684 ::Error(""TCling::RegisterRdictForLoadPCM"", ""Rdict '%s' is both in Module extension and in File system."", pcmFileNameFullPath.c_str());; 1685 return;; 1686 }; 1687 ; 1688 // The pcmFileNameFullPath must be resolved already because we cannot resolve; 1689 // a link to a non-existent file.; 1690 fPendingRdicts[pcmFileNameFullPath] = *pcmContent;; 1691}; 1692 ; 1693////////////////////////////////////////////////////////////////////////////////; 1694/// Tries to load a PCM from TFile; ret",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:94381,Safety,abort,aborted,94381,"process a command line.; 2411///; 2412/// If the command is executed and the error is 0, then the return value; 2413/// is the int value corresponding to the result of the executed command; 2414/// (float and double return values will be truncated).; 2415///; 2416 ; 2417// Method for handling the interpreter exceptions.; 2418// the MetaProcessor is passing in as argument to teh function, because; 2419// cling::Interpreter::CompilationResult is a nested class and it cannot be; 2420// forward declared, thus this method cannot be a static member function; 2421// of TCling.; 2422 ; 2423static int HandleInterpreterException(cling::MetaProcessor* metaProcessor,; 2424 const char* input_line,; 2425 cling::Interpreter::CompilationResult& compRes,; 2426 cling::Value* result); 2427{; 2428 try {; 2429 return metaProcessor->process(input_line, compRes, result);; 2430 }; 2431 catch (cling::InterpreterException& ex); 2432 {; 2433 Error(""HandleInterpreterException"", ""%s\n%s"", ex.what(), ""Execution of your code was aborted."");; 2434 ex.diagnose();; 2435 compRes = cling::Interpreter::kFailure;; 2436 }; 2437 return 0;; 2438}; 2439 ; 2440////////////////////////////////////////////////////////////////////////////////; 2441 ; 2442bool TCling::DiagnoseIfInterpreterException(const std::exception &e) const; 2443{; 2444 if (auto ie = dynamic_cast<const cling::InterpreterException*>(&e)) {; 2445 ie->diagnose();; 2446 return true;; 2447 }; 2448 return false;; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452 ; 2453Longptr_t TCling::ProcessLine(const char* line, EErrorCode* error/*=0*/); 2454{; 2455 // Copy the passed line, it comes from a static buffer in TApplication; 2456 // which can be reentered through the Cling evaluation routines,; 2457 // which would overwrite the static buffer and we would forget what we; 2458 // were doing.; 2459 //; 2460 TString sLine(line);; 2461 if (strstr(line,fantomline)) {; 2462 // End-Of-Line action; 2463",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:120702,Safety,avoid,avoid,120702,"gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 3105 bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();; 3106 fInterpreter->enableDynamicLookup(false);; 3107 bool oldRawInput = fInterpreter->isRawInputEnabled();; 3108 fInterpreter->enableRawInput(true);; 3109 ; 3110 Bool_t ret = LoadText(code);; 3111 ; 3112 fInterpreter->enableRawInput(oldRawInput);; 3113 fInterpreter->enableDynamicLookup(oldDynLookup);; 3114 return ret;; 3115}; 3116 ; 3117////////////////////////////////////////////////////////////////////////////////; 3118/// It calls a ""fantom"" method to synchronize user keyboard input; 3119/// and ROOT prompt line.; 3120 ; 3121void TCling::EndOfLineAction(); 3122{; 3123 ProcessLineSynch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling; 3127// into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which; 3128// was already taking a lock.; 3129static Bool_t s_IsLibraryLoaded(const char* libname, cling::Interpreter* fInterpreter); 3130{; 3131 // Check shared library.; 3132 TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 31",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:140348,Safety,abort,aborted,140348,"not declarations, like ""Int_t x;"").; 3584 ; 3585Longptr_t TCling::Calc(const char* line, EErrorCode* error); 3586{; 3587#ifdef R__WIN32; 3588 // Test on ApplicationImp not being 0 is needed because only at end of; 3589 // TApplication ctor the IsLineProcessing flag is set to 0, so before; 3590 // we can not use it.; 3591 if (gApplication && gApplication->GetApplicationImp()) {; 3592 while (gROOT->IsLineProcessing() && !gApplication) {; 3593 Warning(""Calc"", ""waiting for cling thread to free"");; 3594 gSystem->Sleep(500);; 3595 }; 3596 gROOT->SetLineIsProcessing();; 3597 }; 3598#endif // R__WIN32; 3599 R__LOCKGUARD_CLING(gInterpreterMutex);; 3600 if (error) {; 3601 *error = TInterpreter::kNoError;; 3602 }; 3603 cling::Value valRef;; 3604 cling::Interpreter::CompilationResult cr = cling::Interpreter::kFailure;; 3605 try {; 3606 cr = fInterpreter->evaluate(line, valRef);; 3607 }; 3608 catch (cling::InterpreterException& ex); 3609 {; 3610 Error(""Calc"", ""%s.\n%s"", ex.what(), ""Evaluation of your expression was aborted."");; 3611 ex.diagnose();; 3612 cr = cling::Interpreter::kFailure;; 3613 }; 3614 ; 3615 if (cr != cling::Interpreter::kSuccess) {; 3616 // Failure in compilation.; 3617 if (error) {; 3618 // Note: Yes these codes are weird.; 3619 *error = TInterpreter::kRecoverable;; 3620 }; 3621 return 0L;; 3622 }; 3623 if (!valRef.isValid()) {; 3624 // Failure at runtime.; 3625 if (error) {; 3626 // Note: Yes these codes are weird.; 3627 *error = TInterpreter::kDangerous;; 3628 }; 3629 return 0L;; 3630 }; 3631 ; 3632 if (valRef.isVoid()) {; 3633 return 0;; 3634 }; 3635 ; 3636 RegisterTemporary(valRef);; 3637#ifdef R__WIN32; 3638 if (gApplication && gApplication->GetApplicationImp()) {; 3639 gROOT->SetLineHasBeenProcessed();; 3640 }; 3641#endif // R__WIN32; 3642 return valRef.castAs<Longptr_t>();; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Set a getline function to call when input is needed.; 3647 ; 3648void TClin",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:156333,Safety,redund,redundant,156333,"nexpected: {; 4016 Fatal(""TCling::SetClassInfo::AlternateTuple"",; 4017 ""Layout of std::tuple on this platform is unexpected."");; 4018 break;; 4019 }; 4020 }; 4021 ; 4022 alternateTuple << ""};\n"";; 4023 alternateTuple << ""}}\n"";; 4024 alternateTuple << ""#endif\n"";; 4025 if (!gCling->Declare(alternateTuple.str().c_str())); 4026 {; 4027 // Declare is not silent (yet?), so add an explicit error message; 4028 // to indicate the consequence of the syntax errors.; 4029 Error(""Load"",""Could not declare %s"",alternateName.c_str());; 4030 return """";; 4031 }; 4032 alternateName = ""ROOT::Internal::"" + alternateName;; 4033 return alternateName;; 4034}; 4035 ; 4036////////////////////////////////////////////////////////////////////////////////; 4037/// Set pointer to the TClingClassInfo in TClass.; 4038/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we; 4039/// already have one.; 4040 ; 4041void TCling::SetClassInfo(TClass* cl, Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInfo to nullptr.; 4051 if (TClinginfo) {; 4052 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4053 }; 4054 delete TClinginfo;; 4055 cl->fClassInfo = nullptr;; 4056 }; 4057 return;; 4058 }; 4059 ; 4060 R__LOCKGUARD(gInterpreterMutex);; 4061 if (cl->fClassInfo && !reload) {; 4062 return;; 4063 }; 4064 //Remove the decl_id from the DeclIdToTClass map; 4065 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4066 if (TClinginfo) {; 4067 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4068 }; 4069 delete TClinginfo;; 4070 cl->fClassInfo = nullptr;; 4071 std::string name(cl->GetName());; 407",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:158899,Safety,detect,detect,158899,"t);; 4089 if (reload || name.empty()) {; 4090 // We could not generate the alternate; 4091 SetWithoutClassInfoState(cl);; 4092 return;; 4093 }; 4094 }; 4095 ; 4096 bool instantiateTemplate = !cl->TestBit(TClass::kUnloading);; 4097 // FIXME: Rather than adding an option to the TClingClassInfo, we should consider combining code; 4098 // that is currently in the caller (like SetUnloaded) that disable AutoLoading and AutoParsing and; 4099 // code is in the callee (disabling template instantiation) and end up with a more explicit class:; 4100 // TClingClassInfoReadOnly.; 4101 TClingClassInfo* info = new TClingClassInfo(GetInterpreterImpl(), name.c_str(), instantiateTemplate);; 4102 if (!info->IsValid()) {; 4103 SetWithoutClassInfoState(cl);; 4104 delete info;; 4105 return;; 4106 }; 4107 cl->fClassInfo = (ClassInfo_t*)info; // Note: We are transferring ownership here.; 4108 // In case a class contains an external enum, the enum will be seen as a; 4109 // class. We must detect this special case and make the class a Zombie.; 4110 // Here we assume that a class has at least one method.; 4111 // We can NOT call TClass::Property from here, because this method; 4112 // assumes that the TClass is well formed to do a lot of information; 4113 // caching. The method SetClassInfo (i.e. here) is usually called during; 4114 // the building phase of the TClass, hence it is NOT well formed yet.; 4115 Bool_t zombieCandidate = kFALSE;; 4116 if (; 4117 info->IsValid() &&; 4118 !(info->Property() & (kIsClass | kIsStruct | kIsNamespace)); 4119 ) {; 4120 zombieCandidate = kTRUE;; 4121 }; 4122 if (!info->IsLoaded()) {; 4123 if (info->Property() & (kIsNamespace)) {; 4124 // Namespaces can have info but no corresponding CINT dictionary; 4125 // because they are auto-created if one of their contained; 4126 // classes has a dictionary.; 4127 zombieCandidate = kTRUE;; 4128 }; 4129 // this happens when no dictionary is available; 4130 delete info;; 4131 cl->fClassInfo = nullptr;; 4132 }; 4133 if (zo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:161560,Safety,avoid,avoid,161560,"4 TClass::AddClassToDeclIdMap(((TClingClassInfo*)cl->fClassInfo)->GetDeclId(), cl);; 4155 }; 4156}; 4157 ; 4158////////////////////////////////////////////////////////////////////////////////; 4159/// Checks if an entity with the specified name is defined in Cling.; 4160/// Returns kUnknown if the entity is not defined.; 4161/// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; 4162/// Returns kKnown if the entity is defined.; 4163///; 4164/// By default, structs, namespaces, classes, enums and unions are looked for.; 4165/// If the flag isClassOrNamespaceOnly is true, classes, structs and; 4166/// namespaces only are considered. I.e. if the name is an enum or a union,; 4167/// the returned value is false.; 4168///; 4169/// In the case where the class is not loaded and belongs to a namespace; 4170/// or is nested, looking for the full class name is outputting a lots of; 4171/// (expected) error messages. Currently the only way to avoid this is to; 4172/// specifically check that each level of nesting is already loaded.; 4173/// In case of templates the idea is that everything between the outer; 4174/// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`; 4175 ; 4176TInterpreter::ECheckClassInfo; 4177TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly /* = kFALSE*/); 4178{; 4179 R__LOCKGUARD(gInterpreterMutex);; 4180 static const char *anonEnum = ""anonymous enum "";; 4181 static const int cmplen = strlen(anonEnum);; 4182 ; 4183 if (fIsShuttingDown || 0 == strncmp(name, anonEnum, cmplen)) {; 4184 return kUnknown;; 4185 }; 4186 ; 4187 // Do not turn on the AutoLoading if it is globally off.; 4188 autoload = autoload && IsClassAutoLoadingEnabled();; 4189 ; 4190 // Avoid the double search below in case the name is a fundamental type; 4191 // or typedef to a fundamental type.; 4192 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 4193 TDataType *fundType = (TDataTy",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:177379,Safety,avoid,avoid,177379," are waiting for more input either because the collected; 4542/// input contains unbalanced braces or last seen token was a `\` (backslash-newline); 4543 ; 4544Int_t TCling::GetMore() const; 4545{; 4546 return fMetaProcessor->awaitingMoreInput();; 4547}; 4548 ; 4549////////////////////////////////////////////////////////////////////////////////; 4550/// Generate a TClass for the given class.; 4551/// Since the caller has already check the ClassInfo, let it give use the; 4552/// result (via the value of emulation) rather than recalculate it.; 4553 ; 4554TClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent /* = kFALSE */); 4555{; 4556// For now the following line would lead to the (unwanted) instantiation; 4557// of class template. This could/would need to be resurrected only if; 4558// we re-introduce so sort of automatic instantiation. However this would; 4559// have to include carefull look at the template parameter to avoid; 4560// creating instance we can not really use (if the parameter are only forward; 4561// declaration or do not have all the necessary interfaces).; 4562 ; 4563 // TClingClassInfo tci(fInterpreter, classname);; 4564 // if (1 || !tci.IsValid()) {; 4565 ; 4566 Version_t version = 1;; 4567 if (TClassEdit::IsSTLCont(classname)) {; 4568 version = TClass::GetClass(""TVirtualStreamerInfo"")->GetClassVersion();; 4569 }; 4570 R__LOCKGUARD(gInterpreterMutex);; 4571 TClass *cl = new TClass(classname, version, silent);; 4572 if (!emulation) {; 4573 // Set the class version if the class is versioned.; 4574 // Note that we cannot just call CLASS::Class_Version() as we might not have; 4575 // an execution engine (when invoked from rootcling).; 4576 ; 4577 // Do not call cl->GetClassVersion(), it has side effects!; 4578 Version_t oldvers = cl->fClassVersion;; 4579 if (oldvers == version && cl->GetClassInfo()) {; 4580 // We have a version and it might need an update.; 4581 TClingClassInfo* cli = (TClingClassInfo*)cl->GetClassInfo(",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:186721,Safety,redund,redundant,186721,"; 4775 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 4776 ; 4777 // Could trigger deserialization of decls.; 4778 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4779 ; 4780 if (cl) {; 4781 d = cl->GetDataMember(name);; 4782 // We check if the decl of the data member has an annotation which indicates; 4783 // an ioname.; 4784 // In case this is true, if the name requested is not the ioname, we; 4785 // return 0, as if the member did not exist. In some sense we override; 4786 // the information in the TClassInfo instance, isolating the typesystem in; 4787 // TClass from the one in the AST.; 4788 if (const ValueDecl* decl = (const ValueDecl*) d){; 4789 std::string ioName;; 4790 bool hasIoName = ROOT::TMetaUtils::ExtractAttrPropertyFromName(*decl,""ioname"",ioName);; 4791 if (hasIoName && ioName != name) return nullptr;; 4792 }; 4793 return d;; 4794 }; 4795 // We are looking up for something on the TU scope.; 4796 // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That; 4797 // interface will actually construct iterators and walk over the decls on the global scope. In would return the first; 4798 // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch; 4799 // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which; 4800 // are only fulfilling ROOT's understanding for a Data Member.; 4801 // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something; 4802 // similar as below.; 4803 using namespace clang;; 4804 Sema& SemaR = fInterpreter->getSema();; 4805 DeclarationName DName = &SemaR.Context.Idents.get(name);; 4806 ; 4807 LookupResult R(SemaR, DName, SourceLocation(), Sema::LookupOrdinaryName,; 4808 Sema::ForExternalRedeclaration);; 4809 ; 4810 cling::utils::Lookup::Named(&SemaR, R);; 4811 ; 4812 LookupResult::Filter F = R",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:220206,Safety,avoid,avoid,220206,"/ the same key for the same lib; 5632 if (gDebug > 3); 5633 Info(""ReadRootmapFile"", ""While processing %s, key %s was found to be already defined for %s"",; 5634 rootmapfile, keyname, lib_name.c_str());; 5635 }; 5636 } else {; 5637 fMapfile->SetValue(keyname, lib_name.c_str());; 5638 }; 5639 }; 5640 }; 5641 file.close();; 5642 return 0;; 5643}; 5644 ; 5645////////////////////////////////////////////////////////////////////////////////; 5646/// Create a resource table and read the (possibly) three resource files,; 5647/// i.e. `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`), `$HOME/<name>`; 5648/// and `$PWD/<name>`. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You; 5649/// can read additional user defined resource files by creating additional TEnv; 5650/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 5651/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 5652/// case the home directory resides on an automounted remote file system; 5653/// and one wants to avoid the file system from being mounted.; 5654 ; 5655void TCling::InitRootmapFile(const char *name); 5656{; 5657 assert(requiresRootMap(name) && ""We have a module!"");; 5658 ; 5659 if (!requiresRootMap(name)); 5660 return;; 5661 ; 5662 Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);; 5663 ; 5664 fMapfile->SetRcName(name);; 5665 ; 5666 TString sname = ""system"";; 5667 sname += name;; 5668 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 5669 ; 5670 Int_t ret = ReadRootmapFile(s);; 5671 if (ret == -3) // old format; 5672 fMapfile->ReadFile(s, kEnvGlobal);; 5673 delete [] s;; 5674 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 5675 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 5676 ret = ReadRootmapFile(s);; 5677 if (ret == -3) // old format; 5678 fMapfile->ReadFile(s, kEnvUser);; 5679 delete [] s;; 5680 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 5681 ret = ReadRootmapFile(name);; 5682 if ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:224428,Safety,safe,safe,224428,"///////////; 5735/// Load map between class and library. If rootmapfile is specified a; 5736/// specific rootmap file can be added (typically used by ACLiC).; 5737/// In case of error -1 is returned, 0 otherwise.; 5738/// The interpreter uses this information to automatically load the shared; 5739/// library for a class (autoload mechanism), see the AutoLoad() methods below.; 5740 ; 5741Int_t TCling::LoadLibraryMap(const char* rootmapfile); 5742{; 5743 if (rootmapfile && *rootmapfile && !requiresRootMap(rootmapfile)); 5744 return 0;; 5745 ; 5746 R__LOCKGUARD(gInterpreterMutex);; 5747 ; 5748 // open the [system].rootmap files; 5749 if (!fMapfile) {; 5750 fMapfile = new TEnv();; 5751 fMapfile->IgnoreDuplicates(kTRUE);; 5752 fRootmapFiles = new TObjArray;; 5753 fRootmapFiles->SetOwner();; 5754 InitRootmapFile("".rootmap"");; 5755 }; 5756 ; 5757 // Prepare a list of all forward declarations for cling; 5758 // For some experiments it is easily as big as 500k characters. To be on the; 5759 // safe side, we go for 1M.; 5760 TUniqueString uniqueString(1048576);; 5761 ; 5762 // Load all rootmap files in the dynamic load path ((DY)LD_LIBRARY_PATH, etc.).; 5763 // A rootmap file must end with the string "".rootmap"".; 5764 TString ldpath = gSystem->GetDynamicPath();; 5765 if (ldpath != fRootmapLoadPath) {; 5766 fRootmapLoadPath = ldpath;; 5767#ifdef WIN32; 5768 TObjArray* paths = ldpath.Tokenize("";"");; 5769#else; 5770 TObjArray* paths = ldpath.Tokenize("":"");; 5771#endif; 5772 TString d;; 5773 for (Int_t i = 0; i < paths->GetEntriesFast(); i++) {; 5774 d = ((TObjString *)paths->At(i))->GetString();; 5775 // check if directory already scanned; 5776 Int_t skip = 0;; 5777 for (Int_t j = 0; j < i; j++) {; 5778 TString pd = ((TObjString *)paths->At(j))->GetString();; 5779 if (pd == d) {; 5780 skip++;; 5781 break;; 5782 }; 5783 }; 5784 if (!skip) {; 5785 void* dirp = gSystem->OpenDirectory(d);; 5786 if (dirp) {; 5787 if (gDebug > 3) {; 5788 Info(""LoadLibraryMap"", ""%s"", d.Data());; 5789 };",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:243518,Safety,avoid,avoid,243518,"ilure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:245490,Safety,avoid,avoids,245490," to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoadingRAII autoLoadOff(this);; 6310 // Try using externally provided callback first.; 6311 if (fAutoLoadCallBack) {; 6312 int success = (*(AutoLoadCallBack_t)fAutoLoadCallBack)(cls);; 6313 if (success); 6314 return success;; 6315 }; 6316 ; 6317 // During the 'Deep' part of the search we will call GetClassSharedLibsForModule; 6318 // (when module are enabled) which might end up calling AutoParsing but; 6319 // that should only be for the cases where the library has no generated pcm; 6320 // and in that case a rootmap should be available.; 6321 // This avoids a very costly operation (for generally no gain) but reduce the; 6322 // quality of the search (i.e. bad in case of library with no pcm and no rootmap; 6323 // file).; 6324 TInterpreter::SuspendAutoParsing autoParseRaii(this);; 6325 std::unordered_set<std::string> visited;; 6326 return DeepAutoLoadImpl(cls, visited, false /*normalized*/);; 6327}; 6328 ; 6329////////////////////////////////////////////////////////////////////////////////; 6330/// Parse the payload or header.; 6331 ; 6332static cling::Interpreter::CompilationResult ExecAutoParse(const char *what,; 6333 Bool_t header,; 6334 cling::Interpreter *interpreter); 6335{; 6336 std::string code = gNonInterpreterClassDef ;; 6337 if (!header) {; 6338 // This is the complete header file content and not the; 6339 // name of a header.; 6340 code += what;; 6341 ; 6342 } else {; 6343 code += (""#include \"""");; 6344 code += what;; 6345 code += ""\""\n"";; 6346 }; 6347 code += (""#ifdef __ROOTCLING__\n""; 6348 ""#undef __ROOTCLING__\n""; 6349 + gInterpreterClassDef +; 6350 ""#endif"");; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:261171,Safety,avoid,avoid,261171,"pdateClassInfoWithDecl(const NamedDecl* ND); 6682{; 6683 const TagDecl *td = dyn_cast<TagDecl>(ND);; 6684 const NamespaceDecl *ns = dyn_cast<NamespaceDecl>(ND);; 6685 const NamedDecl *canon = nullptr;; 6686 ; 6687 std::string name;; 6688 TagDecl* tdDef = nullptr;; 6689 if (td) {; 6690 canon = tdDef = td->getDefinition();; 6691 // Let's pass the decl to the TClass only if it has a definition.; 6692 if (!tdDef) return;; 6693 ; 6694 if (!tdDef->isCompleteDefinition() || llvm::isa<clang::FunctionDecl>(tdDef->getDeclContext())) {; 6695 // Ignore incomplete definition.; 6696 // Ignore declaration within a function.; 6697 return;; 6698 }; 6699 ; 6700 auto declName = tdDef->getNameAsString();; 6701 // Check if we have registered the unqualified name into the list; 6702 // of TClass that are in kNoInfo, kEmulated or kFwdDeclaredState.; 6703 // Since this is used as heureutistic to avoid spurrious calls to GetNormalizedName; 6704 // the unqualified name is sufficient (and the fully qualified name might be; 6705 // 'wrong' if there is difference in spelling in the template paramters (for example); 6706 if (!TClass::HasNoInfoOrEmuOrFwdDeclaredDecl(declName.c_str())){; 6707 // fprintf (stderr,""WARNING: Impossible to find a TClassEntry in kNoInfo or kEmulated the decl of which would be called %s. Skip w/o building the normalized name.\n"",declName.c_str() );; 6708 return;; 6709 }; 6710 ; 6711 clang::QualType type(tdDef->getTypeForDecl(), 0);; 6712 ROOT::TMetaUtils::GetNormalizedName(name, type, *fInterpreter, *fNormalizedCtxt);; 6713 } else if (ns) {; 6714 canon = ns->getCanonicalDecl();; 6715 name = ND->getQualifiedNameAsString();; 6716 } else {; 6717 name = ND->getQualifiedNameAsString();; 6718 }; 6719 ; 6720 // Supposedly we are being called while something is being; 6721 // loaded ... let's now tell the autoloader to do the work; 6722 // yet another time.; 6723 SuspendAutoLoadingRAII autoLoadOff(this);; 6724 // FIXME: There can be more than one TClass for a single decl.; 6725 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:281866,Safety,avoid,avoid,281866,"t().getBinary();; 7183 ; 7184 std::set<string> DedupSet;; 7185 std::string Result = lib + ' ';; 7186 for (const auto &S : BinObjFile->symbols()) {; 7187 uint32_t Flags = llvm::cantFail(S.getFlags());; 7188 // Skip defined symbols: we have them.; 7189 if (!(Flags & llvm::object::SymbolRef::SF_Undefined)); 7190 continue;; 7191 // Skip undefined weak symbols: if we don't have them we won't need them.; 7192 // `__gmon_start__` being a typical example.; 7193 if (Flags & llvm::object::SymbolRef::SF_Weak); 7194 continue;; 7195 llvm::Expected<StringRef> SymNameErr = S.getName();; 7196 if (!SymNameErr) {; 7197 Warning(""GetSharedLibDepsForModule"", ""Failed to read symbol"");; 7198 continue;; 7199 }; 7200 llvm::StringRef SymName = SymNameErr.get();; 7201 if (SymName.empty()); 7202 continue;; 7203 ; 7204 if (BinObjFile->isELF()) {; 7205 // Skip the symbols which are part of the C/C++ runtime and have a; 7206 // fixed library version. See binutils ld VERSION. Those reside in; 7207 // 'system' libraries, which we avoid in FindLibraryForSymbol.; 7208 if (SymName.contains(""@GLIBCXX"") || SymName.contains(""@CXXABI"") ||; 7209 SymName.contains(""@GLIBC"") || SymName.contains(""@GCC"")); 7210 continue;; 7211 ; 7212 // Those are 'weak undefined' symbols produced by gcc. We can; 7213 // ignore them.; 7214 // FIXME: It is unclear whether we can ignore all weak undefined; 7215 // symbols:; 7216 // http://lists.llvm.org/pipermail/llvm-dev/2017-October/118177.html; 7217 static constexpr llvm::StringRef RegisterClasses(""_Jv_RegisterClasses"");; 7218 static constexpr llvm::StringRef RegisterCloneTable(""_ITM_registerTMCloneTable"");; 7219 static constexpr llvm::StringRef DeregisterCloneTable(""_ITM_deregisterTMCloneTable"");; 7220 if (SymName == RegisterClasses ||; 7221 SymName == RegisterCloneTable ||; 7222 SymName == DeregisterCloneTable); 7223 continue;; 7224 }; 7225 ; 7226 // If we can find the address of the symbol, we have loaded it. Skip.; 7227 if (skipLoadedLibs) {; 7228 std::string SymNameForDlsym",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:294052,Safety,safe,safe,294052,";; 7506 return compRes == cling::Interpreter::kFailure;; 7507}; 7508 ; 7509////////////////////////////////////////////////////////////////////////////////; 7510/// Load the declarations from text into the interpreter.; 7511/// Note that this cannot be (top level) statements; text must contain; 7512/// top level declarations.; 7513/// Returns true on success, false on failure.; 7514 ; 7515Bool_t TCling::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to protect critical section; 7534/// of its code (non-thread safe parts).; 7535 ; 7536void TCling::SetAlloclockfunc(void (* /* p */ )()) const; 7537{; 7538 // nothing to do for now.; 7539}; 7540 ; 7541////////////////////////////////////////////////////////////////////////////////; 7542/// [Place holder for Mutex Unlock] Provide the interpreter with a way to; 7543/// release a lock used to protect critical section; 7544/// of its code (non-thread safe parts).; 7545 ; 7546void TCling::SetAllocunlockfunc(void (* /* p */ )()) const; 7547{; 7548 // nothing to do for now.; 7549}; 7550 ; 7551////////////////////////////////////////////////////////////////////////////////; 7552/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCall",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:294442,Safety,safe,safe,294442,"ng::LoadText(const char* text) const; 7516{; 7517 return (fInterpreter->declare(text) == cling::Interpreter::kSuccess);; 7518}; 7519 ; 7520////////////////////////////////////////////////////////////////////////////////; 7521/// Interface to cling function; 7522 ; 7523const char* TCling::MapCppName(const char* name) const; 7524{; 7525 TTHREAD_TLS_DECL(std::string,buffer);; 7526 ROOT::TMetaUtils::GetCppName(buffer,name);; 7527 return buffer.c_str(); // NOLINT; 7528}; 7529 ; 7530////////////////////////////////////////////////////////////////////////////////; 7531/// [Place holder for Mutex Lock]; 7532/// Provide the interpreter with a way to; 7533/// acquire a lock used to protect critical section; 7534/// of its code (non-thread safe parts).; 7535 ; 7536void TCling::SetAlloclockfunc(void (* /* p */ )()) const; 7537{; 7538 // nothing to do for now.; 7539}; 7540 ; 7541////////////////////////////////////////////////////////////////////////////////; 7542/// [Place holder for Mutex Unlock] Provide the interpreter with a way to; 7543/// release a lock used to protect critical section; 7544/// of its code (non-thread safe parts).; 7545 ; 7546void TCling::SetAllocunlockfunc(void (* /* p */ )()) const; 7547{; 7548 // nothing to do for now.; 7549}; 7550 ; 7551////////////////////////////////////////////////////////////////////////////////; 7552/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCallbacks->IsAutoLoadingEnabled();; 7561}; 7562 ; 7563////////////////////////////////////////////////////////////////////////////////; 7564/// Enable/Disable the AutoLoading of libraries.; 7565/// Returns the old value, i.e whether it was enabled or not.; 7566 ; 7567int TCling::SetClassAutoLoading(int autoload) const; 7568{; 7569 // If no state change is required, exit early.; 7570 // FIXME: In future ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:302182,Safety,safe,safe,302182,"ss(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are in the middle of parsing, so let's make; 7719 // sure to save the state and then restore it.; 7720 ; 7721 if (gDirectory) {; 7722 auto iSpecObjMap = fSpecialObjectMaps.find(gDirectory);; 7723 if (iSpecObjMap != fSpecialObjectMaps.end()) {; 7724 auto iSpecObj = iSpecObjMap->second.find(Name);; 7725 if (iSpecObj != iSpecObjMap->second.end()) {; 7726 LookupCtx = gDirectory;; 7727 return iSpecObj->second;; 7728 }; 7729 }; 7730 }; 7731 ; 7732 // Save state of the PP; 7733 Sema &SemaR = fInterpreter->getSema();; 7734 ASTContext& C = SemaR.getASTContext();; 7735 Preprocessor &PP = SemaR.getPreprocessor();; 7736 Parser& P = const_cast<Parser&>(fInterpreter->getParser());; 7737 Preprocessor::CleanupAndRestoreCacheRAII cleanupRAII(PP);; 7738 Parser::ParserCurTokRestoreRAII savedCurToken(P);; 7739 // After we have saved the token reset the current one to something which; 7740 // is safe (semi colon usually means empty decl); 7741 Token& Tok = const_cast<Token&>(P.getCurToken());; 7742 Tok.setKind(tok::semi);; 7743 ; 7744 // We can't PushDeclContext, because we go up and the routine that pops; 7745 // the DeclContext assumes that we drill down always.; 7746 // We have to be on the global context. At that point we are in a; 7747 // wrapper function so the parent context must be the global.; 7748 Sema::ContextAndScopeRAII pushedDCAndS(SemaR, C.getTranslationUnitDecl(),; 7749 SemaR.TUScope);; 7750 ; 7751 TObject* specObj = gROOT->FindSpecialObject(Name, LookupCtx);; 7752 if (specObj) {; 7753 if (!LookupCtx) {; 7754 Error(""GetObjectAddress"", ""Got a special object without LookupCtx!"");; 7755 } else {; 7756 fSpecialObjectMaps[LookupCtx][Name] = specObj;; 7757 }; 7758 }; 7759 return specObj;; 7760}; 7761 ; 7762////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:372923,Safety,safe,safety,372923,"/////; 9632/// Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.; 9633 ; 9634void TCling::ApplyToInterpreterMutex(void *delta); 9635{; 9636 if (gInterpreterMutex) {; 9637 if (delta) {; 9638 auto typedDelta = static_cast<MutexStateAndRecurseCountDelta *>(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 st",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:373393,Safety,safe,safety,373393,"(delta);; 9639 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP{typedDelta};; 9640 gCoreMutex->Apply(std::move(typedDelta->fDelta));; 9641 // Now that we have the lock, update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 std::swap(uniqueP->fInitialState, fInitialMutex);; 9670 uniqueP->fDelta = gCoreMutex->Rewind(*uniqueP->fInitialState.fState);; 9671 return uniqueP.release();; 9672 }; 9673 R__ASSERT(fInitialMutex.fRecurseCount == 0);; 9674 return nullptr;; 9675}; ClingRAII.h; R__EXTERN#define R_",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:378938,Safety,avoid,avoid,378938," kDescending; ETupleOrdering::kUnexpected@ kUnexpected; TCling__LibraryLoadingFailedbool TCling__LibraryLoadingFailed(const std::string &errmessage, const std::string &libStem, bool permanent, bool resolved)Lookup libraries in LD_LIBRARY_PATH and DYLD_LIBRARY_PATH with mangled_name, which is extracted by er...Definition TCling.cxx:351; gIgnoredPCMNamesstatic const std::unordered_set< std::string > gIgnoredPCMNamesList of dicts that have the PCM information already in the PCH.Definition TCling.cxx:1939; s_IsLibraryLoadedstatic Bool_t s_IsLibraryLoaded(const char *libname, cling::Interpreter *fInterpreter)Definition TCling.cxx:3129; TCling__GetClassSharedLibsconst char * TCling__GetClassSharedLibs(const char *className, bool skipCore)Definition TCling.cxx:633; loadGlobalModuleIndexstatic GlobalModuleIndex * loadGlobalModuleIndex(cling::Interpreter &interp)Definition TCling.cxx:1080; TClingLookupHelper__ExistingTypeCheckbool TClingLookupHelper__ExistingTypeCheck(const std::string &tname, std::string &result)Try hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing.Definition TCling.cxx:903; HasASTFileOnDiskstatic bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName=nullptr)Checks if there is an ASTFile on disk for the given module M.Definition TCling.cxx:1065; TCling__UnlockCompilationDuringUserCodeExecutionvoid TCling__UnlockCompilationDuringUserCodeExecution(void *)Unlock the interpreter.Definition TCling.cxx:379; AlternateTuplestatic std::string AlternateTuple(const char *classname, const cling::LookupHelper &lh, Bool_t silent)Definition TCling.cxx:3947; R__InitStreamerInfoFactorystatic bool R__InitStreamerInfoFactory()Helper to initialize TVirtualStreamerInfo's factor early.Definition TCling.cxx:1664; TCling__AutoParseCallbackint TCling__AutoParseCallback(const char *className)Definition TCling.cxx:628; TCling__DEBUG__DCtoRecordDeclclang::RecordDecl * TCling__DEBUG__DCtoRecordDecl(cla",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:387387,Safety,abort,abort,387387,"; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnumConstant.h; TEnum.h; TEnv.h; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; TFunctionTemplate.h; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Recta",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:55870,Security,inject,injected,55870," if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // module build remarks from clang to make it easier to spot when we do; 1496 // this by accident.; 1497 interpArgs.push_back(""-Rmodule-build"");; 1498 }; 1499 // ROOT implements its AutoLoading upon module's link directives. We; 1500 // generate module A { header ""A.h"" link ""A.so"" export * } where ROOT's; 1501 // facilities use the link directive to dynamically load the relevant; 1502 // library. So, we need to suppress clang's default autolink behavior.; 1503 interpArgs.push_back(""-fno-autolink"");; 1504 }; 1505 ; 1506#ifdef R__FAST_MATH; 1507 // Same setting as in rootcling_impl.cxx.; 1508 interpArgs.push_back(""-ffast-math"");; 1509#endif; 1510 ; 1511 TString llvmResourceDir = TROOT::GetEtcDir() + ""/cling"";; 1512 // Add statically injected extra arguments, usually coming from rootcling.; 1513 for (const char** extraArgs = TROOT::GetExtraInterpreterArgs();; 1514 extraArgs && *extraArgs; ++extraArgs) {; 1515 if (!strcmp(*extraArgs, ""-resource-dir"")) {; 1516 // Take the next arg as the llvm resource directory.; 1517 llvmResourceDir = *(++extraArgs);; 1518 } else {; 1519 interpArgs.push_back(*extraArgs);; 1520 }; 1521 }; 1522 ; 1523 std::vector<std::string> _empty;; 1524 auto args = TROOT::AddExtraInterpreterArgs(_empty);; 1525 for (const auto &arg: args); 1526 interpArgs.emplace_back(arg.c_str());; 1527 ; 1528 // Add the Rdict module file extension.; 1529 cling::Interpreter::ModuleFileExtensions extensions;; 1530 EnvOpt = llvm::sys::Process::GetEnv(""ROOTDEBUG_RDICT"");; 1531 if (!EnvOpt.has_value()); 1532 extensions.push_back(std::make_shared<TClingRdictModuleFileExtension>());; 1533 ; 1534 fInterpreter = std::make_unique<cling::Interpreter>(interpArgs.size(),; 1535 &(interpArgs",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:76217,Security,inject,injected,76217,"aced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022 // We need the dictionary initialization but we don't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:76856,Security,inject,inject,76856,");; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022 // We need the dictionary initialization but we don't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2029 llvm::SaveAndRestore<bool> SaveHeaderParsing(fHeaderParsingOnDemand);; 2030 fHeaderParsingOnDemand = !hasCxxModule;; 2031 ; 2032 // Treat Aclic Libs in a special way. Do not delay the parsing.; 2033 bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;; 2034 bool isACLiC = strstr(modulename, ""_ACLiC_dict"") != nullptr;; 2035 if (hasHeaderParsingOnDemand && isACLiC) {; 2036 if (gDebug>1); 2037 Info(""TCling::RegisterModule"",; 20",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:143086,Security,access,access,143086,"_t TCling::HandleNewTransaction(const cling::Transaction &T); 3666{; 3667 R__LOCKGUARD(gInterpreterMutex);; 3668 ; 3669 if ((std::distance(T.decls_begin(), T.decls_end()) != 1); 3670 || T.deserialized_decls_begin() != T.deserialized_decls_end(); 3671 || T.macros_begin() != T.macros_end(); 3672 || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {; 3673 fTransactionCount++;; 3674 return true;; 3675 }; 3676 return false;; 3677}; 3678 ; 3679////////////////////////////////////////////////////////////////////////////////; 3680/// Delete object from cling symbol table so it can not be used anymore.; 3681/// cling objects are always on the heap.; 3682 ; 3683void TCling::RecursiveRemove(TObject* obj); 3684{; 3685 // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**; 3686 // put in place the Read/Write part here. Keeping the write lock; 3687 // here is 'catasptrophic' for scaling as it means that ALL calls; 3688 // to RecursiveRemove will take the write lock and performance; 3689 // of many threads trying to access the write lock at the same; 3690 // time is relatively bad.; 3691 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3692 // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal; 3693 // (but isn't at the moment).; 3694 if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {; 3695 std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);; 3696 if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {; 3697 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3698 DeleteGlobal(obj);; 3699 ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);; 3700 }; 3701 }; 3702}; 3703 ; 3704////////////////////////////////////////////////////////////////////////////////; 3705/// Pressing Ctrl+C should forward here. In the case where we have had; 3706/// continuation requested we must reset it.; 3707 ; 3708void TCling::Reset(); 370",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:146712,Security,access,accessed,146712,"//////////////////////////////////; 3751/// Reset the Cling 'user' global objects/variables state to the state saved by the last; 3752/// call to TCling::SaveGlobalsContext().; 3753 ; 3754void TCling::ResetGlobalVar(void* obj); 3755{; 3756#if defined(R__MUST_REVISIT); 3757#if R__MUST_REVISIT(6,2); 3758 R__LOCKGUARD(gInterpreterMutex);; 3759 Warning(""ResetGlobalVar"",""Cling should support the equivalent of resetglobalvar(obj)"");; 3760#endif; 3761#endif; 3762}; 3763 ; 3764////////////////////////////////////////////////////////////////////////////////; 3765/// Rewind Cling dictionary to the point where it was before executing; 3766/// the current macro. This function is typically called after SEGV or; 3767/// ctlr-C after doing a longjmp back to the prompt.; 3768 ; 3769void TCling::RewindDictionary(); 3770{; 3771#if defined(R__MUST_REVISIT); 3772#if R__MUST_REVISIT(6,2); 3773 R__LOCKGUARD(gInterpreterMutex);; 3774 Warning(""RewindDictionary"",""Cling should provide a way to revert transaction similar to rewinddictionary()"");; 3775#endif; 3776#endif; 3777}; 3778 ; 3779////////////////////////////////////////////////////////////////////////////////; 3780/// Delete obj from Cling symbol table so it cannot be accessed anymore.; 3781/// Returns 1 in case of success and 0 in case object was not in table.; 3782 ; 3783Int_t TCling::DeleteGlobal(void* obj); 3784{; 3785#if defined(R__MUST_REVISIT); 3786#if R__MUST_REVISIT(6,2); 3787 R__LOCKGUARD(gInterpreterMutex);; 3788 Warning(""DeleteGlobal"",""Cling should provide the equivalent of deleteglobal(obj), see also DeleteVariable."");; 3789#endif; 3790#endif; 3791 return 0;; 3792}; 3793 ; 3794////////////////////////////////////////////////////////////////////////////////; 3795/// Undeclare obj called name.; 3796/// Returns 1 in case of success, 0 for failure.; 3797 ; 3798Int_t TCling::DeleteVariable(const char* name); 3799{; 3800#if defined(R__MUST_REVISIT); 3801#if R__MUST_REVISIT(6,2); 3802 Warning(""DeleteVariable"",""should do more tha",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:197755,Security,access,access,197755,"; 5064 // The DeclarationName is funcname, unless it's a ctor or dtor.; 5065 // FIXME: or operator or conversion! See enum clang::DeclarationName::NameKind.; 5066 ; 5067 if (RecDecl) {; 5068 if (RecDecl->getNameAsString() == funcname) {; 5069 clang::QualType QT = Ctx.getTypeDeclType(RecDecl);; 5070 DName = Ctx.DeclarationNames.getCXXConstructorName(Ctx.getCanonicalType(QT));; 5071 } else if (funcname[0] == '~' && RecDecl->getNameAsString() == funcname + 1) {; 5072 clang::QualType QT = Ctx.getTypeDeclType(RecDecl);; 5073 DName = Ctx.DeclarationNames.getCXXDestructorName(Ctx.getCanonicalType(QT));; 5074 } else {; 5075 DName = &Ctx.Idents.get(funcname);; 5076 }; 5077 } else {; 5078 DName = &Ctx.Idents.get(funcname);; 5079 }; 5080 ; 5081 // NotForRedeclaration: we want to find names in inline namespaces etc.; 5082 clang::LookupResult R(S, DName, clang::SourceLocation(),; 5083 Sema::LookupOrdinaryName, clang::Sema::NotForRedeclaration);; 5084 R.suppressDiagnostics(); // else lookup with NotForRedeclaration will check access etc; 5085 S.LookupQualifiedName(R, const_cast<DeclContext*>(DeclCtx));; 5086 if (R.empty()) return;; 5087 R.resolveKind();; 5088 res.reserve(res.size() + (R.end() - R.begin()));; 5089 for (clang::LookupResult::iterator IR = R.begin(), ER = R.end();; 5090 IR != ER; ++IR) {; 5091 if (const clang::FunctionDecl* FD; 5092 = llvm::dyn_cast<const clang::FunctionDecl>(*IR)) {; 5093 if (!FD->getDescribedFunctionTemplate()) {; 5094 res.push_back(FD);; 5095 }; 5096 } else if (const auto *USD = llvm::dyn_cast<const clang::UsingShadowDecl>(*IR)) {; 5097 // FIXME: multi-level using; 5098 if (llvm::isa<clang::FunctionDecl>(USD->getTargetDecl())) {; 5099 res.push_back(USD);; 5100 }; 5101 }; 5102 }; 5103}; 5104 ; 5105////////////////////////////////////////////////////////////////////////////////; 5106/// Return pointer to cling interface function for a method of a class with; 5107/// a certain prototype, i.e. ""char*,int,float"". If the class is 0 the global; 5108/// fu",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:203310,Security,secur,security,203310,"(const char* name, std::string &output, Bool_t full); 5201{; 5202 output.clear();; 5203 ; 5204 R__LOCKGUARD(gInterpreterMutex);; 5205 ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can report; 5231/// compilation and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint secu",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:204337,Security,secur,security,204337,"s does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can report; 5231/// compilation and runtime errors properly.; 5232 ; 5233void TCling::Execute(const char* function, const char* params, int* error); 5234{; 5235 R__LOCKGUARD_CLING(gInterpreterMutex);; 5236 if (error) {; 5237 *error = TInterpreter::kNoError;; 5238 }; 5239 TClingClassInfo cl(GetInterpreterImpl());; 5240 Longptr_t offset = 0L;; 5241 TClingCallFunc func(GetInterpreterImpl());; 5242 func.SetFunc(&cl, function, params, &offset);; 5243 func.Exec(nullptr);; 5244}; 5245 ; 5246////////////////////////////////////////////////////////////////////////////////; 5247/// Execute a method from class cl with arguments params.; 5248///; 5249/// FIXME: The cint-based version of this code does not check if the; 5250/// SetFunc() call works, and does not do any real checking; 5251/// for errors from the Exec() call. It did fetch the most; 5252/// recent cint security error and return that in error, but; 5253/// this does not really translate well to cling/clang. We; 5254/// should enhance these interfaces so that we can report; 5255/// compilation and runtime errors properly.; 5256 ; 5257void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5258 const char* params, Bool_t objectIsConst, int* error); 5259{; 5260 R__LOCKGUARD_CLING(gInterpreterMutex);; 5261 if (error) {; 5262 *error = TInterpreter::kNoError;; 5263 }; 5264 // If the actual class of this object inherits 2nd (or more) from TObject,; 5265 // 'obj' is unlikely to be the start of the object (as described by IsA()),; 5266 // hence gInterpreter->Execute will improperly correct the offset.; 5267 void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);; 5268 Longptr_t offset = 0L;; 5269 TClingCallFunc func(GetInterpreterImpl());; 5270 func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);; 5271 void* address = (void*)((Longptr_t)addr + offset);; 5272 func.Exec(",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:264427,Security,expose,expose,264427,"///////////////////////////////////////////////; 6752/// Update all canvases at end the terminal input command.; 6753 ; 6754void TCling::UpdateAllCanvases(); 6755{; 6756 TIter next(gROOT->GetListOfCanvases());; 6757 TVirtualPad* canvas;; 6758 while ((canvas = (TVirtualPad*)next())) {; 6759 canvas->Update();; 6760 }; 6761}; 6762 ; 6763////////////////////////////////////////////////////////////////////////////////; 6764 ; 6765void TCling::UpdateListsOnCommitted(const cling::Transaction &T) {; 6766 std::set<TClass*> modifiedTClasses; // TClasses that require update after this transaction; 6767 ; 6768 // If the transaction does not contain anything we can return earlier.; 6769 if (!HandleNewTransaction(T)) return;; 6770 ; 6771 bool isTUTransaction = false;; 6772 if (!T.empty() && T.decls_begin() + 1 == T.decls_end() && !T.hasNestedTransactions()) {; 6773 clang::Decl* FirstDecl = *(T.decls_begin()->m_DGR.begin());; 6774 if (llvm::isa<clang::TranslationUnitDecl>(FirstDecl)) {; 6775 // The is the first transaction, we have to expose to meta; 6776 // what's already in the AST.; 6777 isTUTransaction = true;; 6778 }; 6779 }; 6780 ; 6781 std::set<const void*> TransactionDeclSet;; 6782 if (!isTUTransaction && T.decls_end() - T.decls_begin()) {; 6783 const clang::Decl* WrapperFD = T.getWrapperFD();; 6784 for (cling::Transaction::const_iterator I = T.decls_begin(), E = T.decls_end();; 6785 I != E; ++I) {; 6786 if (I->m_Call != cling::Transaction::kCCIHandleTopLevelDecl; 6787 && I->m_Call != cling::Transaction::kCCIHandleTagDeclDefinition); 6788 continue;; 6789 ; 6790 for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),; 6791 DE = I->m_DGR.end(); DI != DE; ++DI) {; 6792 if (*DI == WrapperFD); 6793 continue;; 6794 TransactionDeclSet.insert(*DI);; 6795 ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);; 6796 }; 6797 }; 6798 }; 6799 ; 6800 // The above might trigger more decls to be deserialized.; 6801 // Thus the iteration over the deserialized decls must be last.;",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:345874,Security,access,access,345874,"plate arguments of the; 8858/// function template described by ft_info.; 8859 ; 8860UInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const; 8861{; 8862 if (!ft_info) return 0;; 8863 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8864 return ft->getTemplateParameters()->getMinRequiredArguments();; 8865}; 8866 ; 8867////////////////////////////////////////////////////////////////////////////////; 8868/// Return the property of the function template.; 8869 ; 8870Long_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const; 8871{; 8872 if (!ft_info) return 0;; 8873 ; 8874 long property = 0L;; 8875 property |= kIsCompiled;; 8876 ; 8877 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8878 ; 8879 switch (ft->getAccess()) {; 8880 case clang::AS_public:; 8881 property |= kIsPublic;; 8882 break;; 8883 case clang::AS_protected:; 8884 property |= kIsProtected;; 8885 break;; 8886 case clang::AS_private:; 8887 property |= kIsPrivate;; 8888 break;; 8889 case clang::AS_none:; 8890 if (ft->getDeclContext()->isNamespace()); 8891 property |= kIsPublic;; 8892 break;; 8893 default:; 8894 // IMPOSSIBLE; 8895 assert(false && ""Unexpected value for the access property value in Clang"");; 8896 break;; 8897 }; 8898 ; 8899 const clang::FunctionDecl *fd = ft->getTemplatedDecl();; 8900 if (const clang::CXXMethodDecl *md =; 8901 llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {; 8902 if (md->getMethodQualifiers().hasConst()) {; 8903 property |= kIsConstant | kIsConstMethod;; 8904 }; 8905 if (md->isVirtual()) {; 8906 property |= kIsVirtual;; 8907 }; 8908 if (md->isPureVirtual()) {; 8909 property |= kIsPureVirtual;; 8910 }; 8911 if (const clang::CXXConstructorDecl *cd =; 8912 llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {; 8913 if (cd->isExplicit()) {; 8914 property |= kIsExplicit;; 8915 }; 8916 }; 8917 else if (const clang::CXXConversionDecl *cd =; 8918 llvm::dyn_cast<clang::CXXConversionDecl>(md)) {; 8919 if ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:373590,Security,access,access,373590,", update the global; 9642 R__ASSERT(fInitialMutex.fRecurseCount == 0 && ""Inconsistent state of fInitialMutex! Another thread within Interpreter critical section."");; 9643 std::swap(fInitialMutex, typedDelta->fInitialState);; 9644 } else {; 9645 // This case happens when EnableThreadSafety is first called from; 9646 // the interpreter function we just handled.; 9647 // Since thread safety was not enabled at the time we rewound, there was; 9648 // no lock taken and even-though we should be locking the rest of this; 9649 // interpreter handling/modifying code (since there might be threads in; 9650 // flight), we can't because there would not be any lock guard to release the; 9651 // locks; 9652 if (fInitialMutex || fInitialMutex.fRecurseCount !=0); 9653 Error(""ApplyToInterpreterMutex"",; 9654 ""After returning from user code that turned on thread safety support, we notice that fInitialMutex is already used ... ""; 9655 ""so the rest of this function/stack execution might have race condition (with the other thread that thinks it has exclusive access to the interpreter state."");; 9656 }; 9657 }; 9658}; 9659 ; 9660////////////////////////////////////////////////////////////////////////////////; 9661/// Reset the interpreter lock to the state it had before interpreter-related; 9662/// calls happened.; 9663 ; 9664void *TCling::RewindInterpreterMutex(); 9665{; 9666 if (fInitialMutex) {; 9667 // Need to start a new recurse count.; 9668 std::unique_ptr<MutexStateAndRecurseCountDelta> uniqueP(new MutexStateAndRecurseCountDelta());; 9669 std::swap(uniqueP->fInitialState, fInitialMutex);; 9670 uniqueP->fDelta = gCoreMutex->Rewind(*uniqueP->fInitialState.fState);; 9671 return uniqueP.release();; 9672 }; 9673 R__ASSERT(fInitialMutex.fRecurseCount == 0);; 9674 return nullptr;; 9675}; ClingRAII.h; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; RConversionRuleP",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:397363,Security,hash,hash,397363,"39; ROOT::TVirtualRWMutex::Rewindvirtual std::unique_ptr< StateDelta > Rewind(const State &earlierState)=0; ROOT::TVirtualRWMutex::Applyvirtual void Apply(std::unique_ptr< StateDelta > &&delta)=0; ROOT::TVirtualRWMutex::GetStateBeforevirtual std::unique_ptr< State > GetStateBefore()=0; R; TADefinition TStructViewer.cxx:24; TApplication::ExecuteFilestatic Longptr_t ExecuteFile(const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::GetProtostatic TProtoClass * GetProto(const char *cname)Given the class name returns the TClassProto object for the class.Definition TClassTable.cxx:742; TClassTable::Checkstatic Bool_t Check(const char *cname, std::string &normname)Definition TClassTable.cxx:563; TClassTable::Addstatic void Add(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Add a class to the class table (this is a static function).Definition TClassTable.cxx:398; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:397753,Security,hash,hash,397753,"const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::GetProtostatic TProtoClass * GetProto(const char *cname)Given the class name returns the TClassProto object for the class.Definition TClassTable.cxx:742; TClassTable::Checkstatic Bool_t Check(const char *cname, std::string &normname)Definition TClassTable.cxx:563; TClassTable::Addstatic void Add(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Add a class to the class table (this is a static function).Definition TClassTable.cxx:398; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLTy",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:429299,Security,access,accessed,429299,"action &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * Ty",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:445580,Security,hash,hash,445580,"o_t *minfo) const finalDefinition TCling.cxx:9075; TCling::CreateListOfMethodsvoid CreateListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:467983,Security,hash,hash,467983,"ual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoadCallBack_tint(* AutoLoadCallBack_t)(const char *)Definition TInterpreter.h:132; TInterpreter::EReturnTypeEReturnTypeD",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:468199,Security,hash,hash,468199,"l void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::fInfoMethodInfo_t * fInfoDefinition TFunction.h:36; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition THashList.cxx:378; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::RegisterPrebuiltModulePathvirtual bool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0; TInterpreter::HasPCMForLibraryvirtual Bool_t HasPCMForLibrary(const char *libname) const =0; TInterpreter::AutoParsevirtual Int_t AutoParse(const char *cls)=0; TInterpreter::AutoLoadCallBack_tint(* AutoLoadCallBack_t)(const char *)Definition TInterpreter.h:132; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::Declarevirtual Bool_t Declare(const char *code)=0; TInterpreter::GetClassSharedLibsvirtual const char * GetClassSharedLibs(const char *cls, bool skipCore=true)=0; TInterpreter::ECheckCla",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:470297,Security,access,access,470297,"n TInterpreter.h:215; TInterpreter::kUnknown@ kUnknownDefinition TInterpreter.h:214; TInterpreter::kWithClassDefInline@ kWithClassDefInlineDefinition TInterpreter.h:216; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::GetRootMapFilesvirtual TObjArray * GetRootMapFiles() const =0; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TInterpreter::kProcessing@ kProcessingDefinition TInterpreter.h:77; TInterpreter::kNoError@ kNoErrorDefinition TInterpreter.h:73; TInterpreter::kRecoverable@ kRecoverableDefinition TInterpreter.h:74; TInterpreter::kDangerous@ kDangerousDefinition TInterpreter.h:75; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corres",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:470970,Security,access,access,470970,"preter::kRecoverable@ kRecoverableDefinition TInterpreter.h:74; TInterpreter::kDangerous@ kDangerousDefinition TInterpreter.h:75; TIterDefinition TCollection.h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the functi",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:471124,Security,access,access,471124,"h:235; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfDataMembers::FindObjectTObject * FindObject(const char *name) const overrideSpecialize FindObject to do search for the a data member just by name or create it if its not already...Definition TListOfDataMembers.cxx:182; TListOfDataMembers::FindTDictionary * Find(DeclId_t id) constReturn (after creating it if necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:471715,Security,access,access,471715,"necessary) the TDataMember describing the data member corresponding to t...Definition TListOfDataMembers.cxx:205; TListOfDataMembers::GetClassTClass * GetClass() constDefinition TListOfDataMembers.h:90; TListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnumsWithLock.h:31; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::FindTFunction * Find(DeclId_t id) constReturn the TMethod or TFunction describing the function corresponding to the Decl 'id'.Definition TListOfFunctions.cxx:250; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from me",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:472091,Security,access,access,472091," collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfEnums::FindTEnum * Find(DeclId_t id) constReturn the TEnum corresponding to the Decl 'id' or NULL if it does not exist.Definition TListOfEnums.cxx:179; TListOfEnums::GetTEnum * Get(DeclId_t id, const char *name)Return (after creating it if necessary) the TEnum describing the enum corresponding to the Decl 'id'.Definition TListOfEnums.cxx:205; TListOfEnums::GetClassTClass * GetClass() constDefinition TListOfEnums.h:62; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::FindTFunction * Find(DeclId_t id) constReturn the TMethod or TFunction describing the function corresponding to the Decl 'id'.Definition TListOfFunctions.cxx:250; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::GetParentconst char * GetParent() constDefinition TMemberInspector.cxx:75; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cx",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:472770,Security,access,accessing,472770,".Definition TListOfFunctionTemplates.h:35; TListOfFunctionTemplates::GetTFunctionTemplate * Get(DeclId_t id)Return (after creating it if necessary) the TMethod or TFunction describing the function correspondin...Definition TListOfFunctionTemplates.cxx:253; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListOfFunctions::FindTFunction * Find(DeclId_t id) constReturn the TMethod or TFunction describing the function corresponding to the Decl 'id'.Definition TListOfFunctions.cxx:250; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::GetParentconst char * GetParent() constDefinition TMemberInspector.cxx:75; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberInspector::GetObjectValidityEObjectPointerState GetObjectValidity() constDefinition TMemberInspector.h:50; TMemberInspector::IsTreatingNonAccessibleTypesvirtual Bool_t IsTreatingNonAccessibleTypes()Definition TMemberInspector.h:60; TMemberInspector::SetObjectValidityvoid SetObjectValidity(EObjectPointerState val)Definition TMemberInspector.h:51; TMemberInspector::InspectMembervoid InspectMember(const T &obj, const char *name, Bool_t isTransient)Definition TMemberInspector.h:63; TMemberInspector::kValidObjectGiven@ kValidObjectGivenDefinition TMemberInspector.h:36; TMemberInspector::kNoObjectGiven@ kNoObjectGivenDefinition TMemberInspector.h:35; TMemberInspector::kUns",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:478008,Security,inject,inject,478008,"cceeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::LastIndexInt_t LastIndex() constDefinition TSeqCollection.h:55; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & Repla",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:481932,Security,access,access,481932,"lename of the form:Definition TSystem.cxx:4258; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetDynamicPathvirtual const char * GetDynamicPath()Return the dynamic path (used to find shared libraries).Definition TSystem.cxx:1795; TSystem::FindDynamicLibraryvirtual const char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE)Find a dynamic library using the system search paths.Definition TSystem.cxx:2034; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definit",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:481966,Security,access,access,481966,"lename of the form:Definition TSystem.cxx:4258; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::GetProcInfovirtual int GetProcInfo(ProcInfo_t *info) constReturns cpu and memory used by this process into the ProcInfo_t structure.Definition TSystem.cxx:2489; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetDynamicPathvirtual const char * GetDynamicPath()Return the dynamic path (used to find shared libraries).Definition TSystem.cxx:1795; TSystem::FindDynamicLibraryvirtual const char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE)Find a dynamic library using the system search paths.Definition TSystem.cxx:2034; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definit",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:8202,Testability,test,testing,8202," 220}; 221R__DLLEXPORT clang::RecordDecl* TCling__DEBUG__DCtoRecordDecl(clang::DeclContext* DC) {; 222 return llvm::dyn_cast<clang::RecordDecl>(DC);; 223}; 224R__DLLEXPORT void TCling__DEBUG__dump(clang::DeclContext* DC) {; 225 return DC->dumpDeclContext();; 226}; 227R__DLLEXPORT void TCling__DEBUG__dump(clang::Decl* D) {; 228 return D->dump();; 229}; 230R__DLLEXPORT void TCling__DEBUG__dump(clang::FunctionDecl* FD) {; 231 return FD->dump();; 232}; 233R__DLLEXPORT void TCling__DEBUG__decl_dump(void* D) {; 234 return ((clang::Decl*)D)->dump();; 235}; 236R__DLLEXPORT void TCling__DEBUG__printName(clang::Decl* D) {; 237 if (clang::NamedDecl* ND = llvm::dyn_cast<clang::NamedDecl>(D)) {; 238 std::string name;; 239 {; 240 llvm::raw_string_ostream OS(name);; 241 ND->getNameForDiagnostic(OS, D->getASTContext().getPrintingPolicy(),; 242 true /*Qualified*/);; 243 }; 244 printf(""%s\n"", name.c_str());; 245 }; 246}; 247//______________________________________________________________________________; 248// These functions are helpers for testing issues directly rather than; 249// relying on side effects.; 250// This is used for the test for ROOT-7462/ROOT-6070; 251R__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {; 252 return D->isInvalidDecl();; 253}; 254R__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {; 255 TClingClassInfo *info( (TClingClassInfo*) input);; 256 assert(info && info->IsValid());; 257 return info->GetDecl()->isInvalidDecl();; 258}; 259 ; 260using std::string, std::vector;; 261using namespace clang;; 262using namespace ROOT;; 263 ; 264namespace {; 265 static const std::string gInterpreterClassDef = R""ICF(; 266#undef ClassDef; 267#define ClassDef(name, id) \; 268_ClassDefInterp_(name,id,virtual,) \; 269static int DeclFileLine() { return __LINE__; }; 270#undef ClassDefNV; 271#define ClassDefNV(name, id) \; 272_ClassDefInterp_(name,id,,) \; 273static int DeclFileLine() { return __LINE__; }; 274#undef ClassDefOverride; 275#define ClassDefOv",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:8298,Testability,test,test,8298,"______________________________; 248// These functions are helpers for testing issues directly rather than; 249// relying on side effects.; 250// This is used for the test for ROOT-7462/ROOT-6070; 251R__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {; 252 return D->isInvalidDecl();; 253}; 254R__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {; 255 TClingClassInfo *info( (TClingClassInfo*) input);; 256 assert(info && info->IsValid());; 257 return info->GetDecl()->isInvalidDecl();; 258}; 259 ; 260using std::string, std::vector;; 261using namespace clang;; 262using namespace ROOT;; 263 ; 264namespace {; 265 static const std::string gInterpreterClassDef = R""ICF(; 266#undef ClassDef; 267#define ClassDef(name, id) \; 268_ClassDefInterp_(name,id,virtual,) \; 269static int DeclFileLine() { return __LINE__; }; 270#undef ClassDefNV; 271#define ClassDefNV(name, id) \; 272_ClassDefInterp_(name,id,,) \; 273static int DeclFileLine() { return __LINE__; }; 274#undef ClassDefOverride; 275#define ClassDefOverride(name, id) \; 276_ClassDefInterp_(name,id,,override) \; 277static int DeclFileLine() { return __LINE__; }; 278)ICF"";; 279 ; 280 static const std::string gNonInterpreterClassDef = R""ICF(; 281#define __ROOTCLING__ 1; 282#undef ClassDef; 283#define ClassDef(name,id) \; 284_ClassDefOutline_(name,id,virtual,) \; 285static int DeclFileLine() { return __LINE__; }; 286#undef ClassDefNV; 287#define ClassDefNV(name, id)\; 288_ClassDefOutline_(name,id,,)\; 289static int DeclFileLine() { return __LINE__; }; 290#undef ClassDefOverride; 291#define ClassDefOverride(name, id)\; 292_ClassDefOutline_(name,id,,override)\; 293static int DeclFileLine() { return __LINE__; }; 294)ICF"";; 295 ; 296// The macros below use ::Error, so let's ensure it is included; 297 static const std::string gClassDefInterpMacro = R""ICF(; 298#include ""TError.h""; 299 ; 300#define _ClassDefInterp_(name,id,virtual_keyword, overrd) \; 301private: \; 302public: \; 303 static TClass *Class() { stati",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:8563,Testability,assert,assert,8563,"______________________________; 248// These functions are helpers for testing issues directly rather than; 249// relying on side effects.; 250// This is used for the test for ROOT-7462/ROOT-6070; 251R__DLLEXPORT bool TCling__TEST_isInvalidDecl(clang::Decl* D) {; 252 return D->isInvalidDecl();; 253}; 254R__DLLEXPORT bool TCling__TEST_isInvalidDecl(ClassInfo_t *input) {; 255 TClingClassInfo *info( (TClingClassInfo*) input);; 256 assert(info && info->IsValid());; 257 return info->GetDecl()->isInvalidDecl();; 258}; 259 ; 260using std::string, std::vector;; 261using namespace clang;; 262using namespace ROOT;; 263 ; 264namespace {; 265 static const std::string gInterpreterClassDef = R""ICF(; 266#undef ClassDef; 267#define ClassDef(name, id) \; 268_ClassDefInterp_(name,id,virtual,) \; 269static int DeclFileLine() { return __LINE__; }; 270#undef ClassDefNV; 271#define ClassDefNV(name, id) \; 272_ClassDefInterp_(name,id,,) \; 273static int DeclFileLine() { return __LINE__; }; 274#undef ClassDefOverride; 275#define ClassDefOverride(name, id) \; 276_ClassDefInterp_(name,id,,override) \; 277static int DeclFileLine() { return __LINE__; }; 278)ICF"";; 279 ; 280 static const std::string gNonInterpreterClassDef = R""ICF(; 281#define __ROOTCLING__ 1; 282#undef ClassDef; 283#define ClassDef(name,id) \; 284_ClassDefOutline_(name,id,virtual,) \; 285static int DeclFileLine() { return __LINE__; }; 286#undef ClassDefNV; 287#define ClassDefNV(name, id)\; 288_ClassDefOutline_(name,id,,)\; 289static int DeclFileLine() { return __LINE__; }; 290#undef ClassDefOverride; 291#define ClassDefOverride(name, id)\; 292_ClassDefOutline_(name,id,,override)\; 293static int DeclFileLine() { return __LINE__; }; 294)ICF"";; 295 ; 296// The macros below use ::Error, so let's ensure it is included; 297 static const std::string gClassDefInterpMacro = R""ICF(; 298#include ""TError.h""; 299 ; 300#define _ClassDefInterp_(name,id,virtual_keyword, overrd) \; 301private: \; 302public: \; 303 static TClass *Class() { stati",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:36908,Testability,assert,assert,36908," std::string& str); 1015{; 1016 bool notPresent = fLinesHashSet.emplace(fHashFunc(str)).second;; 1017 if (notPresent){; 1018 fContent+=str;; 1019 }; 1020 return notPresent;; 1021}; 1022 ; 1023std::string TCling::ToString(const char* type, void* obj); 1024{; 1025 return fInterpreter->toString(type, obj);; 1026}; 1027 ; 1028////////////////////////////////////////////////////////////////////////////////; 1029///\returns true if the module was loaded.; 1030static bool LoadModule(const std::string &ModuleName, cling::Interpreter &interp); 1031{; 1032 // When starting up ROOT, cling would load all modulemap files on the include; 1033 // paths. However, in a ROOT session, it is very common to run aclic which; 1034 // will invoke rootcling and possibly produce a modulemap and a module in; 1035 // the current folder.; 1036 //; 1037 // Before failing, try loading the modulemap in the current folder and try; 1038 // loading the requested module from it.; 1039 std::string currentDir = gSystem->WorkingDirectory();; 1040 assert(!currentDir.empty());; 1041 gCling->RegisterPrebuiltModulePath(currentDir);; 1042 if (gDebug > 2); 1043 ::Info(""TCling::__LoadModule"", ""Preloading module %s. \n"",; 1044 ModuleName.c_str());; 1045 ; 1046 return interp.loadModule(ModuleName, /*Complain=*/true);; 1047}; 1048 ; 1049////////////////////////////////////////////////////////////////////////////////; 1050/// Loads the C++ modules that we require to run any ROOT program. This is just; 1051/// supposed to make a C++ module from a modulemap available to the interpreter.; 1052static void LoadModules(const std::vector<std::string> &modules, cling::Interpreter &interp); 1053{; 1054 for (const auto &modName : modules); 1055 LoadModule(modName, interp);; 1056}; 1057 ; 1058static bool IsFromRootCling() {; 1059 // rootcling also uses TCling for generating the dictionary ROOT files.; 1060 const static bool foundSymbol = dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"");; 1061 return foundSymbol;; 1062}; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:38825,Testability,assert,assert,38825,""");; 1061 return foundSymbol;; 1062}; 1063 ; 1064/// Checks if there is an ASTFile on disk for the given module \c M.; 1065static bool HasASTFileOnDisk(clang::Module *M, const clang::Preprocessor &PP, std::string *FullFileName = nullptr); 1066{; 1067 const HeaderSearchOptions &HSOpts = PP.getHeaderSearchInfo().getHeaderSearchOpts();; 1068 ; 1069 std::string ModuleFileName;; 1070 if (!HSOpts.PrebuiltModulePaths.empty()); 1071 // Load the module from *only* in the prebuilt module path.; 1072 ModuleFileName = PP.getHeaderSearchInfo().getPrebuiltModuleFileName(M->Name);; 1073 if (FullFileName); 1074 *FullFileName = ModuleFileName;; 1075 ; 1076 return !ModuleFileName.empty();; 1077}; 1078 ; 1079static bool HaveFullGlobalModuleIndex = false;; 1080static GlobalModuleIndex *loadGlobalModuleIndex(cling::Interpreter &interp); 1081{; 1082 CompilerInstance &CI = *interp.getCI();; 1083 Preprocessor &PP = CI.getPreprocessor();; 1084 auto ModuleManager = CI.getASTReader();; 1085 assert(ModuleManager);; 1086 // StringRef ModuleIndexPath = HSI.getModuleCachePath();; 1087 // HeaderSearch& HSI = PP.getHeaderSearchInfo();; 1088 // HSI.setModuleCachePath(TROOT::GetSharedLibDir().Data());; 1089 std::string ModuleIndexPath = TROOT::GetSharedLibDir().Data();; 1090 if (ModuleIndexPath.empty()); 1091 return nullptr;; 1092 // Get an existing global index. This loads it if not already loaded.; 1093 ModuleManager->resetForReload();; 1094 ModuleManager->loadGlobalIndex();; 1095 GlobalModuleIndex *GlobalIndex = ModuleManager->getGlobalIndex();; 1096 ; 1097 // For finding modules needing to be imported for fixit messages,; 1098 // we need to make the global index cover all modules, so we do that here.; 1099 if (!GlobalIndex && !HaveFullGlobalModuleIndex) {; 1100 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1101 bool RecreateIndex = false;; 1102 for (ModuleMap::module_iterator I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1103 Module *TheModule = I->second;; 1104 //",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:41285,Testability,assert,assert,41285,"tionFinder> {; 1115 DefinitionFinder(clang::GlobalModuleIndex::UserDefinedInterestingIDs& IDs,; 1116 clang::TranslationUnitDecl* TU) : DefinitionIDs(IDs) {; 1117 TraverseDecl(TU);; 1118 }; 1119 bool VisitNamedDecl(NamedDecl *ND) {; 1120 if (!ND->isFromASTFile()); 1121 return true;; 1122 if (!ND->getIdentifier()); 1123 return true;; 1124 ; 1125 if (ND->getAccess() == AS_protected || ND->getAccess() == AS_private); 1126 return true;; 1127 ; 1128 if (TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {; 1129 if (TD->isCompleteDefinition()); 1130 Register(TD);; 1131 } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {; 1132 Register(NSD, /*AddSingleEntry=*/ false);; 1133 }; 1134 else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND)); 1135 Register(TND);; 1136 // FIXME: Add the rest...; 1137 return true; // continue decending; 1138 }; 1139 private:; 1140 clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;; 1141 void Register(const NamedDecl* ND, bool AddSingleEntry = true) {; 1142 assert(ND->isFromASTFile());; 1143 // FIXME: All decls should have an owning module once rootcling; 1144 // updates its generated decls from within the LookupHelper & co.; 1145 if (!ND->hasOwningModule()) {; 1146#ifndef NDEBUG; 1147 SourceManager &SM = ND->getASTContext().getSourceManager();; 1148 SourceLocation Loc = ND->getLocation();; 1149 const FileEntry *FE = SM.getFileEntryForID(SM.getFileID(Loc));; 1150 (void)FE;; 1151 assert(FE->getName().contains(""input_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:41715,Testability,assert,assert,41715,"128 if (TagDecl *TD = llvm::dyn_cast<TagDecl>(ND)) {; 1129 if (TD->isCompleteDefinition()); 1130 Register(TD);; 1131 } else if (NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {; 1132 Register(NSD, /*AddSingleEntry=*/ false);; 1133 }; 1134 else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND)); 1135 Register(TND);; 1136 // FIXME: Add the rest...; 1137 return true; // continue decending; 1138 }; 1139 private:; 1140 clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;; 1141 void Register(const NamedDecl* ND, bool AddSingleEntry = true) {; 1142 assert(ND->isFromASTFile());; 1143 // FIXME: All decls should have an owning module once rootcling; 1144 // updates its generated decls from within the LookupHelper & co.; 1145 if (!ND->hasOwningModule()) {; 1146#ifndef NDEBUG; 1147 SourceManager &SM = ND->getASTContext().getSourceManager();; 1148 SourceLocation Loc = ND->getLocation();; 1149 const FileEntry *FE = SM.getFileEntryForID(SM.getFileID(Loc));; 1150 (void)FE;; 1151 assert(FE->getName().contains(""input_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 Global",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:41882,Testability,assert,assert,41882,"NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {; 1132 Register(NSD, /*AddSingleEntry=*/ false);; 1133 }; 1134 else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND)); 1135 Register(TND);; 1136 // FIXME: Add the rest...; 1137 return true; // continue decending; 1138 }; 1139 private:; 1140 clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;; 1141 void Register(const NamedDecl* ND, bool AddSingleEntry = true) {; 1142 assert(ND->isFromASTFile());; 1143 // FIXME: All decls should have an owning module once rootcling; 1144 // updates its generated decls from within the LookupHelper & co.; 1145 if (!ND->hasOwningModule()) {; 1146#ifndef NDEBUG; 1147 SourceManager &SM = ND->getASTContext().getSourceManager();; 1148 SourceLocation Loc = ND->getLocation();; 1149 const FileEntry *FE = SM.getFileEntryForID(SM.getFileID(Loc));; 1150 (void)FE;; 1151 assert(FE->getName().contains(""input_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 GlobalIndex = ModuleManager->getGlobalIndex();; 1177 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:41910,Testability,assert,assert,41910,"NamespaceDecl *NSD = llvm::dyn_cast<NamespaceDecl>(ND)) {; 1132 Register(NSD, /*AddSingleEntry=*/ false);; 1133 }; 1134 else if (TypedefNameDecl *TND = dyn_cast<TypedefNameDecl>(ND)); 1135 Register(TND);; 1136 // FIXME: Add the rest...; 1137 return true; // continue decending; 1138 }; 1139 private:; 1140 clang::GlobalModuleIndex::UserDefinedInterestingIDs &DefinitionIDs;; 1141 void Register(const NamedDecl* ND, bool AddSingleEntry = true) {; 1142 assert(ND->isFromASTFile());; 1143 // FIXME: All decls should have an owning module once rootcling; 1144 // updates its generated decls from within the LookupHelper & co.; 1145 if (!ND->hasOwningModule()) {; 1146#ifndef NDEBUG; 1147 SourceManager &SM = ND->getASTContext().getSourceManager();; 1148 SourceLocation Loc = ND->getLocation();; 1149 const FileEntry *FE = SM.getFileEntryForID(SM.getFileID(Loc));; 1150 (void)FE;; 1151 assert(FE->getName().contains(""input_line_""));; 1152#endif; 1153 return;; 1154 }; 1155 ; 1156 Module *OwningModule = ND->getOwningModule()->getTopLevelModule();; 1157 assert(OwningModule);; 1158 assert(!ND->getName().empty() && ""Empty name"");; 1159 if (AddSingleEntry && DefinitionIDs.count(ND->getName())); 1160 return;; 1161 // FIXME: The FileEntry in not stable to serialize.; 1162 // FIXME: We might end up with many times with the same module.; 1163 // FIXME: We might end up two modules containing a definition.; 1164 // FIXME: What do we do if no definition is found.; 1165 DefinitionIDs[ND->getName()].push_back(OwningModule->getASTFile());; 1166 }; 1167 };; 1168 DefinitionFinder defFinder(IDs, CI.getASTContext().getTranslationUnitDecl());; 1169 ; 1170 llvm::cantFail(GlobalModuleIndex::writeIndex(CI.getFileManager(),; 1171 CI.getPCHContainerReader(),; 1172 ModuleIndexPath,; 1173 &IDs));; 1174 ModuleManager->resetForReload();; 1175 ModuleManager->loadGlobalIndex();; 1176 GlobalIndex = ModuleManager->getGlobalIndex();; 1177 }; 1178 HaveFullGlobalModuleIndex = true;; 1179 }; 1180 return GlobalIndex;; 1181",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:45403,Testability,assert,assert,45403,"r<std::string> FIXMEModules = {""Hist""};; 1230 clang::CompilerInstance &CI = *clingInterp.getCI();; 1231 clang::Preprocessor &PP = CI.getPreprocessor();; 1232 ModuleMap &MMap = PP.getHeaderSearchInfo().getModuleMap();; 1233 if (MMap.findModule(""RInterface"")); 1234 FIXMEModules.push_back(""RInterface"");; 1235 ; 1236 LoadModules(FIXMEModules, clingInterp);; 1237 ; 1238 GlobalModuleIndex *GlobalIndex = nullptr;; 1239 loadGlobalModuleIndex(clingInterp);; 1240 // FIXME: The ASTReader still calls loadGlobalIndex and loads the file; 1241 // We should investigate how to suppress it completely.; 1242 GlobalIndex = CI.getASTReader()->getGlobalIndex();; 1243 ; 1244 llvm::StringSet<> KnownModuleFileNames;; 1245 if (GlobalIndex); 1246 GlobalIndex->getKnownModuleFileNames(KnownModuleFileNames);; 1247 ; 1248 std::vector<std::string> PendingModules;; 1249 PendingModules.reserve(256);; 1250 for (auto I = MMap.module_begin(), E = MMap.module_end(); I != E; ++I) {; 1251 clang::Module *M = I->second;; 1252 assert(M);; 1253 ; 1254 // We want to load only already created modules.; 1255 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:46473,Testability,assert,assert,46473,"55 std::string FullASTFilePath;; 1256 if (!HasASTFileOnDisk(M, PP, &FullASTFilePath)); 1257 continue;; 1258 ; 1259 if (GlobalIndex && KnownModuleFileNames.count(FullASTFilePath)); 1260 continue;; 1261 ; 1262 if (M->IsUnimportable); 1263 continue;; 1264 ; 1265 if (GlobalIndex); 1266 LoadModule(M->Name, clingInterp);; 1267 else {; 1268 // FIXME: We may be able to remove those checks as cling::loadModule; 1269 // checks if a module was alredy loaded.; 1270 if (std::find(CoreModules.begin(), CoreModules.end(), M->Name) != CoreModules.end()); 1271 continue; // This is a core module which was already loaded.; 1272 ; 1273 // Load system modules now and delay the other modules after we have; 1274 // loaded all system ones.; 1275 if (M->IsSystem); 1276 LoadModule(M->Name, clingInterp);; 1277 else; 1278 PendingModules.push_back(M->Name);; 1279 }; 1280 }; 1281 LoadModules(PendingModules, clingInterp);; 1282 }; 1283 ; 1284 // Check that the gROOT macro was exported by any core module.; 1285 assert(clingInterp.getMacro(""gROOT"") && ""Couldn't load gROOT macro?"");; 1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes += gClassDefInterpMacro + ""\n""; 1314 + gInterpreterClassDef + ""\n""; 1315 ""#undef ClassImp\n""; 1316",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:47728,Testability,assert,assert,47728,"1286 ; 1287 // `ERROR` and `PI` are from loading R related modules, which conflict with; 1288 // user's code.; 1289 clingInterp.declare(R""CODE(; 1290#ifdef PI; 1291# undef PI; 1292#endif; 1293#ifdef ERROR; 1294# undef ERROR; 1295#endif; 1296 )CODE"");; 1297}; 1298 ; 1299static void RegisterPreIncludedHeaders(cling::Interpreter &clingInterp); 1300{; 1301 std::string PreIncludes;; 1302 bool hasCxxModules = clingInterp.getCI()->getLangOpts().Modules;; 1303 ; 1304 // For the list to also include string, we have to include it now.; 1305 // rootcling does parts already if needed, e.g. genreflex does not want using; 1306 // namespace std.; 1307 if (IsFromRootCling()) {; 1308 PreIncludes += ""#include \""RtypesCore.h\""\n"";; 1309 } else {; 1310 if (!hasCxxModules); 1311 PreIncludes += ""#include \""Rtypes.h\""\n"";; 1312 ; 1313 PreIncludes += gClassDefInterpMacro + ""\n""; 1314 + gInterpreterClassDef + ""\n""; 1315 ""#undef ClassImp\n""; 1316 ""#define ClassImp(X);\n"";; 1317 }; 1318 if (!hasCxxModules); 1319 PreIncludes += ""#include <string>\n"";; 1320 ; 1321 // We must include it even when we have modules because it is marked as; 1322 // textual in the modulemap due to the nature of the assert header.; 1323#ifndef R__WIN32; 1324 PreIncludes += ""#include <cassert>\n"";; 1325#endif; 1326 PreIncludes += ""using namespace std;\n"";; 1327 clingInterp.declare(PreIncludes);; 1328}; 1329 ; 1330////////////////////////////////////////////////////////////////////////////////; 1331/// Initialize the cling interpreter interface.; 1332/// \param name name for TInterpreter; 1333/// \param title title for TInterpreter; 1334/// \param argv - array of arguments passed to the cling::Interpreter constructor; 1335/// e.g. `-DFOO=bar`. The last element of the array must be `nullptr`.; 1336 ; 1337TCling::TCling(const char *name, const char *title, const char* const argv[], void *interpLibHandle); 1338: TInterpreter(name, title), fGlobalsListSerial(-1), fMapfile(nullptr),; 1339 fRootmapFiles(nullptr), fLockProcess",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:54111,Testability,assert,assert,54111,"es only if -cxxmodule; 1451 // flag is passed.; 1452 if (fCxxModulesEnabled && !fromRootCling) {; 1453 // For now we prefer rootcling to enumerate explicitly its modulemaps.; 1454 std::vector<std::string> ModuleMaps;; 1455 std::string ModuleMapSuffix = ROOT::FoundationUtils::GetPathSeparator() + ""ROOT.modulemap"";; 1456 ModuleMaps.push_back(TROOT::GetIncludeDir().Data() + ModuleMapSuffix);; 1457 GetEnvVarPath(""CLING_MODULEMAP_FILES"", ModuleMaps);; 1458 ; 1459 std::string cwd = gSystem->WorkingDirectory();; 1460 // Give highest precedence of the modulemap in the cwd if any.; 1461 if (llvm::sys::fs::exists(cwd + ModuleMapSuffix)); 1462 ModuleMaps.push_back(cwd + ModuleMapSuffix);; 1463 ; 1464 for (const std::string& M : ModuleMaps); 1465 clingArgsStorage.push_back(""-fmodule-map-file="" + M);; 1466 ; 1467 std::string ModulesCachePath;; 1468 EnvOpt = llvm::sys::Process::GetEnv(""CLING_MODULES_CACHE_PATH"");; 1469 if (EnvOpt.has_value()){; 1470 StringRef Env(*EnvOpt);; 1471 assert(llvm::sys::fs::exists(Env) && ""Path does not exist!"");; 1472 ModulesCachePath = Env.str();; 1473 } else {; 1474 ModulesCachePath = TROOT::GetSharedLibDir();; 1475 }; 1476 ; 1477 clingArgsStorage.push_back(""-fmodules-cache-path="" + ModulesCachePath);; 1478 }; 1479 ; 1480 std::vector<const char*> interpArgs;; 1481 for (std::vector<std::string>::const_iterator iArg = clingArgsStorage.begin(),; 1482 eArg = clingArgsStorage.end(); iArg != eArg; ++iArg); 1483 interpArgs.push_back(iArg->c_str());; 1484 ; 1485 // Activate C++ modules support. If we are running within rootcling, it's up; 1486 // to rootcling to set this flag depending on whether it wants to produce; 1487 // C++ modules.; 1488 TString vfsArg;; 1489 if (fCxxModulesEnabled) {; 1490 if (!fromRootCling) {; 1491 // We only set this flag, rest is done by the CIFactory.; 1492 interpArgs.push_back(""-fmodules"");; 1493 interpArgs.push_back(""-fno-implicit-module-maps"");; 1494 // We should never build modules during runtime, so let's enable the; 1495 // ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:61759,Testability,assert,assert,61759,"21 // Run them before shutting down.; 1622 if (!IsFromRootCling()); 1623 GetInterpreterImpl()->runAtExitFuncs();; 1624 fIsShuttingDown = true;; 1625 delete fMapfile;; 1626 delete fRootmapFiles;; 1627 delete fTemporaries;; 1628 delete fNormalizedCtxt;; 1629 delete fLookupHelper;; 1630 gCling = nullptr;; 1631}; 1632 ; 1633////////////////////////////////////////////////////////////////////////////////; 1634/// Initialize the interpreter, once TROOT::fInterpreter is set.; 1635 ; 1636void TCling::Initialize(); 1637{; 1638 fClingCallbacks->Initialize();; 1639 ; 1640 // We are set up. Enable ROOT's AutoLoading.; 1641 if (IsFromRootCling()); 1642 return;; 1643 ; 1644 // Read the rules before enabling the auto loading to not inadvertently; 1645 // load the libraries for the classes concerned even-though the user is; 1646 // *not* using them.; 1647 // Note this call must happen before the first call to LoadLibraryMap.; 1648 assert(GetRootMapFiles() == nullptr && ""Must be called before LoadLibraryMap!"");; 1649 TClass::ReadRules(); // Read the default customization rules ...; 1650 ; 1651 LoadLibraryMap();; 1652 SetClassAutoLoading(true);; 1653}; 1654 ; 1655void TCling::ShutDown(); 1656{; 1657 fIsShuttingDown = true;; 1658 ResetGlobals();; 1659}; 1660 ; 1661////////////////////////////////////////////////////////////////////////////////; 1662/// Helper to initialize TVirtualStreamerInfo's factor early.; 1663/// Use static initialization to insure only one TStreamerInfo is created.; 1664static bool R__InitStreamerInfoFactory(); 1665{; 1666 // Use lambda since SetFactory return void.; 1667 auto setFactory = []() {; 1668 TVirtualStreamerInfo::SetFactory(new TStreamerInfo());; 1669 return kTRUE;; 1670 };; 1671 static bool doneFactory = setFactory();; 1672 return doneFactory; // avoid unused variable warning.; 1673}; 1674 ; 1675////////////////////////////////////////////////////////////////////////////////; 1676/// Register Rdict data for future loading by LoadPCM;; 1677 ; 1678void",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:68220,Testability,assert,assert,68220,"r_t dict = gClassTable->GetDict(proto->GetName());; 1782 if (!dict) {; 1783 ::Error(""TCling::LoadPCM"", ""Inconsistent TClassTable for %s"", proto->GetName());; 1784 } else {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdi",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:68264,Testability,assert,assert,68264,"lse {; 1785 // This will replace the existing TClass.; 1786 TClass *ncl = (*dict)();; 1787 if (ncl); 1788 ncl->PostLoadCheck();; 1789 }; 1790 }; 1791 }; 1792 }; 1793 ; 1794 protoClasses->Clear(); // Ownership was transfered to TClassTable.; 1795 delete protoClasses;; 1796 }; 1797 ; 1798 TObjArray *dataTypes;; 1799 pcmFile.GetObject(""__Typedefs"", dataTypes);; 1800 if (dataTypes) {; 1801 for (auto typedf : *dataTypes); 1802 gROOT->GetListOfTypes()->Add(typedf);; 1803 dataTypes->Clear(); // Ownership was transfered to TListOfTypes.; 1804 delete dataTypes;; 1805 }; 1806}; 1807 ; 1808////////////////////////////////////////////////////////////////////////////////; 1809/// Tries to load a rdict PCM, issues diagnostics if it fails.; 1810 ; 1811void TCling::LoadPCM(std::string pcmFileNameFullPath); 1812{; 1813 SuspendAutoLoadingRAII autoloadOff(this);; 1814 SuspendAutoParsing autoparseOff(this);; 1815 assert(!pcmFileNameFullPath.empty());; 1816 assert(llvm::sys::path::is_absolute(pcmFileNameFullPath));; 1817 ; 1818 // Easier to work with the ROOT interfaces.; 1819 TString pcmFileName = pcmFileNameFullPath;; 1820 ; 1821 // Prevent the ROOT-PCMs hitting this during auto-load during; 1822 // JITting - which will cause recursive compilation.; 1823 // Avoid to call the plugin manager at all.; 1824 R__InitStreamerInfoFactory();; 1825 ; 1826 TDirectory::TContext ctxt;; 1827 llvm::SaveAndRestore<Int_t> SaveGDebug(gDebug);; 1828 if (gDebug > 5) {; 1829 gDebug -= 5;; 1830 ::Info(""TCling::LoadPCM"", ""Loading ROOT PCM %s"", pcmFileName.Data());; 1831 } else {; 1832 gDebug = 0;; 1833 }; 1834 ; 1835 if (llvm::sys::fs::is_symlink_file(pcmFileNameFullPath)); 1836 pcmFileNameFullPath = ROOT::TMetaUtils::GetRealPath(pcmFileNameFullPath);; 1837 ; 1838 auto pendingRdict = fPendingRdicts.find(pcmFileNameFullPath);; 1839 if (pendingRdict != fPendingRdicts.end()) {; 1840 llvm::StringRef pcmContent = pendingRdict->second;; 1841 TMemFile::ZeroCopyView_t range{pcmContent.data(), pcmContent.size()};; 18",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:71921,Testability,assert,assert,71921,"83 // It visits the AST and marks all classes (in all of their redeclarations); 1884 // with the setHasExternalLexicalStorage method.; 1885 public:; 1886 bool VisitRecordDecl(clang::RecordDecl* rcd){; 1887 if (gDebug > 2); 1888 Info(""ExtLexicalStorageAdder"",; 1889 ""Adding external lexical storage to class %s"",; 1890 rcd->getNameAsString().c_str());; 1891 auto reDeclPtr = rcd->getMostRecentDecl();; 1892 do {; 1893 reDeclPtr->setHasExternalLexicalStorage();; 1894 } while ((reDeclPtr = reDeclPtr->getPreviousDecl()));; 1895 ; 1896 return false;; 1897 }; 1898 };; 1899 ; 1900 ; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904///\returns true if the module map was loaded, false on error or if the map was; 1905/// already loaded.; 1906bool TCling::RegisterPrebuiltModulePath(const std::string &FullPath,; 1907 const std::string &ModuleMapName /*= ""module.modulemap""*/) const; 1908{; 1909 assert(llvm::sys::path::is_absolute(FullPath));; 1910 Preprocessor &PP = fInterpreter->getCI()->getPreprocessor();; 1911 FileManager &FM = PP.getFileManager();; 1912 // FIXME: In a ROOT session we can add an include path (through .I /inc/path); 1913 // We should look for modulemap files there too.; 1914 if (auto DE = FM.getOptionalDirectoryRef(FullPath)) {; 1915 HeaderSearch &HS = PP.getHeaderSearchInfo();; 1916 HeaderSearchOptions &HSOpts = HS.getHeaderSearchOpts();; 1917 const auto &ModPaths = HSOpts.PrebuiltModulePaths;; 1918 bool pathExists = std::find(ModPaths.begin(), ModPaths.end(), FullPath) != ModPaths.end();; 1919 if (!pathExists); 1920 HSOpts.AddPrebuiltModulePath(FullPath);; 1921 // We cannot use HS.lookupModuleMapFile(DE, /*IsFramework*/ false);; 1922 // because its internal call to getFile has CacheFailure set to true.; 1923 // In our case, modulemaps can appear any time due to ACLiC.; 1924 // Code copied from HS.lookupModuleMapFile.; 1925 llvm::SmallString<256> ModuleMapFileName(DE->getName());; 1926 llvm::sys::path::append(",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:78786,Testability,assert,assert,78786,"44 // their autoparse information. We could be more subtil and remove only; 2045 // the failed one or only the one in this module, but for now this is; 2046 // better than nothing.; 2047 fLookedUpClasses.clear();; 2048 ; 2049 // Make sure we do not set off AutoLoading or autoparsing during the; 2050 // module registration!; 2051 SuspendAutoLoadingRAII autoLoadOff(this);; 2052 ; 2053 for (const char** inclPath = includePaths; *inclPath; ++inclPath) {; 2054 TCling::AddIncludePath(*inclPath);; 2055 }; 2056 cling::Transaction* T = nullptr;; 2057 // Put the template decls and the number of arguments to skip in the TNormalizedCtxt; 2058 for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){; 2059 const std::string& fwdDecl = fwdDeclArgToSkipPair.first;; 2060 const int nArgsToSkip = fwdDeclArgToSkipPair.second;; 2061 auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A fwd declaration could not be compiled"");; 2064 if (compRes!=cling::Interpreter::kSuccess){; 2065 Warning(""TCling::RegisterModule"",; 2066 ""Problems in declaring string '%s' were encountered."",; 2067 fwdDecl.c_str()) ;; 2068 continue;; 2069 }; 2070 ; 2071 // Drill through namespaces recursively until the template is found; 2072 if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){; 2073 fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);; 2074 }; 2075 ; 2076 }; 2077 ; 2078 // FIXME: Remove #define __ROOTCLING__ once PCMs are there.; 2079 // This is used to give Sema the same view on ACLiC'ed files (which; 2080 // are then #included through the dictionary) as rootcling had.; 2081 TString code = gNonInterpreterClassDef;; 2082 if (payloadCode); 2083 code += payloadCode;; 2084 ; 2085 std::string dyLibName = cling::DynamicLibraryManager::getSymbolLocation(triggerFunc);; 2086 assert(!llvm::sys::fs::is_symlink_file(dyLibName));; 2087 ; 2088 if (dyLibName.empty()) {; 2089 ::Error(""TCling::R",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:79786,Testability,assert,assert,79786,"o compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A fwd declaration could not be compiled"");; 2064 if (compRes!=cling::Interpreter::kSuccess){; 2065 Warning(""TCling::RegisterModule"",; 2066 ""Problems in declaring string '%s' were encountered."",; 2067 fwdDecl.c_str()) ;; 2068 continue;; 2069 }; 2070 ; 2071 // Drill through namespaces recursively until the template is found; 2072 if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){; 2073 fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);; 2074 }; 2075 ; 2076 }; 2077 ; 2078 // FIXME: Remove #define __ROOTCLING__ once PCMs are there.; 2079 // This is used to give Sema the same view on ACLiC'ed files (which; 2080 // are then #included through the dictionary) as rootcling had.; 2081 TString code = gNonInterpreterClassDef;; 2082 if (payloadCode); 2083 code += payloadCode;; 2084 ; 2085 std::string dyLibName = cling::DynamicLibraryManager::getSymbolLocation(triggerFunc);; 2086 assert(!llvm::sys::fs::is_symlink_file(dyLibName));; 2087 ; 2088 if (dyLibName.empty()) {; 2089 ::Error(""TCling::RegisterModule"", ""Dictionary trigger function for %s not found"", modulename);; 2090 return;; 2091 }; 2092 ; 2093 // The triggerFunc may not be in a shared object but in an executable.; 2094 bool isSharedLib = cling::DynamicLibraryManager::isSharedLibrary(dyLibName);; 2095 ; 2096 bool wasDlopened = false;; 2097 ; 2098 // If this call happens after dlopen has finished (i.e. late registration); 2099 // there is no need to dlopen the library recursively. See ROOT-8437 where; 2100 // the dyLibName would correspond to the binary.; 2101 if (!lateRegistration) {; 2102 ; 2103 if (isSharedLib) {; 2104 // We need to open the dictionary shared library, to resolve symbols; 2105 // requested by the JIT from it: as the library is currently being dlopen'ed,; 2106 // its symbols are not yet reachable from the process.; 2107 // Recu",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:84451,Testability,assert,assert,84451,"& ""Inconsistent enum fwd decl (end)!"");; 2168 while (isspace(fwdDeclsLine[posEnumNameEnd])); 2169 --posEnumNameEnd;; 2170 // posEnumNameEnd now points to the last character of the name.; 2171 ; 2172 std::string enumName = fwdDeclsLine.substr(posEnumName,; 2173 posEnumNameEnd - posEnumName + 1);; 2174 ; 2175 if (clang::NamedDecl* enumDecl; 2176 = cling::utils::Lookup::Named(&fInterpreter->getSema(),; 2177 enumName.c_str(), DC)) {; 2178 // We have an existing enum decl (forward or definition);; 2179 // skip this.; 2180 R__ASSERT(llvm::dyn_cast<clang::EnumDecl>(enumDecl) && ""not an enum decl!"");; 2181 (void)enumDecl;; 2182 continue;; 2183 }; 2184 }; 2185 }; 2186 ; 2187 fwdDeclsCodeLessEnums += fwdDeclsLine + ""\n"";; 2188 }; 2189 }; 2190 ; 2191 if (!fwdDeclsCodeLessEnums.empty()){ // Avoid the overhead if nothing is to be declared; 2192 auto compRes = fInterpreter->declare(fwdDeclsCodeLessEnums, &T);; 2193 assert(cling::Interpreter::kSuccess == compRes &&; 2194 ""The forward declarations could not be compiled"");; 2195 if (compRes!=cling::Interpreter::kSuccess){; 2196 Warning(""TCling::RegisterModule"",; 2197 ""Problems in compiling forward declarations for module %s: '%s'"",; 2198 modulename, fwdDeclsCodeLessEnums.c_str()) ;; 2199 }; 2200 else if (T){; 2201 // Loop over all decls in the transaction and go through them all; 2202 // to mark them properly.; 2203 // In order to do that, we first iterate over all the DelayedCallInfos; 2204 // within the transaction. Then we loop over all Decls in the DeclGroupRef; 2205 // contained in the DelayedCallInfos. For each decl, we traverse.; 2206 ExtLexicalStorageAdder elsa;; 2207 for (auto dciIt = T->decls_begin();dciIt!=T->decls_end();dciIt++){; 2208 cling::Transaction::DelayCallInfo& dci = *dciIt;; 2209 for(auto dit = dci.m_DGR.begin(); dit != dci.m_DGR.end(); ++dit) {; 2210 clang::Decl* declPtr = *dit;; 2211 elsa.TraverseDecl(declPtr);; 2212 }; 2213 }; 2214 }; 2215 }; 2216 ; 2217 // Now we register all the headers necessary for the cl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:90148,Testability,assert,assert,90148,"ame(modulename));; 2300 LoadPCM(pcmFileNameFullPath.str().str());; 2301 }; 2302 ; 2303 { // scope within which diagnostics are de-activated; 2304 // For now we disable diagnostics because we saw them already at; 2305 // dictionary generation time. That won't be an issue with the PCMs.; 2306 ; 2307 clangDiagSuppr diagSuppr(TheSema.getDiagnostics());; 2308 ; 2309#if defined(R__MUST_REVISIT); 2310#if R__MUST_REVISIT(6,2); 2311 Warning(""TCling::RegisterModule"",""Diagnostics suppression should be gone by now."");; 2312#endif; 2313#endif; 2314 ; 2315 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand){; 2316 SuspendAutoParsing autoParseRaii(this);; 2317 ; 2318 const cling::Transaction* watermark = fInterpreter->getLastTransaction();; 2319 cling::Interpreter::CompilationResult compRes = fInterpreter->parseForModule(code.Data());; 2320 if (isACLiC) {; 2321 // Register an unload point.; 2322 fMetaProcessor->registerUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:91224,Testability,assert,assert,91224,"sterUnloadPoint(watermark, headers[0]);; 2323 }; 2324 ; 2325 assert(cling::Interpreter::kSuccess == compRes &&; 2326 ""Payload code of a dictionary could not be parsed correctly."");; 2327 if (compRes!=cling::Interpreter::kSuccess) {; 2328 Warning(""TCling::RegisterModule"",; 2329 ""Problems declaring payload for module %s."", modulename) ;; 2330 }; 2331 }; 2332 }; 2333 ; 2334 // Now that all the header have been registered/compiled, let's; 2335 // make sure to 'reset' the TClass that have a class init in this module; 2336 // but already had their type information available (using information/header; 2337 // loaded from other modules or from class rules or from opening a TFile; 2338 // or from loading header in a way that did not provoke the loading of; 2339 // the library we just loaded).; 2340 ProcessClassesToUpdate();; 2341 ; 2342 if (!ModuleWasSuccessfullyLoaded && !hasHeaderParsingOnDemand) {; 2343 // __ROOTCLING__ might be pulled in through PCH; 2344 fInterpreter->declare(""#ifdef __ROOTCLING__\n""; 2345 ""#undef __ROOTCLING__\n""; 2346 + gInterpreterClassDef +; 2347 ""#endif"");; 2348 }; 2349 ; 2350 if (wasDlopened) {; 2351 assert(isSharedLib);; 2352 void* dyLibHandle = fRegisterModuleDyLibs.back();; 2353 fRegisterModuleDyLibs.pop_back();; 2354 dlclose(dyLibHandle);; 2355 }; 2356}; 2357 ; 2358void TCling::AddAvailableIndentifiers(TSeqCollection& Idents) {; 2359 clang::CompilerInstance& CI = *GetInterpreterImpl()->getCI();; 2360 ASTContext &C = CI.getASTContext();; 2361 ; 2362 // Do not do anything if we have no global module index.; 2363 // FIXME: This is mostly to real with false positives in the TTabCom; 2364 // interface for non-modules.; 2365 if (!fCxxModulesEnabled); 2366 return;; 2367 ; 2368 if (IdentifierInfoLookup *External = C.Idents.getExternalIdentifierLookup()) {; 2369 std::unique_ptr<IdentifierIterator> Iter(External->getIdentifiers());; 2370 for (llvm::StringRef Ident = Iter->Next(); !Ident.empty(); Ident = Iter->Next()) {; 2371 std::string I = Ident.str();",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:121913,Testability,test,test,121913," TString tLibName(libname);; 3133 if (gSystem->FindDynamicLibrary(tLibName, kTRUE)); 3134 return fInterpreter->getDynamicLibraryManager()->isLibraryLoaded(tLibName.Data());; 3135 return false;; 3136}; 3137 ; 3138Bool_t TCling::IsLibraryLoaded(const char* libname) const; 3139{; 3140 R__LOCKGUARD(gInterpreterMutex);; 3141 return s_IsLibraryLoaded(libname, GetInterpreterImpl());; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Return true if ROOT has cxxmodules pcm for a given library name.; 3146// FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.; 3147Bool_t TCling::HasPCMForLibrary(const char *libname) const; 3148{; 3149 llvm::StringRef ModuleName(libname);; 3150 ModuleName = llvm::sys::path::stem(ModuleName);; 3151 ModuleName.consume_front(""lib"");; 3152 ; 3153 // FIXME: In case when the modulemap is not yet loaded we will return the; 3154 // wrong result. Consider a call to HasPCMForLibrary(../test/libEvent.so); 3155 // We will only load the modulemap for libEvent.so after we dlopen libEvent; 3156 // which may happen after calling this interface. Maybe we should also check; 3157 // if there is a Event.pcm file and a module.modulemap, load it and return; 3158 // true.; 3159 clang::ModuleMap &moduleMap = fInterpreter->getCI()->getPreprocessor().getHeaderSearchInfo().getModuleMap();; 3160 clang::Module *M = moduleMap.findModule(ModuleName);; 3161 return M && !M->IsUnimportable && M->getASTFile();; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Return true if the file has already been loaded by cint.; 3166/// We will try in this order:; 3167/// actual filename; 3168/// filename as a path relative to; 3169/// the include path; 3170/// the shared library path; 3171 ; 3172Bool_t TCling::IsLoaded(const char* filename) const; 3173{; 3174 R__LOCKGUARD(gInterpreterMutex);; 3175 ; 3176 //FIXME: if we use llvm::sys::fs::make_absolute ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:136660,Testability,assert,assert,136660,"r) ||; 3488 strstr(filename, ""/usr/bin/cyg"")); 3489 return;; 3490#elif defined(R__WIN32); 3491 if (strstr(filename, ""/Windows/"")); 3492 return;; 3493#elif defined (R__LINUX); 3494 if (strstr(filename, ""/ld-linux""); 3495 || strstr(filename, ""linux-gnu/""); 3496 || strstr(filename, ""/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:206960,Testability,assert,assert,206960,"double quotes and all; 5289/// internal quotes are escaped.; 5290 ; 5291void TCling::Execute(TObject* obj, TClass* cl, TMethod* method,; 5292 TObjArray* params, int* error); 5293{; 5294 if (!method) {; 5295 Error(""Execute"", ""No method was defined"");; 5296 return;; 5297 }; 5298 TList* argList = method->GetListOfMethodArgs();; 5299 // Check number of actual parameters against of expected formal ones; 5300 ; 5301 Int_t nparms = argList->LastIndex() + 1;; 5302 Int_t argc = params ? params->GetEntries() : 0;; 5303 ; 5304 if (argc > nparms) {; 5305 Error(""Execute"",""Too many parameters to call %s, got %d but expected at most %d."",method->GetName(),argc,nparms);; 5306 return;; 5307 }; 5308 if (nparms != argc) {; 5309 // Let's see if the 'missing' argument are all defaulted.; 5310 // if nparms==0 then either we stopped earlier either argc is also zero and we can't reach here.; 5311 assert(nparms > 0);; 5312 ; 5313 TMethodArg *arg = (TMethodArg *) argList->At( 0 );; 5314 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5315 // There is a default value for the first missing; 5316 // argument, so we are fine.; 5317 } else {; 5318 Int_t firstDefault = -1;; 5319 for (Int_t i = 0; i < nparms; i ++) {; 5320 arg = (TMethodArg *) argList->At( i );; 5321 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5322 firstDefault = i;; 5323 break;; 5324 }; 5325 }; 5326 if (firstDefault >= 0) {; 5327 Error(""Execute"",""Too few arguments to call %s, got only %d but expected at least %d and at most %d."",method->GetName(),argc,firstDefault,nparms);; 5328 } else {; 5329 Error(""Execute"",""Too few arguments to call %s, got only %d but expected %d."",method->GetName(),argc,nparms);; 5330 }; 5331 return;; 5332 }; 5333 }; 5334 ; 5335 const char* listpar = """";; 5336 TString complete(10);; 5337 if (params) {; 5338 // Create a character string of parameters from TObjArray; 5339 TIter next(params);; 5340 for (Int_t i = 0; i < argc; i ++) {; 5341 TMethodArg* arg = (TMethodArg*) argList->At(i);; 534",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:214394,Testability,assert,assert,214394,"ring,t);; 5481 ; 5482 if (!strstr(typeDesc, ""(*)("")) {; 5483 const char *s = strchr(typeDesc, ' ');; 5484 const char *template_start = strchr(typeDesc, '<');; 5485 if (!strcmp(typeDesc, ""long long"")) {; 5486 t = typeDesc;; 5487 }; 5488 else if (!strncmp(typeDesc, ""unsigned "", s + 1 - typeDesc)) {; 5489 t = typeDesc;; 5490 }; 5491 // s is the position of the second 'word' (if any); 5492 // except in the case of templates where there will be a space; 5493 // just before any closing '>': eg.; 5494 // TObj<std::vector<UShort_t,__malloc_alloc_template<0> > >*; 5495 else if (s && (template_start == nullptr || (s < template_start))) {; 5496 t = s + 1;; 5497 }; 5498 else {; 5499 t = typeDesc;; 5500 }; 5501 }; 5502 else {; 5503 t = typeDesc;; 5504 }; 5505 auto l = t.length();; 5506 while (l > 0 && (t[l - 1] == '*' || t[l - 1] == '&')); 5507 --l;; 5508 t.resize(l);; 5509 return t.c_str(); // NOLINT; 5510}; 5511 ; 5512static bool requiresRootMap(const char* rootmapfile); 5513{; 5514 assert(rootmapfile && *rootmapfile);; 5515 ; 5516 llvm::StringRef libName = llvm::sys::path::filename(rootmapfile);; 5517 libName.consume_back("".rootmap"");; 5518 ; 5519 return !gInterpreter->HasPCMForLibrary(libName.str().c_str());; 5520}; 5521 ; 5522////////////////////////////////////////////////////////////////////////////////; 5523/// Read and parse a rootmapfile in its new format, and return 0 in case of; 5524/// success, -1 if the file has already been read, and -3 in case its format; 5525/// is the old one (e.g. containing ""Library.ClassName""), -4 in case of syntax; 5526/// error.; 5527 ; 5528int TCling::ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString); 5529{; 5530 if (!(rootmapfile && *rootmapfile)); 5531 return 0;; 5532 ; 5533 if (!requiresRootMap(rootmapfile)); 5534 return 0; // success; 5535 ; 5536 // For ""class "", ""namespace "", ""typedef "", ""header "", ""enum "", ""var "" respectively; 5537 const std::map<char, unsigned int> keyLenMap = {{'c',6},{'n',10},{'t',8},{'h',7},{",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:220320,Testability,assert,assert,220320," objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 5651/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 5652/// case the home directory resides on an automounted remote file system; 5653/// and one wants to avoid the file system from being mounted.; 5654 ; 5655void TCling::InitRootmapFile(const char *name); 5656{; 5657 assert(requiresRootMap(name) && ""We have a module!"");; 5658 ; 5659 if (!requiresRootMap(name)); 5660 return;; 5661 ; 5662 Bool_t ignore = fMapfile->IgnoreDuplicates(kFALSE);; 5663 ; 5664 fMapfile->SetRcName(name);; 5665 ; 5666 TString sname = ""system"";; 5667 sname += name;; 5668 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 5669 ; 5670 Int_t ret = ReadRootmapFile(s);; 5671 if (ret == -3) // old format; 5672 fMapfile->ReadFile(s, kEnvGlobal);; 5673 delete [] s;; 5674 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 5675 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 5676 ret = ReadRootmapFile(s);; 5677 if (ret == -3) // old format; 5678 fMapfile->ReadFile(s, kEnvUser);; 5679 delete [] s;; 5680 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())) {; 5681 ret = ReadRootmapFile(name);; 5682 if (ret == -3) // old format; 5683 fMapfile->ReadFile(name, kEnvLocal);; 5684 }; 5685 } else {; 5686 ret = ReadRootmapFile(name);; 5687 if (ret == -3) // old format; 5688 fMapfile->ReadFile(name, kEnvLocal);; 5689 }; 5690 fMapfile->IgnoreDuplicates(ignore);; 5691}; 5692 ; 5693 ; 5694namespace {; 5695 using namespace clang;; 5696 ; 5697 class ExtVisibleStorageAdder: public RecursiveASTVisitor<ExtVisibleStorageAdder>{; 5698 // This class is to be considered an helper for AutoLoading.; 5699 // It is a recursive visitor is used to inspect namespaces and specializations; 5700 // coming from forward declarations in rootmaps and to set the external visible; 5701 // storage flag for them.; 5702 public:; 5703 ExtVisibleStorageAdder(std::unordered_set<const NamespaceDecl*>& nsSet): fNSS",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:229034,Testability,assert,assert,229034,"TEnv considers a blank a terminator; 5869 cls.ReplaceAll(""-"", "" "");; 5870 if (gDebug > 6) {; 5871 const char* wlib = gSystem->DynamicPathName(lib, kTRUE);; 5872 if (wlib) {; 5873 Info(""LoadLibraryMap"", ""class %s in %s"", cls.Data(), wlib);; 5874 }; 5875 else {; 5876 Info(""LoadLibraryMap"", ""class %s in %s (library does not exist)"", cls.Data(), lib);; 5877 }; 5878 delete[] wlib;; 5879 }; 5880 delete tokens;; 5881 }; 5882 else if (!strncmp(cls.Data(), ""Declare."", 8) && cls.Length() > 8) {; 5883 cls.Remove(0, 8);; 5884 // convert ""-"" to "" "", since class names may have; 5885 // blanks and TEnv considers a blank a terminator; 5886 cls.ReplaceAll(""-"", "" "");; 5887 fInterpreter->declare(cls.Data());; 5888 }; 5889 }; 5890 ; 5891 // Process the forward declarations collected; 5892 cling::Transaction* T = nullptr;; 5893 auto compRes= fInterpreter->declare(uniqueString.Data(), &T);; 5894 assert(cling::Interpreter::kSuccess == compRes && ""A declaration in a rootmap could not be compiled"");; 5895 ; 5896 if (compRes!=cling::Interpreter::kSuccess){; 5897 Warning(""LoadLibraryMap"",; 5898 ""Problems in %s declaring '%s' were encountered."", rootmapfile, uniqueString.Data()) ;; 5899 }; 5900 ; 5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {; 5904 if (declIt->m_DGR.isSingleDecl()) {; 5905 if (Decl* D = declIt->m_DGR.getSingleDecl()) {; 5906 if (clang::isa<TagDecl>(D) || clang::isa<NamespaceDecl>(D)) {; 5907 evsAdder.TraverseDecl(D);; 5908 }; 5909 }; 5910 }; 5911 }; 5912 }; 5913 ; 5914 // clear duplicates; 5915 ; 5916 return 0;; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Scan again along the dynamic path for library maps. Entries for the loaded; 5921/// shared libraries are unloaded first. This can be useful after reseting; 5922/// the dynamic path through TSystem::SetDynamicPath(); 5923/// In case of error -1 is returned, 0 othe",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:237381,Testability,assert,assert,237381,"/////////////////////////////; 6107/// Demangle the name (from the typeinfo) and then request the class; 6108/// via the usual name based interface (TClass::GetClass).; 6109 ; 6110TClass *TCling::GetClass(const std::type_info& typeinfo, Bool_t load) const; 6111{; 6112 int err = 0;; 6113 char* demangled_name = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6114 if (err) return nullptr;; 6115 TClass* theClass = TClass::GetClass(demangled_name, load, kTRUE);; 6116 free(demangled_name);; 6117 return theClass;; 6118}; 6119 ; 6120////////////////////////////////////////////////////////////////////////////////; 6121/// Load library containing the specified class. Returns 0 in case of error; 6122/// and 1 in case if success.; 6123 ; 6124Int_t TCling::AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded /* = kFALSE */); 6125{; 6126 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6127 ; 6128 int err = 0;; 6129 char* demangled_name_c = TClassEdit::DemangleTypeIdName(typeinfo, err);; 6130 if (err) {; 6131 return 0;; 6132 }; 6133 ; 6134 std::string demangled_name(demangled_name_c);; 6135 free(demangled_name_c);; 6136 ; 6137 // AutoLoad expects (because TClass::GetClass already prepares it that way) a; 6138 // shortened name.; 6139 TClassEdit::TSplitType splitname( demangled_name.c_str(), (TClassEdit::EModType)(TClassEdit::kLong64 | TClassEdit::kDropStd) );; 6140 splitname.ShortType(demangled_name, TClassEdit::kDropStlDefault | TClassEdit::kDropStd);; 6141 ; 6142 // No need to worry about typedef, they aren't any ... but there are; 6143 // inlined namespaces ...; 6144 ; 6145 Int_t result = AutoLoad(demangled_name.c_str());; 6146 if (result == 0) {; 6147 demangled_name = TClassEdit::GetLong64_Name(demangled_name);; 6148 result = AutoLoad(demangled_name.c_str(), knowDictNotLoaded);; 6149 }; 6150 ; 6151 return result;; 6152}; 6153 ; 6154////////////////////////////////////////////////////////////////////////////////; 6155// Get the list of '",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:243619,Testability,assert,assert,243619,"ilure load; 6250 // the top-level library. See detailed comment in the TProtoClass; 6251 // branch (above).; 6252 (void)DeepAutoLoadImpl(membertypename.c_str(), visited, true /*normalized*/);; 6253 }; 6254 }; 6255 gInterpreter->DataMemberInfo_Delete(memberinfo);; 6256 }; 6257 gInterpreter->ClassInfo_Delete(classinfo);; 6258 return 1;; 6259}; 6260 ; 6261////////////////////////////////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:243879,Testability,assert,assert,243879,"///////////////////////////////////////////////////////; 6262/// Load library containing the specified class. Returns 0 in case of error; 6263/// and 1 in case if success.; 6264 ; 6265Int_t TCling::AutoLoad(const char *cls, Bool_t knowDictNotLoaded /* = kFALSE */); 6266{; 6267 // Prevent update to IsClassAutoloading between our check and our actions.; 6268 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 6269 ; 6270 // TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; 6271 // rootcling (in *_rdict.pcm file generation) it is a no op.; 6272 // FIXME: We should avoid calling autoload when we know we are not supposed; 6273 // to and transform this check into an assert.; 6274 if (!IsClassAutoLoadingEnabled()) {; 6275 // Never load any library from rootcling/genreflex.; 6276 if (gDebug > 2) {; 6277 Info(""TCling::AutoLoad"", ""Explicitly disabled (the class name is %s)"", cls);; 6278 }; 6279 return 0;; 6280 }; 6281 ; 6282 assert(IsClassAutoLoadingEnabled() && ""Calling when AutoLoading is off!"");; 6283 ; 6284 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 6285 ; 6286 if (!knowDictNotLoaded && gClassTable->GetDictNorm(cls)) {; 6287 // The library is already loaded as the class's dictionary is known.; 6288 // Return success.; 6289 // Note: the name (cls) is expected to be normalized as it comes either; 6290 // from a callbacks (that can/should calculate the normalized name from the; 6291 // decl) or from TClass::GetClass (which does also calculate the normalized; 6292 // name).; 6293 return 1;; 6294 }; 6295 ; 6296 if (gDebug > 2) {; 6297 Info(""TCling::AutoLoad"",; 6298 ""Trying to autoload for %s"", cls);; 6299 }; 6300 ; 6301 if (!gROOT || !gInterpreter || gROOT->TestBit(TObject::kInvalidObject)) {; 6302 if (gDebug > 2) {; 6303 Info(""TCling::AutoLoad"",; 6304 ""Disabled due to gROOT or gInterpreter being invalid/not ready (the class name is %s)"", cls);; 6305 }; 6306 return 0;; 6307 }; 6308 // Prevent the recursion when the library dictionary are loaded.; 6309 SuspendAutoLoading",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:257412,Testability,assert,assert,257412,"/////////////////////////////////////////; 6589/// Autoload a library based on a missing symbol.; 6590 ; 6591void* TCling::LazyFunctionCreatorAutoload(const std::string& mangled_name) {; 6592 std::string dlsym_mangled_name = ROOT::TMetaUtils::DemangleNameForDlsym(mangled_name);; 6593 ; 6594 // We have already loaded the library.; 6595 if (void* Addr = llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name)); 6596 return Addr;; 6597 ; 6598 const cling::DynamicLibraryManager &DLM = *GetInterpreterImpl()->getDynamicLibraryManager();; 6599 R__LOCKGUARD(gInterpreterMutex);; 6600 ; 6601 auto LibLoader = [](const std::string& LibName) -> bool {; 6602 if (gSystem->Load(LibName.c_str(), """", false) < 0) {; 6603 ::Error(""TCling__LazyFunctionCreatorAutoloadForModule"",; 6604 ""Failed to load library %s"", LibName.c_str());; 6605 return false;; 6606 }; 6607 return true; //success.; 6608 };; 6609 ; 6610 std::string libName = DLM.searchLibrariesForSymbol(mangled_name,; 6611 /*searchSystem=*/ true);; 6612 ; 6613 assert(!llvm::StringRef(libName).startswith(""libNew"") &&; 6614 ""We must not resolve symbols from libNew!"");; 6615 ; 6616 if (libName.empty()); 6617 return nullptr;; 6618 ; 6619 if (!LibLoader(libName)); 6620 return nullptr;; 6621 ; 6622 return llvm::sys::DynamicLibrary::SearchForAddressOfSymbol(dlsym_mangled_name);; 6623}; 6624 ; 6625////////////////////////////////////////////////////////////////////////////////; 6626 ; 6627Bool_t TCling::IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl); 6628{; 6629 return fNSFromRootmaps.count(nsDecl) != 0;; 6630}; 6631 ; 6632////////////////////////////////////////////////////////////////////////////////; 6633/// Internal function. Actually do the update of the ClassInfo when seeing; 6634// new TagDecl or NamespaceDecl.; 6635void TCling::RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias); 6636{; 6637 ; 6638 TClingClassInfo *cci = ((TClingClassInfo *)cl->fClassInfo);; 6639 if (cci) {; 6640 /",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:274526,Testability,log,logic,274526,"re); 6997{; 6998 if (!cls || !*cls); 6999 return {};; 7000 ; 7001 using namespace clang;; 7002 if (const Decl *D = LH.findScope(cls, cling::LookupHelper::NoDiagnostics,; 7003 /*type*/ nullptr, /*instantiate*/ false)) {; 7004 if (!D->isFromASTFile()) {; 7005 if (gDebug > 5); 7006 Warning(""GetClassSharedLibsForModule"", ""Decl found for %s is not part of a module"", cls);; 7007 return {};; 7008 }; 7009 class ModuleCollector : public ConstDeclVisitor<ModuleCollector> {; 7010 llvm::DenseSet<Module *> &m_TopLevelModules;; 7011 ; 7012 public:; 7013 ModuleCollector(llvm::DenseSet<Module *> &TopLevelModules) : m_TopLevelModules(TopLevelModules) {}; 7014 void Collect(const Decl *D) { Visit(D); }; 7015 ; 7016 void VisitDecl(const Decl *D); 7017 {; 7018 // FIXME: Such case is described ROOT-7765 where; 7019 // ROOT_GENERATE_DICTIONARY does not contain the list of headers.; 7020 // They are specified as #includes in the LinkDef file. This leads to; 7021 // generation of incomplete modulemap files and this logic fails to; 7022 // compute the corresponding module of D.; 7023 // FIXME: If we want to support such a case, we should not rely on; 7024 // the contents of the modulemap but mangle D and look it up in the; 7025 // .so files.; 7026 if (!D->hasOwningModule()); 7027 return;; 7028 if (Module *M = D->getOwningModule()->getTopLevelModule()); 7029 m_TopLevelModules.insert(M);; 7030 }; 7031 ; 7032 void VisitTemplateArgument(const TemplateArgument &TA); 7033 {; 7034 switch (TA.getKind()) {; 7035 case TemplateArgument::Null:; 7036 case TemplateArgument::Integral:; 7037 case TemplateArgument::Pack:; 7038 case TemplateArgument::NullPtr:; 7039 case TemplateArgument::StructuralValue:; 7040 case TemplateArgument::Expression:; 7041 case TemplateArgument::Template:; 7042 case TemplateArgument::TemplateExpansion: return;; 7043 case TemplateArgument::Type:; 7044 if (const TagType *TagTy = dyn_cast<TagType>(TA.getAsType())); 7045 return Visit(TagTy->getDecl());; 7046 return;; 7047 case Template",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:276577,Testability,assert,assert,276577,"TA.getAsDecl());; 7048 }; 7049 llvm_unreachable(""Invalid TemplateArgument::Kind!"");; 7050 }; 7051 ; 7052 void VisitClassTemplateSpecializationDecl(const ClassTemplateSpecializationDecl *CTSD); 7053 {; 7054 if (CTSD->getOwningModule()); 7055 VisitDecl(CTSD);; 7056 else; 7057 VisitDecl(CTSD->getSpecializedTemplate());; 7058 const TemplateArgumentList &ArgList = CTSD->getTemplateArgs();; 7059 for (const TemplateArgument *Arg = ArgList.data(), *ArgEnd = Arg + ArgList.size(); Arg != ArgEnd; ++Arg) {; 7060 VisitTemplateArgument(*Arg);; 7061 }; 7062 }; 7063 };; 7064 ; 7065 llvm::DenseSet<Module *> TopLevelModules;; 7066 ModuleCollector m(TopLevelModules);; 7067 m.Collect(D);; 7068 std::string result;; 7069 for (auto M : TopLevelModules) {; 7070 // ROOT-unaware modules (i.e. not processed by rootcling) do not have a; 7071 // link declaration.; 7072 if (!M->LinkLibraries.size()); 7073 continue;; 7074 // We have preloaded the Core module thus libCore.so; 7075 if (M->Name == ""Core"" && skipCore); 7076 continue;; 7077 assert(M->LinkLibraries.size() == 1);; 7078 if (!result.empty()); 7079 result += ' ';; 7080 result += M->LinkLibraries[0].Library;; 7081 }; 7082 return result;; 7083 }; 7084 return {};; 7085}; 7086 ; 7087////////////////////////////////////////////////////////////////////////////////; 7088/// Get the list of shared libraries containing the code for class cls.; 7089/// The first library in the list is the one containing the class, the; 7090/// others are the libraries the first one depends on. Returns 0; 7091/// in case the library is not found.; 7092/// \param cls the name of the class; 7093/// \param skipCore if true (default), remove ""Core"" from the returned list; 7094 ; 7095const char* TCling::GetClassSharedLibs(const char* cls, bool skipCore); 7096{; 7097 if (fCxxModulesEnabled) {; 7098 // Lock the interpreter mutex before interacting with cling.; 7099 // TODO: Can we move this further deep? In principle the lock should be in; 7100 // GetClassSharedLibsForModul",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:277962,Testability,test,tests,277962,"// The first library in the list is the one containing the class, the; 7090/// others are the libraries the first one depends on. Returns 0; 7091/// in case the library is not found.; 7092/// \param cls the name of the class; 7093/// \param skipCore if true (default), remove ""Core"" from the returned list; 7094 ; 7095const char* TCling::GetClassSharedLibs(const char* cls, bool skipCore); 7096{; 7097 if (fCxxModulesEnabled) {; 7098 // Lock the interpreter mutex before interacting with cling.; 7099 // TODO: Can we move this further deep? In principle the lock should be in; 7100 // GetClassSharedLibsForModule, but it might be needed also for; 7101 // getLookupHelper?; 7102 R__LOCKGUARD(gInterpreterMutex);; 7103 llvm::StringRef className = cls;; 7104 // If we get a class name containing lambda, we cannot parse it and we; 7105 // can exit early.; 7106 // FIXME: This works around a bug when we are instantiating a template; 7107 // make_unique and the substitution fails. Seen in most of the dataframe; 7108 // tests.; 7109 if (className.contains(""(lambda)"")); 7110 return nullptr;; 7111 // Limit the recursion which can be induced by GetClassSharedLibsForModule.; 7112 SuspendAutoLoadingRAII AutoLoadingDisabled(this);; 7113 cling::LookupHelper &LH = fInterpreter->getLookupHelper();; 7114 std::string libs = GetClassSharedLibsForModule(cls, LH, skipCore);; 7115 if (!libs.empty()) {; 7116 fAutoLoadLibStorage.push_back(libs);; 7117 return fAutoLoadLibStorage.back().c_str();; 7118 }; 7119 }; 7120 ; 7121 if (!cls || !*cls) {; 7122 return nullptr;; 7123 }; 7124 // lookup class to find list of libraries; 7125 if (fMapfile) {; 7126 TEnvRec* libs_record = nullptr;; 7127 libs_record = fMapfile->Lookup(cls);; 7128 if (libs_record) {; 7129 const char* libs = libs_record->GetValue();; 7130 return (*libs) ? libs : nullptr;; 7131 }; 7132 else {; 7133 // Try the old format...; 7134 TString c = TString(""Library."") + cls;; 7135 // convert ""::"" to ""@@"", we used ""@@"" because TEnv; 7136 // considers",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:280448,Testability,assert,assert,280448,"= libs_record->GetValue();; 7148 return (*libs) ? libs : nullptr;; 7149 }; 7150 }; 7151 }; 7152 return nullptr;; 7153}; 7154 ; 7155/// This interface returns a list of dependent libraries in the form:; 7156/// lib libA.so libB.so libC.so. The first library is the library we are; 7157/// searching dependencies for.; 7158/// Note: In order to speed up the search, we display the dependencies of the; 7159/// libraries which are not yet loaded. For instance, if libB.so was already; 7160/// loaded the list would contain: lib libA.so libC.so.; 7161static std::string GetSharedLibImmediateDepsSlow(std::string lib,; 7162 cling::Interpreter *interp,; 7163 bool skipLoadedLibs = true); 7164{; 7165 TString LibFullPath(lib);; 7166 if (!llvm::sys::path::is_absolute(lib)) {; 7167 if (!gSystem->FindDynamicLibrary(LibFullPath, /*quiet=*/true)) {; 7168 Error(""TCling__GetSharedLibImmediateDepsSlow"", ""Cannot find library '%s'"", lib.c_str());; 7169 return """";; 7170 }; 7171 } else {; 7172 assert(llvm::sys::fs::exists(lib) && ""Must exist!"");; 7173 lib = llvm::sys::path::filename(lib).str();; 7174 }; 7175 ; 7176 auto ObjF = llvm::object::ObjectFile::createObjectFile(LibFullPath.Data());; 7177 if (!ObjF) {; 7178 Warning(""TCling__GetSharedLibImmediateDepsSlow"", ""Failed to read object file %s"", lib.c_str());; 7179 return """";; 7180 }; 7181 ; 7182 llvm::object::ObjectFile *BinObjFile = ObjF.get().getBinary();; 7183 ; 7184 std::set<string> DedupSet;; 7185 std::string Result = lib + ' ';; 7186 for (const auto &S : BinObjFile->symbols()) {; 7187 uint32_t Flags = llvm::cantFail(S.getFlags());; 7188 // Skip defined symbols: we have them.; 7189 if (!(Flags & llvm::object::SymbolRef::SF_Undefined)); 7190 continue;; 7191 // Skip undefined weak symbols: if we don't have them we won't need them.; 7192 // `__gmon_start__` being a typical example.; 7193 if (Flags & llvm::object::SymbolRef::SF_Weak); 7194 continue;; 7195 llvm::Expected<StringRef> SymNameErr = S.getName();; 7196 if (!SymNameErr) {; 7197 Warnin",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:288408,Testability,assert,assert,288408,"ing messages from stdout. Return the previous state.; 7355 ; 7356Bool_t TCling::SetErrorMessages(Bool_t enable); 7357{; 7358#if defined(R__MUST_REVISIT); 7359#if R__MUST_REVISIT(6,2); 7360 Warning(""SetErrorMessages"", ""Interface not available yet."");; 7361#endif; 7362#endif; 7363 return TCling::IsErrorMessagesEnabled();; 7364}; 7365 ; 7366////////////////////////////////////////////////////////////////////////////////; 7367/// Refresh the list of include paths known to the interpreter and return it; 7368/// with -I prepended.; 7369 ; 7370const char* TCling::GetIncludePath(); 7371{; 7372 R__LOCKGUARD(gInterpreterMutex);; 7373 ; 7374 fIncludePath = """";; 7375 ; 7376 llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.; 7377 //false - no system header, true - with flags.; 7378 fInterpreter->GetIncludePaths(includePaths, false, true);; 7379 if (const size_t nPaths = includePaths.size()) {; 7380 assert(!(nPaths & 1) && ""GetIncludePath, number of paths and options is not equal"");; 7381 ; 7382 for (size_t i = 0; i < nPaths; i += 2) {; 7383 if (i); 7384 fIncludePath.Append(' ');; 7385 fIncludePath.Append(includePaths[i].c_str());; 7386 ; 7387 if (includePaths[i] != ""-I""); 7388 fIncludePath.Append(' ');; 7389 fIncludePath.Append('""');; 7390 fIncludePath.Append(includePaths[i + 1], includePaths[i + 1].length());; 7391 fIncludePath.Append('""');; 7392 }; 7393 }; 7394 ; 7395 return fIncludePath;; 7396}; 7397 ; 7398////////////////////////////////////////////////////////////////////////////////; 7399/// Return the directory containing CINT's stl cintdlls.; 7400 ; 7401const char* TCling::GetSTLIncludePath() const; 7402{; 7403 return """";; 7404}; 7405 ; 7406//______________________________________________________________________________; 7407// M I S C; 7408//______________________________________________________________________________; 7409 ; 7410int TCling::DisplayClass(FILE* /*fout*/, const char* /*name*/, int /*base*/, int /*start*/) const; 7411{; 7412 // Inte",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:289737,Testability,assert,assert,289737,"equal"");; 7381 ; 7382 for (size_t i = 0; i < nPaths; i += 2) {; 7383 if (i); 7384 fIncludePath.Append(' ');; 7385 fIncludePath.Append(includePaths[i].c_str());; 7386 ; 7387 if (includePaths[i] != ""-I""); 7388 fIncludePath.Append(' ');; 7389 fIncludePath.Append('""');; 7390 fIncludePath.Append(includePaths[i + 1], includePaths[i + 1].length());; 7391 fIncludePath.Append('""');; 7392 }; 7393 }; 7394 ; 7395 return fIncludePath;; 7396}; 7397 ; 7398////////////////////////////////////////////////////////////////////////////////; 7399/// Return the directory containing CINT's stl cintdlls.; 7400 ; 7401const char* TCling::GetSTLIncludePath() const; 7402{; 7403 return """";; 7404}; 7405 ; 7406//______________________________________________________________________________; 7407// M I S C; 7408//______________________________________________________________________________; 7409 ; 7410int TCling::DisplayClass(FILE* /*fout*/, const char* /*name*/, int /*base*/, int /*start*/) const; 7411{; 7412 // Interface to cling function; 7413 return 0;; 7414}; 7415 ; 7416////////////////////////////////////////////////////////////////////////////////; 7417/// Interface to cling function; 7418 ; 7419int TCling::DisplayIncludePath(FILE *fout) const; 7420{; 7421 assert(fout != nullptr && ""DisplayIncludePath, 'fout' parameter is null"");; 7422 ; 7423 llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.; 7424 //false - no system header, true - with flags.; 7425 fInterpreter->GetIncludePaths(includePaths, false, true);; 7426 if (const size_t nPaths = includePaths.size()) {; 7427 assert(!(nPaths & 1) && ""DisplayIncludePath, number of paths and options is not equal"");; 7428 ; 7429 std::string allIncludes(""include path:"");; 7430 for (size_t i = 0; i < nPaths; i += 2) {; 7431 allIncludes += ' ';; 7432 allIncludes += includePaths[i];; 7433 ; 7434 if (includePaths[i] != ""-I""); 7435 allIncludes += ' ';; 7436 allIncludes += includePaths[i + 1];; 7437 }; 7438 ; 7439 fprintf(fout, ""%s\n"", ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:290077,Testability,assert,assert,290077,"____________________________________________________________________________; 7409 ; 7410int TCling::DisplayClass(FILE* /*fout*/, const char* /*name*/, int /*base*/, int /*start*/) const; 7411{; 7412 // Interface to cling function; 7413 return 0;; 7414}; 7415 ; 7416////////////////////////////////////////////////////////////////////////////////; 7417/// Interface to cling function; 7418 ; 7419int TCling::DisplayIncludePath(FILE *fout) const; 7420{; 7421 assert(fout != nullptr && ""DisplayIncludePath, 'fout' parameter is null"");; 7422 ; 7423 llvm::SmallVector<std::string, 10> includePaths;//Why 10? Hell if I know.; 7424 //false - no system header, true - with flags.; 7425 fInterpreter->GetIncludePaths(includePaths, false, true);; 7426 if (const size_t nPaths = includePaths.size()) {; 7427 assert(!(nPaths & 1) && ""DisplayIncludePath, number of paths and options is not equal"");; 7428 ; 7429 std::string allIncludes(""include path:"");; 7430 for (size_t i = 0; i < nPaths; i += 2) {; 7431 allIncludes += ' ';; 7432 allIncludes += includePaths[i];; 7433 ; 7434 if (includePaths[i] != ""-I""); 7435 allIncludes += ' ';; 7436 allIncludes += includePaths[i + 1];; 7437 }; 7438 ; 7439 fprintf(fout, ""%s\n"", allIncludes.c_str());; 7440 }; 7441 ; 7442 return 0;; 7443}; 7444 ; 7445////////////////////////////////////////////////////////////////////////////////; 7446/// Interface to cling function; 7447 ; 7448void* TCling::FindSym(const char* entry) const; 7449{; 7450 R__LOCKGUARD(gInterpreterMutex);; 7451 return fInterpreter->getAddressOfGlobal(entry);; 7452}; 7453 ; 7454////////////////////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466/////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:295544,Testability,assert,assert,295544,"52/// Returns if class AutoLoading is currently enabled.; 7553 ; 7554bool TCling::IsClassAutoLoadingEnabled() const; 7555{; 7556 if (IsFromRootCling()); 7557 return false;; 7558 if (!fClingCallbacks); 7559 return false;; 7560 return fClingCallbacks->IsAutoLoadingEnabled();; 7561}; 7562 ; 7563////////////////////////////////////////////////////////////////////////////////; 7564/// Enable/Disable the AutoLoading of libraries.; 7565/// Returns the old value, i.e whether it was enabled or not.; 7566 ; 7567int TCling::SetClassAutoLoading(int autoload) const; 7568{; 7569 // If no state change is required, exit early.; 7570 // FIXME: In future we probably want to complain if we made a request which; 7571 // was with the same state as before in order to catch programming errors.; 7572 if ((bool) autoload == IsClassAutoLoadingEnabled()); 7573 return autoload;; 7574 ; 7575 assert(fClingCallbacks && ""We must have callbacks!"");; 7576 bool oldVal = fClingCallbacks->IsAutoLoadingEnabled();; 7577 fClingCallbacks->SetAutoLoadingEnabled(autoload);; 7578 return oldVal;; 7579}; 7580 ; 7581////////////////////////////////////////////////////////////////////////////////; 7582/// Enable/Disable the Autoparsing of headers.; 7583/// Returns the old value, i.e whether it was enabled or not.; 7584 ; 7585int TCling::SetClassAutoparsing(int autoparse); 7586{; 7587 bool oldVal = fHeaderParsingOnDemand;; 7588 fHeaderParsingOnDemand = autoparse;; 7589 return oldVal;; 7590}; 7591 ; 7592////////////////////////////////////////////////////////////////////////////////; 7593/// Suspend the Autoparsing of headers.; 7594/// Returns the old value, i.e whether it was suspended or not.; 7595 ; 7596Bool_t TCling::SetSuspendAutoParsing(Bool_t value) {; 7597 Bool_t old = fIsAutoParsingSuspended;; 7598 fIsAutoParsingSuspended = value;; 7599 if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);; 7600 return old;; 7601}; 7602 ; 7603/////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:321556,Testability,test,testio,321556," name) const; 8231{; 8232 R__LOCKGUARD(gInterpreterMutex);; 8233 return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), name);; 8234}; 8235 ; 8236ClassInfo_t* TCling::ClassInfo_Factory(DeclId_t declid) const; 8237{; 8238 R__LOCKGUARD(gInterpreterMutex);; 8239 return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), (const clang::Decl*)declid);; 8240}; 8241 ; 8242 ; 8243////////////////////////////////////////////////////////////////////////////////; 8244 ; 8245int TCling::ClassInfo_GetMethodNArg(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst /* = false */, EFunctionMatchMode mode /* = kConversionMatch */) const; 8246{; 8247 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8248 return TClinginfo->GetMethodNArg(method, proto, objectIsConst, mode);; 8249}; 8250 ; 8251////////////////////////////////////////////////////////////////////////////////; 8252 ; 8253bool TCling::ClassInfo_HasDefaultConstructor(ClassInfo_t* cinfo, Bool_t testio) const; 8254{; 8255 TClingClassInfo *TClinginfo = (TClingClassInfo *) cinfo;; 8256 return TClinginfo->HasDefaultConstructor(testio) != ROOT::TMetaUtils::EIOCtorCategory::kAbsent;; 8257}; 8258 ; 8259////////////////////////////////////////////////////////////////////////////////; 8260 ; 8261bool TCling::ClassInfo_HasMethod(ClassInfo_t* cinfo, const char* name) const; 8262{; 8263 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8264 return TClinginfo->HasMethod(name);; 8265}; 8266 ; 8267////////////////////////////////////////////////////////////////////////////////; 8268 ; 8269void TCling::ClassInfo_Init(ClassInfo_t* cinfo, const char* name) const; 8270{; 8271 R__LOCKGUARD(gInterpreterMutex);; 8272 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8273 TClinginfo->Init(name);; 8274}; 8275 ; 8276////////////////////////////////////////////////////////////////////////////////; 8277 ; 8278void TCling::ClassInfo_Init(ClassInfo_t* cinfo, int tagnum) const; 8279{; 8280 R__LO",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:321687,Testability,test,testio,321687,"me);; 8234}; 8235 ; 8236ClassInfo_t* TCling::ClassInfo_Factory(DeclId_t declid) const; 8237{; 8238 R__LOCKGUARD(gInterpreterMutex);; 8239 return (ClassInfo_t*) new TClingClassInfo(GetInterpreterImpl(), (const clang::Decl*)declid);; 8240}; 8241 ; 8242 ; 8243////////////////////////////////////////////////////////////////////////////////; 8244 ; 8245int TCling::ClassInfo_GetMethodNArg(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst /* = false */, EFunctionMatchMode mode /* = kConversionMatch */) const; 8246{; 8247 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8248 return TClinginfo->GetMethodNArg(method, proto, objectIsConst, mode);; 8249}; 8250 ; 8251////////////////////////////////////////////////////////////////////////////////; 8252 ; 8253bool TCling::ClassInfo_HasDefaultConstructor(ClassInfo_t* cinfo, Bool_t testio) const; 8254{; 8255 TClingClassInfo *TClinginfo = (TClingClassInfo *) cinfo;; 8256 return TClinginfo->HasDefaultConstructor(testio) != ROOT::TMetaUtils::EIOCtorCategory::kAbsent;; 8257}; 8258 ; 8259////////////////////////////////////////////////////////////////////////////////; 8260 ; 8261bool TCling::ClassInfo_HasMethod(ClassInfo_t* cinfo, const char* name) const; 8262{; 8263 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8264 return TClinginfo->HasMethod(name);; 8265}; 8266 ; 8267////////////////////////////////////////////////////////////////////////////////; 8268 ; 8269void TCling::ClassInfo_Init(ClassInfo_t* cinfo, const char* name) const; 8270{; 8271 R__LOCKGUARD(gInterpreterMutex);; 8272 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8273 TClinginfo->Init(name);; 8274}; 8275 ; 8276////////////////////////////////////////////////////////////////////////////////; 8277 ; 8278void TCling::ClassInfo_Init(ClassInfo_t* cinfo, int tagnum) const; 8279{; 8280 R__LOCKGUARD(gInterpreterMutex);; 8281 TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;; 8282 TClinginfo->Init(tagnum);; 8283}; 8",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:345832,Testability,assert,assert,345832,"plate arguments of the; 8858/// function template described by ft_info.; 8859 ; 8860UInt_t TCling::FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *ft_info) const; 8861{; 8862 if (!ft_info) return 0;; 8863 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8864 return ft->getTemplateParameters()->getMinRequiredArguments();; 8865}; 8866 ; 8867////////////////////////////////////////////////////////////////////////////////; 8868/// Return the property of the function template.; 8869 ; 8870Long_t TCling::FuncTempInfo_Property(FuncTempInfo_t *ft_info) const; 8871{; 8872 if (!ft_info) return 0;; 8873 ; 8874 long property = 0L;; 8875 property |= kIsCompiled;; 8876 ; 8877 const clang::FunctionTemplateDecl *ft = (clang::FunctionTemplateDecl*)ft_info;; 8878 ; 8879 switch (ft->getAccess()) {; 8880 case clang::AS_public:; 8881 property |= kIsPublic;; 8882 break;; 8883 case clang::AS_protected:; 8884 property |= kIsProtected;; 8885 break;; 8886 case clang::AS_private:; 8887 property |= kIsPrivate;; 8888 break;; 8889 case clang::AS_none:; 8890 if (ft->getDeclContext()->isNamespace()); 8891 property |= kIsPublic;; 8892 break;; 8893 default:; 8894 // IMPOSSIBLE; 8895 assert(false && ""Unexpected value for the access property value in Clang"");; 8896 break;; 8897 }; 8898 ; 8899 const clang::FunctionDecl *fd = ft->getTemplatedDecl();; 8900 if (const clang::CXXMethodDecl *md =; 8901 llvm::dyn_cast<clang::CXXMethodDecl>(fd)) {; 8902 if (md->getMethodQualifiers().hasConst()) {; 8903 property |= kIsConstant | kIsConstMethod;; 8904 }; 8905 if (md->isVirtual()) {; 8906 property |= kIsVirtual;; 8907 }; 8908 if (md->isPureVirtual()) {; 8909 property |= kIsPureVirtual;; 8910 }; 8911 if (const clang::CXXConstructorDecl *cd =; 8912 llvm::dyn_cast<clang::CXXConstructorDecl>(md)) {; 8913 if (cd->isExplicit()) {; 8914 property |= kIsExplicit;; 8915 }; 8916 }; 8917 else if (const clang::CXXConversionDecl *cd =; 8918 llvm::dyn_cast<clang::CXXConversionDecl>(md)) {; 8919 if ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:461836,Testability,test,testio,461836,"mplate.Definition TCling.cxx:8957; TCling::fMetaProcessorstd::unique_ptr< cling::MetaProcessor > fMetaProcessorDefinition TCling.h:131; TCling::TypeInfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:8434; TCling::GenerateTClassTClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE) finalGenerate a TClass for the given class.Definition TCling.cxx:4554; TCling::fTransactionCountULong64_t fTransactionCountDefinition TCling.h:148; TCling::ClassInfo_HasDefaultConstructorbool ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalDefinition TCling.cxx:8253; TCling::EndOfLineActionvoid EndOfLineAction() finalIt calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line.Definition TCling.cxx:3121; TCling::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; T",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:32092,Usability,clear,clear,32092,"; 876 public:; 877 clangDiagSuppr(clang::DiagnosticsEngine& diag): fDiagEngine(diag){; 878 fOldDiagValue = fDiagEngine.getIgnoreAllWarnings();; 879 fDiagEngine.setIgnoreAllWarnings(true);; 880 }; 881 ; 882 ~clangDiagSuppr() {; 883 fDiagEngine.setIgnoreAllWarnings(fOldDiagValue);; 884 }; 885 private:; 886 clang::DiagnosticsEngine& fDiagEngine;; 887 bool fOldDiagValue;; 888 };; 889 ; 890}; 891 ; 892////////////////////////////////////////////////////////////////////////////////; 893/// Allow calling autoparsing from TMetaUtils; 894bool TClingLookupHelper__AutoParse(const char *cname); 895{; 896 return gCling->AutoParse(cname);; 897}; 898 ; 899////////////////////////////////////////////////////////////////////////////////; 900/// Try hard to avoid looking up in the Cling database as this could enduce; 901/// an unwanted autoparsing.; 902 ; 903bool TClingLookupHelper__ExistingTypeCheck(const std::string &tname,; 904 std::string &result); 905{; 906 result.clear();; 907 ; 908 unsigned long offset = 0;; 909 if (strncmp(tname.c_str(), ""const "", 6) == 0) {; 910 offset = 6;; 911 }; 912 unsigned long end = tname.length();; 913 while( end && (tname[end-1]=='&' || tname[end-1]=='*' || tname[end-1]==']') ) {; 914 if ( tname[end-1]==']' ) {; 915 --end;; 916 while ( end && tname[end-1]!='[' ) --end;; 917 }; 918 --end;; 919 }; 920 std::string innerbuf;; 921 const char *inner;; 922 if (end != tname.length()) {; 923 innerbuf = tname.substr(offset,end-offset);; 924 inner = innerbuf.c_str();; 925 } else {; 926 inner = tname.c_str()+offset;; 927 }; 928 ; 929 //if (strchr(tname.c_str(),'[')!=0) fprintf(stderr,""DEBUG: checking on %s vs %s %lu %lu\n"",tname.c_str(),inner,offset,end);; 930 if (gROOT->GetListOfClasses()->FindObject(inner); 931 || TClassTable::Check(inner,result) ) {; 932 // This is a known class.; 933 return true;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:33670,Usability,clear,clear,33670,"ue;; 934 }; 935 ; 936 THashTable *typeTable = dynamic_cast<THashTable*>( gROOT->GetListOfTypes() );; 937 TDataType *type = (TDataType *)typeTable->THashTable::FindObject( inner );; 938 if (type) {; 939 // This is a raw type and an already loaded typedef.; 940 const char *newname = type->GetFullTypeName();; 941 if (type->GetType() == kLong64_t) {; 942 newname = ""Long64_t"";; 943 } else if (type->GetType() == kULong64_t) {; 944 newname = ""ULong64_t"";; 945 }; 946 if (strcmp(inner,newname) == 0) {; 947 return true;; 948 }; 949 if (offset) result = ""const "";; 950 result += newname;; 951 if ( end != tname.length() ) {; 952 result += tname.substr(end,tname.length()-end);; 953 }; 954 if (result == tname) result.clear();; 955 return true;; 956 }; 957 ; 958 // Check if the name is an enumerator; 959 const auto lastPos = TClassEdit::GetUnqualifiedName(inner);; 960 if (lastPos != inner) // Main switch: case 1 - scoped enum, case 2 global enum; 961 {; 962 // We have a scope; 963 const auto enName = lastPos;; 964 const auto scopeNameSize = (lastPos - inner) / sizeof(decltype(*lastPos)) - 2;; 965 std::string scopeName{inner, scopeNameSize};; 966 // Check if the scope is in the list of classes; 967 if (auto scope = static_cast<TClass *>(gROOT->GetListOfClasses()->FindObject(scopeName.c_str()))) {; 968 auto enumTable = dynamic_cast<const THashList *>(scope->GetListOfEnums(false));; 969 if (enumTable && enumTable->THashList::FindObject(enName)); 970 return true;; 971 }; 972 // It may still be in one of the loaded protoclasses; 973 else if (auto scope = static_cast<TProtoClass *>(gClassTable->GetProtoNorm(scopeName.c_str()))) {; 974 auto listOfEnums = scope->GetListOfEnums();; 975 if (listOfEnums) { // it could be null: no enumerators in the protoclass; 976 auto enumTable = dynamic_cast<const THashList *>(listOfEnums);; 977 if (enumTable && enumTable->THashList::FindObject(enName)); 978 return true;; 979 }; 980 }; 981 } else; 982 {; 983 // We don't have any scope: this could only be a ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:78104,Usability,clear,clear,78104,"a special way. Do not delay the parsing.; 2033 bool hasHeaderParsingOnDemand = fHeaderParsingOnDemand;; 2034 bool isACLiC = strstr(modulename, ""_ACLiC_dict"") != nullptr;; 2035 if (hasHeaderParsingOnDemand && isACLiC) {; 2036 if (gDebug>1); 2037 Info(""TCling::RegisterModule"",; 2038 ""Header parsing on demand is active but this is an Aclic library. Disabling it for this library."");; 2039 hasHeaderParsingOnDemand = false;; 2040 }; 2041 ; 2042 ; 2043 // Make sure we relookup symbols that were search for before we loaded; 2044 // their autoparse information. We could be more subtil and remove only; 2045 // the failed one or only the one in this module, but for now this is; 2046 // better than nothing.; 2047 fLookedUpClasses.clear();; 2048 ; 2049 // Make sure we do not set off AutoLoading or autoparsing during the; 2050 // module registration!; 2051 SuspendAutoLoadingRAII autoLoadOff(this);; 2052 ; 2053 for (const char** inclPath = includePaths; *inclPath; ++inclPath) {; 2054 TCling::AddIncludePath(*inclPath);; 2055 }; 2056 cling::Transaction* T = nullptr;; 2057 // Put the template decls and the number of arguments to skip in the TNormalizedCtxt; 2058 for (auto& fwdDeclArgToSkipPair : fwdDeclsArgToSkip){; 2059 const std::string& fwdDecl = fwdDeclArgToSkipPair.first;; 2060 const int nArgsToSkip = fwdDeclArgToSkipPair.second;; 2061 auto compRes = fInterpreter->declare(fwdDecl.c_str(), &T);; 2062 assert(cling::Interpreter::kSuccess == compRes &&; 2063 ""A fwd declaration could not be compiled"");; 2064 if (compRes!=cling::Interpreter::kSuccess){; 2065 Warning(""TCling::RegisterModule"",; 2066 ""Problems in declaring string '%s' were encountered."",; 2067 fwdDecl.c_str()) ;; 2068 continue;; 2069 }; 2070 ; 2071 // Drill through namespaces recursively until the template is found; 2072 if(ClassTemplateDecl* TD = FindTemplateInNamespace(T->getFirstDecl().getSingleDecl())){; 2073 fNormalizedCtxt->AddTemplAndNargsToKeep(TD->getCanonicalDecl(), nArgsToSkip);; 2074 }; 2075 ; 2076 }; 2077 ; 2",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:81805,Usability,clear,clear,81805,"2108 void* dyLibHandle = dlopen(dyLibName.c_str(), RTLD_LAZY | RTLD_GLOBAL);; 2109 if (dyLibHandle) {; 2110 fRegisterModuleDyLibs.push_back(dyLibHandle);; 2111 wasDlopened = true;; 2112 } else {; 2113 PrintDlError(dyLibName.c_str(), modulename);; 2114 }; 2115 }; 2116 } // if (!lateRegistration); 2117 ; 2118 if (hasHeaderParsingOnDemand && fwdDeclsCode){; 2119 // We now parse the forward declarations. All the classes are then modified; 2120 // in order for them to have an external lexical storage.; 2121 std::string fwdDeclsCodeLessEnums;; 2122 {; 2123 // Search for enum forward decls and only declare them if no; 2124 // declaration exists yet.; 2125 std::string fwdDeclsLine;; 2126 std::istringstream fwdDeclsCodeStr(fwdDeclsCode);; 2127 std::vector<std::string> scopes;; 2128 while (std::getline(fwdDeclsCodeStr, fwdDeclsLine)) {; 2129 const auto enumPos = fwdDeclsLine.find(""enum __attribute__((annotate(\"""");; 2130 // We check if the line contains a fwd declaration of an enum; 2131 if (enumPos != std::string::npos) {; 2132 // We clear the scopes which we may have carried from a previous iteration; 2133 scopes.clear();; 2134 // We check if the enum is not in a scope. If yes, save its name; 2135 // and the names of the enclosing scopes.; 2136 if (enumPos != 0) {; 2137 // it's enclosed in namespaces. We need to understand what they are; 2138 auto nsPos = fwdDeclsLine.find(""namespace"");; 2139 R__ASSERT(nsPos < enumPos && ""Inconsistent enum and enclosing scope parsing!"");; 2140 while (nsPos < enumPos && nsPos != std::string::npos) {; 2141 // we have a namespace, let's put it in the collection of scopes; 2142 const auto nsNameStart = nsPos + 10;; 2143 const auto nsNameEnd = fwdDeclsLine.find('{', nsNameStart);; 2144 const auto nsName = fwdDeclsLine.substr(nsNameStart, nsNameEnd - nsNameStart);; 2145 scopes.push_back(nsName);; 2146 nsPos = fwdDeclsLine.find(""namespace"", nsNameEnd);; 2147 }; 2148 }; 2149 clang::DeclContext* DC = nullptr;; 2150 for (auto &&aScope: scopes) {; 2151",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:81887,Usability,clear,clear,81887,");; 2111 wasDlopened = true;; 2112 } else {; 2113 PrintDlError(dyLibName.c_str(), modulename);; 2114 }; 2115 }; 2116 } // if (!lateRegistration); 2117 ; 2118 if (hasHeaderParsingOnDemand && fwdDeclsCode){; 2119 // We now parse the forward declarations. All the classes are then modified; 2120 // in order for them to have an external lexical storage.; 2121 std::string fwdDeclsCodeLessEnums;; 2122 {; 2123 // Search for enum forward decls and only declare them if no; 2124 // declaration exists yet.; 2125 std::string fwdDeclsLine;; 2126 std::istringstream fwdDeclsCodeStr(fwdDeclsCode);; 2127 std::vector<std::string> scopes;; 2128 while (std::getline(fwdDeclsCodeStr, fwdDeclsLine)) {; 2129 const auto enumPos = fwdDeclsLine.find(""enum __attribute__((annotate(\"""");; 2130 // We check if the line contains a fwd declaration of an enum; 2131 if (enumPos != std::string::npos) {; 2132 // We clear the scopes which we may have carried from a previous iteration; 2133 scopes.clear();; 2134 // We check if the enum is not in a scope. If yes, save its name; 2135 // and the names of the enclosing scopes.; 2136 if (enumPos != 0) {; 2137 // it's enclosed in namespaces. We need to understand what they are; 2138 auto nsPos = fwdDeclsLine.find(""namespace"");; 2139 R__ASSERT(nsPos < enumPos && ""Inconsistent enum and enclosing scope parsing!"");; 2140 while (nsPos < enumPos && nsPos != std::string::npos) {; 2141 // we have a namespace, let's put it in the collection of scopes; 2142 const auto nsNameStart = nsPos + 10;; 2143 const auto nsNameEnd = fwdDeclsLine.find('{', nsNameStart);; 2144 const auto nsName = fwdDeclsLine.substr(nsNameStart, nsNameEnd - nsNameStart);; 2145 scopes.push_back(nsName);; 2146 nsPos = fwdDeclsLine.find(""namespace"", nsNameEnd);; 2147 }; 2148 }; 2149 clang::DeclContext* DC = nullptr;; 2150 for (auto &&aScope: scopes) {; 2151 DC = cling::utils::Lookup::Namespace(&fInterpreter->getSema(), aScope.c_str(), DC);; 2152 if (!DC) {; 2153 // No decl context means we have to fwd dec",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:105226,Usability,simpl,simple,105226,"cl) {; 2701 // We stream std::string without going through members..; 2702 return;; 2703 }; 2704 ; 2705 if (TClassEdit::IsStdArray(cl->GetName())) {; 2706 // We treat std arrays as C arrays; 2707 return;; 2708 }; 2709 ; 2710 if (TClassEdit::IsUniquePtr(cl->GetName())) {; 2711 // Ignore error caused by the inside of std::unique_ptr; 2712 // This is needed solely because of rootclingIO's IsUnsupportedUniquePointer; 2713 // which checks the number of elements in the GetListOfRealData.; 2714 // If this usage is removed, this can be replaced with a return statement.; 2715 // See https://github.com/root-project/root/issues/13574; 2716 isTransient = true;; 2717 }; 2718 ; 2719 const char* cobj = (const char*) obj; // for ptr arithmetics; 2720 ; 2721 // Treat the case of std::complex in a special manner. We want to enforce; 2722 // the layout of a stl implementation independent class, which is the; 2723 // complex as implemented in ROOT5.; 2724 ; 2725 // A simple lambda to simplify the code; 2726 auto inspInspect = [&] (ptrdiff_t offset){; 2727 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_real"", cobj, isTransient);; 2728 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_imag"", cobj + offset, isTransient);; 2729 };; 2730 ; 2731 auto complexType = TClassEdit::GetComplexType(cl->GetName());; 2732 switch(complexType) {; 2733 case TClassEdit::EComplexType::kNone:; 2734 {; 2735 break;; 2736 }; 2737 case TClassEdit::EComplexType::kFloat:; 2738 {; 2739 inspInspect(sizeof(float));; 2740 return;; 2741 }; 2742 case TClassEdit::EComplexType::kDouble:; 2743 {; 2744 inspInspect(sizeof(double));; 2745 return;; 2746 }; 2747 case TClassEdit::EComplexType::kInt:; 2748 {; 2749 inspInspect(sizeof(int));; 2750 return;; 2751 }; 2752 case TClassEdit::EComplexType::kLong:; 2753 {; 2754 inspInspect(sizeof(long));; 2755 return;; 2756 }; 2757 }; 2758 ; 2759 static clang::PrintingPolicy; 2760 printPol(fInterpreter->getCI()->getLangOpts());; 2761 if (printPol.Indentation) {; 2762 //",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:105243,Usability,simpl,simplify,105243,"cl) {; 2701 // We stream std::string without going through members..; 2702 return;; 2703 }; 2704 ; 2705 if (TClassEdit::IsStdArray(cl->GetName())) {; 2706 // We treat std arrays as C arrays; 2707 return;; 2708 }; 2709 ; 2710 if (TClassEdit::IsUniquePtr(cl->GetName())) {; 2711 // Ignore error caused by the inside of std::unique_ptr; 2712 // This is needed solely because of rootclingIO's IsUnsupportedUniquePointer; 2713 // which checks the number of elements in the GetListOfRealData.; 2714 // If this usage is removed, this can be replaced with a return statement.; 2715 // See https://github.com/root-project/root/issues/13574; 2716 isTransient = true;; 2717 }; 2718 ; 2719 const char* cobj = (const char*) obj; // for ptr arithmetics; 2720 ; 2721 // Treat the case of std::complex in a special manner. We want to enforce; 2722 // the layout of a stl implementation independent class, which is the; 2723 // complex as implemented in ROOT5.; 2724 ; 2725 // A simple lambda to simplify the code; 2726 auto inspInspect = [&] (ptrdiff_t offset){; 2727 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_real"", cobj, isTransient);; 2728 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_imag"", cobj + offset, isTransient);; 2729 };; 2730 ; 2731 auto complexType = TClassEdit::GetComplexType(cl->GetName());; 2732 switch(complexType) {; 2733 case TClassEdit::EComplexType::kNone:; 2734 {; 2735 break;; 2736 }; 2737 case TClassEdit::EComplexType::kFloat:; 2738 {; 2739 inspInspect(sizeof(float));; 2740 return;; 2741 }; 2742 case TClassEdit::EComplexType::kDouble:; 2743 {; 2744 inspInspect(sizeof(double));; 2745 return;; 2746 }; 2747 case TClassEdit::EComplexType::kInt:; 2748 {; 2749 inspInspect(sizeof(int));; 2750 return;; 2751 }; 2752 case TClassEdit::EComplexType::kLong:; 2753 {; 2754 inspInspect(sizeof(long));; 2755 return;; 2756 }; 2757 }; 2758 ; 2759 static clang::PrintingPolicy; 2760 printPol(fInterpreter->getCI()->getLangOpts());; 2761 if (printPol.Indentation) {; 2762 //",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:118899,Usability,clear,cleared,118899,"; 3050 } else {; 3051 Error(""InspectMembers"",; 3052 ""Cannot calculate offset of virtual base %s of class %s"",; 3053 sBaseName.c_str(), clname);; 3054 continue;; 3055 }; 3056 }; 3057 } else {; 3058 baseOffset = recLayout.getBaseClassOffset(baseDecl).getQuantity();; 3059 }; 3060 // TOFIX: baseCl can be null here!; 3061 if (baseCl->IsLoaded()) {; 3062 // For loaded class, CallShowMember will (especially for TObject); 3063 // call the virtual ShowMember rather than the class specific version; 3064 // resulting in an infinite recursion.; 3065 InspectMembers(insp, cobj + baseOffset, baseCl, isTransient);; 3066 } else {; 3067 baseCl->CallShowMembers(cobj + baseOffset,; 3068 insp, isTransient);; 3069 }; 3070 } // loop over bases; 3071}; 3072 ; 3073////////////////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090////////////////////////////////////////////////////////////////////////////////; 3091/// Declare code to the interpreter, without any of the interpreter actions; 3092/// that could trigger a re-interpretation of the code. I.e. make cling; 3093/// behave like a compiler: no dynamic lookup, no input wrapping for; 3094/// subsequent execution, no automatic provision of declarations but just a; 3095/// plain `#include`.; 3096/// Returns true on success, false on failure.; 3097 ; 3098bool TCling::Declare(const char* code); 3099{; 3100 R__LOCKGUARD_CLING(gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 31",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:157666,Usability,simpl,simpler,157666," Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInfo to nullptr.; 4051 if (TClinginfo) {; 4052 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4053 }; 4054 delete TClinginfo;; 4055 cl->fClassInfo = nullptr;; 4056 }; 4057 return;; 4058 }; 4059 ; 4060 R__LOCKGUARD(gInterpreterMutex);; 4061 if (cl->fClassInfo && !reload) {; 4062 return;; 4063 }; 4064 //Remove the decl_id from the DeclIdToTClass map; 4065 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4066 if (TClinginfo) {; 4067 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4068 }; 4069 delete TClinginfo;; 4070 cl->fClassInfo = nullptr;; 4071 std::string name(cl->GetName());; 4072 ; 4073 auto SetWithoutClassInfoState = [](TClass *cl); 4074 {; 4075 if (cl->fState != TClass::kHasTClassInit) {; 4076 if (cl->fStreamerInfo->GetEntries() != 0) {; 4077 cl->fState = TClass::kEmulated;; 4078 } else {; 4079 cl->fState = TClass::kForwardDeclared;; 4080 }; 4081 }; 4082 };; 4083 // Handle the special case of 'tuple' where we ignore the real implementation; 4084 // details and just overlay a 'simpler'/'simplistic' version that is easy; 4085 // for the I/O to understand and handle.; 4086 if (strncmp(cl->GetName(),""tuple<"",strlen(""tuple<""))==0) {; 4087 if (!reload); 4088 name = AlternateTuple(cl->GetName(), fInterpreter->getLookupHelper(), silent);; 4089 if (reload || name.empty()) {; 4090 // We could not generate the alternate; 4091 SetWithoutClassInfoState(cl);; 4092 return;; 4093 }; 4094 }; 4095 ; 4096 bool instantiateTemplate = !cl->TestBit(TClass::kUnloading);; 4097 // FIXME: Rather than adding an option to the TClingCl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:157676,Usability,simpl,simplistic,157676," Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInfo to nullptr.; 4051 if (TClinginfo) {; 4052 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4053 }; 4054 delete TClinginfo;; 4055 cl->fClassInfo = nullptr;; 4056 }; 4057 return;; 4058 }; 4059 ; 4060 R__LOCKGUARD(gInterpreterMutex);; 4061 if (cl->fClassInfo && !reload) {; 4062 return;; 4063 }; 4064 //Remove the decl_id from the DeclIdToTClass map; 4065 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4066 if (TClinginfo) {; 4067 TClass::RemoveClassDeclId(TClinginfo->GetDeclId());; 4068 }; 4069 delete TClinginfo;; 4070 cl->fClassInfo = nullptr;; 4071 std::string name(cl->GetName());; 4072 ; 4073 auto SetWithoutClassInfoState = [](TClass *cl); 4074 {; 4075 if (cl->fState != TClass::kHasTClassInit) {; 4076 if (cl->fStreamerInfo->GetEntries() != 0) {; 4077 cl->fState = TClass::kEmulated;; 4078 } else {; 4079 cl->fState = TClass::kForwardDeclared;; 4080 }; 4081 }; 4082 };; 4083 // Handle the special case of 'tuple' where we ignore the real implementation; 4084 // details and just overlay a 'simpler'/'simplistic' version that is easy; 4085 // for the I/O to understand and handle.; 4086 if (strncmp(cl->GetName(),""tuple<"",strlen(""tuple<""))==0) {; 4087 if (!reload); 4088 name = AlternateTuple(cl->GetName(), fInterpreter->getLookupHelper(), silent);; 4089 if (reload || name.empty()) {; 4090 // We could not generate the alternate; 4091 SetWithoutClassInfoState(cl);; 4092 return;; 4093 }; 4094 }; 4095 ; 4096 bool instantiateTemplate = !cl->TestBit(TClass::kUnloading);; 4097 // FIXME: Rather than adding an option to the TClingCl",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:190138,Usability,simpl,simply,190138,"ling::GetEnum"", ""DeclContext not found for %s .\n"", name);; 4854 }; 4855 }; 4856 } else {; 4857 // If it is a global enum.; 4858 // Could trigger deserialization of decls.; 4859 cling::Interpreter::PushTransactionRAII RAII(GetInterpreterImpl());; 4860 possibleEnum = cling::utils::Lookup::Tag(&fInterpreter->getSema(), name);; 4861 }; 4862 if (possibleEnum && (possibleEnum != (clang::Decl*)-1); 4863 && isa<clang::EnumDecl>(possibleEnum)) {; 4864 return possibleEnum;; 4865 }; 4866 return nullptr;; 4867}; 4868 ; 4869////////////////////////////////////////////////////////////////////////////////; 4870/// Return pointer to cling DeclId for a global value; 4871 ; 4872TInterpreter::DeclId_t TCling::GetDeclId( const llvm::GlobalValue *gv ) const; 4873{; 4874 if (!gv) return nullptr;; 4875 ; 4876 llvm::StringRef mangled_name = gv->getName();; 4877 ; 4878 int err = 0;; 4879 char* demangled_name_c = TClassEdit::DemangleName(mangled_name.str().c_str(), err);; 4880 if (err) {; 4881 if (err == -2) {; 4882 // It might simply be an unmangled global name.; 4883 DeclId_t d;; 4884 TClingClassInfo gcl(GetInterpreterImpl());; 4885 d = gcl.GetDataMember(mangled_name.str().c_str());; 4886 return d;; 4887 }; 4888 return nullptr;; 4889 }; 4890 ; 4891 std::string scopename(demangled_name_c);; 4892 free(demangled_name_c);; 4893 ; 4894 //; 4895 // Separate out the class or namespace part of the; 4896 // function name.; 4897 //; 4898 std::string dataname;; 4899 ; 4900 if (!strncmp(scopename.c_str(), ""typeinfo for "", sizeof(""typeinfo for "")-1)) {; 4901 scopename.erase(0, sizeof(""typeinfo for "")-1);; 4902 } else if (!strncmp(scopename.c_str(), ""vtable for "", sizeof(""vtable for "")-1)) {; 4903 scopename.erase(0, sizeof(""vtable for "")-1);; 4904 } else {; 4905 // See if it is a function; 4906 std::string::size_type pos = scopename.rfind('(');; 4907 if (pos != std::string::npos) {; 4908 return nullptr;; 4909 }; 4910 // Separate the scope and member name; 4911 pos = scopename.rfind(':');; 4912 if (pos ",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:191307,Usability,clear,clear,191307,"0 ; 4891 std::string scopename(demangled_name_c);; 4892 free(demangled_name_c);; 4893 ; 4894 //; 4895 // Separate out the class or namespace part of the; 4896 // function name.; 4897 //; 4898 std::string dataname;; 4899 ; 4900 if (!strncmp(scopename.c_str(), ""typeinfo for "", sizeof(""typeinfo for "")-1)) {; 4901 scopename.erase(0, sizeof(""typeinfo for "")-1);; 4902 } else if (!strncmp(scopename.c_str(), ""vtable for "", sizeof(""vtable for "")-1)) {; 4903 scopename.erase(0, sizeof(""vtable for "")-1);; 4904 } else {; 4905 // See if it is a function; 4906 std::string::size_type pos = scopename.rfind('(');; 4907 if (pos != std::string::npos) {; 4908 return nullptr;; 4909 }; 4910 // Separate the scope and member name; 4911 pos = scopename.rfind(':');; 4912 if (pos != std::string::npos) {; 4913 if ((pos != 0) && (scopename[pos-1] == ':')) {; 4914 dataname = scopename.substr(pos+1);; 4915 scopename.erase(pos-1);; 4916 }; 4917 } else {; 4918 scopename.clear();; 4919 dataname = scopename;; 4920 }; 4921 }; 4922 //fprintf(stderr, ""name: '%s'\n"", name.c_str());; 4923 // Now we have the class or namespace name, so do the lookup.; 4924 ; 4925 ; 4926 DeclId_t d;; 4927 if (scopename.size()) {; 4928 TClingClassInfo cl(GetInterpreterImpl(), scopename.c_str());; 4929 d = cl.GetDataMember(dataname.c_str());; 4930 }; 4931 else {; 4932 TClingClassInfo gcl(GetInterpreterImpl());; 4933 d = gcl.GetDataMember(dataname.c_str());; 4934 }; 4935 return d;; 4936}; 4937 ; 4938////////////////////////////////////////////////////////////////////////////////; 4939/// NOT IMPLEMENTED.; 4940 ; 4941TInterpreter::DeclId_t TCling::GetDataMemberWithValue(const void *ptrvalue) const; 4942{; 4943 Error(""GetDataMemberWithValue()"", ""not implemented"");; 4944 return nullptr;; 4945}; 4946 ; 4947////////////////////////////////////////////////////////////////////////////////; 4948/// Return pointer to cling DeclId for a data member with a given name.; 4949 ; 4950TInterpreter::DeclId_t TCling::GetDataMemberAtAddr(const vo",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:202413,Usability,clear,clear,202413,"ing::GetFunctionTemplate(ClassInfo_t *opaque_cl, const char* name); 5178{; 5179 R__LOCKGUARD(gInterpreterMutex);; 5180 DeclId_t f;; 5181 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5182 if (cl) {; 5183 f = cl->GetFunctionTemplate(name);; 5184 }; 5185 else {; 5186 TClingClassInfo gcl(GetInterpreterImpl());; 5187 f = gcl.GetFunctionTemplate(name);; 5188 }; 5189 return f;; 5190 ; 5191}; 5192 ; 5193////////////////////////////////////////////////////////////////////////////////; 5194/// The 'name' is known to the interpreter, this function returns; 5195/// the internal version of this name (usually just resolving typedefs); 5196/// This is used in particular to synchronize between the name used; 5197/// by rootcling and by the run-time environment (TClass); 5198/// Return 0 if the name is not known.; 5199 ; 5200void TCling::GetInterpreterTypeName(const char* name, std::string &output, Bool_t full); 5201{; 5202 output.clear();; 5203 ; 5204 R__LOCKGUARD(gInterpreterMutex);; 5205 ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can rep",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:229736,Usability,clear,clear,229736,""" "");; 5887 fInterpreter->declare(cls.Data());; 5888 }; 5889 }; 5890 ; 5891 // Process the forward declarations collected; 5892 cling::Transaction* T = nullptr;; 5893 auto compRes= fInterpreter->declare(uniqueString.Data(), &T);; 5894 assert(cling::Interpreter::kSuccess == compRes && ""A declaration in a rootmap could not be compiled"");; 5895 ; 5896 if (compRes!=cling::Interpreter::kSuccess){; 5897 Warning(""LoadLibraryMap"",; 5898 ""Problems in %s declaring '%s' were encountered."", rootmapfile, uniqueString.Data()) ;; 5899 }; 5900 ; 5901 if (T) {; 5902 ExtVisibleStorageAdder evsAdder(fNSFromRootmaps);; 5903 for (auto declIt = T->decls_begin(); declIt < T->decls_end(); ++declIt) {; 5904 if (declIt->m_DGR.isSingleDecl()) {; 5905 if (Decl* D = declIt->m_DGR.getSingleDecl()) {; 5906 if (clang::isa<TagDecl>(D) || clang::isa<NamespaceDecl>(D)) {; 5907 evsAdder.TraverseDecl(D);; 5908 }; 5909 }; 5910 }; 5911 }; 5912 }; 5913 ; 5914 // clear duplicates; 5915 ; 5916 return 0;; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Scan again along the dynamic path for library maps. Entries for the loaded; 5921/// shared libraries are unloaded first. This can be useful after reseting; 5922/// the dynamic path through TSystem::SetDynamicPath(); 5923/// In case of error -1 is returned, 0 otherwise.; 5924 ; 5925Int_t TCling::RescanLibraryMap(); 5926{; 5927 UnloadAllSharedLibraryMaps();; 5928 LoadLibraryMap();; 5929 return 0;; 5930}; 5931 ; 5932////////////////////////////////////////////////////////////////////////////////; 5933/// Reload the library map entries coming from all the loaded shared libraries,; 5934/// after first unloading the current ones.; 5935/// In case of error -1 is returned, 0 otherwise.; 5936 ; 5937Int_t TCling::ReloadAllSharedLibraryMaps(); 5938{; 5939 const TString sharedLibLStr = GetSharedLibs();; 5940 const TObjArray* sharedLibL = sharedLibLStr.Tokenize("" "");; 5941 const Int_t nrSharedLibs = sharedLibL->Get",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:266093,Usability,clear,clear,266093,"4 TransactionDeclSet.insert(*DI);; 6795 ((TCling*)gCling)->HandleNewDecl(*DI, false, modifiedTClasses);; 6796 }; 6797 }; 6798 }; 6799 ; 6800 // The above might trigger more decls to be deserialized.; 6801 // Thus the iteration over the deserialized decls must be last.; 6802 for (cling::Transaction::const_iterator I = T.deserialized_decls_begin(),; 6803 E = T.deserialized_decls_end(); I != E; ++I) {; 6804 for (DeclGroupRef::const_iterator DI = I->m_DGR.begin(),; 6805 DE = I->m_DGR.end(); DI != DE; ++DI); 6806 if (TransactionDeclSet.find(*DI) == TransactionDeclSet.end()) {; 6807 //FIXME: HandleNewDecl should take DeclGroupRef; 6808 ((TCling*)gCling)->HandleNewDecl(*DI, /*isDeserialized*/true,; 6809 modifiedTClasses);; 6810 }; 6811 }; 6812 ; 6813 ; 6814 // When fully building the reflection info in TClass, a deserialization; 6815 // could be triggered, which may result in request for building the; 6816 // reflection info for the same TClass. This in turn will clear the caches; 6817 // for the TClass in-flight and cause null ptr derefs.; 6818 // FIXME: This is a quick fix, solving most of the issues. The actual; 6819 // question is: Shouldn't TClass provide a lock mechanism on update or lock; 6820 // itself until the update is done.; 6821 //; 6822 std::vector<TClass*> modifiedTClassesDiff(modifiedTClasses.size());; 6823 std::vector<TClass*>::iterator it;; 6824 it = set_difference(modifiedTClasses.begin(), modifiedTClasses.end(),; 6825 ((TCling*)gCling)->GetModTClasses().begin(),; 6826 ((TCling*)gCling)->GetModTClasses().end(),; 6827 modifiedTClassesDiff.begin());; 6828 modifiedTClassesDiff.resize(it - modifiedTClassesDiff.begin());; 6829 ; 6830 // Lock the TClass for updates; 6831 ((TCling*)gCling)->GetModTClasses().insert(modifiedTClassesDiff.begin(),; 6832 modifiedTClassesDiff.end());; 6833 for (std::vector<TClass*>::const_iterator I = modifiedTClassesDiff.begin(),; 6834 E = modifiedTClassesDiff.end(); I != E; ++I) {; 6835 // Make sure the TClass has not been deleted.",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:300375,Usability,simpl,simple,300375," corresponding to the statement.; 7678int TCling::Evaluate(const char* code, TInterpreterValue& value); 7679{; 7680 auto V = reinterpret_cast<cling::Value*>(value.GetValAddr());; 7681 auto compRes = fInterpreter->evaluate(code, *V);; 7682 return compRes!=cling::Interpreter::kSuccess ? 0 : 1 ;; 7683}; 7684 ; 7685////////////////////////////////////////////////////////////////////////////////; 7686 ; 7687void TCling::RegisterTemporary(const TInterpreterValue& value); 7688{; 7689 using namespace cling;; 7690 const Value* V = reinterpret_cast<const Value*>(value.GetValAddr());; 7691 RegisterTemporary(*V);; 7692}; 7693 ; 7694////////////////////////////////////////////////////////////////////////////////; 7695/// Register value as a temporary, extending its lifetime to that of the; 7696/// interpreter. This is needed for TCling's compatibility interfaces; 7697/// returning long - the address of the temporary objects.; 7698/// As such, ""simple"" types don't need to be stored; they are returned by; 7699/// value; only pointers / references / objects need to be stored.; 7700 ; 7701void TCling::RegisterTemporary(const cling::Value& value); 7702{; 7703 if (value.isValid() && value.needsManagedAllocation()) {; 7704 R__LOCKGUARD(gInterpreterMutex);; 7705 fTemporaries->push_back(value);; 7706 }; 7707}; 7708 ; 7709////////////////////////////////////////////////////////////////////////////////; 7710/// If the interpreter encounters Name, check whether that is an object ROOT; 7711/// could retrieve. To not re-read objects from disk, cache the name/object; 7712/// pair for a given LookupCtx.; 7713 ; 7714TObject* TCling::GetObjectAddress(const char *Name, void *&LookupCtx); 7715{; 7716 // The call to FindSpecialObject might induces any kind of use; 7717 // of the interpreter ... (library loading, function calling, etc.); 7718 // ... and we _know_ we are in the middle of parsing, so let's make; 7719 // sure to save the state and then restore it.; 7720 ; 7721 if (gDirectory) {; 7722 aut",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8cxx_source.html:341066,Usability,clear,clear,341066,"ls::TNormalizedCtxt &normCtxt); 8742{; 8743 const clang::TypeDecl* td = llvm::dyn_cast<clang::TypeDecl>(decl->getDeclContext());; 8744 if (!td) return;; 8745 ; 8746 clang::QualType qualType(td->getTypeForDecl(),0);; 8747 ROOT::TMetaUtils::GetNormalizedName(name, qualType, interp, normCtxt);; 8748 unsigned int level = 0;; 8749 for(size_t cursor = name.length()-1; cursor != 0; --cursor) {; 8750 if (name[cursor] == '>') ++level;; 8751 else if (name[cursor] == '<' && level) --level;; 8752 else if (level == 0 && name[cursor] == ':') {; 8753 name.erase(0,cursor+1);; 8754 break;; 8755 }; 8756 }; 8757}; 8758 ; 8759////////////////////////////////////////////////////////////////////////////////; 8760 ; 8761void TCling::GetFunctionName(const clang::Decl *decl, std::string &output) const; 8762{; 8763 output.clear();; 8764 ; 8765 const auto *FD = llvm::dyn_cast<clang::FunctionDecl>(decl);; 8766 if (const auto *USD = llvm::dyn_cast<clang::UsingShadowDecl>(decl)) {; 8767 FD = llvm::dyn_cast<clang::FunctionDecl>(USD->getTargetDecl());; 8768 }; 8769 if (!FD) {; 8770 Error(""GetFunctionName"", ""NULL Decl!"");; 8771 return;; 8772 }; 8773 ; 8774 // For using-decls, show ""Derived"", not ""Base"", i.e. use the; 8775 // name of the decl context of the UsingShadowDecl (aka `decl`); 8776 // not the name of FD's decl context.; 8777 if (llvm::isa<clang::CXXConstructorDecl>(FD)); 8778 {; 8779 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8780 ; 8781 } else if (llvm::isa<clang::CXXDestructorDecl>(decl)); 8782 {; 8783 ConstructorName(output, decl, *fInterpreter, *fNormalizedCtxt);; 8784 output.insert(output.begin(), '~');; 8785 } else {; 8786 llvm::raw_string_ostream stream(output);; 8787 auto printPolicy = decl->getASTContext().getPrintingPolicy();; 8788 // Don't trigger fopen of the source file to count lines:; 8789 printPolicy.AnonymousTagLocations = false;; 8790 FD->getNameForDiagnostic(stream, printPolicy, /*Qualified=*/false);; 8791 }; 8792}; 8793 ; 8794//////////////////////",MatchSource.WIKI,doc/master/TCling_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html
https://root.cern/doc/master/TCling_8h_source.html:10043,Availability,error,error,10043,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:10379,Availability,error,error,10379,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:10466,Availability,error,error,10466,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:10546,Availability,error,error,10546,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:12291,Availability,error,error,12291," TClass *oldcl) final;; 257 ; 258 Int_t SetClassSharedLibs(const char *cls, const char *libs) final;; 259 void SetGetline(const char * (*getlineFunc)(const char* prompt),; 260 void (*histaddFunc)(const char* line)) final;; 261 void Reset() final;; 262 void ResetAll() final;; 263 void ResetGlobals() final;; 264 void ResetGlobalVar(void* obj) final;; 265 void RewindDictionary() final;; 266 Int_t DeleteGlobal(void* obj) final;; 267 Int_t DeleteVariable(const char *name) final;; 268 void SaveContext() final;; 269 void SaveGlobalsContext() final;; 270 void UpdateListOfGlobals() final;; 271 void UpdateListOfGlobalFunctions() final;; 272 void UpdateListOfTypes() final;; 273 void SetClassInfo(TClass* cl, Bool_t reload = kFALSE, Bool_t silent = kFALSE) final;; 274 ; 275 ECheckClassInfo CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamespaceOnly = kFALSE) final;; 276 ; 277 Bool_t CheckClassTemplate(const char *name) final;; 278 Longptr_t Calc(const char* line, EErrorCode* error = nullptr) final;; 279 void CreateListOfBaseClasses(TClass* cl) const final;; 280 void CreateListOfDataMembers(TClass* cl) const final;; 281 void CreateListOfMethods(TClass* cl) const final;; 282 void CreateListOfMethodArgs(TFunction* m) const final;; 283 void UpdateListOfMethods(TClass* cl) const final;; 284 void UpdateListOfDataMembers(TClass* cl) const;; 285 ; 286 DeclId_t GetDataMember(ClassInfo_t *cl, const char *name) const final;; 287 DeclId_t GetDataMemberAtAddr(const void *addr) const final;; 288 DeclId_t GetDataMemberWithValue(const void *ptrvalue) const final;; 289 DeclId_t GetEnum(TClass *cl, const char *name) const final;; 290 TEnum* CreateEnum(void *VD, TClass *cl) const final;; 291 void UpdateEnumConstants(TEnum* enumObj, TClass* cl) const final;; 292 void LoadEnums(TListOfEnums& cl) const final;; 293 std::string ToString(const char* type, void *obj) final;; 294 TString GetMangledName(TClass* cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) f",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:14699,Availability,error,error,14699,"ol_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 298 DeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) final;; 299 DeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ;",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:14812,Availability,error,error,14812,"tion(ClassInfo_t *cl, const char *funcname) final;; 299 DeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 vo",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:14947,Availability,error,error,14947,"ar* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:15050,Availability,error,error,15050,";; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t tagnum);; 332 static void UpdateClassInfoWork(const char* name);; 333 void RefreshClassInfo(TClass *cl",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:15281,Availability,error,error,15281,"ionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t tagnum);; 332 static void UpdateClassInfoWork(const char* name);; 333 void RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias);; 334 void UpdateClassInfoWithDecl(const clang::NamedDecl* ND);; 335 static void UpdateAllCanvases();; 336 ; 337 // Misc; 338 int DisplayClass(FILE* fout, const char* name, int base, int s",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:16442,Availability,error,error,16442,"= kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t tagnum);; 332 static void UpdateClassInfoWork(const char* name);; 333 void RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias);; 334 void UpdateClassInfoWithDecl(const clang::NamedDecl* ND);; 335 static void UpdateAllCanvases();; 336 ; 337 // Misc; 338 int DisplayClass(FILE* fout, const char* name, int base, int start) const final;; 339 int DisplayIncludePath(FILE* fout) const final;; 340 void* FindSym(const char* entry) const final;; 341 void GenericError(const char* error) const final;; 342 Long_t GetExecByteCode() const final;; 343 const char* GetTopLevelMacroName() const final;; 344 const char* GetCurrentMacroName() const final;; 345 int GetSecurityError() const final;; 346 int LoadFile(const char* path) const final;; 347 Bool_t LoadText(const char* text) const final;; 348 const char* MapCppName(const char*) const final;; 349 void SetAlloclockfunc(void (*)()) const final;; 350 void SetAllocunlockfunc(void (*)()) const final;; 351 int SetClassAutoLoading(int) const final;; 352 int SetClassAutoparsing(int) final;; 353 Bool_t IsAutoParsingSuspended() const final { return fIsAutoParsingSuspended; }; 354 void SetErrmsgcallback(void* p) const final;; 355 void ReportDiagnosticsToErrorHandler(bool enable = true) final;; 356 void SetTempLevel(int val) const final;; 357 int UnloadFile(const char* path) const final;; 358 ; 359 void CodeComplete(const std::string&, size_t&,; 360 std::vector<std::string>&) final;; 361 int Evaluate(const char*, TInterpreterValue",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:34612,Availability,error,error,34612,"xxxInfo_t' to nullptr.; 593 if (O && O->IsValid()); 594 L.Unload(O), O->Update(nullptr);; 595 }; 596 ; 597 void InvalidateCachedDecl(const std::tuple<TListOfDataMembers*,; 598 TListOfFunctions*,; 599 TListOfFunctionTemplates*,; 600 TListOfEnums*> &Lists, const clang::Decl *D);; 601 ; 602 class SuspendAutoLoadingRAII {; 603 TCling *fTCling = nullptr;; 604 bool fOldValue;; 605 ; 606 public:; 607 SuspendAutoLoadingRAII(TCling *tcling) : fTCling(tcling) { fOldValue = fTCling->SetClassAutoLoading(false); }; 608 ~SuspendAutoLoadingRAII() { fTCling->SetClassAutoLoading(fOldValue); }; 609 };; 610 ; 611 class TUniqueString {; 612 public:; 613 TUniqueString() = delete;; 614 TUniqueString(const TUniqueString &) = delete;; 615 TUniqueString(Long64_t size);; 616 const char *Data();; 617 bool Append(const std::string &str);; 618 private:; 619 std::string fContent;; 620 std::set<size_t> fLinesHashSet;; 621 std::hash<std::string> fHashFunc;; 622 };; 623 ; 624 TCling();; 625 TCling(const TCling&) = delete;; 626 TCling& operator=(const TCling&) = delete;; 627 ; 628 void Execute(TMethod*, TObjArray*, int* /*error*/ = nullptr) final {}; 629 ; 630 void UpdateListOfLoadedSharedLibraries();; 631 void RegisterLoadedSharedLibrary(const char* name);; 632 void AddFriendToClass(clang::FunctionDecl*, clang::CXXRecordDecl*) const;; 633 ; 634 std::map<std::string, llvm::StringRef> fPendingRdicts;; 635 void RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 636 void LoadPCM(std::string pcmFileNameFullPath);; 637 void LoadPCMImpl(TFile &pcmFile);; 638 ; 639 void InitRootmapFile(const char *name);; 640 int ReadRootmapFile(const char *rootmapfile, TUniqueString* uniqueString = nullptr);; 641 Bool_t HandleNewTransaction(const cling::Transaction &T);; 642 bool IsClassAutoLoadingEnabled() const;; 643 void ProcessClassesToUpdate();; 644 cling::Interpreter *GetInterpreterImpl() const { return fInterpreter.get(); }; 645 cling::MetaProcessor *GetMetaProcessorImpl()",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:43956,Availability,error,error,43956,"OfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TCling::TypedefInfo_IsValidbool TypedefInfo_IsValid(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9482; TCling::AutoLoadInt_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded=kFALSE) finalLoad library containing the specified class.Definition TCling.cxx:6265; TCling::GetAutoLoadCallBackvoid * GetAutoLoadCallBack() const finalDefinition TCling.h:198; TCling::CallFunc_Initvoid CallFunc_Init(CallFunc_t *func) const finalDefinition TCling.cxx:7940; TCling::SetGetlinevoid SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line)) finalSet a getline function to call when input is needed.Definition TCling.cxx:3648; TCling::LibraryLoadingFailedbool LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)Definition TCling.cxx:6568; TCling::GenericErrorvoid GenericError(const char *error) const finalLet the interpreter issue a generic error, and set its error state.Definition TCling.cxx:7457; TCling::fRegisterModuleDyLibsstd::vector< void * > fRegisterModuleDyLibsDefinition TCling.h:138; TCling::CallFunc_ExecWithReturnvoid CallFunc_ExecWithReturn(CallFunc_t *func, void *address, void *ret) const finalDefinition TCling.cxx:7866; TCling::MethodInfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrv",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:44010,Availability,error,error,44010,"OfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TCling::TypedefInfo_IsValidbool TypedefInfo_IsValid(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9482; TCling::AutoLoadInt_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded=kFALSE) finalLoad library containing the specified class.Definition TCling.cxx:6265; TCling::GetAutoLoadCallBackvoid * GetAutoLoadCallBack() const finalDefinition TCling.h:198; TCling::CallFunc_Initvoid CallFunc_Init(CallFunc_t *func) const finalDefinition TCling.cxx:7940; TCling::SetGetlinevoid SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line)) finalSet a getline function to call when input is needed.Definition TCling.cxx:3648; TCling::LibraryLoadingFailedbool LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)Definition TCling.cxx:6568; TCling::GenericErrorvoid GenericError(const char *error) const finalLet the interpreter issue a generic error, and set its error state.Definition TCling.cxx:7457; TCling::fRegisterModuleDyLibsstd::vector< void * > fRegisterModuleDyLibsDefinition TCling.h:138; TCling::CallFunc_ExecWithReturnvoid CallFunc_ExecWithReturn(CallFunc_t *func, void *address, void *ret) const finalDefinition TCling.cxx:7866; TCling::MethodInfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrv",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:44029,Availability,error,error,44029,"OfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TCling::TypedefInfo_IsValidbool TypedefInfo_IsValid(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9482; TCling::AutoLoadInt_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded=kFALSE) finalLoad library containing the specified class.Definition TCling.cxx:6265; TCling::GetAutoLoadCallBackvoid * GetAutoLoadCallBack() const finalDefinition TCling.h:198; TCling::CallFunc_Initvoid CallFunc_Init(CallFunc_t *func) const finalDefinition TCling.cxx:7940; TCling::SetGetlinevoid SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line)) finalSet a getline function to call when input is needed.Definition TCling.cxx:3648; TCling::LibraryLoadingFailedbool LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)Definition TCling.cxx:6568; TCling::GenericErrorvoid GenericError(const char *error) const finalLet the interpreter issue a generic error, and set its error state.Definition TCling.cxx:7457; TCling::fRegisterModuleDyLibsstd::vector< void * > fRegisterModuleDyLibsDefinition TCling.h:138; TCling::CallFunc_ExecWithReturnvoid CallFunc_ExecWithReturn(CallFunc_t *func, void *address, void *ret) const finalDefinition TCling.cxx:7866; TCling::MethodInfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrv",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:48364,Availability,error,error,48364,"efinition TCling.cxx:8215; TCling::MethodInfo_Nameconst char * MethodInfo_Name(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9138; TCling::BaseClassInfo_FactoryBaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *info) const finalDefinition TCling.cxx:8472; TCling::LoadTextBool_t LoadText(const char *text) const finalLoad the declarations from text into the interpreter.Definition TCling.cxx:7515; TCling::GetSharedLibDepsconst char * GetSharedLibDeps(const char *lib, bool tryDyld=false) finalGet the list a libraries on which the specified lib depends.Definition TCling.cxx:7289; TCling::MethodInfo_MethodCallReturnTypeEReturnType MethodInfo_MethodCallReturnType(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9188; TCling::GetObjectAddressTObject * GetObjectAddress(const char *Name, void *&LookupCtx)If the interpreter encounters Name, check whether that is an object ROOT could retrieve.Definition TCling.cxx:7714; TCling::ProcessLineAsynchLongptr_t ProcessLineAsynch(const char *line, EErrorCode *error=nullptr)Let cling process a command line asynch.Definition TCling.cxx:3560; TCling::MethodInfo_IsValidbool MethodInfo_IsValid(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9059; TCling::TClingTCling(); TCling::FuncTempInfo_FactoryFuncTempInfo_t * FuncTempInfo_Factory(DeclId_t declid) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8815; TCling::TypeInfo_FactoryTypeInfo_t * TypeInfo_Factory() const finalDefinition TCling.cxx:9348; TCling::IsClassAutoLoadingEnabledbool IsClassAutoLoadingEnabled() constReturns if class AutoLoading is currently enabled.Definition TCling.cxx:7554; TCling::InvalidateGlobalvoid InvalidateGlobal(const clang::Decl *D)Invalidate cached TCling information for the given global declaration.Definition TCling.cxx:6876; TCling::Evaluateint Evaluate(const char *, TInterpreterValue &) finalGet the interpreter value corresponding to the statement.Definition TCling.cxx:7678; TCling::MakeInterpreterValuestd::unique_ptr< TInterpr",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:50218,Availability,failure,failure,50218,"aluateint Evaluate(const char *, TInterpreterValue &) finalGet the interpreter value corresponding to the statement.Definition TCling.cxx:7678; TCling::MakeInterpreterValuestd::unique_ptr< TInterpreterValue > MakeInterpreterValue() const finalDefinition TCling.cxx:7663; TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseC",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:54701,Availability,error,error,54701," TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunc",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:56327,Availability,error,error,56327,"ope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * TypedefInfo_Factory() const finalDefinition TCling.cxx:9449; TCling::fRootmapFilesTObjArray * fRootmapFilesDefinition TCling.h:126; TCling::IsVoidPointerTypebool IsVoidPointerType(const void *QualTypePtr) constDefinition TCling.cxx:9587; TCling::ProcessLineLongptr_t ProcessLine(const char *line, EErrorCode *error=nullptr) finalDefinition TCling.cxx:2453; TCling::ClassInfo_Sizeint ClassInfo_Size(ClassInfo_t *info) const finalDefinition TCling.cxx:8400; TCling::MethodArgInfo_TypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nullptr) finalExecute a cling macro.Definition TCling.cxx:5403; TCling::fClassesToUpdatestd::vector< std::pair< TClass *, DictFuncPtr_t > > fClassesToUpdateDefinition TCling.h:146; TCling::DataMemberInfo_Nextint DataMemberInfo_Next(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8642; TCling::TypedefInfo_Nameconst char * TypedefInfo_Name(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9522; TCling::BaseClassInfo_Deletevoid BaseClassInfo_Delete(BaseClassInfo_t *bcinfo) const finalDefinition TCling",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:56781,Availability,error,error,56781,"to, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * TypedefInfo_Factory() const finalDefinition TCling.cxx:9449; TCling::fRootmapFilesTObjArray * fRootmapFilesDefinition TCling.h:126; TCling::IsVoidPointerTypebool IsVoidPointerType(const void *QualTypePtr) constDefinition TCling.cxx:9587; TCling::ProcessLineLongptr_t ProcessLine(const char *line, EErrorCode *error=nullptr) finalDefinition TCling.cxx:2453; TCling::ClassInfo_Sizeint ClassInfo_Size(ClassInfo_t *info) const finalDefinition TCling.cxx:8400; TCling::MethodArgInfo_TypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nullptr) finalExecute a cling macro.Definition TCling.cxx:5403; TCling::fClassesToUpdatestd::vector< std::pair< TClass *, DictFuncPtr_t > > fClassesToUpdateDefinition TCling.h:146; TCling::DataMemberInfo_Nextint DataMemberInfo_Next(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8642; TCling::TypedefInfo_Nameconst char * TypedefInfo_Name(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9522; TCling::BaseClassInfo_Deletevoid BaseClassInfo_Delete(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8465; TCling::MethodInfo_ExtraPropertyLong_t MethodInfo_ExtraProperty(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9100; TCling::LoadMacrovoid LoadMacro(const char *filename, EErrorCode *error=nullptr) finalLoad a macro file in cling's memory.Definition TCling.cxx:3552; TCling::FuncTempInfo_FactoryCopyFuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t *) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8826; TCling::Dat",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:57507,Availability,error,error,57507,"ypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nullptr) finalExecute a cling macro.Definition TCling.cxx:5403; TCling::fClassesToUpdatestd::vector< std::pair< TClass *, DictFuncPtr_t > > fClassesToUpdateDefinition TCling.h:146; TCling::DataMemberInfo_Nextint DataMemberInfo_Next(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8642; TCling::TypedefInfo_Nameconst char * TypedefInfo_Name(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9522; TCling::BaseClassInfo_Deletevoid BaseClassInfo_Delete(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8465; TCling::MethodInfo_ExtraPropertyLong_t MethodInfo_ExtraProperty(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9100; TCling::LoadMacrovoid LoadMacro(const char *filename, EErrorCode *error=nullptr) finalLoad a macro file in cling's memory.Definition TCling.cxx:3552; TCling::FuncTempInfo_FactoryCopyFuncTempInfo_t * FuncTempInfo_FactoryCopy(FuncTempInfo_t *) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8826; TCling::DataMemberInfo_MaxIndexint DataMemberInfo_MaxIndex(DataMemberInfo_t *dminfo, Int_t dim) const finalDefinition TCling.cxx:8634; TCling::FuncTempInfo_IsValidBool_t FuncTempInfo_IsValid(FuncTempInfo_t *) const finalCheck validity of a FuncTempInfo_t.Definition TCling.cxx:8837; TCling::AddIncludePathvoid AddIncludePath(const char *path) finalAdd a directory to the list of directories in which the interpreter looks for include files.Definition TCling.cxx:2662; TCling::ClassInfo_IsBasebool ClassInfo_IsBase(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8287; TCling::RecursiveRemovevoid RecursiveRemove(TObject *obj) finalDelete object from cling symbol table so it can not be used anymore.Definition TCling.cxx:3683;",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:60701,Availability,error,error,60701,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:60766,Availability,failure,failures,60766,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:67293,Availability,error,error,67293,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:67358,Availability,failure,failures,67358,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:71880,Availability,error,error,71880,"ing::GetRootMapFilesTObjArray * GetRootMapFiles() const finalDefinition TCling.h:223; TCling::DataMemberInfo_IsValidbool DataMemberInfo_IsValid(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8626; TCling::ClassInfo_IsEnumbool ClassInfo_IsEnum(const char *name) const finalDefinition TCling.cxx:8295; TCling::MethodInfo_NDefaultArgint MethodInfo_NDefaultArg(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9075; TCling::CreateListOfMethodsvoid CreateListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::SpecialObjectLookupCtx_tvoid * SpecialObjectLookupCtx_tDefinition TCling.h:151; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototyp",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:78447,Availability,error,error,78447,"id(CallFunc_t *func) const finalDefinition TCling.cxx:7949; TCling::BaseClassInfo_Nameconst char * BaseClassInfo_Name(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8563; TCling::fLookupHelperROOT::TMetaUtils::TClingLookupHelper * fLookupHelperDefinition TCling.h:135; TCling::DataMemberInfo_ValidArrayIndexconst char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8714; TCling::GetMoreInt_t GetMore() const finalReturn whether we are waiting for more input either because the collected input contains unbalanced b...Definition TCling.cxx:4544; TCling::fIsAutoParsingSuspendedBool_t fIsAutoParsingSuspendedDefinition TCling.h:182; TCling::ToStringstd::string ToString(const char *type, void *obj) finalDefinition TCling.cxx:1023; TCling::GetDeclIdDeclId_t GetDeclId(const llvm::GlobalValue *gv) constReturn pointer to cling DeclId for a global value.Definition TCling.cxx:4872; TCling::Executevoid Execute(const char *function, const char *params, int *error=nullptr) finalExecute a global function with arguments params.Definition TCling.cxx:5233; TCling::ClassInfo_IsLoadedbool ClassInfo_IsLoaded(ClassInfo_t *info) const finalDefinition TCling.cxx:8320; TCling::ClassInfo_TagnumLongptr_t ClassInfo_Tagnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8408; TCling::BaseClassInfo_PropertyLong_t BaseClassInfo_Property(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8529; TCling::CallFunc_SetFuncvoid CallFunc_SetFunc(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *params, Longptr_t *Offset) const finalDefinition TCling.cxx:8038; TCling::GetUsingNamespacesstd::vector< std::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TS",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:80752,Availability,error,error,80752," TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelMacroName() const finalReturn the file name of the current un-included interpreted file.Definition TCling.cxx:5416; TCling::fPrevLoadedDynLibInfovoid * fPrevLoadedDynLibInfoDefinition TCling.h:137; TCling::UpdateListOfDataMembersvoid UpdateListOfDataMembers(TClass *cl) constUpdate the list of p",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:90896,Availability,error,error,90896,"ling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarker() const finalDefinition TCling.h:224; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDic",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:43045,Deployability,update,update,43045,"ng::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TCling::LoadEnumsvoid LoadEnums(TListOfEnums &cl) const finalCreate list of pointers to enums for TClass cl.Definition TCling.cxx:4395; TCling::UpdateListOfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TCling::TypedefInfo_IsValidbool TypedefInfo_IsValid(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9482; TCling::AutoLoadInt_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded=kFALSE) finalLoad library containing the specified class.Definition TCling.cxx:6265; TCling::GetAutoLoadCallBackvoid * GetAutoLoadCallBack() const finalDefinition TCling.h:198; TCling::CallFunc_Initvoid CallFunc_Init(CallFunc_t *func) const finalDefinition TCling.cxx:7940; TCling::SetGetlinevoid SetGetline(const char *(*getlineFunc)(const char *prompt), void(*histaddFunc)(const char *line)) finalSet a getline function to call when input is needed.Definition TCling.cxx:3648; TCling::LibraryLoadingFailedbool LibraryLoadingFailed(const std::string &, const std::string &, bool, bool)Definition TCling.cxx:6568; TCling::GenericErrorvoid GenericError(const char *error) const finalLet the interpreter issue a generic error",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:51359,Deployability,update,update,51359,"ing::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:81163,Deployability,update,update,81163," the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelMacroName() const finalReturn the file name of the current un-included interpreted file.Definition TCling.cxx:5416; TCling::fPrevLoadedDynLibInfovoid * fPrevLoadedDynLibInfoDefinition TCling.h:137; TCling::UpdateListOfDataMembersvoid UpdateListOfDataMembers(TClass *cl) constUpdate the list of pointers to data members for TClass cl This is now a nop.Definition TCling.cxx:4516; TCling::InspectMembersvoid InspectMembers(TMemberInspector &, const void *obj, const TClass *cl, Bool_t isTransient) finalVisit all members over members, recursing over base classes.Definition TCling.cxx:2684; TCling::SetClassSharedLibsInt_t SetClassSharedLibs(const char *cls, const char *libs)",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:85244,Deployability,release,release,85244, the code for class cls.Definition TCling.cxx:7095; TCling::DataMemberInfo_OffsetLongptr_t DataMemberInfo_Offset(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8650; TCling::CallFunc_FactoryCallFunc_t * CallFunc_Factory() const finalDefinition TCling.cxx:7909; TCling::MethodInfo_FactoryMethodInfo_t * MethodInfo_Factory() const finalDefinition TCling.cxx:9018; TCling::DataMemberInfo_TypePropertyLong_t DataMemberInfo_TypeProperty(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8666; TCling::ClearFileBusyvoid ClearFileBusy() finalReset the interpreter internal state in case a previous action was not correctly terminated.Definition TCling.cxx:3077; TCling::GetMetaProcessorImplcling::MetaProcessor * GetMetaProcessorImpl() constDefinition TCling.h:645; TCling::DiagnoseIfInterpreterExceptionbool DiagnoseIfInterpreterException(const std::exception &e) const finalDefinition TCling.cxx:2442; TCling::SetAllocunlockfuncvoid SetAllocunlockfunc(void(*)()) const final[Place holder for Mutex Unlock] Provide the interpreter with a way to release a lock used to protect ...Definition TCling.cxx:7546; TCling::fLookedUpClassesstd::set< size_t > fLookedUpClassesDefinition TCling.h:121; TCling::TClingTCling(const TCling &)=delete; TCling::AddAvailableIndentifiersvirtual void AddAvailableIndentifiers(TSeqCollection &Idents) finalDefinition TCling.cxx:2358; TCling::TypedefInfo_Deletevoid TypedefInfo_Delete(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9442; TCling::Resetvoid Reset() finalPressing Ctrl+C should forward here.Definition TCling.cxx:3708; TCling::TypedefInfo_TrueNameconst char * TypedefInfo_TrueName(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9514; TCling::SetClassAutoLoadingint SetClassAutoLoading(int) const finalEnable/Disable the AutoLoading of libraries.Definition TCling.cxx:7567; TCling::ClassInfo_FullNameconst char * ClassInfo_FullName(ClassInfo_t *info) const finalDefinition TCling.cxx:8424; TCling::AutoParseImplRecurseUInt_t Aut,MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:90438,Deployability,update,update,90438,"ing::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarker() const finalDefinition TCling.h:224; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()U",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:94353,Deployability,integrat,integration,94353," for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; clangDefinition BaseSelectionRule.h:29; llvmDefinition TString.h:847; ROOT::TVirtualRWMutex::StateDeltaState as returned by GetStateDelta() that can be passed to Restore()Definition TVirtualRWMutex.h:70; TCling::CharPtrCmp_tDefinition TCling.h:140; TCling::CharPtrCmp_t::operator()bool operator()(const char *a, const char *b) constDefinition TCling.h:141; TCling::MutexStateAndRecurseCountDeltaDefinition TCling.h:167; TCling::MutexStateAndRecurseCountDelta::fDeltastd::unique_ptr< StateDelta > fDeltaDefinition TCling.h:171; TCling::MutexStateAndRecurseCountDelta::fInitialStateMutexStateAndRecurseCount fInitialStateDefinition TCling.h:170; TCling::MutexStateAndRecurseCountDefinition TCling.h:155; TCling::MutexStateAndRecurseCount:",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:816,Integrability,interface,interface,816,". ROOT: core/metacling/src/TCling.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCling.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Axel Naumann, 2011-10-19; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TCling; 14#define ROOT_TCling; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCling //; 19// //; 20// This class defines an interface to the cling C++ interpreter. //; 21// //; 22// Cling is a full ANSI compliant C++ interpreter based on //; 23// clang/LLVM technology. //; 24// //; 25//////////////////////////////////////////////////////////////////////////; 26 ; 27#include ""TInterpreter.h""; 28 ; 29#include <map>; 30#include <memory>; 31#include <set>; 32#include <tuple>; 33#include <unordered_map>; 34#include <unordered_set>; 35#include <vector>; 36#include <string>; 37#include <utility>; 38 ; 39#ifndef WIN32; 40#define TWin32SendClass char; 41#endif; 42 ; 43namespace llvm {; 44 class GlobalValue;; 45 class StringRef;; 46}; 47 ; 48namespace clang {; 49 class CXXRecordDecl;; 50 class Decl;; 51 class DeclContext;; 52 class EnumDecl;; 53 class FunctionDecl;; 54 class IdentifierIterator;; 55 class NamedDecl;; 56 class NamespaceDecl;; 57 class TagDecl;; 58 class Type;; 59 class QualType;; 60}; 61namespace cling {; 62 class Interpreter;; 63 class MetaProcessor;; 64 class Transaction;; 65 class Value;; 66}; 67 ; 68class TClingCallbacks;; 69class TEnv;; 70class TFile;; 71class THashTable;; 72class TInterpreterValue;; 73class TMethod;; 74class TObjArray;; 75class TListOfDataMembers;; 76class TLis",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:18122,Integrability,interface,interface,18122,,MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:21350,Integrability,interface,interface,21350,"odInfo_t* info) const final;; 403 void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 404 void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 405 void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 406 void CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Longptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 407 ; 408 std::string CallFunc_GetWrapperCode(CallFunc_t *func) const final;; 409 ; 410 // ClassInfo interface; 411 DeclId_t GetDeclId(ClassInfo_t *info) const final;; 412 Bool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const final;; 413 Long_t ClassInfo_ClassProperty(ClassInfo_t* info) const final;; 414 void ClassInfo_Delete(ClassInfo_t* info) const final;; 415 void ClassInfo_Delete(ClassInfo_t* info, void* arena) const final;; 416 void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const final;; 417 void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const final;; 418 ClassInfo_t* ClassInfo_Factory(Bool_t all = kTRUE) const final;; 419 ClassInfo_t* ClassInfo_Factory(ClassInfo_t* cl) const final;; 420 ClassInfo_t* ClassInfo_Factory(const char* name) const final;; 421 ClassInfo_t* ClassInfo_Factory(DeclId_t declid) const final;; 422 Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const final;; 423 int ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:24441,Integrability,interface,interface,24441,"r* proto, Bool_t objectIsConst, Longptr_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const final;; 436 int ClassInfo_Next(ClassInfo_t* info) const final;; 437 void* ClassInfo_New(ClassInfo_t* info) const final;; 438 void* ClassInfo_New(ClassInfo_t* info, int n) const final;; 439 void* ClassInfo_New(ClassInfo_t* info, int n, void* arena) const final;; 440 void* ClassInfo_New(ClassInfo_t* info, void* arena) const final;; 441 Long_t ClassInfo_Property(ClassInfo_t* info) const final;; 442 int ClassInfo_Size(ClassInfo_t* info) const final;; 443 Longptr_t ClassInfo_Tagnum(ClassInfo_t* info) const final;; 444 const char* ClassInfo_FileName(ClassInfo_t* info) const final;; 445 const char* ClassInfo_FullName(ClassInfo_t* info) const final;; 446 const char* ClassInfo_Name(ClassInfo_t* info) const final;; 447 const char* ClassInfo_Title(ClassInfo_t* info) const final;; 448 const char* ClassInfo_TmpltName(ClassInfo_t* info) const final;; 449 ; 450 // BaseClassInfo interface; 451 void BaseClassInfo_Delete(BaseClassInfo_t* bcinfo) const final;; 452 BaseClassInfo_t* BaseClassInfo_Factory(ClassInfo_t* info) const final;; 453 BaseClassInfo_t* BaseClassInfo_Factory(ClassInfo_t* derived,; 454 ClassInfo_t* base) const final;; 455 int BaseClassInfo_Next(BaseClassInfo_t* bcinfo) const final;; 456 int BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const final;; 457 Longptr_t BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const final;; 458 Long_t BaseClassInfo_Property(BaseClassInfo_t* bcinfo) const final;; 459 Longptr_t BaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const final;; 460 ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) const final;; 461 const char* BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const final;; 462 const char* BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const final;; 463 const char* BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const final;; 464 ; 465 // ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:25461,Integrability,interface,interface,25461,"lassInfo_Delete(BaseClassInfo_t* bcinfo) const final;; 452 BaseClassInfo_t* BaseClassInfo_Factory(ClassInfo_t* info) const final;; 453 BaseClassInfo_t* BaseClassInfo_Factory(ClassInfo_t* derived,; 454 ClassInfo_t* base) const final;; 455 int BaseClassInfo_Next(BaseClassInfo_t* bcinfo) const final;; 456 int BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const final;; 457 Longptr_t BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const final;; 458 Long_t BaseClassInfo_Property(BaseClassInfo_t* bcinfo) const final;; 459 Longptr_t BaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const final;; 460 ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) const final;; 461 const char* BaseClassInfo_FullName(BaseClassInfo_t* bcinfo) const final;; 462 const char* BaseClassInfo_Name(BaseClassInfo_t* bcinfo) const final;; 463 const char* BaseClassInfo_TmpltName(BaseClassInfo_t* bcinfo) const final;; 464 ; 465 // DataMemberInfo interface; 466 DeclId_t GetDeclId(DataMemberInfo_t *info) const final;; 467 int DataMemberInfo_ArrayDim(DataMemberInfo_t* dminfo) const final;; 468 void DataMemberInfo_Delete(DataMemberInfo_t* dminfo) const final;; 469 DataMemberInfo_t* DataMemberInfo_Factory(ClassInfo_t* clinfo, TDictionary::EMemberSelection selection) const final;; 470 DataMemberInfo_t *DataMemberInfo_Factory(DeclId_t declid, ClassInfo_t* clinfo) const final;; 471 DataMemberInfo_t* DataMemberInfo_FactoryCopy(DataMemberInfo_t* dminfo) const final;; 472 bool DataMemberInfo_IsValid(DataMemberInfo_t* dminfo) const final;; 473 int DataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const final;; 474 int DataMemberInfo_Next(DataMemberInfo_t* dminfo) const final;; 475 Longptr_t DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const final;; 476 Long_t DataMemberInfo_Property(DataMemberInfo_t* dminfo) const final;; 477 Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const final;; 478 int DataMemberInfo_TypeSiz",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:27017,Integrability,interface,interface,27017,"berInfo_t* dminfo) const final;; 473 int DataMemberInfo_MaxIndex(DataMemberInfo_t* dminfo, Int_t dim) const final;; 474 int DataMemberInfo_Next(DataMemberInfo_t* dminfo) const final;; 475 Longptr_t DataMemberInfo_Offset(DataMemberInfo_t* dminfo) const final;; 476 Long_t DataMemberInfo_Property(DataMemberInfo_t* dminfo) const final;; 477 Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const final;; 478 int DataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const final;; 479 const char* DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const final;; 480 const char* DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const final;; 481 const char* DataMemberInfo_Name(DataMemberInfo_t* dminfo) const final;; 482 const char* DataMemberInfo_Title(DataMemberInfo_t* dminfo) const final;; 483 const char* DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const final;; 484 void SetDeclAttr(DeclId_t, const char* /* attribute */) final;; 485 ; 486 ; 487 // Function Template interface; 488 DeclId_t GetDeclId(FuncTempInfo_t *info) const final;; 489 void FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const final;; 490 FuncTempInfo_t *FuncTempInfo_Factory(DeclId_t declid) const final;; 491 FuncTempInfo_t *FuncTempInfo_FactoryCopy(FuncTempInfo_t * /* ft_info */) const final;; 492 Bool_t FuncTempInfo_IsValid(FuncTempInfo_t * /* ft_info */) const final;; 493 UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t * /* ft_info */) const final;; 494 UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t * /* ft_info */) const final;; 495 Long_t FuncTempInfo_Property(FuncTempInfo_t * /* ft_info */) const final;; 496 Long_t FuncTempInfo_ExtraProperty(FuncTempInfo_t * /* ft_info */) const final;; 497 void FuncTempInfo_Name(FuncTempInfo_t * /* ft_info */, TString& name) const final;; 498 void FuncTempInfo_Title(FuncTempInfo_t * /* ft_info */, TString& name) const final;; 499 ; 500 // MethodInfo interface; 501 DeclId_t GetDeclId(MethodInfo_t *info) const final;; 502 void Metho",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:27940,Integrability,interface,interface,27940,"nst char* /* attribute */) final;; 485 ; 486 ; 487 // Function Template interface; 488 DeclId_t GetDeclId(FuncTempInfo_t *info) const final;; 489 void FuncTempInfo_Delete(FuncTempInfo_t * /* ft_info */) const final;; 490 FuncTempInfo_t *FuncTempInfo_Factory(DeclId_t declid) const final;; 491 FuncTempInfo_t *FuncTempInfo_FactoryCopy(FuncTempInfo_t * /* ft_info */) const final;; 492 Bool_t FuncTempInfo_IsValid(FuncTempInfo_t * /* ft_info */) const final;; 493 UInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t * /* ft_info */) const final;; 494 UInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t * /* ft_info */) const final;; 495 Long_t FuncTempInfo_Property(FuncTempInfo_t * /* ft_info */) const final;; 496 Long_t FuncTempInfo_ExtraProperty(FuncTempInfo_t * /* ft_info */) const final;; 497 void FuncTempInfo_Name(FuncTempInfo_t * /* ft_info */, TString& name) const final;; 498 void FuncTempInfo_Title(FuncTempInfo_t * /* ft_info */, TString& name) const final;; 499 ; 500 // MethodInfo interface; 501 DeclId_t GetDeclId(MethodInfo_t *info) const final;; 502 void MethodInfo_CreateSignature(MethodInfo_t* minfo, TString& signature) const final;; 503 void MethodInfo_Delete(MethodInfo_t* minfo) const final;; 504 MethodInfo_t* MethodInfo_Factory() const final;; 505 MethodInfo_t* MethodInfo_Factory(ClassInfo_t *clinfo) const final;; 506 MethodInfo_t *MethodInfo_Factory(DeclId_t declid) const final;; 507 MethodInfo_t* MethodInfo_FactoryCopy(MethodInfo_t* minfo) const final;; 508 void* MethodInfo_InterfaceMethod(MethodInfo_t* minfo) const final;; 509 bool MethodInfo_IsValid(MethodInfo_t* minfo) const final;; 510 int MethodInfo_NArg(MethodInfo_t* minfo) const final;; 511 int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const final;; 512 int MethodInfo_Next(MethodInfo_t* minfo) const final;; 513 Long_t MethodInfo_Property(MethodInfo_t* minfo) const final;; 514 Long_t MethodInfo_ExtraProperty(MethodInfo_t* minfo) const final;; 515 TypeInfo_t* MethodInfo_Type(MethodInfo_t* minfo) const ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:29502,Integrability,interface,interface,29502,ool MethodInfo_IsValid(MethodInfo_t* minfo) const final;; 510 int MethodInfo_NArg(MethodInfo_t* minfo) const final;; 511 int MethodInfo_NDefaultArg(MethodInfo_t* minfo) const final;; 512 int MethodInfo_Next(MethodInfo_t* minfo) const final;; 513 Long_t MethodInfo_Property(MethodInfo_t* minfo) const final;; 514 Long_t MethodInfo_ExtraProperty(MethodInfo_t* minfo) const final;; 515 TypeInfo_t* MethodInfo_Type(MethodInfo_t* minfo) const final;; 516 EReturnType MethodInfo_MethodCallReturnType(MethodInfo_t* minfo) const final;; 517 const char* MethodInfo_GetMangledName(MethodInfo_t* minfo) const final;; 518 const char* MethodInfo_GetPrototype(MethodInfo_t* minfo) const final;; 519 const char* MethodInfo_Name(MethodInfo_t* minfo) const final;; 520 const char* MethodInfo_TypeName(MethodInfo_t* minfo) const final;; 521 std::string MethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const final;; 522 const char* MethodInfo_Title(MethodInfo_t* minfo) const final;; 523 ; 524 // MethodArgInfo interface; 525 void MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const final;; 526 MethodArgInfo_t* MethodArgInfo_Factory() const final;; 527 MethodArgInfo_t* MethodArgInfo_Factory(MethodInfo_t *minfo) const final;; 528 MethodArgInfo_t* MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const final;; 529 bool MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const final;; 530 int MethodArgInfo_Next(MethodArgInfo_t* marginfo) const final;; 531 Long_t MethodArgInfo_Property(MethodArgInfo_t* marginfo) const final;; 532 const char* MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const final;; 533 const char* MethodArgInfo_Name(MethodArgInfo_t* marginfo) const final;; 534 const char* MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const final;; 535 std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const final;; 536 TypeInfo_t* MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) const;; 537 ; 538 // TypeInfo interface; 539 void TypeInfo_Delete(TypeInfo_t* tinfo) co,MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:30450,Integrability,interface,interface,30450,"info) const final;; 523 ; 524 // MethodArgInfo interface; 525 void MethodArgInfo_Delete(MethodArgInfo_t* marginfo) const final;; 526 MethodArgInfo_t* MethodArgInfo_Factory() const final;; 527 MethodArgInfo_t* MethodArgInfo_Factory(MethodInfo_t *minfo) const final;; 528 MethodArgInfo_t* MethodArgInfo_FactoryCopy(MethodArgInfo_t* marginfo) const final;; 529 bool MethodArgInfo_IsValid(MethodArgInfo_t* marginfo) const final;; 530 int MethodArgInfo_Next(MethodArgInfo_t* marginfo) const final;; 531 Long_t MethodArgInfo_Property(MethodArgInfo_t* marginfo) const final;; 532 const char* MethodArgInfo_DefaultValue(MethodArgInfo_t* marginfo) const final;; 533 const char* MethodArgInfo_Name(MethodArgInfo_t* marginfo) const final;; 534 const char* MethodArgInfo_TypeName(MethodArgInfo_t* marginfo) const final;; 535 std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const final;; 536 TypeInfo_t* MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) const;; 537 ; 538 // TypeInfo interface; 539 void TypeInfo_Delete(TypeInfo_t* tinfo) const final;; 540 TypeInfo_t* TypeInfo_Factory() const final;; 541 TypeInfo_t *TypeInfo_Factory(const char* name) const final;; 542 TypeInfo_t* TypeInfo_FactoryCopy(TypeInfo_t* /* tinfo */) const final;; 543 void TypeInfo_Init(TypeInfo_t* tinfo, const char* funcname) const final;; 544 bool TypeInfo_IsValid(TypeInfo_t* tinfo) const final;; 545 const char* TypeInfo_Name(TypeInfo_t* /* info */) const final;; 546 Long_t TypeInfo_Property(TypeInfo_t* tinfo) const final;; 547 int TypeInfo_RefType(TypeInfo_t* /* tinfo */) const final;; 548 int TypeInfo_Size(TypeInfo_t* tinfo) const final;; 549 const char* TypeInfo_TrueName(TypeInfo_t* tinfo) const final;; 550 void* TypeInfo_QualTypePtr(TypeInfo_t* tinfo) const;; 551 ; 552 // TypedefInfo interface; 553 DeclId_t GetDeclId(TypedefInfo_t *info) const final;; 554 void TypedefInfo_Delete(TypedefInfo_t* tinfo) const final;; 555 TypedefInfo_t* TypedefInfo_Factory() const final;; 556 TypedefInfo_t* Typ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:31245,Integrability,interface,interface,31245,"const final;; 535 std::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const final;; 536 TypeInfo_t* MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) const;; 537 ; 538 // TypeInfo interface; 539 void TypeInfo_Delete(TypeInfo_t* tinfo) const final;; 540 TypeInfo_t* TypeInfo_Factory() const final;; 541 TypeInfo_t *TypeInfo_Factory(const char* name) const final;; 542 TypeInfo_t* TypeInfo_FactoryCopy(TypeInfo_t* /* tinfo */) const final;; 543 void TypeInfo_Init(TypeInfo_t* tinfo, const char* funcname) const final;; 544 bool TypeInfo_IsValid(TypeInfo_t* tinfo) const final;; 545 const char* TypeInfo_Name(TypeInfo_t* /* info */) const final;; 546 Long_t TypeInfo_Property(TypeInfo_t* tinfo) const final;; 547 int TypeInfo_RefType(TypeInfo_t* /* tinfo */) const final;; 548 int TypeInfo_Size(TypeInfo_t* tinfo) const final;; 549 const char* TypeInfo_TrueName(TypeInfo_t* tinfo) const final;; 550 void* TypeInfo_QualTypePtr(TypeInfo_t* tinfo) const;; 551 ; 552 // TypedefInfo interface; 553 DeclId_t GetDeclId(TypedefInfo_t *info) const final;; 554 void TypedefInfo_Delete(TypedefInfo_t* tinfo) const final;; 555 TypedefInfo_t* TypedefInfo_Factory() const final;; 556 TypedefInfo_t* TypedefInfo_Factory(const char* name) const final;; 557 TypedefInfo_t* TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) const final;; 558 void TypedefInfo_Init(TypedefInfo_t* tinfo, const char* name) const final;; 559 bool TypedefInfo_IsValid(TypedefInfo_t* tinfo) const final;; 560 int TypedefInfo_Next(TypedefInfo_t* tinfo) const final;; 561 Long_t TypedefInfo_Property(TypedefInfo_t* tinfo) const final;; 562 int TypedefInfo_Size(TypedefInfo_t* tinfo) const final;; 563 const char* TypedefInfo_TrueName(TypedefInfo_t* tinfo) const final;; 564 const char* TypedefInfo_Name(TypedefInfo_t* tinfo) const final;; 565 const char* TypedefInfo_Title(TypedefInfo_t* tinfo) const final;; 566 ; 567 // QualType Opaque Ptr interface; 568 bool IsSameType(const void * QualTypePtr1, const void * QualTypePtr2) co",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:32163,Integrability,interface,interface,32163,"id* TypeInfo_QualTypePtr(TypeInfo_t* tinfo) const;; 551 ; 552 // TypedefInfo interface; 553 DeclId_t GetDeclId(TypedefInfo_t *info) const final;; 554 void TypedefInfo_Delete(TypedefInfo_t* tinfo) const final;; 555 TypedefInfo_t* TypedefInfo_Factory() const final;; 556 TypedefInfo_t* TypedefInfo_Factory(const char* name) const final;; 557 TypedefInfo_t* TypedefInfo_FactoryCopy(TypedefInfo_t* tinfo) const final;; 558 void TypedefInfo_Init(TypedefInfo_t* tinfo, const char* name) const final;; 559 bool TypedefInfo_IsValid(TypedefInfo_t* tinfo) const final;; 560 int TypedefInfo_Next(TypedefInfo_t* tinfo) const final;; 561 Long_t TypedefInfo_Property(TypedefInfo_t* tinfo) const final;; 562 int TypedefInfo_Size(TypedefInfo_t* tinfo) const final;; 563 const char* TypedefInfo_TrueName(TypedefInfo_t* tinfo) const final;; 564 const char* TypedefInfo_Name(TypedefInfo_t* tinfo) const final;; 565 const char* TypedefInfo_Title(TypedefInfo_t* tinfo) const final;; 566 ; 567 // QualType Opaque Ptr interface; 568 bool IsSameType(const void * QualTypePtr1, const void * QualTypePtr2) const;; 569 bool IsIntegerType(const void * QualTypePtr) const;; 570 bool IsSignedIntegerType(const void * QualTypePtr) const;; 571 bool IsUnsignedIntegerType(const void * QualTypePtr) const;; 572 bool IsFloatingType(const void * QualTypePtr) const;; 573 bool IsPointerType(const void * QualTypePtr) const;; 574 bool IsVoidPointerType(const void * QualTypePtr) const;; 575 ; 576 // FunctionDecl interface ; 577 bool FunctionDeclId_IsMethod(DeclId_t fdeclid) const;; 578 ; 579 std::set<TClass*>& GetModTClasses() { return fModTClasses; }; 580 ; 581 void HandleNewDecl(const void* DV, bool isDeserialized, std::set<TClass*>& modifiedClasses);; 582 void UpdateListsOnCommitted(const cling::Transaction &T);; 583 void UpdateListsOnUnloaded(const cling::Transaction &T);; 584 void InvalidateGlobal(const clang::Decl *D);; 585 void TransactionRollback(const cling::Transaction &T);; 586 void LibraryLoaded(const void* dyLibHan",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:32643,Integrability,interface,interface,32643,"defInfo_FactoryCopy(TypedefInfo_t* tinfo) const final;; 558 void TypedefInfo_Init(TypedefInfo_t* tinfo, const char* name) const final;; 559 bool TypedefInfo_IsValid(TypedefInfo_t* tinfo) const final;; 560 int TypedefInfo_Next(TypedefInfo_t* tinfo) const final;; 561 Long_t TypedefInfo_Property(TypedefInfo_t* tinfo) const final;; 562 int TypedefInfo_Size(TypedefInfo_t* tinfo) const final;; 563 const char* TypedefInfo_TrueName(TypedefInfo_t* tinfo) const final;; 564 const char* TypedefInfo_Name(TypedefInfo_t* tinfo) const final;; 565 const char* TypedefInfo_Title(TypedefInfo_t* tinfo) const final;; 566 ; 567 // QualType Opaque Ptr interface; 568 bool IsSameType(const void * QualTypePtr1, const void * QualTypePtr2) const;; 569 bool IsIntegerType(const void * QualTypePtr) const;; 570 bool IsSignedIntegerType(const void * QualTypePtr) const;; 571 bool IsUnsignedIntegerType(const void * QualTypePtr) const;; 572 bool IsFloatingType(const void * QualTypePtr) const;; 573 bool IsPointerType(const void * QualTypePtr) const;; 574 bool IsVoidPointerType(const void * QualTypePtr) const;; 575 ; 576 // FunctionDecl interface ; 577 bool FunctionDeclId_IsMethod(DeclId_t fdeclid) const;; 578 ; 579 std::set<TClass*>& GetModTClasses() { return fModTClasses; }; 580 ; 581 void HandleNewDecl(const void* DV, bool isDeserialized, std::set<TClass*>& modifiedClasses);; 582 void UpdateListsOnCommitted(const cling::Transaction &T);; 583 void UpdateListsOnUnloaded(const cling::Transaction &T);; 584 void InvalidateGlobal(const clang::Decl *D);; 585 void TransactionRollback(const cling::Transaction &T);; 586 void LibraryLoaded(const void* dyLibHandle, const char* canonicalName);; 587 void LibraryUnloaded(const void* dyLibHandle, const char* canonicalName);; 588 ; 589private: // Private Utility Functions and Classes; 590 template <typename List, typename Object>; 591 static void RemoveAndInvalidateObject(List &L, Object *O) {; 592 // Invalidate stored information by setting the `xxxInfo_t' to nullptr.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:42100,Integrability,interface,interface,42100,"AII()Definition TCling.h:608; TCling::SuspendAutoLoadingRAII::fTClingTCling * fTClingDefinition TCling.h:603; TCling::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TCling.h:604; TCling::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TCling *tcling)Definition TCling.h:607; TCling::TUniqueStringDefinition TCling.h:611; TCling::TUniqueString::TUniqueStringTUniqueString(const TUniqueString &)=delete; TCling::TUniqueString::Dataconst char * Data()Definition TCling.cxx:1006; TCling::TUniqueString::Appendbool Append(const std::string &str)Append string to the storage if not added already.Definition TCling.cxx:1014; TCling::TUniqueString::TUniqueStringTUniqueString()=delete; TCling::TUniqueString::fHashFuncstd::hash< std::string > fHashFuncDefinition TCling.h:621; TCling::TUniqueString::fLinesHashSetstd::set< size_t > fLinesHashSetDefinition TCling.h:620; TCling::TUniqueString::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TCling::LoadEnumsvoid LoadEnums(TListOfEnums &cl) const finalCreate list of pointers to enums for TClass cl.Definition TCling.cxx:4395; TCling::UpdateListOfGlobalsvoid UpdateListOfGlobals() finalNo op: see TClingCallbacks (used to update the list of globals)Definition TCling.cxx:3885; TC",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:47900,Integrability,depend,depends,47900,"eListsOnCommittedvoid UpdateListsOnCommitted(const cling::Transaction &T)Definition TCling.cxx:6765; TCling::TypeInfo_RefTypeint TypeInfo_RefType(TypeInfo_t *) const finalDefinition TCling.cxx:9404; TCling::CreateListOfBaseClassesvoid CreateListOfBaseClasses(TClass *cl) const finalCreate list of pointers to base class(es) for TClass cl.Definition TCling.cxx:4371; TCling::GetPromptchar * GetPrompt() finalDefinition TCling.h:217; TCling::ClassInfo_FactoryClassInfo_t * ClassInfo_Factory(Bool_t all=kTRUE) const finalDefinition TCling.cxx:8215; TCling::MethodInfo_Nameconst char * MethodInfo_Name(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9138; TCling::BaseClassInfo_FactoryBaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *info) const finalDefinition TCling.cxx:8472; TCling::LoadTextBool_t LoadText(const char *text) const finalLoad the declarations from text into the interpreter.Definition TCling.cxx:7515; TCling::GetSharedLibDepsconst char * GetSharedLibDeps(const char *lib, bool tryDyld=false) finalGet the list a libraries on which the specified lib depends.Definition TCling.cxx:7289; TCling::MethodInfo_MethodCallReturnTypeEReturnType MethodInfo_MethodCallReturnType(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9188; TCling::GetObjectAddressTObject * GetObjectAddress(const char *Name, void *&LookupCtx)If the interpreter encounters Name, check whether that is an object ROOT could retrieve.Definition TCling.cxx:7714; TCling::ProcessLineAsynchLongptr_t ProcessLineAsynch(const char *line, EErrorCode *error=nullptr)Let cling process a command line asynch.Definition TCling.cxx:3560; TCling::MethodInfo_IsValidbool MethodInfo_IsValid(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9059; TCling::TClingTCling(); TCling::FuncTempInfo_FactoryFuncTempInfo_t * FuncTempInfo_Factory(DeclId_t declid) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8815; TCling::TypeInfo_FactoryTypeInfo_t * TypeInfo_Factory() const finalDefinition TCling.cxx:9348; T",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:50740,Integrability,interface,interface,50740,"*func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_Res",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:53423,Integrability,rout,routines,53423,"nterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const finalReturn true if the entity pointed to by 'declid' is declared in the context described by 'info'.Definition TCling.cxx:8131; TCling::IsLibraryLoadedBool_t IsLibraryLoaded(const char *libname) const finalDefinition TCling.cxx:3138; TCling::GetExecByteCodeLong_t GetExecByteCode() const finalThis routines used to return the address of the internal wrapper function (of the interpreter) that w...Definition TCling.cxx:7479; TCling::DataMemberInfo_ArrayDimint DataMemberInfo_ArrayDim(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLook",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:53475,Integrability,wrap,wrapper,53475,"nterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...Definition TCling.cxx:4723; TCling::ClassInfo_ContainsBool_t ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const finalReturn true if the entity pointed to by 'declid' is declared in the context described by 'info'.Definition TCling.cxx:8131; TCling::IsLibraryLoadedBool_t IsLibraryLoaded(const char *libname) const finalDefinition TCling.cxx:3138; TCling::GetExecByteCodeLong_t GetExecByteCode() const finalThis routines used to return the address of the internal wrapper function (of the interpreter) that w...Definition TCling.cxx:7479; TCling::DataMemberInfo_ArrayDimint DataMemberInfo_ArrayDim(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLook",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:54707,Integrability,message,messages,54707," TCling.cxx:8584; TCling::MethodArgInfo_TypeInfoTypeInfo_t * MethodArgInfo_TypeInfo(MethodArgInfo_t *marginfo) constDefinition TCling.cxx:9328; TCling::DataMemberInfo_FactoryCopyDataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8618; TCling::HandleNewTransactionBool_t HandleNewTransaction(const cling::Transaction &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunc",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:55876,Integrability,interface,interface,55876,"nfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * TypedefInfo_Factory() const finalDefinition TCling.cxx:9449; TCling::fRootmapFilesTObjArray * fRootmapFilesDefinition TCling.h:126; TCling::IsVoidPointerTypebool IsVoidPointerType(const void *QualTypePtr) constDefinition TCling.cxx:9587; TCling::ProcessLineLongptr_t ProcessLine(const char *line, EErrorCode *error=nullptr) finalDefinition TCling.cxx:2453; TCling::ClassInfo_Sizeint ClassInfo_Size(ClassInfo_t *info) const finalDefinition TCling.cxx:8400; TCling::MethodArgInfo_TypeNameconst char * MethodArgInfo_TypeName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9312; TCling::GetInterpreterImplcling::Interpreter * GetInterpreterImpl() constDefinition TCling.h:644; TCling::ExecuteMacroLongptr_t ExecuteMacro(const char *filename, EErrorCode *error=nu",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:60707,Integrability,message,messages,60707,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:60787,Integrability,message,messages,60787,"e(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9304; TCling::HasPCMForLibraryBool_t HasPCMForLibrary(const char *libname) const finalReturn true if ROOT has cxxmodules pcm for a given library name.Definition TCling.cxx:3147; TCling::TypedefInfo_Initvoid TypedefInfo_Init(TypedefInfo_t *tinfo, const char *name) const finalDefinition TCling.cxx:9472; TCling::DataMemberInfo_Titleconst char * DataMemberInfo_Title(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8706; TCling::CallFunc_ExecIntLongptr_t CallFunc_ExecInt(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7885; TCling::ClearStackvoid ClearStack() finalDelete existing temporary values.Definition TCling.cxx:3085; TCling::SetAlloclockfuncvoid SetAlloclockfunc(void(*)()) const final[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(Metho",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:63508,Integrability,interface,interface,63508,"ame(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::IsAutoParsingSuspendedBool_t IsAutoParsingSuspended() const finalDefinition TCling.h:353; TCling::fSharedLibsTString fSharedLibsDefinition TCling.h:113; TCling::fPendingRdictsstd::map< std::string, llvm::StringRef > fPendingRdictsDefinition TCling.h:634; TCling::UpdateClassInfoWorkstatic void UpdateClassInfoWork(const char *name)Definition TCling.cxx:6745; TCling::LoadInt_t Load(const char *filenam, Bool_t system=kFALSE) finalLoad a library file in cling's memory.Definition TCling.cxx:3515; TCling::TypedefInfo_Nextint TypedefInfo_Next(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9490; TCling::GetInterfaceMethodvoid * GetInterfaceMethod(TClass *cl, const char *method, const char *params, Bool_t objectIsConst=kFALSE) finalReturn pointer to cling interface function for a method of a class with parameters params (params is ...Definition TCling.cxx:5007; TCling::TypeInfo_Initvoid TypeInfo_Init(TypeInfo_t *tinfo, const char *funcname) const finalDefinition TCling.cxx:9371; TCling::SetSuspendAutoParsingBool_t SetSuspendAutoParsing(Bool_t value) finalSuspend the Autoparsing of headers.Definition TCling.cxx:7596; TCling::DataMemberInfo_TypeSizeint DataMemberInfo_TypeSize(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8674; TCling::fgSetOfSpecialsstatic void * fgSetOfSpecialsDefinition TCling.h:105; TCling::ClassInfo_Titleconst char * ClassInfo_Title(ClassInfo_t *info) const finalDefinition TCling.cxx:8442; TCling::DataMemberInfo_Nameconst char * DataMemberInfo_Name(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8698; TCling::TypeNameconst char * TypeName(const char *typeDesc) finalReturn the absolute type of typeDesc.Definition TCling.cxx:5478; TCling::fNormalized",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:65847,Integrability,interface,interface,65847," MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::SetAutoLoadCallBackvoid * SetAutoLoadCallBack(void *cb) finalDefinition TCling.h:199; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:67299,Integrability,message,messages,67299,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:67379,Integrability,message,messages,67379,"ssInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(TEnum *enumObj, TClass *cl) const finalDefinition TCling.cxx:421; TCling::ExecuteWithArgsAndReturnvoid ExecuteWithArgsAndReturn(TMethod *method, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:5385; TCling::IsErrorMessagesEnabledBool_t IsErrorMessagesEnabled() const finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7342; TCling::fIncludePathTString fIncludePathDefinition TCling.h:115; TCling::DisplayIncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTempor",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:72759,Integrability,interface,interface,72759,"st cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const finalCreate list of pointers to method arguments for TMethod m.Definition TCling.cxx:4523; TCling::Executevoid Execute(TMethod *, TObjArray *, int *=nullptr) finalExecute method on this object with parameters stored in the TObjArray.Definition TCling.h:628; TCling::GetSTLIncludePathvirtual const char * GetSTLIncludePath() const finalReturn the directory containing CINT's stl ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:83090,Integrability,interface,interface,83090,"haredLibsInt_t SetClassSharedLibs(const char *cls, const char *libs) finalRegister the AutoLoading information for a class.Definition TCling.cxx:6078; TCling::MethodInfo_FactoryCopyMethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9043; TCling::fParsedPayloadsAddressesstd::set< const char * > fParsedPayloadsAddressesDefinition TCling.h:123; TCling::CallFunc_IFacePtrCallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *func) const finalDefinition TCling.cxx:7958; TCling::GetExitCodeInt_t GetExitCode() const finalDefinition TCling.h:211; TCling::MethodArgInfo_FactoryMethodArgInfo_t * MethodArgInfo_Factory() const finalDefinition TCling.cxx:9248; TCling::SetProcessLineLockvoid SetProcessLineLock(Bool_t lock=kTRUE) finalDefinition TCling.h:320; TCling::UpdateClassInfostatic void UpdateClassInfo(char *name, Long_t tagnum)No op: see TClingCallbacks.Definition TCling.cxx:6739; TCling::GetFunctionDeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5029; TCling::ClassInfo_Deletevoid ClassInfo_Delete(ClassInfo_t *info) const finalDefinition TCling.cxx:8184; TCling::fInterpreterstd::unique_ptr< cling::Interpreter > fInterpreterDefinition TCling.h:130; TCling::ClassInfo_GetUnderlyingTypeEDataType ClassInfo_GetUnderlyingType(ClassInfo_t *info) const finalDefinition TCling.cxx:8311; TCling::FuncTempInfo_Deletevoid FuncTempInfo_Delete(FuncTempInfo_t *) const finalDelete the FuncTempInfo_t.Definition TCling.cxx:8806; TCling::GetFunctionTemplateDeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5177; TCling::operator=TCling & operator=(const TCling &)=delete; TCling::DeleteVariableInt_t DeleteVariable(const char *name) finalUndeclare obj called name.Definition TCling.cxx:3798; TCling::GetClassShared",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:83770,Integrability,interface,interface,83770,"TCling.cxx:9248; TCling::SetProcessLineLockvoid SetProcessLineLock(Bool_t lock=kTRUE) finalDefinition TCling.h:320; TCling::UpdateClassInfostatic void UpdateClassInfo(char *name, Long_t tagnum)No op: see TClingCallbacks.Definition TCling.cxx:6739; TCling::GetFunctionDeclId_t GetFunction(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5029; TCling::ClassInfo_Deletevoid ClassInfo_Delete(ClassInfo_t *info) const finalDefinition TCling.cxx:8184; TCling::fInterpreterstd::unique_ptr< cling::Interpreter > fInterpreterDefinition TCling.h:130; TCling::ClassInfo_GetUnderlyingTypeEDataType ClassInfo_GetUnderlyingType(ClassInfo_t *info) const finalDefinition TCling.cxx:8311; TCling::FuncTempInfo_Deletevoid FuncTempInfo_Delete(FuncTempInfo_t *) const finalDelete the FuncTempInfo_t.Definition TCling.cxx:8806; TCling::GetFunctionTemplateDeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) finalReturn pointer to cling interface function for a method of a class with a certain name.Definition TCling.cxx:5177; TCling::operator=TCling & operator=(const TCling &)=delete; TCling::DeleteVariableInt_t DeleteVariable(const char *name) finalUndeclare obj called name.Definition TCling.cxx:3798; TCling::GetClassSharedLibsconst char * GetClassSharedLibs(const char *cls, bool skipCore=true) finalGet the list of shared libraries containing the code for class cls.Definition TCling.cxx:7095; TCling::DataMemberInfo_OffsetLongptr_t DataMemberInfo_Offset(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8650; TCling::CallFunc_FactoryCallFunc_t * CallFunc_Factory() const finalDefinition TCling.cxx:7909; TCling::MethodInfo_FactoryMethodInfo_t * MethodInfo_Factory() const finalDefinition TCling.cxx:9018; TCling::DataMemberInfo_TypePropertyLong_t DataMemberInfo_TypeProperty(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8666; TCling::ClearFileBusyvoid ClearFileBusy() ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:86240,Integrability,rout,routine,86240,"a way to release a lock used to protect ...Definition TCling.cxx:7546; TCling::fLookedUpClassesstd::set< size_t > fLookedUpClassesDefinition TCling.h:121; TCling::TClingTCling(const TCling &)=delete; TCling::AddAvailableIndentifiersvirtual void AddAvailableIndentifiers(TSeqCollection &Idents) finalDefinition TCling.cxx:2358; TCling::TypedefInfo_Deletevoid TypedefInfo_Delete(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9442; TCling::Resetvoid Reset() finalPressing Ctrl+C should forward here.Definition TCling.cxx:3708; TCling::TypedefInfo_TrueNameconst char * TypedefInfo_TrueName(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9514; TCling::SetClassAutoLoadingint SetClassAutoLoading(int) const finalEnable/Disable the AutoLoading of libraries.Definition TCling.cxx:7567; TCling::ClassInfo_FullNameconst char * ClassInfo_FullName(ClassInfo_t *info) const finalDefinition TCling.cxx:8424; TCling::AutoParseImplRecurseUInt_t AutoParseImplRecurse(const char *cls, bool topLevel)Helper routine for TCling::AutoParse implementing the actual call to the parser and looping over temp...Definition TCling.cxx:6381; TCling::MethodInfo_TypeNameconst char * MethodInfo_TypeName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9147; TCling::CallFunc_SetArgvoid CallFunc_SetArg(CallFunc_t *func, Long_t param) const finalDefinition TCling.cxx:7974; TCling::GetIncludePathconst char * GetIncludePath() finalRefresh the list of include paths known to the interpreter and return it with -I prepended.Definition TCling.cxx:7370; TCling::UpdateListsOnUnloadedvoid UpdateListsOnUnloaded(const cling::Transaction &T)Invalidate stored TCling state for declarations included in transaction ‘T’.Definition TCling.cxx:6849; TCling::UpdateClassInfoWithDeclvoid UpdateClassInfoWithDecl(const clang::NamedDecl *ND)Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.Definition TCling.cxx:6681; TCling::IsSameTypebool IsSameType(const void *QualTypePtr1, const void *QualTypePtr",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:89326,Integrability,synchroniz,synchronize,89326,"nfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:8434; TCling::GenerateTClassTClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE) finalGenerate a TClass for the given class.Definition TCling.cxx:4554; TCling::fTransactionCountULong64_t fTransactionCountDefinition TCling.h:148; TCling::ClassInfo_HasDefaultConstructorbool ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalDefinition TCling.cxx:8253; TCling::EndOfLineActionvoid EndOfLineAction() finalIt calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line.Definition TCling.cxx:3121; TCling::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarke",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:91924,Integrability,interface,interface,91924," a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollect",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:92603,Integrability,interface,interface,92603,"brary.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunct",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:94353,Integrability,integrat,integration,94353," for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; clangDefinition BaseSelectionRule.h:29; llvmDefinition TString.h:847; ROOT::TVirtualRWMutex::StateDeltaState as returned by GetStateDelta() that can be passed to Restore()Definition TVirtualRWMutex.h:70; TCling::CharPtrCmp_tDefinition TCling.h:140; TCling::CharPtrCmp_t::operator()bool operator()(const char *a, const char *b) constDefinition TCling.h:141; TCling::MutexStateAndRecurseCountDeltaDefinition TCling.h:167; TCling::MutexStateAndRecurseCountDelta::fDeltastd::unique_ptr< StateDelta > fDeltaDefinition TCling.h:171; TCling::MutexStateAndRecurseCountDelta::fInitialStateMutexStateAndRecurseCount fInitialStateDefinition TCling.h:170; TCling::MutexStateAndRecurseCountDefinition TCling.h:155; TCling::MutexStateAndRecurseCount:",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:3086,Modifiability,variab,variables,3086,"#include <unordered_set>; 35#include <vector>; 36#include <string>; 37#include <utility>; 38 ; 39#ifndef WIN32; 40#define TWin32SendClass char; 41#endif; 42 ; 43namespace llvm {; 44 class GlobalValue;; 45 class StringRef;; 46}; 47 ; 48namespace clang {; 49 class CXXRecordDecl;; 50 class Decl;; 51 class DeclContext;; 52 class EnumDecl;; 53 class FunctionDecl;; 54 class IdentifierIterator;; 55 class NamedDecl;; 56 class NamespaceDecl;; 57 class TagDecl;; 58 class Type;; 59 class QualType;; 60}; 61namespace cling {; 62 class Interpreter;; 63 class MetaProcessor;; 64 class Transaction;; 65 class Value;; 66}; 67 ; 68class TClingCallbacks;; 69class TEnv;; 70class TFile;; 71class THashTable;; 72class TInterpreterValue;; 73class TMethod;; 74class TObjArray;; 75class TListOfDataMembers;; 76class TListOfFunctions;; 77class TListOfFunctionTemplates;; 78class TListOfEnums;; 79 ; 80namespace ROOT {; 81 namespace TMetaUtils {; 82 class TNormalizedCtxt;; 83 class TClingLookupHelper;; 84 }; 85}; 86 ; 87extern ""C"" {; 88 void TCling__UpdateListsOnCommitted(const cling::Transaction&,; 89 cling::Interpreter*);; 90 void TCling__UpdateListsOnUnloaded(const cling::Transaction&);; 91 void TCling__InvalidateGlobal(const clang::Decl*);; 92 void TCling__TransactionRollback(const cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:61887,Modifiability,variab,variable,61887,"ctoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::string &output, Bool_t full=kFALSE) finalThe 'name' is known to the interpreter, this function returns the internal version of this name (usua...Definition TCling.cxx:5200; TCling::fGlobalsListSerialInt_t fGlobalsListSerialDefinition TCling.h:114; TCling::IsAutoParsingSuspendedBool_t IsAutoParsingSuspended() const finalDefinition TCling.h:353; TCling::fSharedL",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:80117,Modifiability,variab,variables,80117,"d::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TString &name) const finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlo",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:80478,Modifiability,variab,variables,80478," finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelM",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:87875,Modifiability,variab,variable,87875,"ed(const cling::Transaction &T)Invalidate stored TCling state for declarations included in transaction ‘T’.Definition TCling.cxx:6849; TCling::UpdateClassInfoWithDeclvoid UpdateClassInfoWithDecl(const clang::NamedDecl *ND)Internal function. Inform a TClass about its new TagDecl or NamespaceDecl.Definition TCling.cxx:6681; TCling::IsSameTypebool IsSameType(const void *QualTypePtr1, const void *QualTypePtr2) constDefinition TCling.cxx:9538; TCling::IsProcessLineLockedBool_t IsProcessLineLocked() const finalDefinition TCling.h:317; TCling::Initializevirtual void Initialize() finalInitialize the interpreter, once TROOT::fInterpreter is set.Definition TCling.cxx:1636; TCling::ClassInfo_GetMethodNArgint ClassInfo_GetMethodNArg(ClassInfo_t *info, const char *method, const char *proto, Bool_t objectIsConst=false, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8245; TCling::GetDataMemberDeclId_t GetDataMember(ClassInfo_t *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4771; TCling::fAutoLoadCallBackvoid * fAutoLoadCallBackDefinition TCling.h:147; TCling::FuncTempInfo_Namevoid FuncTempInfo_Name(FuncTempInfo_t *, TString &name) const finalReturn the name of this function template.Definition TCling.cxx:8957; TCling::fMetaProcessorstd::unique_ptr< cling::MetaProcessor > fMetaProcessorDefinition TCling.h:131; TCling::TypeInfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:843",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:92121,Modifiability,config,config,92121,"har *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TList",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:3482,Performance,load,loaded,3482,"t cling::Transaction&);; 93 TObject* TCling__GetObjectAddress(const char *Name, void *&LookupCtx);; 94 const clang::Decl* TCling__GetObjectDecl(TObject *obj);; 95 void TCling__LibraryLoaded(const void* dyLibHandle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unord",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:3687,Performance,load,load,3687,"ndle,; 96 const char* canonicalName);; 97 void TCling__LibraryUnloaded(const void* dyLibHandle,; 98 const char* canonicalName);; 99 void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 100}; 101 ; 102class TCling final : public TInterpreter {; 103private: // Static Data Members; 104 ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:5289,Performance,load,loaded,5289,"s were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 153 std::map<SpecialObjectLookupCtx_t, SpecialObjectMap_t> fSpecialObjectMaps;; 154 ; 155 struct MutexStateAndRecurseCount {; 156 /// State of gCoreMutex when the first interpret",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:8577,Performance,load,load,8577,"nst char* const argv[], void *interpLibHandle);; 196 ; 197 void AddIncludePath(const char* path) final;; 198 void *GetAutoLoadCallBack() const final { return fAutoLoadCallBack; }; 199 void *SetAutoLoadCallBack(void* cb) final { void* prev = fAutoLoadCallBack; fAutoLoadCallBack = cb; return prev; }; 200 Int_t AutoLoad(const char *classname, Bool_t knowDictNotLoaded = kFALSE) final;; 201 Int_t AutoLoad(const std::type_info& typeinfo, Bool_t knowDictNotLoaded = kFALSE) final;; 202 Int_t AutoParse(const char* cls) final;; 203 void* LazyFunctionCreatorAutoload(const std::string& mangled_name);; 204 bool LibraryLoadingFailed(const std::string&, const std::string&, bool, bool);; 205 Bool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl* nsDecl);; 206 void ClearFileBusy() final;; 207 void ClearStack() final; // Delete existing temporary values; 208 Bool_t Declare(const char* code) final;; 209 void EndOfLineAction() final;; 210 TClass *GetClass(const std::type_info& typeinfo, Bool_t load) const final;; 211 Int_t GetExitCode() const final { return fExitCode; }; 212 TEnv* GetMapfile() const final { return fMapfile; }; 213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void In",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:45383,Performance,cache,cached,45383,"nfo_TypeTypeInfo_t * MethodInfo_Type(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9109; TCling::fAutoLoadLibStoragestd::vector< std::string > fAutoLoadLibStorageDefinition TCling.h:118; TCling::CallFunc_Deletevoid CallFunc_Delete(CallFunc_t *func) const finalDefinition TCling.cxx:7843; TCling::fLockProcessLineBool_t fLockProcessLineDefinition TCling.h:127; TCling::LoadFileint LoadFile(const char *path) const finalLoad a source file or library called path into the interpreter.Definition TCling.cxx:7500; TCling::ResetAllvoid ResetAll() finalReset the Cling state to its initial state.Definition TCling.cxx:3724; TCling::SetDeclAttrvoid SetDeclAttr(DeclId_t, const char *) finalDefinition TCling.cxx:8725; TCling::HandleNewDeclvoid HandleNewDecl(const void *DV, bool isDeserialized, std::set< TClass * > &modifiedClasses)Definition TCling.cxx:496; TCling::InvalidateCachedDeclvoid InvalidateCachedDecl(const std::tuple< TListOfDataMembers *, TListOfFunctions *, TListOfFunctionTemplates *, TListOfEnums * > &Lists, const clang::Decl *D)Invalidate cached TCling information for the given declaration, and removed it from the appropriate o...Definition TCling.cxx:6891; TCling::MethodInfo_PropertyLong_t MethodInfo_Property(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9091; TCling::LoadFunctionTemplatesvirtual void LoadFunctionTemplates(TClass *cl) const finalCreate list of pointers to function templates for TClass cl.Definition TCling.cxx:4442; TCling::ClassInfo_IsValidMethodbool ClassInfo_IsValidMethod(ClassInfo_t *info, const char *method, const char *proto, Longptr_t *offset, ROOT::EFunctionMatchMode=ROOT::kConversionMatch) const finalDefinition TCling.cxx:8336; TCling::DataMemberInfo_PropertyLong_t DataMemberInfo_Property(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8658; TCling::SetClassAutoparsingint SetClassAutoparsing(int) finalEnable/Disable the Autoparsing of headers.Definition TCling.cxx:7585; TCling::fCurExecutingMacrosstd::vector< const cha",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:49051,Performance,cache,cached,49051,"fo) const finalDefinition TCling.cxx:9188; TCling::GetObjectAddressTObject * GetObjectAddress(const char *Name, void *&LookupCtx)If the interpreter encounters Name, check whether that is an object ROOT could retrieve.Definition TCling.cxx:7714; TCling::ProcessLineAsynchLongptr_t ProcessLineAsynch(const char *line, EErrorCode *error=nullptr)Let cling process a command line asynch.Definition TCling.cxx:3560; TCling::MethodInfo_IsValidbool MethodInfo_IsValid(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9059; TCling::TClingTCling(); TCling::FuncTempInfo_FactoryFuncTempInfo_t * FuncTempInfo_Factory(DeclId_t declid) const finalConstruct a FuncTempInfo_t.Definition TCling.cxx:8815; TCling::TypeInfo_FactoryTypeInfo_t * TypeInfo_Factory() const finalDefinition TCling.cxx:9348; TCling::IsClassAutoLoadingEnabledbool IsClassAutoLoadingEnabled() constReturns if class AutoLoading is currently enabled.Definition TCling.cxx:7554; TCling::InvalidateGlobalvoid InvalidateGlobal(const clang::Decl *D)Invalidate cached TCling information for the given global declaration.Definition TCling.cxx:6876; TCling::Evaluateint Evaluate(const char *, TInterpreterValue &) finalGet the interpreter value corresponding to the statement.Definition TCling.cxx:7678; TCling::MakeInterpreterValuestd::unique_ptr< TInterpreterValue > MakeInterpreterValue() const finalDefinition TCling.cxx:7663; TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resou",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:50434,Performance,load,load,50434,"TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:66",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:52054,Performance,load,loaded,52054,"stead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseClassInfo_Next(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8492; TCling::RefreshClassInfovoid RefreshClassInfo(TClass *cl, const clang::NamedDecl *def, bool alias)Internal function. Actually do the update of the ClassInfo when seeing.Definition TCling.cxx:6635; TCling::CallFunc_FactoryCopyCallFunc_t * CallFunc_FactoryCopy(CallFunc_t *func) const finalDefinition TCling.cxx:7917; TCling::CallFunc_ExecDoubleDouble_t CallFunc_ExecDouble(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7901; TCling::CallFunc_ResetArgvoid CallFunc_ResetArg(CallFunc_t *func) const finalDefinition TCling.cxx:7966; TCling::GetCurrentMacroNameconst char * GetCurrentMacroName() const finalReturn the file name of the currently interpreted file, included or not.Definition TCling.cxx:5463; TCling::IsLoadedBool_t IsLoaded(const char *filename) const finalReturn true if the file has already been loaded by cint.Definition TCling.cxx:3172; TCling::SaveGlobalsContextvoid SaveGlobalsContext() finalSave the current Cling state of global objects.Definition TCling.cxx:3872; TCling::CallFunc_IgnoreExtraArgsvoid CallFunc_IgnoreExtraArgs(CallFunc_t *func, bool ignore) const finalDefinition TCling.cxx:7932; TCling::fExitCodeInt_t fExitCodeDefinition TCling.h:109; TCling::ApplyToInterpreterMutexvoid ApplyToInterpreterMutex(void *delta)Re-apply the lock count delta that TCling__ResetInterpreterMutex() caused.Definition TCling.cxx:9634; TCling::LazyFunctionCreatorAutoloadvoid * LazyFunctionCreatorAutoload(const std::string &mangled_name)Autoload a library based on a missing symbol.Definition TCling.cxx:6591; TCling::GenerateDictionaryInt_t GenerateDictionary(const char *classes, const char *includes="""", const char *options=nullptr) finalGenerate the dictionary for the C++ classes listed in the first argument (in a semi-colon separated l...De",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:61506,Performance,load,loaded,61506,"nal[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::s",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:61582,Performance,load,load,61582,"nal[Place holder for Mutex Lock] Provide the interpreter with a way to acquire a lock used to protect cr...Definition TCling.cxx:7536; TCling::SetErrorMessagesBool_t SetErrorMessages(Bool_t enable=kTRUE) finalIf error messages are disabled, the interpreter should suppress its failures and warning messages fro...Definition TCling.cxx:7356; TCling::CallFunc_FactoryMethodMethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *func) const finalDefinition TCling.cxx:7924; TCling::IsUnsignedIntegerTypebool IsUnsignedIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9563; TCling::TypedefInfo_FactoryCopyTypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9465; TCling::GetFunctionOverloadsvoid GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const finalInsert overloads of name in cl to res.Definition TCling.cxx:5048; TCling::UnRegisterTClassUpdatevoid UnRegisterTClassUpdate(const TClass *oldcl) finalIf the dictionary is loaded, we can remove the class from the list (otherwise the class might be load...Definition TCling.cxx:2393; TCling::MethodArgInfo_TypeNormalizedNamestd::string MethodArgInfo_TypeNormalizedName(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9320; TCling::GetEnumDeclId_t GetEnum(TClass *cl, const char *name) const finalReturn pointer to cling Decl of global/static variable that is located at the address given by addr.Definition TCling.cxx:4832; TCling::MethodArgInfo_PropertyLong_t MethodArgInfo_Property(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9288; TCling::TypedefInfo_Sizeint TypedefInfo_Size(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9506; TCling::CallFunc_ExecWithArgsAndReturnvoid CallFunc_ExecWithArgsAndReturn(CallFunc_t *func, void *address, const void *args[]=nullptr, int nargs=0, void *ret=nullptr) const finalDefinition TCling.cxx:7874; TCling::GetInterpreterTypeNamevoid GetInterpreterTypeName(const char *name, std::s",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:65740,Performance,load,load,65740," MethodInfo_Next(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9083; TCling::SetAutoLoadCallBackvoid * SetAutoLoadCallBack(void *cb) finalDefinition TCling.h:199; TCling::ClassInfo_ClassPropertyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:66014,Performance,load,loaded,66014,"tyLong_t ClassInfo_ClassProperty(ClassInfo_t *info) const finalDefinition TCling.cxx:8176; TCling::MethodInfo_Deletevoid MethodInfo_Delete(MethodInfo_t *minfo) const finalInterface to cling function.Definition TCling.cxx:9002; TCling::fIsShuttingDownbool fIsShuttingDownDefinition TCling.h:187; TCling::MethodArgInfo_Deletevoid MethodArgInfo_Delete(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9241; TCling::DataMemberInfo_FactoryDataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t *clinfo, TDictionary::EMemberSelection selection) const finalDefinition TCling.cxx:8599; TCling::ClassInfo_Destructvoid ClassInfo_Destruct(ClassInfo_t *info, void *arena) const finalDefinition TCling.cxx:8207; TCling::GetClassTClass * GetClass(const std::type_info &typeinfo, Bool_t load) const finalDemangle the name (from the typeinfo) and then request the class via the usual name based interface (...Definition TCling.cxx:6110; TCling::UnloadAllSharedLibraryMapsInt_t UnloadAllSharedLibraryMaps() finalUnload the library map entries coming from all the loaded shared libraries.Definition TCling.cxx:5998; TCling::ClassInfo_Initvoid ClassInfo_Init(ClassInfo_t *info, const char *funcname) const finalDefinition TCling.cxx:8269; TCling::GetModTClassesstd::set< TClass * > & GetModTClasses()Definition TCling.h:579; TCling::BaseClassInfo_ClassInfoClassInfo_t * BaseClassInfo_ClassInfo(BaseClassInfo_t *) const finalDefinition TCling.cxx:8537; TCling::fClingCallbacksTClingCallbacks * fClingCallbacksDefinition TCling.h:139; TCling::CallFunc_ExecInt64Long64_t CallFunc_ExecInt64(CallFunc_t *func, void *address) const finalDefinition TCling.cxx:7893; TCling::ClassInfo_PropertyLong_t ClassInfo_Property(ClassInfo_t *info) const finalDefinition TCling.cxx:8392; TCling::ClassInfo_GetBaseOffsetLongptr_t ClassInfo_GetBaseOffset(ClassInfo_t *fromDerived, ClassInfo_t *toBase, void *address, bool isDerivedObject) const finalDefinition TCling.cxx:8516; TCling::UpdateEnumConstantsvoid UpdateEnumConstants(T",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:68539,Performance,load,loaded,68539,"IncludePathint DisplayIncludePath(FILE *fout) const finalInterface to cling function.Definition TCling.cxx:7419; TCling::TransactionRollbackvoid TransactionRollback(const cling::Transaction &T)Definition TCling.cxx:6951; TCling::FuncTempInfo_PropertyLong_t FuncTempInfo_Property(FuncTempInfo_t *) const finalReturn the property of the function template.Definition TCling.cxx:8870; TCling::CreateEnumTEnum * CreateEnum(void *VD, TClass *cl) const finalDefinition TCling.cxx:469; TCling::TypeInfo_TrueNameconst char * TypeInfo_TrueName(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9420; TCling::UnloadLibraryMapInt_t UnloadLibraryMap(const char *library) finalUnload library map entries coming from the specified library.Definition TCling.cxx:6016; TCling::RegisterTemporaryvoid RegisterTemporary(const TInterpreterValue &value)Definition TCling.cxx:7687; TCling::fInitialMutexMutexStateAndRecurseCount fInitialMutexDefinition TCling.h:174; TCling::GetSharedLibsconst char * GetSharedLibs() finalReturn the list of shared libraries loaded into the process.Definition TCling.cxx:6989; TCling::MethodArgInfo_Nextint MethodArgInfo_Next(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9280; TCling::SnapshotMutexStatevoid SnapshotMutexState(ROOT::TVirtualRWMutex *mtx) finalDefinition TCling.cxx:9603; TCling::TypeInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::kNullArgvstatic constexpr const char * kNullArgv[]Definition TCling.h:185; TCling::TCling__RegisterRdictForLoadPCMfriend void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Definition TCling.cxx:588; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template describ",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:70016,Performance,load,load,70016,"eInfo_PropertyLong_t TypeInfo_Property(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9396; TCling::kNullArgvstatic constexpr const char * kNullArgv[]Definition TCling.h:185; TCling::TCling__RegisterRdictForLoadPCMfriend void TCling__RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Definition TCling.cxx:588; TCling::MethodInfo_GetPrototypeconst char * MethodInfo_GetPrototype(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9129; TCling::FuncTempInfo_TemplateMinReqArgsUInt_t FuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t *) const finalReturn the number of required template arguments of the function template described by ft_info.Definition TCling.cxx:8860; TCling::fTemporariesstd::vector< cling::Value > * fTemporariesDefinition TCling.h:133; TCling::RegisterModulevoid RegisterModule(const char *modulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) finalInject the module named ""modulename"" into cling; load all headers.Definition TCling.cxx:2010; TCling::ShallowAutoLoadImplstatic Int_t ShallowAutoLoadImpl(const char *cls)Definition TCling.cxx:6156; TCling::MethodInfo_CreateSignaturevoid MethodInfo_CreateSignature(MethodInfo_t *minfo, TString &signature) const finalDefinition TCling.cxx:9009; TCling::CheckClassTemplateBool_t CheckClassTemplate(const char *name) finalReturn true if there is a class template by the given name ...Definition TCling.cxx:4349; TCling::LibraryLoadedvoid LibraryLoaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6974; TCling::RegisterTClassUpdatevoid RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict) finalRegister classes that already existed prior to their dictionary loading and that already had a ClassI...Definition TCling.cxx:2384; TCling::",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:70753,Performance,load,loading,70753,"ulename, const char **headers, const char **includePaths, const char *payloadCode, const char *fwdDeclsCode, void(*triggerFunc)(), const FwdDeclArgsToKeepCollection_t &fwdDeclsArgToSkip, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false) finalInject the module named ""modulename"" into cling; load all headers.Definition TCling.cxx:2010; TCling::ShallowAutoLoadImplstatic Int_t ShallowAutoLoadImpl(const char *cls)Definition TCling.cxx:6156; TCling::MethodInfo_CreateSignaturevoid MethodInfo_CreateSignature(MethodInfo_t *minfo, TString &signature) const finalDefinition TCling.cxx:9009; TCling::CheckClassTemplateBool_t CheckClassTemplate(const char *name) finalReturn true if there is a class template by the given name ...Definition TCling.cxx:4349; TCling::LibraryLoadedvoid LibraryLoaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6974; TCling::RegisterTClassUpdatevoid RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict) finalRegister classes that already existed prior to their dictionary loading and that already had a ClassI...Definition TCling.cxx:2384; TCling::GetRootMapFilesTObjArray * GetRootMapFiles() const finalDefinition TCling.h:223; TCling::DataMemberInfo_IsValidbool DataMemberInfo_IsValid(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8626; TCling::ClassInfo_IsEnumbool ClassInfo_IsEnum(const char *name) const finalDefinition TCling.cxx:8295; TCling::MethodInfo_NDefaultArgint MethodInfo_NDefaultArg(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9075; TCling::CreateListOfMethodsvoid CreateListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::SpecialObjectLookupCtx_tvoid * SpecialObjectLookupCtx_tDefinition TCling.h:151; TCling::fTransactionHeadersMapstd::map< const cling::Transacti",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:79828,Performance,load,load,79828,"rty(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8529; TCling::CallFunc_SetFuncvoid CallFunc_SetFunc(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *params, Longptr_t *Offset) const finalDefinition TCling.cxx:8038; TCling::GetUsingNamespacesstd::vector< std::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TString &name) const finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:80971,Performance,load,loaded,80971,"eCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g.Definition TCling.cxx:3585; TCling::ReloadAllSharedLibraryMapsInt_t ReloadAllSharedLibraryMaps() finalReload the library map entries coming from all the loaded shared libraries, after first unloading the...Definition TCling.cxx:5937; TCling::UpdateListOfGlobalFunctionsvoid UpdateListOfGlobalFunctions() finalNo op: see TClingCallbacks (used to update the list of global functions)Definition TCling.cxx:3892; TCling::DataMemberInfo_Deletevoid DataMemberInfo_Delete(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8592; TCling::fPromptchar fPrompt[64]Definition TCling.h:110; TCling::GetTopLevelMacroNameconst char * GetTopLevelMacroName() const finalReturn the file name of the current un-included interpreted file.Definition TCling.cxx:5416; TCling::fPrevLoadedDynLibInfovoid * fPrevLoadedDynLibInfoDefinition TCling.h:137; TCling::UpdateListOfDataMembersvoid UpdateListOfDataMembers(TClass *cl) constUpdate the list of pointers to data members for TClass cl This is now a nop.Definition TCling.cxx:4516; TCling::InspectMembersvoid InspectMembers(TMemberInspector &, const void *obj, const TClass *c",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:90767,Performance,load,loading,90767,"t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; TCling::ShutDownvirtual void ShutDown() finalDefinition TCling.cxx:1655; TCling::GetInterpreterStateMarkerunsigned long long GetInterpreterStateMarker() const finalDefinition TCling.h:224; TCling::UpdateListOfTypesvoid UpdateListOfTypes() finalNo op: see TClingCallbacks (used to update the list of types)Definition TCling.cxx:3899; TCling::TypedefInfo_PropertyLong_t TypedefInfo_Property(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9498; TCling::RegisterRdictForLoadPCMvoid RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent)Register Rdict data for future loading by LoadPCM;.Definition TCling.cxx:1678; TCling::ProcessLineSynchLongptr_t ProcessLineSynch(const char *line, EErrorCode *error=nullptr) finalLet cling process a command line synchronously, i.e we are waiting it will be finished.Definition TCling.cxx:3569; TCling::GetMangledNameWithPrototypeTString GetMangledNameWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn the cling mangled name for a method of a class with a certain prototype, i....Definition TCling.cxx:4989; TCling::UpdateAllCanvasesstatic void UpdateAllCanvases()Update all canvases at end the terminal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnu",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:5104,Safety,avoid,avoid,5104,"ling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 1",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:3984,Security,hash,hashes,3984," ; 105 static void* fgSetOfSpecials; // set of TObjects used in CINT variables; 106 ; 107private: // Data Members; 108 ; 109 Int_t fExitCode; // Value passed to exit() in interpreter.; 110 char fPrompt[64]; // Command line prompt string.; 111 //cling::DictPosition fDictPos; // dictionary context after initialization is complete.; 112 //cling::DictPosition fDictPosGlobals; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of te",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:4388,Security,hash,hash,4388,"als; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently runn",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:4439,Security,hash,hashing,4439,"als; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently runn",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:34416,Security,hash,hash,34416,"xxxInfo_t' to nullptr.; 593 if (O && O->IsValid()); 594 L.Unload(O), O->Update(nullptr);; 595 }; 596 ; 597 void InvalidateCachedDecl(const std::tuple<TListOfDataMembers*,; 598 TListOfFunctions*,; 599 TListOfFunctionTemplates*,; 600 TListOfEnums*> &Lists, const clang::Decl *D);; 601 ; 602 class SuspendAutoLoadingRAII {; 603 TCling *fTCling = nullptr;; 604 bool fOldValue;; 605 ; 606 public:; 607 SuspendAutoLoadingRAII(TCling *tcling) : fTCling(tcling) { fOldValue = fTCling->SetClassAutoLoading(false); }; 608 ~SuspendAutoLoadingRAII() { fTCling->SetClassAutoLoading(fOldValue); }; 609 };; 610 ; 611 class TUniqueString {; 612 public:; 613 TUniqueString() = delete;; 614 TUniqueString(const TUniqueString &) = delete;; 615 TUniqueString(Long64_t size);; 616 const char *Data();; 617 bool Append(const std::string &str);; 618 private:; 619 std::string fContent;; 620 std::set<size_t> fLinesHashSet;; 621 std::hash<std::string> fHashFunc;; 622 };; 623 ; 624 TCling();; 625 TCling(const TCling&) = delete;; 626 TCling& operator=(const TCling&) = delete;; 627 ; 628 void Execute(TMethod*, TObjArray*, int* /*error*/ = nullptr) final {}; 629 ; 630 void UpdateListOfLoadedSharedLibraries();; 631 void RegisterLoadedSharedLibrary(const char* name);; 632 void AddFriendToClass(clang::FunctionDecl*, clang::CXXRecordDecl*) const;; 633 ; 634 std::map<std::string, llvm::StringRef> fPendingRdicts;; 635 void RegisterRdictForLoadPCM(const std::string &pcmFileNameFullPath, llvm::StringRef *pcmContent);; 636 void LoadPCM(std::string pcmFileNameFullPath);; 637 void LoadPCMImpl(TFile &pcmFile);; 638 ; 639 void InitRootmapFile(const char *name);; 640 int ReadRootmapFile(const char *rootmapfile, TUniqueString* uniqueString = nullptr);; 641 Bool_t HandleNewTransaction(const cling::Transaction &T);; 642 bool IsClassAutoLoadingEnabled() const;; 643 void ProcessClassesToUpdate();; 644 cling::Interpreter *GetInterpreterImpl() const { return fInterpreter.get(); }; 645 cling::MetaProcessor *GetMetaProcessorImpl()",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:41849,Security,hash,hash,41849,"lass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClingCallbacksDefinition TClingCallbacks.h:41; TCling::SuspendAutoLoadingRAIIDefinition TCling.h:602; TCling::SuspendAutoLoadingRAII::~SuspendAutoLoadingRAII~SuspendAutoLoadingRAII()Definition TCling.h:608; TCling::SuspendAutoLoadingRAII::fTClingTCling * fTClingDefinition TCling.h:603; TCling::SuspendAutoLoadingRAII::fOldValuebool fOldValueDefinition TCling.h:604; TCling::SuspendAutoLoadingRAII::SuspendAutoLoadingRAIISuspendAutoLoadingRAII(TCling *tcling)Definition TCling.h:607; TCling::TUniqueStringDefinition TCling.h:611; TCling::TUniqueString::TUniqueStringTUniqueString(const TUniqueString &)=delete; TCling::TUniqueString::Dataconst char * Data()Definition TCling.cxx:1006; TCling::TUniqueString::Appendbool Append(const std::string &str)Append string to the storage if not added already.Definition TCling.cxx:1014; TCling::TUniqueString::TUniqueStringTUniqueString()=delete; TCling::TUniqueString::fHashFuncstd::hash< std::string > fHashFuncDefinition TCling.h:621; TCling::TUniqueString::fLinesHashSetstd::set< size_t > fLinesHashSetDefinition TCling.h:620; TCling::TUniqueString::fContentstd::string fContentDefinition TCling.h:619; TClingThis class defines an interface to the cling C++ interpreter.Definition TCling.h:102; TCling::DeepAutoLoadImplstatic Int_t DeepAutoLoadImpl(const char *cls, std::unordered_set< std::string > &visited, bool nameIsNormalized)Definition TCling.cxx:6204; TCling::MethodArgInfo_DefaultValueconst char * MethodArgInfo_DefaultValue(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9296; TCling::ClassInfo_IsScopedEnumbool ClassInfo_IsScopedEnum(ClassInfo_t *info) const finalDefinition TCling.cxx:8302; TCling::TypeInfo_Nameconst char * TypeInfo_Name(TypeInfo_t *) const finalDefinition TCling.cxx:9388; TCling::MethodInfo_InterfaceMethodvoid * MethodInfo_InterfaceMethod(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9050; TClin",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:55069,Security,access,accessed,55069,"action &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * Ty",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:72283,Security,hash,hash,72283,"eListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::SpecialObjectLookupCtx_tvoid * SpecialObjectLookupCtx_tDefinition TCling.h:151; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:92450,Security,hash,hash,92450,"inal input command.Definition TCling.cxx:6754; TCling::LoadLibraryMapInt_t LoadLibraryMap(const char *rootmapfile=nullptr) finalLoad map between class and library.Definition TCling.cxx:5741; TCling::BaseClassInfo_TagnumLongptr_t BaseClassInfo_Tagnum(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8545; TCling::LibraryUnloadedvoid LibraryUnloaded(const void *dyLibHandle, const char *canonicalName)Definition TCling.cxx:6981; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TEnumThe TEnum class implements the enum type.Definition TEnum.h:33; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplates",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:93189,Security,access,access,93189,"v.h:124; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string c",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:93335,Security,access,access,93335,"l functions class (global functions are obtained from CINT).Definition TFunction.h:30; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenu",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:93497,Security,access,access,93497,"efinition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:93659,Security,access,access,93659,"ter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; clangDefinition BaseSelectionRule.h:29; llvmDefinition TS",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:93785,Security,access,accessing,93785,"kClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; clangDefinition BaseSelectionRule.h:29; llvmDefinition TString.h:847; ROOT::TVirtualRWMutex::StateDeltaState as returned by GetStateDelta() that can be passed to Restore()Definition TVirtualR",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:22524,Testability,test,testio,22524,"erty(ClassInfo_t* info) const final;; 414 void ClassInfo_Delete(ClassInfo_t* info) const final;; 415 void ClassInfo_Delete(ClassInfo_t* info, void* arena) const final;; 416 void ClassInfo_DeleteArray(ClassInfo_t* info, void* arena, bool dtorOnly) const final;; 417 void ClassInfo_Destruct(ClassInfo_t* info, void* arena) const final;; 418 ClassInfo_t* ClassInfo_Factory(Bool_t all = kTRUE) const final;; 419 ClassInfo_t* ClassInfo_Factory(ClassInfo_t* cl) const final;; 420 ClassInfo_t* ClassInfo_Factory(const char* name) const final;; 421 ClassInfo_t* ClassInfo_Factory(DeclId_t declid) const final;; 422 Longptr_t ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const final;; 423 int ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst = false, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const final;; 424 bool ClassInfo_HasDefaultConstructor(ClassInfo_t* info, Bool_t testio = kFALSE) const final;; 425 bool ClassInfo_HasMethod(ClassInfo_t* info, const char* name) const final;; 426 void ClassInfo_Init(ClassInfo_t* info, const char* funcname) const final;; 427 void ClassInfo_Init(ClassInfo_t* info, int tagnum) const final;; 428 bool ClassInfo_IsBase(ClassInfo_t* info, const char* name) const final;; 429 bool ClassInfo_IsEnum(const char* name) const final;; 430 bool ClassInfo_IsScopedEnum(ClassInfo_t* info) const final;; 431 EDataType ClassInfo_GetUnderlyingType(ClassInfo_t* info) const final;; 432 bool ClassInfo_IsLoaded(ClassInfo_t* info) const final;; 433 bool ClassInfo_IsValid(ClassInfo_t* info) const final;; 434 bool ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Longptr_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const final;; 435 bool ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst, Longptr_t* offset, ROOT::EFunctionMatchMode /* mod",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:89191,Testability,test,testio,89191,"mplate.Definition TCling.cxx:8957; TCling::fMetaProcessorstd::unique_ptr< cling::MetaProcessor > fMetaProcessorDefinition TCling.h:131; TCling::TypeInfo_IsValidbool TypeInfo_IsValid(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9380; TCling::RegisterPrebuiltModulePathbool RegisterPrebuiltModulePath(const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const finalDefinition TCling.cxx:1906; TCling::MethodInfo_TypeNormalizedNamestd::string MethodInfo_TypeNormalizedName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9156; TCling::ClassInfo_Nameconst char * ClassInfo_Name(ClassInfo_t *info) const finalDefinition TCling.cxx:8434; TCling::GenerateTClassTClass * GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent=kFALSE) finalGenerate a TClass for the given class.Definition TCling.cxx:4554; TCling::fTransactionCountULong64_t fTransactionCountDefinition TCling.h:148; TCling::ClassInfo_HasDefaultConstructorbool ClassInfo_HasDefaultConstructor(ClassInfo_t *info, Bool_t testio=kFALSE) const finalDefinition TCling.cxx:8253; TCling::EndOfLineActionvoid EndOfLineAction() finalIt calls a ""fantom"" method to synchronize user keyboard input and ROOT prompt line.Definition TCling.cxx:3121; TCling::TypeInfo_FactoryCopyTypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) const finalDefinition TCling.cxx:9364; TCling::TypeInfo_QualTypePtrvoid * TypeInfo_QualTypePtr(TypeInfo_t *tinfo) constDefinition TCling.cxx:9428; TCling::ClassInfo_HasMethodbool ClassInfo_HasMethod(ClassInfo_t *info, const char *name) const finalDefinition TCling.cxx:8261; TCling::ClassInfo_DeleteArrayvoid ClassInfo_DeleteArray(ClassInfo_t *info, void *arena, bool dtorOnly) const finalDefinition TCling.cxx:8199; TCling::fClassesHeadersMapstd::map< size_t, std::vector< const char * > > fClassesHeadersMapDefinition TCling.h:119; TCling::DataMemberInfo_TypeTrueNameconst char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *dminfo) const finalDefinition TCling.cxx:8690; T",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/TCling_8h_source.html:4432,Usability,simpl,simple,4432,"als; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently runn",MatchSource.WIKI,doc/master/TCling_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html
https://root.cern/doc/master/tcl_8C.html:251,Testability,test,tests,251,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
https://root.cern/doc/master/tcl_8C.html:280,Testability,test,tests,280,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
https://root.cern/doc/master/tcl_8C.html:450,Testability,test,tests,450,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
https://root.cern/doc/master/tcl_8C.html:931,Testability,test,test,931,". ROOT: tutorials/tree/tcl.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tcl.C File ReferenceTutorials » Tree tutorials. Detailed Description; How to write a TClonesArray to a TTree ; The following tests can be run Interactive tests Root > .x tcl.C //no-split interpreted; Root > .x tcl.C(1) //split interpreted; Root > .x tcl.C++ //no-split compiled; Root > .x tcl.C++(1) //split compiled; Batch tests: same as above but with no graphics root -b -q tcl.C; root -b -q tcl.C++; root -b -q ""tcl.C(1)""; root -b -q ""tcl.C++(1)""; ; #include ""TFile.h""; #include ""TClonesArray.h""; #include ""TH2.h""; #include ""TLine.h""; #include ""TTree.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; ; void tclwrite(Int_t split); {; // Generate a Tree with a TClonesArray; // The array can be split or not; TFile f(""tcl.root"",""recreate"");; f.SetCompressionLevel(1); //try level 2 also; TTree T(""T"",""test tcl"");; TClonesArray *arr = new TClonesArray(""TLine"");; TClonesArray &ar = *arr;; T.Branch(""tcl"",&arr,256000,split);; //By default a TClonesArray is created with its BypassStreamer bit set.; //However, because TLine has a custom Streamer, this bit was reset; //by TTree::Branch above. We set again this bit because the current; //version of TLine uses the automatic Streamer.; //BypassingStreamer saves space and time.; arr->BypassStreamer();; for (Int_t ev=0;ev<10000;ev++) {; ar.Clear();; Int_t nlines = Int_t(gRandom->Gaus(50,10));; if(nlines < 0) nlines = 1;; for (Int_t i=0;i<nlines;i++) {; Float_t x1 = gRandom->Rndm();; Float_t y1 = gRandom->Rndm();; Float_t x2 = gRandom->Rndm();; Float_t y2 = gRandom->Rndm();; new(ar[i]) TLine(x1,y1,x2,y2);; }; T.Fill();; }; T.Print();; T.Write();; }; ; void tclread(); {; // read file generated by tclwrite; // loop on all entries.; // histogram center of lines; TFile *f = new TFile(""tcl.root"");; TTree *T = (TTree*)f->Get(""T"");; TH2F *h2 = new TH2F(""h2"",""center of lines"",40,0,1,40,0,1);; ; TClonesArray *arr = new TCl",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
https://root.cern/doc/master/tcl_8C.html:4298,Usability,simpl,simple,4298,"n THbookFile.cxx:91; TLine.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TTree.h; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::Clearvoid Clear(Option_t *option="""") overrideClear the clones array.Definition TClonesArray.cxx:420; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::GetY1Double_t GetY1() constDefinition TLine.h:52; TLine::GetX2Double_t GetX2() constDefinition TLine.h:51; TLine::GetX1Double_t GetX1() constDefinition TLine.h:50; TLine::GetY2Double_t GetY2() constDefinition TLine.h:53; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Pa",MatchSource.WIKI,doc/master/tcl_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tcl_8C.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:31120,Availability,error,error,31120,"ont_t;; 863 using typename InfoBase_t::Iter_t;; 864 using typename InfoBase_t::Value_t;; 865 using typename InfoBase_t::Env_t;; 866 using typename InfoBase_t::PEnv_t;; 867 using typename InfoBase_t::PCont_t;; 868 using typename InfoBase_t::PValue_t;; 869 ; 870 static void resize(void*,size_t) {; 871 }; 872 static void* feed(void *from, void *to, size_t size) {; 873 PCont_t c = PCont_t(to);; 874 PValue_t m = PValue_t(from);; 875 for (size_t i=0; i<size; ++i, ++m); 876 c->set(i,*m);; 877 return nullptr;; 878 }; 879 static int value_offset() {; 880 return 0;; 881 }; 882 };; 883 ; 884} // namespace Detail; 885 ; 886// For (reasonable) backward compatibility:; 887using namespace Detail;; 888} // namespace ROOT; 889 ; 890#endif; c#define c(i)Definition RSha256.hxx:101; e#define e(i)Definition RSha256.hxx:103; RtypesCore.h; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TYPENAME#define TYPENAMEDefinition TCollectionProxyInfo.h:36; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::Detail::TCollectionProxyInfoDefinition TCollectionProxyInfo.h:57; ROOT::Detail::TCollectionProxyInfo::fCopyIteratorvoid *(* fCopyIterator)(void *dest, const void *source)Definition TCollectionProxyInfo.h:520; ROOT::Detail::TCollectionProxyInfo::fConstructFuncvoid *(* fConstructFunc)(void *,",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:5725,Deployability,update,update,5725,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:5803,Deployability,update,update,5803,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:16937,Energy Efficiency,allocate,allocated,16937,"_t(0x1000))->second)) - ((char*)PValue_t(0x1000));; 494 }; 495 };; 496 ; 497 ; 498 public:; 499 const std::type_info &fInfo;; 500 size_t fIterSize;; 501 size_t fValueDiff;; 502 int fValueOffset;; 503 void* (*fSizeFunc)(void*);; 504 void (*fResizeFunc)(void*,size_t);; 505 void* (*fClearFunc)(void*);; 506 void* (*fFirstFunc)(void*);; 507 void* (*fNextFunc)(void*);; 508 void* (*fConstructFunc)(void*,size_t);; 509 void (*fDestructFunc)(void*,size_t);; 510 void* (*fFeedFunc)(void*,void*,size_t);; 511 void* (*fCollectFunc)(void*,void*);; 512 void* (*fCreateEnv)();; 513 ; 514 // Set of function of direct iteration of the collections.; 515 void (*fCreateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 516 // begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 517 // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 518 // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 519 ; 520 void* (*fCopyIterator)(void *dest, const void *source);; 521 // Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 522 // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 523 // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 524 ; 525 void* (*fNext)(void *iter, const void *end);; 526 // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 527 // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 528 // If the end is not reached, 'Next' will return the address of the content unless the collection contains point",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:17425,Energy Efficiency,allocate,allocated,17425,"d*,void*,size_t);; 511 void* (*fCollectFunc)(void*,void*);; 512 void* (*fCreateEnv)();; 513 ; 514 // Set of function of direct iteration of the collections.; 515 void (*fCreateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 516 // begin_arena and end_arena should contain the location of memory arena of size fgIteratorSize.; 517 // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); 518 // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.; 519 ; 520 void* (*fCopyIterator)(void *dest, const void *source);; 521 // Copy the iterator source, into dest. dest should contain should contain the location of memory arena of size fgIteratorSize.; 522 // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement); 523 // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.; 524 ; 525 void* (*fNext)(void *iter, const void *end);; 526 // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 527 // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 528 // If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 529 // which case 'Next' will return the value of the pointer.; 530 ; 531 void (*fDeleteSingleIterator)(void *iter);; 532 void (*fDeleteTwoIterators)(void *begin, void *end);; 533 // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 534 // Otherwise just call the iterator's destructor.; 535 ; 536 public:; 537 TCollectionProxyInfo(const std::type_info& info,; 538 size_t iter_size,; 539 size_t value_diff,; 540 int value_offset,",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:5665,Integrability,rout,routine,5665,"_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 186 }; 187 static void* copy(void * /*dest_arena*/, const void *source_ptr) {; 188 iterator *source = (iterator *)(source_ptr);; 189 void *iter = new iterator(*source);; 190 return iter;; 191 }; 192 static void* next(void *it",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:35744,Integrability,interface,interface,35744,"ateIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)Definition TCollectionProxyInfo.h:515; ROOT::Detail::TCollectionProxyInfo::fValueOffsetint fValueOffsetDefinition TCollectionProxyInfo.h:502; ROOT::Detail::TCollectionProxyInfo::Generatestatic TCollectionProxyInfo * Generate(const T &)Generate proxy from template.Definition TCollectionProxyInfo.h:569; ROOT::Detail::TCollectionProxyInfo::fNextvoid *(* fNext)(void *iter, const void *end)Definition TCollectionProxyInfo.h:525; ROOT::Detail::TCollectionProxyInfo::fCreateEnvvoid *(* fCreateEnv)()Definition TCollectionProxyInfo.h:512; ROOT::Detail::TCollectionProxyInfo::fInfoconst std::type_info & fInfoDefinition TCollectionProxyInfo.h:499; ROOT::Internal::TStdBitsetHelperDefinition TCollectionProxyInfo.h:48; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; bool; object; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMVA_SOFIE_GNN.startstartDefinition TMVA_SOFIE_GNN.py:200; TMVA_SOFIE_GNN.endendDefinition TMVA_SOFIE_GNN.py:207; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Detail::TCollectionProxyInfo::AddressDefinition TCollectionProxyInfo.h:264; ROOT::Detail::TCollectionProxyInfo::Address::~Addressvirtual ~Address()Definition TCollectionProxyInfo.h:265; ROOT::Detail::TCollectionProxyInfo::Address::addressstatic void * address(T ref)Definition TCollectionProxyInfo.h:266; ROOT::Detail::TCollectionProxyInfo::EnvironBaseDefinition TCollectionProxyInfo.h:223; ROOT::Detail::TCollectionProxyInfo::EnvironBase::fIdxsize_t fIdxDefinition TCollectionProxyInfo.h:232; ROOT::Detail::",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:5437,Performance,perform,perform,5437,"ef std::vector<T> Cont_t;; 136 typedef Cont_t *PCont_t;; 137 typedef typename Cont_t::iterator iterator;; 138 ; 139 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 140 PCont_t c = PCont_t(coll);; 141 if (c->empty()) {; 142 *begin_arena = nullptr;; 143 *end_arena = nullptr;; 144 return;; 145 }; 146 *begin_arena = &(*c->begin());; 147#ifdef R__VISUAL_CPLUSPLUS; 148 *end_arena = &(*(c->end()-1)) + 1; // On windows we can not dererence the end iterator at all.; 149#else; 150 // coverity[past_the_end] Safe on other platforms; 151 *end_arena = &(*c->end());; 152#endif; 153 }; 154 static void* copy(void *dest, const void *source) {; 155 *(void**)dest = *(void**)(const_cast<void*>(source));; 156 return dest;; 157 }; 158 static void* next(void * /* iter_loc */, const void * /* end_loc */) {; 159 // Should not be used.; 160 // In the case of vector, so that the I/O can perform better,; 161 // the begin_arena and the end_arena are *not* set to the; 162 // address of any iterator rather they are set to the value of; 163 // the beginning (and end) address of the vector's data.; 164 // Hence this routine (which takes the value of fBegin) can; 165 // *not* update where its points to (which in the case of vector; 166 // would require update the value of fBegin).; 167 R__ASSERT(0 && ""Intentionally not implemented, do not use."");; 168 return nullptr;; 169 }; 170 static void destruct1(void * /* iter_ptr */) {; 171 // Nothing to do; 172 }; 173 static void destruct2(void * /* begin_ptr */, void * /* end_ptr */) {; 174 // Nothing to do; 175 }; 176 };; 177 ; 178 template <typename Cont_t> struct Iterators<Cont_t, /* large= */ true > {; 179 typedef Cont_t *PCont_t;; 180 typedef typename Cont_t::iterator iterator;; 181 ; 182 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 183 PCont_t c = PCont_t(coll);; 184 *begin_arena = new iterator(c->begin());; 185 *end_arena = new iterator(c->end());; 18",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:4210,Safety,avoid,avoid,4210,"t_t, value_ptr*> {; 81 static void* get(typename Cont_t::iterator &iter) {; 82 return (void*)(*iter);; 83 }; 84 };; 85 ; 86 /** @class ROOT::Detail::TCollectionProxyInfo::Iterators; 87 *; 88 * Small helper to implement the function to create,access and destroy; 89 * iterators.; 90 *; 91 **/; 92 ; 93 template <typename Cont_t, bool large = false>; 94 struct Iterators {; 95 typedef Cont_t *PCont_t;; 96 typedef typename Cont_t::iterator iterator;; 97 ; 98 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 99 PCont_t c = PCont_t(coll);; 100 new (*begin_arena) iterator(c->begin());; 101 new (*end_arena) iterator(c->end());; 102 }; 103 static void* copy(void *dest_arena, const void *source_ptr) {; 104 iterator *source = (iterator *)(source_ptr);; 105 new (dest_arena) iterator(*source);; 106 return dest_arena;; 107 }; 108 static void* next(void *iter_loc, const void *end_loc) {; 109 iterator *end = (iterator *)(end_loc);; 110 iterator *iter = (iterator *)(iter_loc);; 111 if (*iter != *end) {; 112 void *result = IteratorValue<Cont_t, typename Cont_t::value_type>::get(*iter);; 113 ++(*iter);; 114 return result;; 115 }; 116 return nullptr;; 117 }; 118 static void destruct1(void *iter_ptr) {; 119 iterator *start = (iterator *)(iter_ptr);; 120 start->~iterator();; 121 }; 122 static void destruct2(void *begin_ptr, void *end_ptr) {; 123 iterator *start = (iterator *)(begin_ptr);; 124 iterator *end = (iterator *)(end_ptr);; 125 start->~iterator();; 126 end->~iterator();; 127 }; 128 };; 129 ; 130 // For Vector we take an extra short cut to avoid derefencing; 131 // the iterator all the time and redefine the 'address' of the; 132 // iterator as the iterator itself. This requires special handling; 133 // in the looper (see TStreamerInfoAction) but is much faster.; 134 template <typename T> struct Iterators<std::vector<T>, false> {; 135 typedef std::vector<T> Cont_t;; 136 typedef Cont_t *PCont_t;; 137 typedef typename Cont_t::iterator ite",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:2855,Security,access,access,2855,"alent; 50 // of 'template <int N> struct TCollectionProxyInfo::Type<std::bitset<N> >' which; 51 // is not effective in C++ (as of gcc 4.3.3).; 52};; 53}; 54 ; 55namespace Detail {; 56 ; 57 class TCollectionProxyInfo {; 58 // This class is a place holder for the information needed; 59 // to create the proper Collection Proxy.; 60 // This is similar to Reflex's CollFuncTable.; 61 ; 62 public:; 63 ; 64 // Same value as TVirtualCollectionProxy.; 65 static const UInt_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 66 ; 67 /** @class ROOT::Detail::TCollectionProxyInfo::IteratorValue; 68 *; 69 * Small helper to encapsulate whether to return the value; 70 * pointed to by the iterator or its address.; 71 *; 72 **/; 73 ; 74 template <typename Cont_t, typename value> struct IteratorValue {; 75 static void* get(typename Cont_t::iterator &iter) {; 76 return (void*)&(*iter);; 77 }; 78 };; 79 ; 80 template <typename Cont_t, typename value_ptr> struct IteratorValue<Cont_t, value_ptr*> {; 81 static void* get(typename Cont_t::iterator &iter) {; 82 return (void*)(*iter);; 83 }; 84 };; 85 ; 86 /** @class ROOT::Detail::TCollectionProxyInfo::Iterators; 87 *; 88 * Small helper to implement the function to create,access and destroy; 89 * iterators.; 90 *; 91 **/; 92 ; 93 template <typename Cont_t, bool large = false>; 94 struct Iterators {; 95 typedef Cont_t *PCont_t;; 96 typedef typename Cont_t::iterator iterator;; 97 ; 98 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 99 PCont_t c = PCont_t(coll);; 100 new (*begin_arena) iterator(c->begin());; 101 new (*end_arena) iterator(c->end());; 102 }; 103 static void* copy(void *dest_arena, const void *source_ptr) {; 104 iterator *source = (iterator *)(source_ptr);; 105 new (dest_arena) iterator(*source);; 106 return dest_arena;; 107 }; 108 static void* next(void *iter_loc, const void *end_loc) {; 109 iterator *end = (iterator *)(end_loc);; 110 iterator *iter = (iterato",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:9655,Security,access,accesses,9655," 258 PairHolder(const PairHolder& c) : first(c.first), second(c.second) {}; 259 virtual ~PairHolder() {}; 260 private:; 261 PairHolder& operator=(const PairHolder&) = delete;; 262 };; 263 ; 264 template <class T> struct Address {; 265 virtual ~Address() {}; 266 static void* address(T ref) {; 267 return const_cast<void*>(reinterpret_cast<const void*>(&ref));; 268 }; 269 };; 270 ; 271 struct SfinaeHelper {; 272 // Use SFINAE to get the size of the container; 273 ; 274 // In general we get the size of the container with the size method; 275 template <class T>; 276 static size_t GetContainerSize(const T& c) {return c.size();}; 277 ; 278 // Since forward_list does not provide a size operator, we have to; 279 // use an alternative. This has a cost of course.; 280 template <class T, class ALLOCATOR>; 281 static size_t GetContainerSize(const std::forward_list<T,ALLOCATOR>& c) {return std::distance(c.begin(),c.end());}; 282 };; 283 ; 284 /** @class ROOT::Detail::TCollectionProxyInfo::Type; 285 *; 286 * Small helper to encapsulate basic data accesses for; 287 * all STL continers.; 288 *; 289 * @author M.Frank; 290 * @version 1.0; 291 * @date 10/10/2004; 292 */; 293 template <class T> struct Type; 294 : public Address<TYPENAME T::const_reference>; 295 {; 296 typedef T Cont_t;; 297 typedef typename T::iterator Iter_t;; 298 typedef typename T::value_type Value_t;; 299 typedef Environ<Iter_t> Env_t;; 300 typedef Env_t *PEnv_t;; 301 typedef Cont_t *PCont_t;; 302 typedef Value_t *PValue_t;; 303 ; 304 virtual ~Type() {}; 305 ; 306 static inline PCont_t object(void* ptr) {; 307 return PCont_t(PEnv_t(ptr)->fObject);; 308 }; 309 static void* size(void* env) {; 310 PEnv_t e = PEnv_t(env);; 311 e->fSize = SfinaeHelper::GetContainerSize(*PCont_t(e->fObject));; 312 return &e->fSize;; 313 }; 314 static void* clear(void* env) {; 315 object(env)->clear();; 316 return nullptr;; 317 }; 318 static void* first(void* env) {; 319 PEnv_t e = PEnv_t(env);; 320 PCont_t c = PCont_t(e->fObject);; 321#if ",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:12220,Security,access,accesses,12220,"->fSize = SfinaeHelper::GetContainerSize(*c);; 327 if ( 0 == e->fSize ) return e->fStart = nullptr;; 328 TYPENAME T::const_reference ref = *(e->iter());; 329 return e->fStart = Type<T>::address(ref);; 330 }; 331 static void* next(void* env) {; 332 PEnv_t e = PEnv_t(env);; 333 PCont_t c = PCont_t(e->fObject);; 334 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 335 // TODO: Need to find something for going backwards....; 336 if ( e->iter() == c->end() ) return nullptr;; 337 TYPENAME T::const_reference ref = *(e->iter());; 338 return Type<T>::address(ref);; 339 }; 340 static void* construct(void *what, size_t size) {; 341 PValue_t m = PValue_t(what);; 342 for (size_t i=0; i<size; ++i, ++m); 343 ::new(m) Value_t();; 344 return nullptr;; 345 }; 346 static void* collect(void *coll, void *array) {; 347 PCont_t c = PCont_t(coll);; 348 PValue_t m = PValue_t(array);; 349 for (Iter_t i=c->begin(); i != c->end(); ++i, ++m ); 350 ::new(m) Value_t(*i);; 351 return nullptr;; 352 }; 353 static void destruct(void *what, size_t size) {; 354 PValue_t m = PValue_t(what);; 355 for (size_t i=0; i < size; ++i, ++m ); 356 m->~Value_t();; 357 }; 358 ; 359 static const bool fgLargeIterator = sizeof(typename Cont_t::iterator) > fgIteratorArenaSize;; 360 typedef Iterators<Cont_t,fgLargeIterator> Iterators_t;; 361 ; 362 };; 363 ; 364 /** @class ROOT::Detail::TCollectionProxyInfo::Pushback; 365 *; 366 * Small helper to encapsulate all necessary data accesses for; 367 * containers like vector, list, deque; 368 *; 369 * @author M.Frank; 370 * @version 1.0; 371 * @date 10/10/2004; 372 */; 373 template <class T> struct Pushback : public Type<T> {; 374 typedef T Cont_t;; 375 typedef typename T::iterator Iter_t;; 376 typedef typename T::value_type Value_t;; 377 typedef Environ<Iter_t> Env_t;; 378 typedef Env_t *PEnv_t;; 379 typedef Cont_t *PCont_t;; 380 typedef Value_t *PValue_t;; 381 static void resize(void* obj, size_t n) {; 382 PCont_t c = PCont_t(obj);; 383 c->resize(n);",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:13164,Security,access,accesses,13164,"ct(void *what, size_t size) {; 354 PValue_t m = PValue_t(what);; 355 for (size_t i=0; i < size; ++i, ++m ); 356 m->~Value_t();; 357 }; 358 ; 359 static const bool fgLargeIterator = sizeof(typename Cont_t::iterator) > fgIteratorArenaSize;; 360 typedef Iterators<Cont_t,fgLargeIterator> Iterators_t;; 361 ; 362 };; 363 ; 364 /** @class ROOT::Detail::TCollectionProxyInfo::Pushback; 365 *; 366 * Small helper to encapsulate all necessary data accesses for; 367 * containers like vector, list, deque; 368 *; 369 * @author M.Frank; 370 * @version 1.0; 371 * @date 10/10/2004; 372 */; 373 template <class T> struct Pushback : public Type<T> {; 374 typedef T Cont_t;; 375 typedef typename T::iterator Iter_t;; 376 typedef typename T::value_type Value_t;; 377 typedef Environ<Iter_t> Env_t;; 378 typedef Env_t *PEnv_t;; 379 typedef Cont_t *PCont_t;; 380 typedef Value_t *PValue_t;; 381 static void resize(void* obj, size_t n) {; 382 PCont_t c = PCont_t(obj);; 383 c->resize(n);; 384 }; 385 static void* feed(void *from, void *to, size_t size) {; 386 PCont_t c = PCont_t(to);; 387 PValue_t m = PValue_t(from);; 388 for (size_t i=0; i<size; ++i, ++m); 389 c->push_back(*m);; 390 return nullptr;; 391 }; 392 static int value_offset() {; 393 return 0;; 394 }; 395 };; 396 ; 397 /** @class ROOT::Detail::TCollectionProxyInfo::Pushfront; 398 *; 399 * Small helper to encapsulate all necessary data accesses for; 400 * containers like forward_list; 401 *; 402 * @author D.Piparo; 403 * @version 1.0; 404 * @date 26/02/2015; 405 */; 406 template <class T> struct Pushfront : public Type<T> {; 407 typedef T Cont_t;; 408 typedef typename T::iterator Iter_t;; 409 typedef typename T::value_type Value_t;; 410 typedef Environ<Iter_t> Env_t;; 411 typedef Env_t *PEnv_t;; 412 typedef Cont_t *PCont_t;; 413 typedef Value_t *PValue_t;; 414 static void resize(void* obj, size_t n) {; 415 PCont_t c = PCont_t(obj);; 416 c->resize(n);; 417 }; 418 static void* feed(void *from, void *to, size_t size) {; 419 PCont_t c = PCont_t(",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:14225,Security,access,accesses,14225,"oid* feed(void *from, void *to, size_t size) {; 386 PCont_t c = PCont_t(to);; 387 PValue_t m = PValue_t(from);; 388 for (size_t i=0; i<size; ++i, ++m); 389 c->push_back(*m);; 390 return nullptr;; 391 }; 392 static int value_offset() {; 393 return 0;; 394 }; 395 };; 396 ; 397 /** @class ROOT::Detail::TCollectionProxyInfo::Pushfront; 398 *; 399 * Small helper to encapsulate all necessary data accesses for; 400 * containers like forward_list; 401 *; 402 * @author D.Piparo; 403 * @version 1.0; 404 * @date 26/02/2015; 405 */; 406 template <class T> struct Pushfront : public Type<T> {; 407 typedef T Cont_t;; 408 typedef typename T::iterator Iter_t;; 409 typedef typename T::value_type Value_t;; 410 typedef Environ<Iter_t> Env_t;; 411 typedef Env_t *PEnv_t;; 412 typedef Cont_t *PCont_t;; 413 typedef Value_t *PValue_t;; 414 static void resize(void* obj, size_t n) {; 415 PCont_t c = PCont_t(obj);; 416 c->resize(n);; 417 }; 418 static void* feed(void *from, void *to, size_t size) {; 419 PCont_t c = PCont_t(to);; 420 if (size==0) return nullptr;; 421 PValue_t m = &(PValue_t(from)[size-1]); // Take the last item; 422 // Iterate backwards not to revert ordering; 423 for (size_t i=0; i<size; ++i, --m){; 424 c->push_front(*m);; 425 }; 426 return nullptr;; 427 }; 428 static int value_offset() {; 429 return 0;; 430 }; 431 };; 432 ; 433 /** @class ROOT::Detail::TCollectionProxyInfo::Insert; 434 *; 435 * Small helper to encapsulate all necessary data accesses for; 436 * containers like set, multiset etc.; 437 *; 438 * @author M.Frank; 439 * @version 1.0; 440 * @date 10/10/2004; 441 */; 442 template <class T> struct Insert : public Type<T> {; 443 typedef T Cont_t;; 444 typedef typename T::iterator Iter_t;; 445 typedef typename T::value_type Value_t;; 446 typedef Environ<Iter_t> Env_t;; 447 typedef Env_t *PEnv_t;; 448 typedef Cont_t *PCont_t;; 449 typedef Value_t *PValue_t;; 450 static void* feed(void *from, void *to, size_t size) {; 451 PCont_t c = PCont_t(to);; 452 PValue_t m = PValue_t",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:15125,Security,access,accesses,15125," {; 419 PCont_t c = PCont_t(to);; 420 if (size==0) return nullptr;; 421 PValue_t m = &(PValue_t(from)[size-1]); // Take the last item; 422 // Iterate backwards not to revert ordering; 423 for (size_t i=0; i<size; ++i, --m){; 424 c->push_front(*m);; 425 }; 426 return nullptr;; 427 }; 428 static int value_offset() {; 429 return 0;; 430 }; 431 };; 432 ; 433 /** @class ROOT::Detail::TCollectionProxyInfo::Insert; 434 *; 435 * Small helper to encapsulate all necessary data accesses for; 436 * containers like set, multiset etc.; 437 *; 438 * @author M.Frank; 439 * @version 1.0; 440 * @date 10/10/2004; 441 */; 442 template <class T> struct Insert : public Type<T> {; 443 typedef T Cont_t;; 444 typedef typename T::iterator Iter_t;; 445 typedef typename T::value_type Value_t;; 446 typedef Environ<Iter_t> Env_t;; 447 typedef Env_t *PEnv_t;; 448 typedef Cont_t *PCont_t;; 449 typedef Value_t *PValue_t;; 450 static void* feed(void *from, void *to, size_t size) {; 451 PCont_t c = PCont_t(to);; 452 PValue_t m = PValue_t(from);; 453 for (size_t i=0; i<size; ++i, ++m); 454 c->insert(*m);; 455 return nullptr;; 456 }; 457 static void resize(void* /* obj */, size_t ) {; 458 ;; 459 }; 460 static int value_offset() {; 461 return 0;; 462 }; 463 };; 464 ; 465 /** @class ROOT::Detail::TCollectionProxyInfo::MapInsert; 466 *; 467 * Small helper to encapsulate all necessary data accesses for; 468 * containers like set, multiset etc.; 469 *; 470 * @author M.Frank; 471 * @version 1.0; 472 * @date 10/10/2004; 473 */; 474 template <class T> struct MapInsert : public Type<T> {; 475 typedef T Cont_t;; 476 typedef typename T::iterator Iter_t;; 477 typedef typename T::value_type Value_t;; 478 typedef Environ<Iter_t> Env_t;; 479 typedef Env_t *PEnv_t;; 480 typedef Cont_t *PCont_t;; 481 typedef Value_t *PValue_t;; 482 static void* feed(void *from, void *to, size_t size) {; 483 PCont_t c = PCont_t(to);; 484 PValue_t m = PValue_t(from);; 485 for (size_t i=0; i<size; ++i, ++m); 486 c->insert(*m);; 487 return ",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:38821,Security,access,accesses,38821,"zesize_t fSizeDefinition TCollectionProxyInfo.h:233; ROOT::Detail::TCollectionProxyInfo::EnvironBase::operator=EnvironBase & operator=(const EnvironBase &); ROOT::Detail::TCollectionProxyInfo::EnvironBase::fObjectvoid * fObjectDefinition TCollectionProxyInfo.h:234; ROOT::Detail::TCollectionProxyInfo::EnvironSmall helper to save proxy environment in the event of recursive calls.Definition TCollectionProxyInfo.h:244; ROOT::Detail::TCollectionProxyInfo::Environ::fIteratorIter_t fIteratorDefinition TCollectionProxyInfo.h:247; ROOT::Detail::TCollectionProxyInfo::Environ::iterT & iter()Definition TCollectionProxyInfo.h:248; ROOT::Detail::TCollectionProxyInfo::Environ::Createstatic void * Create()Definition TCollectionProxyInfo.h:249; ROOT::Detail::TCollectionProxyInfo::Environ::Iter_tT Iter_tDefinition TCollectionProxyInfo.h:246; ROOT::Detail::TCollectionProxyInfo::Environ::EnvironEnviron()Definition TCollectionProxyInfo.h:245; ROOT::Detail::TCollectionProxyInfo::InsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc.Definition TCollectionProxyInfo.h:442; ROOT::Detail::TCollectionProxyInfo::Insert::resizestatic void resize(void *, size_t)Definition TCollectionProxyInfo.h:457; ROOT::Detail::TCollectionProxyInfo::Insert::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:460; ROOT::Detail::TCollectionProxyInfo::Insert::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:447; ROOT::Detail::TCollectionProxyInfo::Insert::feedstatic void * feed(void *from, void *to, size_t size)Definition TCollectionProxyInfo.h:450; ROOT::Detail::TCollectionProxyInfo::Insert::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:443; ROOT::Detail::TCollectionProxyInfo::Insert::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:448; ROOT::Detail::TCollectionProxyInfo::Insert::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:444; ROOT::Detail::TCollectionProxyInfo::Insert::Value_tT::value_type Value_tDefinition TCollection",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:41713,Security,access,access,41713,"ollectionProxyInfo::Iterators< Cont_t, true >::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:206; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::nextstatic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:192; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:182; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::destruct1static void destruct1(void *begin_ptr)Definition TCollectionProxyInfo.h:202; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::copystatic void * copy(void *, const void *source_ptr)Definition TCollectionProxyInfo.h:187; ROOT::Detail::TCollectionProxyInfo::Iterators< Cont_t, true >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:179; ROOT::Detail::TCollectionProxyInfo::IteratorsSmall helper to implement the function to create,access and destroy iterators.Definition TCollectionProxyInfo.h:94; ROOT::Detail::TCollectionProxyInfo::Iterators::nextstatic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:108; ROOT::Detail::TCollectionProxyInfo::Iterators::copystatic void * copy(void *dest_arena, const void *source_ptr)Definition TCollectionProxyInfo.h:103; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:122; ROOT::Detail::TCollectionProxyInfo::Iterators::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:98; ROOT::Detail::TCollectionProxyInfo::Iterators::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:95; ROOT::Detail::TCollectionProxyInfo::Iterators::iteratorCont_t::iterator iteratorDefinition TCollectionProxyInfo.h:96; ROOT::Detail::TCollectionProxyInfo::Iterat",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:42859,Security,access,accesses,42859,"atic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:108; ROOT::Detail::TCollectionProxyInfo::Iterators::copystatic void * copy(void *dest_arena, const void *source_ptr)Definition TCollectionProxyInfo.h:103; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:122; ROOT::Detail::TCollectionProxyInfo::Iterators::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:98; ROOT::Detail::TCollectionProxyInfo::Iterators::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:95; ROOT::Detail::TCollectionProxyInfo::Iterators::iteratorCont_t::iterator iteratorDefinition TCollectionProxyInfo.h:96; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct1static void destruct1(void *iter_ptr)Definition TCollectionProxyInfo.h:118; ROOT::Detail::TCollectionProxyInfo::MapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc.Definition TCollectionProxyInfo.h:474; ROOT::Detail::TCollectionProxyInfo::MapInsert::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:476; ROOT::Detail::TCollectionProxyInfo::MapInsert::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:475; ROOT::Detail::TCollectionProxyInfo::MapInsert::resizestatic void resize(void *, size_t)Definition TCollectionProxyInfo.h:489; ROOT::Detail::TCollectionProxyInfo::MapInsert::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:481; ROOT::Detail::TCollectionProxyInfo::MapInsert::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:479; ROOT::Detail::TCollectionProxyInfo::MapInsert::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:492; ROOT::Detail::TCollectionProxyInfo::MapInsert::Value_tT::value_type Value_tDefinition TCollectionProxyInfo.h:477; ROOT::Detail::TCollectionProxyInfo::MapInsert::Env_tEnviron< Iter_t > Env_tDefinition TCollection",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:45607,Security,access,accesses,45607,"tT firstDefinition TCollectionProxyInfo.h:255; ROOT::Detail::TCollectionProxyInfo::PairHolder::PairHolderPairHolder()Definition TCollectionProxyInfo.h:257; ROOT::Detail::TCollectionProxyInfo::PairHolder::~PairHoldervirtual ~PairHolder()Definition TCollectionProxyInfo.h:259; ROOT::Detail::TCollectionProxyInfo::Pushback< Internal::TStdBitsetHelper< Bitset_t > >::resizestatic void resize(void *, size_t)Definition TCollectionProxyInfo.h:870; ROOT::Detail::TCollectionProxyInfo::Pushback< Internal::TStdBitsetHelper< Bitset_t > >::feedstatic void * feed(void *from, void *to, size_t size)Definition TCollectionProxyInfo.h:872; ROOT::Detail::TCollectionProxyInfo::Pushback< Internal::TStdBitsetHelper< Bitset_t > >::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:879; ROOT::Detail::TCollectionProxyInfo::Pushback< Internal::TStdBitsetHelper< Bitset_t > >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:762; ROOT::Detail::TCollectionProxyInfo::PushbackSmall helper to encapsulate all necessary data accesses for containers like vector,...Definition TCollectionProxyInfo.h:373; ROOT::Detail::TCollectionProxyInfo::Pushback::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:374; ROOT::Detail::TCollectionProxyInfo::Pushback::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:380; ROOT::Detail::TCollectionProxyInfo::Pushback::resizestatic void resize(void *obj, size_t n)Definition TCollectionProxyInfo.h:381; ROOT::Detail::TCollectionProxyInfo::Pushback::feedstatic void * feed(void *from, void *to, size_t size)Definition TCollectionProxyInfo.h:385; ROOT::Detail::TCollectionProxyInfo::Pushback::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:375; ROOT::Detail::TCollectionProxyInfo::Pushback::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:378; ROOT::Detail::TCollectionProxyInfo::Pushback::Value_tT::value_type Value_tDefinition TCollectionProxyInfo.h:376; ROOT::Detail::TCollectionProxyInfo::Pushback::Env_tEnviron< Iter_t > Env_tDefinitio",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:46929,Security,access,accesses,46929,":Detail::TCollectionProxyInfo::Pushback::resizestatic void resize(void *obj, size_t n)Definition TCollectionProxyInfo.h:381; ROOT::Detail::TCollectionProxyInfo::Pushback::feedstatic void * feed(void *from, void *to, size_t size)Definition TCollectionProxyInfo.h:385; ROOT::Detail::TCollectionProxyInfo::Pushback::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:375; ROOT::Detail::TCollectionProxyInfo::Pushback::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:378; ROOT::Detail::TCollectionProxyInfo::Pushback::Value_tT::value_type Value_tDefinition TCollectionProxyInfo.h:376; ROOT::Detail::TCollectionProxyInfo::Pushback::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:377; ROOT::Detail::TCollectionProxyInfo::Pushback::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:379; ROOT::Detail::TCollectionProxyInfo::Pushback::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:392; ROOT::Detail::TCollectionProxyInfo::PushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list.Definition TCollectionProxyInfo.h:406; ROOT::Detail::TCollectionProxyInfo::Pushfront::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:413; ROOT::Detail::TCollectionProxyInfo::Pushfront::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:407; ROOT::Detail::TCollectionProxyInfo::Pushfront::Value_tT::value_type Value_tDefinition TCollectionProxyInfo.h:409; ROOT::Detail::TCollectionProxyInfo::Pushfront::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:412; ROOT::Detail::TCollectionProxyInfo::Pushfront::resizestatic void resize(void *obj, size_t n)Definition TCollectionProxyInfo.h:414; ROOT::Detail::TCollectionProxyInfo::Pushfront::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:428; ROOT::Detail::TCollectionProxyInfo::Pushfront::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:408; ROOT::Detail::TCollectionProxyInfo::Pushfront::feedstatic void * feed(void *from, void *to, ",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:52609,Security,access,accesses,52609,"inition TCollectionProxyInfo.h:779; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:775; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Detail::TCollectionProxyInfo::Type::fgLargeIteratorstatic const bool fgLargeIteratorDefinition TCollectionProxyInfo.h:359; ROOT::Detail::TCollectionProxyInfo::Type::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:314; ROOT::Detail::TCollectionProxyInfo::Type::destructstatic void destruct(void *what, size_t size)Definition TCollectionProxyInfo.h:353; ROOT::Detail::TCollectionProxyInfo::Type::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:318; ROOT::Detail::TCollectionProxyInfo::Type::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:309; ROOT::Detail::TCollectionProxyInfo::Type::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:297; ROOT::Detail::TCollectionProxyInfo::Type::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:296; ROOT::Detail::TCollectionProxyInfo::Type::PValue_tValue_t * PValue_tDefinition TCollectionProx",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:27024,Testability,test,test,27024,"vector<bool> instead"");; 751 return {};; 752 }; 753 };; 754 ; 755 template <typename Bitset_t> struct TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Address<const Bool_t &>; 756 {; 757 typedef Bitset_t Cont_t;; 758 typedef std::pair<size_t,Bool_t> Iter_t;; 759 typedef Bool_t Value_t;; 760 typedef Environ<Iter_t> Env_t;; 761 typedef Env_t *PEnv_t;; 762 typedef Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.first = 0;; 783 e->fIterator.second = c->size() > 0 ? c->test(e->fIterator.first) : false ; // Iterator actually hold the value.; 784 e->fSize = c->size();; 785 return &(e->fIterator.second);; 786 }; 787 static void* next(void* env) {; 788 PEnv_t e = PEnv_t(env);; 789 PCont_t c = PCont_t(e->fObject);; 790 for (; e->fIdx > 0 && e->fIterator.first != c->size(); ++(e->fIterator.first), --e->fIdx){ }; 791 e->fIterator.second = (e->fIterator.first != c->size()) ? c->test(e->fIterator.first) : false;; 792 return &(e->fIterator.second);; 793 }; 794 static void* construct(void*,size_t) {; 795 // Nothing to construct.; 796 return nullptr;; 797 }; 798 static void* collect(void *coll, void *array) {; 799 PCont_t c = PCont_t(coll);; 800 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 801 for (size_t i=0; i != c->size(); ++i, ++m ); 802 *m = c->test(i);; 803 return nullptr;; 804 }; 805 static void destruct(void*,size_t) {; 806 // Nothing to destruct.; 807 }; 808 ; 809 //static const bool fgLargeIterator = sizeof(typename",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:27433,Testability,test,test,27433,"f Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.first = 0;; 783 e->fIterator.second = c->size() > 0 ? c->test(e->fIterator.first) : false ; // Iterator actually hold the value.; 784 e->fSize = c->size();; 785 return &(e->fIterator.second);; 786 }; 787 static void* next(void* env) {; 788 PEnv_t e = PEnv_t(env);; 789 PCont_t c = PCont_t(e->fObject);; 790 for (; e->fIdx > 0 && e->fIterator.first != c->size(); ++(e->fIterator.first), --e->fIdx){ }; 791 e->fIterator.second = (e->fIterator.first != c->size()) ? c->test(e->fIterator.first) : false;; 792 return &(e->fIterator.second);; 793 }; 794 static void* construct(void*,size_t) {; 795 // Nothing to construct.; 796 return nullptr;; 797 }; 798 static void* collect(void *coll, void *array) {; 799 PCont_t c = PCont_t(coll);; 800 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 801 for (size_t i=0; i != c->size(); ++i, ++m ); 802 *m = c->test(i);; 803 return nullptr;; 804 }; 805 static void destruct(void*,size_t) {; 806 // Nothing to destruct.; 807 }; 808 ; 809 //static const bool fgLargeIterator = sizeof(typename Cont_t::iterator) > fgIteratorArenaSize;; 810 //typedef Iterators<Cont_t,fgLargeIterator> Iterators_t;; 811 ; 812 struct Iterators {; 813 union PtrSize_t { size_t fIndex; void *fAddress; };; 814 typedef std::pair<PtrSize_t,Bool_t> iterator;; 815 // In the end iterator we store the bitset pointer; 816 // and do not use the 'second' part of the pair.; 817 // In the other iterator we store the index; 818 // an",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:27840,Testability,test,test,27840," first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.first = 0;; 783 e->fIterator.second = c->size() > 0 ? c->test(e->fIterator.first) : false ; // Iterator actually hold the value.; 784 e->fSize = c->size();; 785 return &(e->fIterator.second);; 786 }; 787 static void* next(void* env) {; 788 PEnv_t e = PEnv_t(env);; 789 PCont_t c = PCont_t(e->fObject);; 790 for (; e->fIdx > 0 && e->fIterator.first != c->size(); ++(e->fIterator.first), --e->fIdx){ }; 791 e->fIterator.second = (e->fIterator.first != c->size()) ? c->test(e->fIterator.first) : false;; 792 return &(e->fIterator.second);; 793 }; 794 static void* construct(void*,size_t) {; 795 // Nothing to construct.; 796 return nullptr;; 797 }; 798 static void* collect(void *coll, void *array) {; 799 PCont_t c = PCont_t(coll);; 800 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 801 for (size_t i=0; i != c->size(); ++i, ++m ); 802 *m = c->test(i);; 803 return nullptr;; 804 }; 805 static void destruct(void*,size_t) {; 806 // Nothing to destruct.; 807 }; 808 ; 809 //static const bool fgLargeIterator = sizeof(typename Cont_t::iterator) > fgIteratorArenaSize;; 810 //typedef Iterators<Cont_t,fgLargeIterator> Iterators_t;; 811 ; 812 struct Iterators {; 813 union PtrSize_t { size_t fIndex; void *fAddress; };; 814 typedef std::pair<PtrSize_t,Bool_t> iterator;; 815 // In the end iterator we store the bitset pointer; 816 // and do not use the 'second' part of the pair.; 817 // In the other iterator we store the index; 818 // and the value.; 819 ; 820 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 821 iterator *begin = new (*begin_arena) iterator;; 822 begin->first.fIndex = 0;; 823 begin->second = false;; 824 iterator *end = new (*end_arena) iterator;; 825 end->first.fAddress = coll;; 826 end->second = false;; 827 }; 828 static void* copy(void *dest_arena, const void *source_ptr) {; 829 const iterator ",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:29254,Testability,test,test,29254,"e_t,Bool_t> iterator;; 815 // In the end iterator we store the bitset pointer; 816 // and do not use the 'second' part of the pair.; 817 // In the other iterator we store the index; 818 // and the value.; 819 ; 820 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 821 iterator *begin = new (*begin_arena) iterator;; 822 begin->first.fIndex = 0;; 823 begin->second = false;; 824 iterator *end = new (*end_arena) iterator;; 825 end->first.fAddress = coll;; 826 end->second = false;; 827 }; 828 static void* copy(void *dest_arena, const void *source_ptr) {; 829 const iterator *source = (const iterator *)(source_ptr);; 830 new (dest_arena) iterator(*source);; 831 return dest_arena;; 832 }; 833 static void* next(void *iter_loc, const void *end_loc) {; 834 const iterator *end = (const iterator *)(end_loc);; 835 PCont_t c = (PCont_t)end->first.fAddress;; 836 iterator *iter = (iterator *)(iter_loc);; 837 if (iter->first.fIndex != c->size()) {; 838 iter->second = c->test(iter->first.fIndex);; 839 ++(iter->first.fIndex);; 840 return &(iter->second);; 841 } else {; 842 return nullptr;; 843 }; 844 }; 845 static void destruct1(void *iter_ptr) {; 846 iterator *start = (iterator *)(iter_ptr);; 847 start->~iterator();; 848 }; 849 static void destruct2(void *begin_ptr, void *end_ptr) {; 850 iterator *start = (iterator *)(begin_ptr);; 851 iterator *end = (iterator *)(end_ptr);; 852 start->~iterator();; 853 end->~iterator();; 854 }; 855 };; 856 typedef Iterators Iterators_t;; 857 };; 858 ; 859 template <typename Bitset_t>; 860 struct TCollectionProxyInfo::Pushback<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > {; 861 using InfoBase_t = TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> >;; 862 using typename InfoBase_t::Cont_t;; 863 using typename InfoBase_t::Iter_t;; 864 using typename InfoBase_t::Value_t;; 865 using typename InfoBase_t::Env_t;; 866 using typename",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:10422,Usability,clear,clear,10422,"st<T,ALLOCATOR>& c) {return std::distance(c.begin(),c.end());}; 282 };; 283 ; 284 /** @class ROOT::Detail::TCollectionProxyInfo::Type; 285 *; 286 * Small helper to encapsulate basic data accesses for; 287 * all STL continers.; 288 *; 289 * @author M.Frank; 290 * @version 1.0; 291 * @date 10/10/2004; 292 */; 293 template <class T> struct Type; 294 : public Address<TYPENAME T::const_reference>; 295 {; 296 typedef T Cont_t;; 297 typedef typename T::iterator Iter_t;; 298 typedef typename T::value_type Value_t;; 299 typedef Environ<Iter_t> Env_t;; 300 typedef Env_t *PEnv_t;; 301 typedef Cont_t *PCont_t;; 302 typedef Value_t *PValue_t;; 303 ; 304 virtual ~Type() {}; 305 ; 306 static inline PCont_t object(void* ptr) {; 307 return PCont_t(PEnv_t(ptr)->fObject);; 308 }; 309 static void* size(void* env) {; 310 PEnv_t e = PEnv_t(env);; 311 e->fSize = SfinaeHelper::GetContainerSize(*PCont_t(e->fObject));; 312 return &e->fSize;; 313 }; 314 static void* clear(void* env) {; 315 object(env)->clear();; 316 return nullptr;; 317 }; 318 static void* first(void* env) {; 319 PEnv_t e = PEnv_t(env);; 320 PCont_t c = PCont_t(e->fObject);; 321#if 0; 322 // Assume iterators do not need destruction; 323 ::new(e->buff) Iter_t(c->begin());; 324#endif; 325 e->fIterator = c->begin();; 326 e->fSize = SfinaeHelper::GetContainerSize(*c);; 327 if ( 0 == e->fSize ) return e->fStart = nullptr;; 328 TYPENAME T::const_reference ref = *(e->iter());; 329 return e->fStart = Type<T>::address(ref);; 330 }; 331 static void* next(void* env) {; 332 PEnv_t e = PEnv_t(env);; 333 PCont_t c = PCont_t(e->fObject);; 334 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 335 // TODO: Need to find something for going backwards....; 336 if ( e->iter() == c->end() ) return nullptr;; 337 TYPENAME T::const_reference ref = *(e->iter());; 338 return Type<T>::address(ref);; 339 }; 340 static void* construct(void *what, size_t size) {; 341 PValue_t m = PValue_t(what);; 342 for (size_t i=0; i<size; ++i, +",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:10459,Usability,clear,clear,10459,"st<T,ALLOCATOR>& c) {return std::distance(c.begin(),c.end());}; 282 };; 283 ; 284 /** @class ROOT::Detail::TCollectionProxyInfo::Type; 285 *; 286 * Small helper to encapsulate basic data accesses for; 287 * all STL continers.; 288 *; 289 * @author M.Frank; 290 * @version 1.0; 291 * @date 10/10/2004; 292 */; 293 template <class T> struct Type; 294 : public Address<TYPENAME T::const_reference>; 295 {; 296 typedef T Cont_t;; 297 typedef typename T::iterator Iter_t;; 298 typedef typename T::value_type Value_t;; 299 typedef Environ<Iter_t> Env_t;; 300 typedef Env_t *PEnv_t;; 301 typedef Cont_t *PCont_t;; 302 typedef Value_t *PValue_t;; 303 ; 304 virtual ~Type() {}; 305 ; 306 static inline PCont_t object(void* ptr) {; 307 return PCont_t(PEnv_t(ptr)->fObject);; 308 }; 309 static void* size(void* env) {; 310 PEnv_t e = PEnv_t(env);; 311 e->fSize = SfinaeHelper::GetContainerSize(*PCont_t(e->fObject));; 312 return &e->fSize;; 313 }; 314 static void* clear(void* env) {; 315 object(env)->clear();; 316 return nullptr;; 317 }; 318 static void* first(void* env) {; 319 PEnv_t e = PEnv_t(env);; 320 PCont_t c = PCont_t(e->fObject);; 321#if 0; 322 // Assume iterators do not need destruction; 323 ::new(e->buff) Iter_t(c->begin());; 324#endif; 325 e->fIterator = c->begin();; 326 e->fSize = SfinaeHelper::GetContainerSize(*c);; 327 if ( 0 == e->fSize ) return e->fStart = nullptr;; 328 TYPENAME T::const_reference ref = *(e->iter());; 329 return e->fStart = Type<T>::address(ref);; 330 }; 331 static void* next(void* env) {; 332 PEnv_t e = PEnv_t(env);; 333 PCont_t c = PCont_t(e->fObject);; 334 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 335 // TODO: Need to find something for going backwards....; 336 if ( e->iter() == c->end() ) return nullptr;; 337 TYPENAME T::const_reference ref = *(e->iter());; 338 return Type<T>::address(ref);; 339 }; 340 static void* construct(void *what, size_t size) {; 341 PValue_t m = PValue_t(what);; 342 for (size_t i=0; i<size; ++i, +",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:20434,Usability,clear,clear,20434,"fCollectFunc(collect_func),; 562 fCreateEnv(create_env),; 563 fCreateIterators(getIterators),fCopyIterator(copyIterator),fNext(next),; 564 fDeleteSingleIterator(deleteSingleIterator),fDeleteTwoIterators(deleteTwoIterators); 565 {; 566 }; 567 ; 568 /// Generate proxy from template; 569 template <class T> static TCollectionProxyInfo* Generate(const T&) {; 570 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 571 // template (used to described the behavior of the stl collection.; 572 // Typical use looks like:; 573 // ::ROOT::Detail::TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 574 ; 575 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 576 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 577 return new TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 578 sizeof(TYPENAME T::Iter_t),; 579 (((char*)&p->second)-((char*)&p->first)),; 580 T::value_offset(),; 581 T::size,; 582 T::resize,; 583 T::clear,; 584 T::first,; 585 T::next,; 586 T::construct,; 587 T::destruct,; 588 T::feed,; 589 T::collect,; 590 T::Env_t::Create,; 591 T::Iterators_t::create,; 592 T::Iterators_t::copy,; 593 T::Iterators_t::next,; 594 T::Iterators_t::destruct1,; 595 T::Iterators_t::destruct2);; 596 }; 597 ; 598 template <class T> static TCollectionProxyInfo Get(const T&) {; 599 ; 600 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 601 // template (used to described the behavior of the stl collection.; 602 // Typical use looks like:; 603 // ::ROOT::Detail::TCollectionProxyInfo::Get(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 604 ; 605 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 606 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 607 return TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 608 sizeof(TYPENAME T::Iter_t),; 609 (((char*)&p->second)-((char*)&p->first)),; 610 T::value_offset(),; 611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::firs",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:21424,Usability,clear,clear,21424," 579 (((char*)&p->second)-((char*)&p->first)),; 580 T::value_offset(),; 581 T::size,; 582 T::resize,; 583 T::clear,; 584 T::first,; 585 T::next,; 586 T::construct,; 587 T::destruct,; 588 T::feed,; 589 T::collect,; 590 T::Env_t::Create,; 591 T::Iterators_t::create,; 592 T::Iterators_t::copy,; 593 T::Iterators_t::next,; 594 T::Iterators_t::destruct1,; 595 T::Iterators_t::destruct2);; 596 }; 597 ; 598 template <class T> static TCollectionProxyInfo Get(const T&) {; 599 ; 600 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 601 // template (used to described the behavior of the stl collection.; 602 // Typical use looks like:; 603 // ::ROOT::Detail::TCollectionProxyInfo::Get(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 604 ; 605 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 606 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 607 return TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 608 sizeof(TYPENAME T::Iter_t),; 609 (((char*)&p->second)-((char*)&p->first)),; 610 T::value_offset(),; 611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::first,; 615 T::next,; 616 T::construct,; 617 T::destruct,; 618 T::feed,; 619 T::collect,; 620 T::Env_t::Create);; 621 }; 622 ; 623 };; 624 ; 625 // This specialization is chosen if T is a vector<bool, A>, irrespective of the nature; 626 // of the allocator A represents.; 627 template <class A> struct TCollectionProxyInfo::Type<std::vector<Bool_t, A>>; 628 : public TCollectionProxyInfo::Address<typename std::vector<Bool_t, A>::const_reference>; 629 {; 630 typedef std::vector<Bool_t, A> Cont_t;; 631 typedef typename Cont_t::iterator Iter_t;; 632 typedef typename Cont_t::value_type Value_t;; 633 typedef Environ<Iter_t> Env_t;; 634 typedef Env_t *PEnv_t;; 635 typedef Cont_t *PCont_t;; 636 typedef Value_t *PValue_t;; 637 ; 638 virtual ~Type() {}; 639 ; 640 static inline PCont_t object(void* ptr) {; 641 return PCont_t(PEnv_t(ptr)->fObject);; 642 }; 643 static void* size(void* env)",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:22451,Usability,clear,clear,22451,"611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::first,; 615 T::next,; 616 T::construct,; 617 T::destruct,; 618 T::feed,; 619 T::collect,; 620 T::Env_t::Create);; 621 }; 622 ; 623 };; 624 ; 625 // This specialization is chosen if T is a vector<bool, A>, irrespective of the nature; 626 // of the allocator A represents.; 627 template <class A> struct TCollectionProxyInfo::Type<std::vector<Bool_t, A>>; 628 : public TCollectionProxyInfo::Address<typename std::vector<Bool_t, A>::const_reference>; 629 {; 630 typedef std::vector<Bool_t, A> Cont_t;; 631 typedef typename Cont_t::iterator Iter_t;; 632 typedef typename Cont_t::value_type Value_t;; 633 typedef Environ<Iter_t> Env_t;; 634 typedef Env_t *PEnv_t;; 635 typedef Cont_t *PCont_t;; 636 typedef Value_t *PValue_t;; 637 ; 638 virtual ~Type() {}; 639 ; 640 static inline PCont_t object(void* ptr) {; 641 return PCont_t(PEnv_t(ptr)->fObject);; 642 }; 643 static void* size(void* env) {; 644 PEnv_t e = PEnv_t(env);; 645 e->fSize = PCont_t(e->fObject)->size();; 646 return &e->fSize;; 647 }; 648 static void* clear(void* env) {; 649 object(env)->clear();; 650 return nullptr;; 651 }; 652 static void* first(void* env) {; 653 PEnv_t e = PEnv_t(env);; 654 PCont_t c = PCont_t(e->fObject);; 655#if 0; 656 // Assume iterators do not need destruction; 657 ::new(e->buff) Iter_t(c->begin());; 658#endif; 659 e->fIterator = c->begin();; 660 e->fSize = c->size();; 661 return nullptr;; 662 }; 663 static void* next(void* env) {; 664 PEnv_t e = PEnv_t(env);; 665 PCont_t c = PCont_t(e->fObject);; 666 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 667 // TODO: Need to find something for going backwards....; 668 return nullptr;; 669 }; 670 static void* construct(void*,size_t) {; 671 // Nothing to construct.; 672 return nullptr;; 673 }; 674 static void* collect(void *coll, void *array) {; 675 PCont_t c = PCont_t(coll);; 676 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 677 for (Iter_t i=c->",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:22488,Usability,clear,clear,22488,"611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::first,; 615 T::next,; 616 T::construct,; 617 T::destruct,; 618 T::feed,; 619 T::collect,; 620 T::Env_t::Create);; 621 }; 622 ; 623 };; 624 ; 625 // This specialization is chosen if T is a vector<bool, A>, irrespective of the nature; 626 // of the allocator A represents.; 627 template <class A> struct TCollectionProxyInfo::Type<std::vector<Bool_t, A>>; 628 : public TCollectionProxyInfo::Address<typename std::vector<Bool_t, A>::const_reference>; 629 {; 630 typedef std::vector<Bool_t, A> Cont_t;; 631 typedef typename Cont_t::iterator Iter_t;; 632 typedef typename Cont_t::value_type Value_t;; 633 typedef Environ<Iter_t> Env_t;; 634 typedef Env_t *PEnv_t;; 635 typedef Cont_t *PCont_t;; 636 typedef Value_t *PValue_t;; 637 ; 638 virtual ~Type() {}; 639 ; 640 static inline PCont_t object(void* ptr) {; 641 return PCont_t(PEnv_t(ptr)->fObject);; 642 }; 643 static void* size(void* env) {; 644 PEnv_t e = PEnv_t(env);; 645 e->fSize = PCont_t(e->fObject)->size();; 646 return &e->fSize;; 647 }; 648 static void* clear(void* env) {; 649 object(env)->clear();; 650 return nullptr;; 651 }; 652 static void* first(void* env) {; 653 PEnv_t e = PEnv_t(env);; 654 PCont_t c = PCont_t(e->fObject);; 655#if 0; 656 // Assume iterators do not need destruction; 657 ::new(e->buff) Iter_t(c->begin());; 658#endif; 659 e->fIterator = c->begin();; 660 e->fSize = c->size();; 661 return nullptr;; 662 }; 663 static void* next(void* env) {; 664 PEnv_t e = PEnv_t(env);; 665 PCont_t c = PCont_t(e->fObject);; 666 for (; e->fIdx > 0 && e->iter() != c->end(); ++(e->iter()), --e->fIdx){ }; 667 // TODO: Need to find something for going backwards....; 668 return nullptr;; 669 }; 670 static void* construct(void*,size_t) {; 671 // Nothing to construct.; 672 return nullptr;; 673 }; 674 static void* collect(void *coll, void *array) {; 675 PCont_t c = PCont_t(coll);; 676 PValue_t m = PValue_t(array); // 'start' is a buffer outside the container.; 677 for (Iter_t i=c->",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:26771,Usability,clear,clear,26771,"def std::vector<Bool_t, A> Cont_t;; 722 typedef typename Cont_t::iterator Iter_t;; 723 typedef typename Cont_t::value_type Value_t;; 724 typedef Environ<Iter_t> Env_t;; 725 typedef Env_t *PEnv_t;; 726 typedef Cont_t *PCont_t;; 727 typedef Value_t *PValue_t;; 728 ; 729 static void resize(void* obj,size_t n) {; 730 PCont_t c = PCont_t(obj);; 731 c->resize(n);; 732 }; 733 static void* feed(void* from, void *to, size_t size) {; 734 PCont_t c = PCont_t(to);; 735 PValue_t m = PValue_t(from);; 736 for (size_t i=0; i<size; ++i, ++m); 737 c->push_back(*m);; 738 return nullptr;; 739 }; 740 static int value_offset() {; 741 return 0;; 742 }; 743 };; 744 ; 745 // Need specialization for boolean references due to stupid STL std::vector<bool>; 746 template <class A> struct TCollectionProxyInfo::Address<std::vector<Bool_t, A>> {; 747 virtual ~Address() {}; 748 static void* address(typename std::vector<Bool_t, A>::const_reference) {; 749 R__ASSERT(false && ""Intentionally not implemented, should use VectorLooper or other functions specialized for ""; 750 ""vector<bool> instead"");; 751 return {};; 752 }; 753 };; 754 ; 755 template <typename Bitset_t> struct TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Address<const Bool_t &>; 756 {; 757 typedef Bitset_t Cont_t;; 758 typedef std::pair<size_t,Bool_t> Iter_t;; 759 typedef Bool_t Value_t;; 760 typedef Environ<Iter_t> Env_t;; 761 typedef Env_t *PEnv_t;; 762 typedef Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:51701,Usability,clear,clearstatic,51701,"::Type< Internal::TStdBitsetHelper< Bitset_t > >::constructstatic void * construct(void *, size_t)Definition TCollectionProxyInfo.h:794; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::collectstatic void * collect(void *coll, void *array)Definition TCollectionProxyInfo.h:798; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:787; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:762; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Iterators_tIterators Iterators_tDefinition TCollectionProxyInfo.h:856; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:779; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:775; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Deta",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:51720,Usability,clear,clear,51720,"::Type< Internal::TStdBitsetHelper< Bitset_t > >::constructstatic void * construct(void *, size_t)Definition TCollectionProxyInfo.h:794; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::collectstatic void * collect(void *coll, void *array)Definition TCollectionProxyInfo.h:798; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:787; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:762; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Iterators_tIterators Iterators_tDefinition TCollectionProxyInfo.h:856; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:779; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:775; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Deta",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:52850,Usability,clear,clearstatic,52850,"Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Detail::TCollectionProxyInfo::Type::fgLargeIteratorstatic const bool fgLargeIteratorDefinition TCollectionProxyInfo.h:359; ROOT::Detail::TCollectionProxyInfo::Type::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:314; ROOT::Detail::TCollectionProxyInfo::Type::destructstatic void destruct(void *what, size_t size)Definition TCollectionProxyInfo.h:353; ROOT::Detail::TCollectionProxyInfo::Type::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:318; ROOT::Detail::TCollectionProxyInfo::Type::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:309; ROOT::Detail::TCollectionProxyInfo::Type::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:297; ROOT::Detail::TCollectionProxyInfo::Type::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:296; ROOT::Detail::TCollectionProxyInfo::Type::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:302; ROOT::Detail::TCollectionProxyInfo::Type::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:301; ROOT::Detail::TCollectionProxyInfo::Type::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:331; ROOT::Detail::TCollectionProxyInfo::Type::Valu",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:52869,Usability,clear,clear,52869,"Env_tEnviron< Iter_t > Env_tDefinition TCollectionProxyInfo.h:760; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:770; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::objectstatic PCont_t object(void *ptr)Definition TCollectionProxyInfo.h:767; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:761; ROOT::Detail::TCollectionProxyInfo::Type< Internal::TStdBitsetHelper< Bitset_t > >::Cont_tBitset_t Cont_tDefinition TCollectionProxyInfo.h:757; ROOT::Detail::TCollectionProxyInfo::TypeSmall helper to encapsulate basic data accesses for all STL continers.Definition TCollectionProxyInfo.h:295; ROOT::Detail::TCollectionProxyInfo::Type::fgLargeIteratorstatic const bool fgLargeIteratorDefinition TCollectionProxyInfo.h:359; ROOT::Detail::TCollectionProxyInfo::Type::clearstatic void * clear(void *env)Definition TCollectionProxyInfo.h:314; ROOT::Detail::TCollectionProxyInfo::Type::destructstatic void destruct(void *what, size_t size)Definition TCollectionProxyInfo.h:353; ROOT::Detail::TCollectionProxyInfo::Type::firststatic void * first(void *env)Definition TCollectionProxyInfo.h:318; ROOT::Detail::TCollectionProxyInfo::Type::sizestatic void * size(void *env)Definition TCollectionProxyInfo.h:309; ROOT::Detail::TCollectionProxyInfo::Type::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:297; ROOT::Detail::TCollectionProxyInfo::Type::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:296; ROOT::Detail::TCollectionProxyInfo::Type::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:302; ROOT::Detail::TCollectionProxyInfo::Type::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:301; ROOT::Detail::TCollectionProxyInfo::Type::nextstatic void * next(void *env)Definition TCollectionProxyInfo.h:331; ROOT::Detail::TCollectionProxyInfo::Type::Valu",MatchSource.WIKI,doc/master/TCollectionProxyInfo_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:8327,Availability,error,error,8327,";; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 va_list ap;; 211 va_start(ap, va_(obj1));; 212 TObject *obj;; 213 ; 214 Add(va_(obj1));; 215 while ((obj = va_arg(ap, TObject *))); 216 Add(obj);; 217 va_end(ap);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Make sure all objects in this collection inherit from class cl.; 222 ; 223Bool_t TCollection::AssertClass(TClass *cl) const; 224{; 225 TObject *obj;; 226 TIter next(this);; 227 Bool_t error = kFALSE;; 228 ; 229 if (!cl) {; 230 Error(""AssertClass"", ""class == 0"");; 231 return kTRUE;; 232 }; 233 ; 234 for (int i = 0; (obj = next()); i++); 235 if (!obj->InheritsFrom(cl)) {; 236 Error(""AssertClass"", ""element %d is not an instance of class %s (%s)"",; 237 i, cl->GetName(), obj->ClassName());; 238 error = kTRUE;; 239 }; 240 return error;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244/// Browse this collection (called by TBrowser).; 245/// If b=0, there is no Browse call TObject::Browse(0) instead.; 246/// This means TObject::Inspect() will be invoked indirectly; 247 ; 248void TCollection::Browse(TBrowser *b); 249{; 250 TIter next(this);; 251 TObject *obj;; 252 ; 253 if (b); 254 while ((obj = next())) b->Add(obj);; 255 else; 256 TObject::Browse(b);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Make a clone of an collection using the Streamer facility.; 261/// If newname is specified, this will be the name of the new collection.; 262 ; 263TObject *TCollection::Clone(const char *newname) const; 264{; 265 TCollection *new_collection = (TCollection*)TOb",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:8638,Availability,error,error,8638,";; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 va_list ap;; 211 va_start(ap, va_(obj1));; 212 TObject *obj;; 213 ; 214 Add(va_(obj1));; 215 while ((obj = va_arg(ap, TObject *))); 216 Add(obj);; 217 va_end(ap);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Make sure all objects in this collection inherit from class cl.; 222 ; 223Bool_t TCollection::AssertClass(TClass *cl) const; 224{; 225 TObject *obj;; 226 TIter next(this);; 227 Bool_t error = kFALSE;; 228 ; 229 if (!cl) {; 230 Error(""AssertClass"", ""class == 0"");; 231 return kTRUE;; 232 }; 233 ; 234 for (int i = 0; (obj = next()); i++); 235 if (!obj->InheritsFrom(cl)) {; 236 Error(""AssertClass"", ""element %d is not an instance of class %s (%s)"",; 237 i, cl->GetName(), obj->ClassName());; 238 error = kTRUE;; 239 }; 240 return error;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244/// Browse this collection (called by TBrowser).; 245/// If b=0, there is no Browse call TObject::Browse(0) instead.; 246/// This means TObject::Inspect() will be invoked indirectly; 247 ; 248void TCollection::Browse(TBrowser *b); 249{; 250 TIter next(this);; 251 TObject *obj;; 252 ; 253 if (b); 254 while ((obj = next())) b->Add(obj);; 255 else; 256 TObject::Browse(b);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Make a clone of an collection using the Streamer facility.; 261/// If newname is specified, this will be the name of the new collection.; 262 ; 263TObject *TCollection::Clone(const char *newname) const; 264{; 265 TCollection *new_collection = (TCollection*)TOb",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:8672,Availability,error,error,8672,";; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 va_list ap;; 211 va_start(ap, va_(obj1));; 212 TObject *obj;; 213 ; 214 Add(va_(obj1));; 215 while ((obj = va_arg(ap, TObject *))); 216 Add(obj);; 217 va_end(ap);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Make sure all objects in this collection inherit from class cl.; 222 ; 223Bool_t TCollection::AssertClass(TClass *cl) const; 224{; 225 TObject *obj;; 226 TIter next(this);; 227 Bool_t error = kFALSE;; 228 ; 229 if (!cl) {; 230 Error(""AssertClass"", ""class == 0"");; 231 return kTRUE;; 232 }; 233 ; 234 for (int i = 0; (obj = next()); i++); 235 if (!obj->InheritsFrom(cl)) {; 236 Error(""AssertClass"", ""element %d is not an instance of class %s (%s)"",; 237 i, cl->GetName(), obj->ClassName());; 238 error = kTRUE;; 239 }; 240 return error;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244/// Browse this collection (called by TBrowser).; 245/// If b=0, there is no Browse call TObject::Browse(0) instead.; 246/// This means TObject::Inspect() will be invoked indirectly; 247 ; 248void TCollection::Browse(TBrowser *b); 249{; 250 TIter next(this);; 251 TObject *obj;; 252 ; 253 if (b); 254 while ((obj = next())) b->Add(obj);; 255 else; 256 TObject::Browse(b);; 257}; 258 ; 259////////////////////////////////////////////////////////////////////////////////; 260/// Make a clone of an collection using the Streamer facility.; 261/// If newname is specified, this will be the name of the new collection.; 262 ; 263TObject *TCollection::Clone(const char *newname) const; 264{; 265 TCollection *new_collection = (TCollection*)TOb",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:28649,Availability,error,error,28649,"2{; 833 return cl->InheritsFrom(base);; 834}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TClass.h; gCollectionMutexTVirtualMutex * gCollectionMutexDefinition TCollection.cxx:52; TCollection.h; gCollectionMutexR__EXTERN TVirtualMutex * gCollectionMutexDefinition TCollection.h:45; R__FOR_EACH#define R__FOR_EACH(type, proc)Definition TCollection.h:373; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TObjArray.h; TObjectTable.h; TPRegexp.h; TROOT.h; TRegexp.h; TSpinLockGuard.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; Varargs.h; va_#define va_(arg)Definition Varargs.h:35; ROOT::Internal::TSpinLockGuardA spin mutex-as-code-guard class.Definition TSpinLockGuard.h:35; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent cl",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:38697,Availability,error,error,38697,"YS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPRegexpDefinition TPRegexp.h:36; TPRegexp::MatchBBool_t MatchB(const TString &s, const TString &mods="""", Int_t start=0, Int_t nMaxMatch=10)Definition TPRegexp.h:78; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegula",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:1588,Deployability,release,release,1588,"*********************/; 11 ; 12/** \class TCollection; 13\ingroup Containers; 14Collection abstract base class. This class describes the base; 15protocol all collection classes have to implement. The ROOT; 16collection classes always store pointers to objects that inherit; 17from TObject. They never adopt the objects. Therefore, it is the; 18user's responsibility to take care of deleting the actual objects; 19once they are not needed anymore. In exceptional cases, when the; 20user is 100% sure nothing else is referencing the objects in the; 21collection, one can delete all objects and the collection at the; 22same time using the Delete() function.; 23 ; 24Collections can be iterated using an iterator object (see; 25TIterator). Depending on the concrete collection class there may be; 26some additional methods of iterating. See the respective classes.; 27 ; 28TCollection inherits from TObject since we want to be able to have; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto l",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:11743,Energy Efficiency,efficient,efficient,11743,"d an object in this collection using its name. Requires a sequential; 309/// scan till the object has been found. Returns 0 if object with specified; 310/// name is not found.; 311 ; 312TObject *TCollection::FindObject(const char *name) const; 313{; 314 TIter next(this);; 315 TObject *obj;; 316 ; 317 while ((obj = next())); 318 if (!strcmp(name, obj->GetName())) return obj;; 319 return nullptr;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// Find an object in this collection by name.; 324 ; 325TObject *TCollection::operator()(const char *name) const; 326{; 327 return FindObject(name);; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Find an object in this collection using the object's IsEqual(); 332/// member function. Requires a sequential scan till the object has; 333/// been found. Returns 0 if object is not found.; 334/// Typically this function is overridden by a more efficient version; 335/// in concrete collection classes (e.g. THashTable).; 336 ; 337TObject *TCollection::FindObject(const TObject *obj) const; 338{; 339 TIter next(this);; 340 TObject *ob;; 341 ; 342 while ((ob = next())); 343 if (ob->IsEqual(obj)) return ob;; 344 return nullptr;; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// Return name of this collection.; 349/// if no name, return the collection class name.; 350 ; 351const char *TCollection::GetName() const; 352{; 353 if (fName.Length() > 0) return fName.Data();; 354 return ClassName();; 355}; 356 ; 357////////////////////////////////////////////////////////////////////////////////; 358/// Increase the collection's capacity by delta slots.; 359 ; 360Int_t TCollection::GrowBy(Int_t delta) const; 361{; 362 if (delta < 0) {; 363 Error(""GrowBy"", ""delta < 0"");; 364 delta = Capacity();; 365 }; 366 return Capacity() + TMath::Range(2, kMaxInt - Capacity(), delta);; 367}; 368 ; 369//",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:24920,Integrability,depend,depending,24920,"14 if (fgGarbageCollection && fgGarbageStack == 0 && fgEmptyingGarbage == kFALSE) {; 715 fgEmptyingGarbage = kTRUE;; 716 fgGarbageCollection->Delete();; 717 fgEmptyingGarbage = kFALSE;; 718 SafeDelete(fgGarbageCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 77",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:38703,Integrability,message,message,38703,"YS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPRegexpDefinition TPRegexp.h:36; TPRegexp::MatchBBool_t MatchB(const TString &s, const TString &mods="""", Int_t start=0, Int_t nMaxMatch=10)Definition TPRegexp.h:78; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegula",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:40404,Integrability,interface,interface,40404,"the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; object; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::RangeShort_t Range(Short_t lb, Short_t ub, Short_t x)Returns x if lb < x < up, lb if x < lb and ub if x > ub.Definition TMathBase.h:302; v@ vDefinition rootcling_impl.cxx:3699. corecontsrcTCollection.cxx. ROOT master - Reference Gui",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:866,Modifiability,inherit,inherit,866,". ROOT: core/cont/src/TCollection.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCollection.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCollection; 13\ingroup Containers; 14Collection abstract base class. This class describes the base; 15protocol all collection classes have to implement. The ROOT; 16collection classes always store pointers to objects that inherit; 17from TObject. They never adopt the objects. Therefore, it is the; 18user's responsibility to take care of deleting the actual objects; 19once they are not needed anymore. In exceptional cases, when the; 20user is 100% sure nothing else is referencing the objects in the; 21collection, one can delete all objects and the collection at the; 22same time using the Delete() function.; 23 ; 24Collections can be iterated using an iterator object (see; 25TIterator). Depending on the concrete collection class there may be; 26some additional methods of iterating. See the respective classes.; 27 ; 28TCollection inherits from TObject since we want to be able to have; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:1483,Modifiability,inherit,inherits,1483,"ee $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCollection; 13\ingroup Containers; 14Collection abstract base class. This class describes the base; 15protocol all collection classes have to implement. The ROOT; 16collection classes always store pointers to objects that inherit; 17from TObject. They never adopt the objects. Therefore, it is the; 18user's responsibility to take care of deleting the actual objects; 19once they are not needed anymore. In exceptional cases, when the; 20user is 100% sure nothing else is referencing the objects in the; 21collection, one can delete all objects and the collection at the; 22same time using the Delete() function.; 23 ; 24Collections can be iterated using an iterator object (see; 25TIterator). Depending on the concrete collection class there may be; 26some additional methods of iterating. See the respective classes.; 27 ; 28TCollection inherits from TObject since we want to be able to have; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *ac",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:4558,Modifiability,variab,variable,4558,": tmp) {; 88 std::stringstream reader;; 89 reader << ""0x"" << std::hex << r;; 90 ::Error(function, "" Readers includes %s"", reader.str().c_str());; 91 }; 92 gSystem->StackTrace();; 93}; 94 ; 95void TCollection::TErrorLock::Lock(const TCollection *collection, const char *function); 96{; 97 auto local = std::this_thread::get_id();; 98 ; 99 std::thread::id holder;; 100 ; 101 if (fWriteCurrent.compare_exchange_strong(holder, local)) {; 102 // fWriteCurrent was the default id and is now local.; 103 ++fWriteCurrentRecurse;; 104 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" acquired first "" << collection << "" lock:"" << this <<; 105 // std::endl;; 106 ; 107 // Now check if there is any readers lingering; 108 if (fReadCurrentRecurse) {; 109 if (fReadSet.size() > 1 || fReadSet.find(local) != fReadSet.end()) {; 110 ConflictReport(std::thread::id(), ""WriteLock while ReadLock taken"", collection, function);; 111 }; 112 }; 113 } else {; 114 // fWriteCurrent was not the default id and is still the 'holder' thread id; 115 // this id is now also in the holder variable; 116 if (holder == local) {; 117 // The holder was actually this thread, no problem there, we; 118 // allow re-entrancy.; 119 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" re-entered "" << fWriteCurrentRecurse << "" "" << collection; 120 // << "" lock:"" << this << std::endl;; 121 } else {; 122 ConflictReport(holder, ""WriteLock"", collection, function);; 123 }; 124 ++fWriteCurrentRecurse;; 125 }; 126}; 127 ; 128void TCollection::TErrorLock::Unlock(); 129{; 130 auto local = std::this_thread::get_id();; 131 auto none = std::thread::id();; 132 ; 133 --fWriteCurrentRecurse;; 134 if (fWriteCurrentRecurse == 0) {; 135 if (fWriteCurrent.compare_exchange_strong(local, none)) {; 136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << s",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:8184,Modifiability,inherit,inherit,8184,"/////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.; 194 ; 195void TCollection::AddAll(const TCollection *col); 196{; 197 TIter next(col);; 198 TObject *obj;; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 va_list ap;; 211 va_start(ap, va_(obj1));; 212 TObject *obj;; 213 ; 214 Add(va_(obj1));; 215 while ((obj = va_arg(ap, TObject *))); 216 Add(obj);; 217 va_end(ap);; 218}; 219 ; 220////////////////////////////////////////////////////////////////////////////////; 221/// Make sure all objects in this collection inherit from class cl.; 222 ; 223Bool_t TCollection::AssertClass(TClass *cl) const; 224{; 225 TObject *obj;; 226 TIter next(this);; 227 Bool_t error = kFALSE;; 228 ; 229 if (!cl) {; 230 Error(""AssertClass"", ""class == 0"");; 231 return kTRUE;; 232 }; 233 ; 234 for (int i = 0; (obj = next()); i++); 235 if (!obj->InheritsFrom(cl)) {; 236 Error(""AssertClass"", ""element %d is not an instance of class %s (%s)"",; 237 i, cl->GetName(), obj->ClassName());; 238 error = kTRUE;; 239 }; 240 return error;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244/// Browse this collection (called by TBrowser).; 245/// If b=0, there is no Browse call TObject::Browse(0) instead.; 246/// This means TObject::Inspect() will be invoked indirectly; 247 ; 248void TCollection::Browse(TBrowser *b); 249{; 250 TIter next(th",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:27537,Modifiability,inherit,inherits,27537," class and assigning it with the original.; 788 ; 789TIter &TIter::operator=(const TIter &rhs); 790{; 791 if (this != &rhs) {; 792 if (rhs.fIterator) {; 793 delete fIterator;; 794 fIterator = rhs.GetCollection()->MakeIterator();; 795 fIterator->operator=(*rhs.fIterator);; 796 }; 797 }; 798 return *this;; 799}; 800 ; 801////////////////////////////////////////////////////////////////////////////////; 802/// Pointing to the first element of the container.; 803 ; 804TIter &TIter::Begin(); 805{; 806 fIterator->Reset();; 807 fIterator->Next();; 808 return *this;; 809}; 810 ; 811////////////////////////////////////////////////////////////////////////////////; 812/// Pointing to the element after the last - to a nullptr value in our case.; 813 ; 814TIter TIter::End(); 815{; 816 return TIter(static_cast<TIterator*>(nullptr));; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Return an empty collection for use with nullptr TRangeCast; 821 ; 822const TCollection &ROOT::Internal::EmptyCollection(); 823{; 824 static TObjArray sEmpty;; 825 return sEmpty;; 826}; 827 ; 828////////////////////////////////////////////////////////////////////////////////; 829/// Return true if 'cl' inherits from 'base'.; 830 ; 831bool ROOT::Internal::ContaineeInheritsFrom(TClass *cl, TClass *base); 832{; 833 return cl->InheritsFrom(base);; 834}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TClass.h; gCo",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:29817,Modifiability,inherit,inherits,29817,"TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TObjArray.h; TObjectTable.h; TPRegexp.h; TROOT.h; TRegexp.h; TSpinLockGuard.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; Varargs.h; va_#define va_(arg)Definition Varargs.h:35; ROOT::Internal::TSpinLockGuardA spin mutex-as-code-guard class.Definition TSpinLockGuard.h:35; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::Drawvoid Draw(Option_t *option="""") overrideDraw all objects in this collection.Definition TCollection.cxx:284; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:31700,Modifiability,inherit,inherit,31700,"Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::Streamervoid Streamer(TBuffer &) overrideStream all objects in the collection to or from the I/O buffer.Definition TCollection.cxx:606; TCollection::kUseRWLock@ kUseRWLockDefinition TCollection.h:146; TCollection::kIsOwner@ kIsOwnerDefinition TCollection.h:144; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195; TCollection::GetNameconst char * GetName() c",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:38549,Modifiability,inherit,inherits,38549,".Definition TObject.cxx:444; TObject::Browsevirtual void Browse(TBrowser *b)Browse object. May be overridden for another default action.Definition TObject.cxx:204; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPRegexpDefinition TPRegexp.h:36; TPRegexp::MatchBBool_t MatchB(const TString &s, const TString &mods="""", Int_t start=0, Int_t nMaxMatch=10)Definition TPRegexp.h:78; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:40744,Modifiability,inherit,inherits,40744,"tatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; object; unsigned int; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; TMath::RangeShort_t Range(Short_t lb, Short_t ub, Short_t x)Returns x if lb < x < up, lb if x < lb and ub if x > ub.Definition TMathBase.h:302; v@ vDefinition rootcling_impl.cxx:3699. corecontsrcTCollection.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:5464,Performance,load,load,5464,"5 // this id is now also in the holder variable; 116 if (holder == local) {; 117 // The holder was actually this thread, no problem there, we; 118 // allow re-entrancy.; 119 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" re-entered "" << fWriteCurrentRecurse << "" "" << collection; 120 // << "" lock:"" << this << std::endl;; 121 } else {; 122 ConflictReport(holder, ""WriteLock"", collection, function);; 123 }; 124 ++fWriteCurrentRecurse;; 125 }; 126}; 127 ; 128void TCollection::TErrorLock::Unlock(); 129{; 130 auto local = std::this_thread::get_id();; 131 auto none = std::thread::id();; 132 ; 133 --fWriteCurrentRecurse;; 134 if (fWriteCurrentRecurse == 0) {; 135 if (fWriteCurrent.compare_exchange_strong(local, none)) {; 136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:5713,Performance,load,load,5713,"ion, function);; 123 }; 124 ++fWriteCurrentRecurse;; 125 }; 126}; 127 ; 128void TCollection::TErrorLock::Unlock(); 129{; 130 auto local = std::this_thread::get_id();; 131 auto none = std::thread::id();; 132 ; 133 --fWriteCurrentRecurse;; 134 if (fWriteCurrentRecurse == 0) {; 135 if (fWriteCurrent.compare_exchange_strong(local, none)) {; 136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 17",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:6105,Performance,load,load,6105,"136 // fWriteCurrent was local and is now none.; 137 ; 138 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero and cleaned : "" << std::dec << fWriteCurrentRecurse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*thi",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:6544,Performance,load,load,6544,"fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.; 194 ; 195void TCollection::AddAll(const TCollection *col); 196{; 197 TIter next(col);; 198 TObject *obj;; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the c",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:15011,Performance,perform,perform,15011,".Index(re) == kNPOS) continue;; 399 }; 400 object->ls(option);; 401 }; 402 TROOT::DecreaseDirLevel();; 403}; 404 ; 405////////////////////////////////////////////////////////////////////////////////; 406/// 'Notify' all objects in this collection.; 407Bool_t TCollection::Notify(); 408{; 409 Bool_t success = true;; 410 for (auto obj : *this) success &= obj->Notify();; 411 return success;; 412}; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Paint all objects in this collection.; 416 ; 417void TCollection::Paint(Option_t *option); 418{; 419 this->R__FOR_EACH(TObject,Paint)(option);; 420}; 421 ; 422////////////////////////////////////////////////////////////////////////////////; 423/// Print the collection header.; 424 ; 425void TCollection::PrintCollectionHeader(Option_t*) const; 426{; 427 TROOT::IndentLevel();; 428 printf(""Collection name='%s', class='%s', size=%d\n"",; 429 GetName(), ClassName(), GetSize());; 430}; 431 ; 432////////////////////////////////////////////////////////////////////////////////; 433/// For given collection entry return the string that is used to; 434/// identify the object and, potentially, perform wildcard/regexp; 435/// filtering on.; 436 ; 437const char* TCollection::GetCollectionEntryName(TObject* entry) const; 438{; 439 return entry->GetName();; 440}; 441 ; 442////////////////////////////////////////////////////////////////////////////////; 443/// Print the collection entry.; 444 ; 445void TCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; 446{; 447 TCollection* coll = dynamic_cast<TCollection*>(entry);; 448 if (coll) {; 449 coll->Print(option, recurse);; 450 } else {; 451 TROOT::IndentLevel();; 452 entry->Print(option);; 453 }; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Default print for collections, calls Print(option, 1).; 458/// This will print the collection header and Print() method",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:6428,Safety,safe,safe,6428,"curse; 139 // << "" 0x"" << std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 140 } else {; 141 // fWriteCurrent was not local, just live it as is.; 142 ; 143 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" zero but somebody else : "" << ""0x"" << std::hex <<; 144 // fWriteCurrent.load() << "" lock:"" << this << std::endl;; 145 }; 146 } else {; 147 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" still holding "" << ""0x"" << std::hex << fWriteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.;",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:6890,Safety,safe,safe,6890,"riteCurrentRecurse; 148 // << "" lock:"" << this << std::endl;; 149 }; 150 ; 151 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" ended with : "" << std::dec << fWriteCurrentRecurse << "" 0x"" <<; 152 // std::hex << fWriteCurrent.load() << "" lock:"" << this << std::endl;; 153}; 154 ; 155void TCollection::TErrorLock::ReadLock(const TCollection *collection, const char *function); 156{; 157 auto local = std::this_thread::get_id();; 158 ; 159 {; 160 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 161 fReadSet.insert(local); // this is not thread safe ...; 162 }; 163 ++fReadCurrentRecurse;; 164 ; 165 if (fWriteCurrentRecurse) {; 166 auto holder = fWriteCurrent.load();; 167 if (holder != local) ConflictReport(holder, ""ReadLock with WriteLock taken"", collection, function);; 168 }; 169}; 170 ; 171void TCollection::TErrorLock::ReadUnlock(); 172{; 173 auto local = std::this_thread::get_id();; 174 {; 175 ROOT::Internal::TSpinLockGuard guard(fSpinLockFlag);; 176 fReadSet.erase(local); // this is not thread safe ...; 177 }; 178 --fReadCurrentRecurse;; 179}; 180 ; 181#endif // R__CHECK_COLLECTION_MULTI_ACCESS; 182 ; 183////////////////////////////////////////////////////////////////////////////////; 184/// TNamed destructor.; 185 ; 186TCollection::~TCollection(); 187{; 188 // Required since we overload TObject::Hash.; 189 ROOT::CallRecursiveRemoveIfNeeded(*this);; 190}; 191 ; 192////////////////////////////////////////////////////////////////////////////////; 193/// Add all objects from collection col to this collection.; 194 ; 195void TCollection::AddAll(const TCollection *col); 196{; 197 TIter next(col);; 198 TObject *obj;; 199 ; 200 while ((obj = next())); 201 Add(obj);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Add all arguments to the collection. The list of objects must be; 206/// terminated by 0, e.g.: l.AddVector(o1, o2, o3, o4, 0);; 207 ; 208void TCollection::AddVector(TObject *va_(obj1), ...); 209{; 210 ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:25255,Safety,safe,safe,25255,"eCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:31471,Safety,safe,safe,31471,"tion.cxx:284; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::Streamervoid Streamer(TBuffer &) overrideStream all objects in the collection to or from the I/O buffer.Definition TCollection.cxx:606; TCollection::kUseRWLock@ kUseRWLockDefinition TCollection.h:146; TC",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:2513,Security,access,accesstype,2513,"e; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto local = std::this_thread::get_id();; 69 std::stringstream cur, loc;; 70 if (holder == std::thread::id()); 71 cur << ""None"";; 72 else; 73 cur << ""0x"" << std::hex << holder;; 74 loc << ""0x"" << std::hex << local;; 75 ; 76 // std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; 77 // collection->IsA()->GetName() << "":"" << collection <<; 78 // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; 79 // ""0x"" << std::hex << local << std::endl;; 80 ; 81 ::Error(function,; 82 ""Access (%s) to a collection (%s:%p) from multiple threads at a time. holder=%s readers=%lu intruder=%s"",; 83 accesstype, collection->IsA()->GetName(), collection, cur.str().c_str(), fReadSet.size(), loc.str().c_str());; 84 ; 85 std::set<std::thread::id> tmp;; 86 for (auto r : fReadSet) tmp.insert(r);; 87 for (auto r : tmp) {; 88 std::stringstream reader;; 89",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:2879,Security,access,accesstype,2879,"e; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto local = std::this_thread::get_id();; 69 std::stringstream cur, loc;; 70 if (holder == std::thread::id()); 71 cur << ""None"";; 72 else; 73 cur << ""0x"" << std::hex << holder;; 74 loc << ""0x"" << std::hex << local;; 75 ; 76 // std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; 77 // collection->IsA()->GetName() << "":"" << collection <<; 78 // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; 79 // ""0x"" << std::hex << local << std::endl;; 80 ; 81 ::Error(function,; 82 ""Access (%s) to a collection (%s:%p) from multiple threads at a time. holder=%s readers=%lu intruder=%s"",; 83 accesstype, collection->IsA()->GetName(), collection, cur.str().c_str(), fReadSet.size(), loc.str().c_str());; 84 ; 85 std::set<std::thread::id> tmp;; 86 for (auto r : fReadSet) tmp.insert(r);; 87 for (auto r : tmp) {; 88 std::stringstream reader;; 89",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:3285,Security,access,accesstype,3285,"Collection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto local = std::this_thread::get_id();; 69 std::stringstream cur, loc;; 70 if (holder == std::thread::id()); 71 cur << ""None"";; 72 else; 73 cur << ""0x"" << std::hex << holder;; 74 loc << ""0x"" << std::hex << local;; 75 ; 76 // std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; 77 // collection->IsA()->GetName() << "":"" << collection <<; 78 // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; 79 // ""0x"" << std::hex << local << std::endl;; 80 ; 81 ::Error(function,; 82 ""Access (%s) to a collection (%s:%p) from multiple threads at a time. holder=%s readers=%lu intruder=%s"",; 83 accesstype, collection->IsA()->GetName(), collection, cur.str().c_str(), fReadSet.size(), loc.str().c_str());; 84 ; 85 std::set<std::thread::id> tmp;; 86 for (auto r : fReadSet) tmp.insert(r);; 87 for (auto r : tmp) {; 88 std::stringstream reader;; 89 reader << ""0x"" << std::hex << r;; 90 ::Error(function, "" Readers includes %s"", reader.str().c_str());; 91 }; 92 gSystem->StackTrace();; 93}; 94 ; 95void TCollection::TErrorLock::Lock(const TCollection *collection, const char *function); 96{; 97 auto local = std::this_thread::get_id();; 98 ; 99 std::thread::id holder;; 100 ; 101 if (fWriteCurrent.compare_exchange_strong(holder, local)) {; 102 // fWriteCurrent was the default id and is now local.; 103 ++fWriteCurrentRecurse;; 104 // std::cerr << ""#"" << ""0x"" << std::hex << local << "" acquired first "" << collection << "" lock:"" << this <<; 105 // std::endl;; 106 ; 107 // Now check if there is any readers lingering; 108 if (fReadCurrentRecurse) {; 109 if (fReadSet.size() > 1 || fReadSet.find(local) != f",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:22840,Security,access,accessible,22840,"Write(const char *name, Int_t option, Int_t bsize) const; 649{; 650 if ((option & kSingleKey)) {; 651 return TObject::Write(name, option, bsize);; 652 } else {; 653 option &= ~kSingleKey;; 654 Int_t nbytes = 0;; 655 TIter next(this);; 656 TObject *obj;; 657 while ((obj = next())) {; 658 nbytes += obj->Write(name, option, bsize);; 659 }; 660 return nbytes;; 661 }; 662}; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Write all objects in this collection. By default all objects in; 666/// the collection are written individually (each object gets its; 667/// own key). Note, this is recursive, i.e. objects in collections; 668/// in the collection are also written individually. To write all; 669/// objects using a single key specify a name and set option to; 670/// TObject::kSingleKey (i.e. 1).; 671 ; 672Int_t TCollection::Write(const char *name, Int_t option, Int_t bsize); 673{; 674 return ((const TCollection*)this)->Write(name,option,bsize);; 675}; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Return the globally accessible collection.; 679 ; 680TCollection *TCollection::GetCurrentCollection(); 681{; 682 return fgCurrentCollection;; 683}; 684 ; 685////////////////////////////////////////////////////////////////////////////////; 686/// Set this collection to be the globally accessible collection.; 687 ; 688void TCollection::SetCurrentCollection(); 689{; 690 fgCurrentCollection = this;; 691}; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Set up for garbage collection.; 695 ; 696void TCollection::StartGarbageCollection(); 697{; 698 R__LOCKGUARD2(gCollectionMutex);; 699 if (!fgGarbageCollection) {; 700 fgGarbageCollection = new TObjectTable;; 701 fgEmptyingGarbage = kFALSE;; 702 fgGarbageStack = 0;; 703 }; 704 fgGarbageStack++;; 705}; 706 ; 707///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:23105,Security,access,accessible,23105,"; 658 nbytes += obj->Write(name, option, bsize);; 659 }; 660 return nbytes;; 661 }; 662}; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Write all objects in this collection. By default all objects in; 666/// the collection are written individually (each object gets its; 667/// own key). Note, this is recursive, i.e. objects in collections; 668/// in the collection are also written individually. To write all; 669/// objects using a single key specify a name and set option to; 670/// TObject::kSingleKey (i.e. 1).; 671 ; 672Int_t TCollection::Write(const char *name, Int_t option, Int_t bsize); 673{; 674 return ((const TCollection*)this)->Write(name,option,bsize);; 675}; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Return the globally accessible collection.; 679 ; 680TCollection *TCollection::GetCurrentCollection(); 681{; 682 return fgCurrentCollection;; 683}; 684 ; 685////////////////////////////////////////////////////////////////////////////////; 686/// Set this collection to be the globally accessible collection.; 687 ; 688void TCollection::SetCurrentCollection(); 689{; 690 fgCurrentCollection = this;; 691}; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Set up for garbage collection.; 695 ; 696void TCollection::StartGarbageCollection(); 697{; 698 R__LOCKGUARD2(gCollectionMutex);; 699 if (!fgGarbageCollection) {; 700 fgGarbageCollection = new TObjectTable;; 701 fgEmptyingGarbage = kFALSE;; 702 fgGarbageStack = 0;; 703 }; 704 fgGarbageStack++;; 705}; 706 ; 707////////////////////////////////////////////////////////////////////////////////; 708/// Do the garbage collection.; 709 ; 710void TCollection::EmptyGarbageCollection(); 711{; 712 R__LOCKGUARD2(gCollectionMutex);; 713 if (fgGarbageStack > 0) fgGarbageStack--;; 714 if (fgGarbageCollection && fgGarbageStack == 0 && fgEmptyingGarbage == kFALSE) {; 715 fgEmptyingG",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:25230,Security,access,access,25230,"eCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; ",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:30788,Security,access,accessible,30788,"t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::Drawvoid Draw(Option_t *option="""") overrideDraw all objects in this collection.Definition TCollection.cxx:284; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:30938,Security,access,accessible,30938,"tionCollection abstract base class.Definition TCollection.h:65; TCollection::Removevirtual TObject * Remove(TObject *obj)=0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::Drawvoid Draw(Option_t *option="""") overrideDraw all objects in this collection.Definition TCollection.cxx:284; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::lsvoid ls(Option_t *option="""") const overrideL",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:31446,Security,access,access,31446,"tion.cxx:284; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::Streamervoid Streamer(TBuffer &) overrideStream all objects in the collection to or from the I/O buffer.Definition TCollection.cxx:606; TCollection::kUseRWLock@ kUseRWLockDefinition TCollection.h:146; TC",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:36666,Security,hash,hash,36666,"jects in this collection.Definition TCollection.cxx:417; TIterDefinition TCollection.h:235; TIter::BeginTIter & Begin()Pointing to the first element of the container.Definition TCollection.cxx:804; TIter::GetCollectionconst TCollection * GetCollection() constDefinition TCollection.h:252; TIter::TIterTIter()Definition TCollection.h:241; TIter::Endstatic TIter End()Pointing to the element after the last - to a nullptr value in our case.Definition TCollection.cxx:814; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectTable::Addvoid Add(TObject *obj)Add an object to the object table.Definition TObjectTable.cxx:147; TObjectTable::Deletevoid Delete(Option_t *opt="""") overrideDelete all objects stored in the TObjectTable.Definition TObjectTable.cxx:195; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Notifyvirtual Bool_t Notify()This method must be overridden to handle object notification (the base implementation is no-op).Definition TObject.cxx:599; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::kSingleKey@ kSingleKeywrite collection with single keyDefinition TObject.h:91; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Browsevirtual void Browse(TBrowser *b)Browse object. May be overridden for an",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8cxx_source.html:25321,Testability,test,test,25321,"}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Assigning an TIter to another. This involves allocating a new TIterator; 787/// of the right sub class and assigning it with the original.; 788 ; 789TIter &TIter::operator=(const TIter &rhs); 790{; 791 if (this != &rhs) {; 792 if (rhs.fIterator) {; 793 delete fIterator;; 794 fIterator = rhs.GetCollection()->MakeIterator();; 795 fIt",MatchSource.WIKI,doc/master/TCollection_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html
https://root.cern/doc/master/TCollection_8h.html:2185,Energy Efficiency,adapt,adapter,2185," type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2370,Energy Efficiency,adapt,adapter,2370,"ock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLECTION_READ_GUARD. #define R__COLLECTION_READ_GUARD; (; ). Definition at line 128 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD. #define R__COLLECTION_READ_LOCKGUARD; (;  ; mute",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:5861,Energy Efficiency,adapt,adapter,5861,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTERN TVirtualMutex* gCollectionMutex. Definition at line 45 of file TCollection.h. ◆ kIterBackward. const Bool_t kIterBackward = !kIterForward. Definition at line 43 of file TCollection.h. ◆ kIterForward. const Bool_t kIterForward = kTRUE. Definition at line 42 of file TCollection.h. corecontincTCollection.h. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:393,Integrability,depend,dependency,393,". ROOT: core/cont/inc/TCollection.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TCollection.h File Reference. #include ""TObject.h""; #include ""TIterator.h""; #include ""TString.h""; #include ""TVirtualRWMutex.h""; #include ""ROOT/RRangeCast.hxx""; #include <cassert>. Include dependency graph for TCollection.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCollection;  Collection abstract base class. More...;  ; class  TIter;  ; class  TIterCategory< T >;  ; class  ROOT::Detail::TRangeCast< T, isDynamic >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,nam",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2185,Integrability,adapter,adapter,2185," type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2370,Integrability,adapter,adapter,2370,"ock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLECTION_READ_GUARD. #define R__COLLECTION_READ_GUARD; (; ). Definition at line 128 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD. #define R__COLLECTION_READ_LOCKGUARD; (;  ; mute",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:5861,Integrability,adapter,adapter,5861,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTERN TVirtualMutex* gCollectionMutex. Definition at line 45 of file TCollection.h. ◆ kIterBackward. const Bool_t kIterBackward = !kIterForward. Definition at line 43 of file TCollection.h. ◆ kIterForward. const Bool_t kIterForward = kTRUE. Definition at line 42 of file TCollection.h. corecontincTCollection.h. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:1167,Modifiability,inherit,inherits,1167,"ence. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TCollection.h File Reference. #include ""TObject.h""; #include ""TIterator.h""; #include ""TString.h""; #include ""TVirtualRWMutex.h""; #include ""ROOT/RRangeCast.hxx""; #include <cassert>. Include dependency graph for TCollection.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCollection;  Collection abstract base class. More...;  ; class  TIter;  ; class  TIterCategory< T >;  ; class  ROOT::Detail::TRangeCast< T, isDynamic >;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Detail;  Special implementation of ROOT::RRangeCast for TCollection, including a check that the cast target type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__F",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2185,Modifiability,adapt,adapter,2185," type inherits from TObject and a new constructor that takes the TCollection by pointer. ;  ; namespace  ROOT::Internal;  . Macros; #define R__COLL_COND_MUTEX(mutex)   this->IsUsingRWLock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2370,Modifiability,adapt,adapter,2370,"ock() ? mutex : nullptr;  ; #define R__COLLECTION_ITER_GUARD(collection);  ; #define R__COLLECTION_READ_GUARD();  ; #define R__COLLECTION_READ_LOCKGUARD(mutex)   ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLECTION_READ_GUARD. #define R__COLLECTION_READ_GUARD; (; ). Definition at line 128 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD. #define R__COLLECTION_READ_LOCKGUARD; (;  ; mute",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:2547,Modifiability,inherit,inherits,2547,"  ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_READ_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_GUARD();  ; #define R__COLLECTION_WRITE_LOCKGUARD(mutex)   ::ROOT::TWriteLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex));  ; #define R__COLLECTION_WRITE_LOCKGUARD_NAMED(name, mutex)   ::ROOT::TWriteLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex));  ; #define R__FOR_EACH(type, proc);  . Typedefs; template<typename T > ; using TRangeDynCast = ROOT::Detail::TRangeCast< T, true >;  TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ;  ; template<typename T > ; using ROOT::Detail::TRangeStaticCast = TRangeCast< T, false >;  TRangeStaticCast is an adapter class that allows the typed iteration through a TCollection. ;  . Functions; bool ROOT::Internal::ContaineeInheritsFrom (TClass *cl, TClass *base);  Return true if 'cl' inherits from 'base'. ;  ; const TCollection & ROOT::Internal::EmptyCollection ();  Return an empty collection for use with nullptr TRangeCast. ;  . Variables; R__EXTERN TVirtualMutex * gCollectionMutex;  ; const Bool_t kIterBackward = !kIterForward;  ; const Bool_t kIterForward = kTRUE;  . Macro Definition Documentation. ◆ R__COLL_COND_MUTEX. #define R__COLL_COND_MUTEX; (;  ; mutex);    this->IsUsingRWLock() ? mutex : nullptr. Definition at line 360 of file TCollection.h. ◆ R__COLLECTION_ITER_GUARD. #define R__COLLECTION_ITER_GUARD; (;  ; collection). Definition at line 129 of file TCollection.h. ◆ R__COLLECTION_READ_GUARD. #define R__COLLECTION_READ_GUARD; (; ). Definition at line 128 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD. #define R__COLLECTION_READ_LOCKGUARD; (;  ; mutex);    ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)). Definition at line 362 of file TCollection.h. ◆ R__COLLECTION_READ_LOCKGUARD",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:5861,Modifiability,adapt,adapter,5861,"t_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTERN TVirtualMutex* gCollectionMutex. Definition at line 45 of file TCollection.h. ◆ kIterBackward. const Bool_t kIterBackward = !kIterForward. Definition at line 43 of file TCollection.h. ◆ kIterForward. const Bool_t kIterForward = kTRUE. Definition at line 42 of file TCollection.h. corecontincTCollection.h. ROOT master - Reference Guide Ge",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h.html:5585,Security,access,accessible,5585,",proc)())) \; _NAME3_(obj_,type,proc)->proc; _NAME3_#define _NAME3_(name1, name2, name3)Definition RConfig.hxx:444; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TIterDefinition TCollection.h:235. Definition at line 373 of file TCollection.h. Typedef Documentation. ◆ TRangeDynCast. template<typename T > . using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>. TRangeDynCast is an adapter class that allows the typed iteration through a TCollection. ; The typical use is: for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; a#define a(i)Definition RSha256.hxx:99; ROOT::Detail::TRangeCastDefinition TCollection.h:311; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; Template Parameters. TThe new type to convert to. . Definition at line 358 of file TCollection.h. Variable Documentation. ◆ gCollectionMutex. R__EXTE",MatchSource.WIKI,doc/master/TCollection_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h.html
https://root.cern/doc/master/TCollection_8h_source.html:6672,Energy Efficiency,allocate,allocated,6672,"TClass *cl) const;; 166 void Browse(TBrowser *b) override;; 167 Int_t Capacity() const { return fSize; }; 168 void Clear(Option_t *option="""") override = 0;; 169 TObject *Clone(const char *newname="""") const override;; 170 Int_t Compare(const TObject *obj) const override;; 171 Bool_t Contains(const char *name) const { return FindObject(name) != nullptr; }; 172 Bool_t Contains(const TObject *obj) const { return FindObject(obj) != nullptr; }; 173 void Delete(Option_t *option="""") override = 0;; 174 void Draw(Option_t *option="""") override;; 175 void Dump() const override;; 176 TObject *FindObject(const char *name) const override;; 177 TObject *operator()(const char *name) const;; 178 TObject *FindObject(const TObject *obj) const override;; 179 virtual Int_t GetEntries() const { return GetSize(); }; 180 const char *GetName() const override;; 181 virtual TObject **GetObjectRef(const TObject *obj) const = 0;; 182 /// Return the *capacity* of the collection, i.e. the current total amount of space that has been allocated so far.; 183 /// Same as `Capacity`. Use `GetEntries` to get the number of elements currently in the collection.; 184 virtual Int_t GetSize() const { return fSize; }; 185 virtual Int_t GrowBy(Int_t delta) const;; 186 ULong_t Hash() const override { return fName.Hash(); }; 187 Bool_t IsArgNull(const char *where, const TObject *obj) const;; 188 virtual Bool_t IsEmpty() const { return GetSize() <= 0; }; 189 Bool_t IsFolder() const override { return kTRUE; }; 190 Bool_t IsOwner() const { return TestBit(kIsOwner); }; 191 Bool_t IsSortable() const override { return kTRUE; }; 192 void ls(Option_t *option="""") const override;; 193 Bool_t Notify() override;; 194 virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;; 195 virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }; 196 void Paint(Option_t *option="""") override;; 197 void Print(Option_t *option="""") const override;; 198 virtual void Print(Option_t *option, Int_t rec",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:12451,Energy Efficiency,adapt,adapter,12451,"91 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <type",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:13374,Energy Efficiency,adapt,adapter,13374," : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; 352/// if (!bcl) continue;; 353/// ... use bcl as a TBaseClass*; 354/// }; 355/// ```; 356/// \tparam T The new type to convert to.; 357template <typename T>; 358using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>;; 359 ; 360#define R__COLL_COND_MUTEX(mutex) this->IsUsingRWLock() ? mutex : nullptr; 361 ; 362#define R__COLLECTION_READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 363#define R__COLLECTION_READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__C",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:8973,Integrability,wrap,wrapper,8973,"t char *where, const TObject *obj) const;; 188 virtual Bool_t IsEmpty() const { return GetSize() <= 0; }; 189 Bool_t IsFolder() const override { return kTRUE; }; 190 Bool_t IsOwner() const { return TestBit(kIsOwner); }; 191 Bool_t IsSortable() const override { return kTRUE; }; 192 void ls(Option_t *option="""") const override;; 193 Bool_t Notify() override;; 194 virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;; 195 virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }; 196 void Paint(Option_t *option="""") override;; 197 void Print(Option_t *option="""") const override;; 198 virtual void Print(Option_t *option, Int_t recurse) const;; 199 virtual void Print(Option_t *option, const char* wildcard, Int_t recurse=1) const;; 200 virtual void Print(Option_t *option, TPRegexp& regexp, Int_t recurse=1) const;; 201 void RecursiveRemove(TObject *obj) override;; 202 virtual TObject *Remove(TObject *obj) = 0;; 203 virtual void RemoveAll(TCollection *col);; 204 void RemoveAll() { Clear(); }; 205 void SetCurrentCollection();; 206 void SetName(const char *name) { fName = name; }; 207 virtual void SetOwner(Bool_t enable = kTRUE);; 208 virtual bool UseRWLock(Bool_t enable = true);; 209 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;; 210 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) const override;; 211 ; 212 R__ALWAYS_INLINE Bool_t IsUsingRWLock() const { return TestBit(TCollection::kUseRWLock); }; 213 ; 214 static TCollection *GetCurrentCollection();; 215 static void StartGarbageCollection();; 216 static void GarbageCollect(TObject *obj);; 217 static void EmptyGarbageCollection();; 218 ; 219 TIter begin() const;; 220 TIter end() const;; 221 ; 222 ClassDefOverride(TCollection,3) //Collection abstract base class; 223};; 224 ; 225 ; 226//////////////////////////////////////////////////////////////////////////; 227// //; 228// TIter //; 229// //; 230// Iterator wrapper.",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:9004,Integrability,depend,depends,9004,"ear(); }; 205 void SetCurrentCollection();; 206 void SetName(const char *name) { fName = name; }; 207 virtual void SetOwner(Bool_t enable = kTRUE);; 208 virtual bool UseRWLock(Bool_t enable = true);; 209 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) override;; 210 Int_t Write(const char *name = nullptr, Int_t option = 0, Int_t bufsize = 0) const override;; 211 ; 212 R__ALWAYS_INLINE Bool_t IsUsingRWLock() const { return TestBit(TCollection::kUseRWLock); }; 213 ; 214 static TCollection *GetCurrentCollection();; 215 static void StartGarbageCollection();; 216 static void GarbageCollect(TObject *obj);; 217 static void EmptyGarbageCollection();; 218 ; 219 TIter begin() const;; 220 TIter end() const;; 221 ; 222 ClassDefOverride(TCollection,3) //Collection abstract base class; 223};; 224 ; 225 ; 226//////////////////////////////////////////////////////////////////////////; 227// //; 228// TIter //; 229// //; 230// Iterator wrapper. Type of iterator used depends on type of //; 231// collection. //; 232// //; 233//////////////////////////////////////////////////////////////////////////; 234 ; 235class TIter {; 236 ; 237private:; 238 TIterator *fIterator{nullptr}; //collection iterator; 239 ; 240protected:; 241 TIter() : fIterator(nullptr) { }; 242 ; 243public:; 244 TIter(const TCollection *col, Bool_t dir = kIterForward); 245 : fIterator(col ? col->MakeIterator(dir) : nullptr) { }; 246 TIter(TIterator *it) : fIterator(it) { }; 247 TIter(const TIter &iter);; 248 TIter &operator=(const TIter &rhs);; 249 virtual ~TIter() { SafeDelete(fIterator); }; 250 TObject *operator()() { return Next(); }; 251 TObject *Next() { return fIterator ? fIterator->Next() : nullptr; }; 252 const TCollection *GetCollection() const { return fIterator ? fIterator->GetCollection() : nullptr; }; 253 Option_t *GetOption() const { return fIterator ? fIterator->GetOption() : """"; }; 254 void Reset() { if (fIterator) fIterator->Reset(); }; 255 TIter &operator++() { Next(); retur",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:10718,Integrability,wrap,wrapper,10718,"erator==(const TIter &aIter) const {; 257 if (fIterator == nullptr); 258 return aIter.fIterator == nullptr || **aIter.fIterator == nullptr;; 259 if (aIter.fIterator == nullptr); 260 return fIterator == nullptr || **fIterator == nullptr;; 261 return *fIterator == *aIter.fIterator;; 262 }; 263 Bool_t operator!=(const TIter &aIter) const {; 264 return !(*this == aIter);; 265 }; 266 TIter &operator=(TIterator *iter); 267 {; 268 if (fIterator); 269 delete fIterator;; 270 fIterator = iter;; 271 return *this;; 272 }; 273 TObject *operator*() const { return fIterator ? *(*fIterator): nullptr; }; 274 TIter &Begin();; 275 static TIter End();; 276 ; 277 ClassDef(TIter,0) //Iterator wrapper; 278};; 279 ; 280template <class T>; 281class TIterCategory: public TIter, public std::iterator_traits<typename T::Iterator_t> {; 282 ; 283public:; 284 TIterCategory(const TCollection *col, Bool_t dir = kIterForward) : TIter(col, dir) { }; 285 TIterCategory(TIterator *it) : TIter(it) { }; 286 virtual ~TIterCategory() { }; 287 TIterCategory &Begin() { TIter::Begin(); return *this; }; 288 static TIterCategory End() { return TIterCategory(static_cast<TIterator*>(nullptr)); }; 289};; 290 ; 291 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynam",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:12451,Integrability,adapter,adapter,12451,"91 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <type",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:13374,Integrability,adapter,adapter,13374," : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; 352/// if (!bcl) continue;; 353/// ... use bcl as a TBaseClass*; 354/// }; 355/// ```; 356/// \tparam T The new type to convert to.; 357template <typename T>; 358using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>;; 359 ; 360#define R__COLL_COND_MUTEX(mutex) this->IsUsingRWLock() ? mutex : nullptr; 361 ; 362#define R__COLLECTION_READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 363#define R__COLLECTION_READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__C",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:26817,Integrability,interface,interface,26817,"h:273; TIter::NextTObject * Next()Definition TCollection.h:251; TIter::Resetvoid Reset()Definition TCollection.h:254; TIter::operator++TIter & operator++()Definition TCollection.h:255; TIter::TIterTIter(TIterator *it)Definition TCollection.h:246; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::TIterTIter(const TCollection *col, Bool_t dir=kIterForward)Definition TCollection.h:244; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TIterator::GetOptionvirtual Option_t * GetOption() constDefinition TIterator.h:40; TIterator::GetCollectionvirtual const TCollection * GetCollection() const =0; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPRegexpDefinition TPRegexp.h:36; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corecontincTCollection.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:857,Modifiability,inherit,inherits,857,". ROOT: core/cont/inc/TCollection.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCollection.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 13/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Wri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:11679,Modifiability,inherit,inherits,11679,"erator==(const TIter &aIter) const {; 257 if (fIterator == nullptr); 258 return aIter.fIterator == nullptr || **aIter.fIterator == nullptr;; 259 if (aIter.fIterator == nullptr); 260 return fIterator == nullptr || **fIterator == nullptr;; 261 return *fIterator == *aIter.fIterator;; 262 }; 263 Bool_t operator!=(const TIter &aIter) const {; 264 return !(*this == aIter);; 265 }; 266 TIter &operator=(TIterator *iter); 267 {; 268 if (fIterator); 269 delete fIterator;; 270 fIterator = iter;; 271 return *this;; 272 }; 273 TObject *operator*() const { return fIterator ? *(*fIterator): nullptr; }; 274 TIter &Begin();; 275 static TIter End();; 276 ; 277 ClassDef(TIter,0) //Iterator wrapper; 278};; 279 ; 280template <class T>; 281class TIterCategory: public TIter, public std::iterator_traits<typename T::Iterator_t> {; 282 ; 283public:; 284 TIterCategory(const TCollection *col, Bool_t dir = kIterForward) : TIter(col, dir) { }; 285 TIterCategory(TIterator *it) : TIter(it) { }; 286 virtual ~TIterCategory() { }; 287 TIterCategory &Begin() { TIter::Begin(); return *this; }; 288 static TIterCategory End() { return TIterCategory(static_cast<TIterator*>(nullptr)); }; 289};; 290 ; 291 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynam",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:12254,Modifiability,inherit,inherit,12254,"91 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <type",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:12451,Modifiability,adapt,adapter,12451,"91 ; 292inline TIter TCollection::begin() const { return ++(TIter(this)); }; 293inline TIter TCollection::end() const { return TIter::End(); }; 294 ; 295namespace ROOT {; 296namespace Internal {; 297 ; 298const TCollection &EmptyCollection();; 299bool ContaineeInheritsFrom(TClass *cl, TClass *base);; 300 ; 301} // namespace Internal; 302 ; 303/// Special implementation of ROOT::RRangeCast for TCollection, including a; 304/// check that the cast target type inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <type",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:13374,Modifiability,adapt,adapter,13374," : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; 352/// if (!bcl) continue;; 353/// ... use bcl as a TBaseClass*; 354/// }; 355/// ```; 356/// \tparam T The new type to convert to.; 357template <typename T>; 358using TRangeDynCast = ROOT::Detail::TRangeCast<T, true>;; 359 ; 360#define R__COLL_COND_MUTEX(mutex) this->IsUsingRWLock() ? mutex : nullptr; 361 ; 362#define R__COLLECTION_READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(R__COLL_COND_MUTEX(mutex)); 363#define R__COLLECTION_READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(R__COLL_COND_MUTEX(mutex)); 364 ; 365#define R__C",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:19054,Modifiability,inherit,inherit,19054,"t.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:293; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::beginTIter begin() constDefinition TCollection.h:292; TCollection::EStatusBitsEStatusBitsDefinition TCollection.h:143; TCollection::kUseRWLock@ kUseRWLockDefinition TCollection.h:146; TCollection::kIsOwner@ kIsOwnerDefinition TCollection.h:144; TCollection::AddAllvirtual void AddAll(const TCollection *col)Add all objects from collection col to this collection.Definition TCollection.cxx:195",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:26978,Modifiability,inherit,inherits,26978,"h:273; TIter::NextTObject * Next()Definition TCollection.h:251; TIter::Resetvoid Reset()Definition TCollection.h:254; TIter::operator++TIter & operator++()Definition TCollection.h:255; TIter::TIterTIter(TIterator *it)Definition TCollection.h:246; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::TIterTIter(const TCollection *col, Bool_t dir=kIterForward)Definition TCollection.h:244; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TIterator::GetOptionvirtual Option_t * GetOption() constDefinition TIterator.h:40; TIterator::GetCollectionvirtual const TCollection * GetCollection() const =0; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPRegexpDefinition TPRegexp.h:36; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corecontincTCollection.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:1748,Performance,concurren,concurrent,1748,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:1842,Performance,concurren,concurrent,1842,"llections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accessty",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:1723,Safety,detect,detects,1723,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:3763,Safety,detect,detect,3763,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:18825,Safety,safe,safe,18825,"ction.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:293; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::beginTIter begin() constDefinition TCollection.h:292; TCollection::EStatusBitsEStatusBitsDefinition TCollection.h:143; TCollection::kUseRWLo",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:1759,Security,access,access,1759,"f contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCollection; 13#define ROOT_TCollection; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TCollection //; 19// //; 20// Collection abstract base class. This class inherits from TObject //; 21// because we want to be able to have collections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWri",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:1900,Security,access,access,1900,"llections of collections. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TObject.h""; 26 ; 27#include ""TIterator.h""; 28 ; 29#include ""TString.h""; 30 ; 31#include ""TVirtualRWMutex.h""; 32 ; 33#include ""ROOT/RRangeCast.hxx""; 34 ; 35#include <cassert>; 36 ; 37class TClass;; 38class TObjectTable;; 39class TVirtualMutex;; 40class TIter;; 41 ; 42const Bool_t kIterForward = kTRUE;; 43const Bool_t kIterBackward = !kIterForward;; 44 ; 45R__EXTERN TVirtualMutex *gCollectionMutex;; 46 ; 47// #define R__CHECK_COLLECTION_MULTI_ACCESS; 48 ; 49// When R__CHECK_COLLECTION_MULTI_ACCESS is turned on (defined),; 50// the normal (not locked) ROOT TCollections are instrumented with a; 51// pseudo read-write lock which does not halt the execution but detects; 52// and report concurrent access to the same collections.; 53// Multiple readers are allowed.; 54// Multiple concurrent writer is reported as a Conflict; 55// Readers access while a write is running is reported as Conflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accessty",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:2917,Security,access,accesstype,2917,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:3779,Security,access,access,3779,"onflict; 56// Re-entrant writing call by the same Writer thread are allowed.; 57// Entering a writing section by a single Reader thread is allowed.; 58 ; 59#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 60#include <atomic>; 61#include <thread>; 62#include <unordered_multiset>; 63#endif; 64 ; 65class TCollection : public TObject {; 66 ; 67#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 68public:; 69 class TErrorLock {; 70 // Warn when multiple thread try to acquire the same 'lock'; 71 std::atomic<std::thread::id> fWriteCurrent;; 72 std::atomic<size_t> fWriteCurrentRecurse;; 73 std::atomic<size_t> fReadCurrentRecurse;; 74 std::unordered_multiset<std::thread::id> fReadSet;; 75 std::atomic_flag fSpinLockFlag;; 76 ; 77 void Lock(const TCollection *collection, const char *function);; 78 ; 79 void Unlock();; 80 ; 81 void ReadLock(const TCollection *collection, const char *function);; 82 ; 83 void ReadUnlock();; 84 ; 85 void ConflictReport(std::thread::id holder, const char *accesstype, const TCollection *collection,; 86 const char *function);; 87 ; 88 public:; 89 TErrorLock() : fWriteCurrent(), fWriteCurrentRecurse(0), fReadCurrentRecurse(0); 90 {; 91 std::atomic_flag_clear(&fSpinLockFlag);; 92 }; 93 ; 94 class WriteGuard {; 95 TErrorLock *fLock;; 96 ; 97 public:; 98 WriteGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 99 {; 100 fLock->Lock(collection, function);; 101 }; 102 ~WriteGuard() { fLock->Unlock(); }; 103 };; 104 ; 105 class ReadGuard {; 106 TErrorLock *fLock;; 107 ; 108 public:; 109 ReadGuard(TErrorLock &lock, const TCollection *collection, const char *function) : fLock(&lock); 110 {; 111 fLock->ReadLock(collection, function);; 112 }; 113 ~ReadGuard() { fLock->ReadUnlock(); }; 114 };; 115 };; 116 ; 117 mutable TErrorLock fLock; //! Special 'lock' to detect multiple access to a collection.; 118 ; 119#define R__COLLECTION_WRITE_GUARD() TCollection::TErrorLock::WriteGuard wg(fLock, this, __PRETTY_FUNCTION__); 120#define R__COLLECTION_R",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:17986,Security,hash,hash,17986,"t *obj)=0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::operator=void operator=(const TCollection &)=delete; TCollection::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TCollection.h:189; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::Asse",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:18142,Security,access,accessible,18142,"operator=(const TCollection &)=delete; TCollection::IsFolderBool_t IsFolder() const overrideReturns kTRUE in case object contains browsable objects (like containers or lists of other objects).Definition TCollection.h:189; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.c",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:18292,Security,access,accessible,18292,"ike containers or lists of other objects).Definition TCollection.h:189; TCollection::PrintCollectionEntryvirtual void PrintCollectionEntry(TObject *entry, Option_t *option, Int_t recurse) constPrint the collection entry.Definition TCollection.cxx:445; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::NotifyBool_t Notify() override'Notify' all objects in this collection.Definition TCollection.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:2",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:18800,Security,access,access,18800,"ction.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:293; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::beginTIter begin() constDefinition TCollection.h:292; TCollection::EStatusBitsEStatusBitsDefinition TCollection.h:143; TCollection::kUseRWLo",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:26398,Security,hash,hash,26398,"to the element after the last - to a nullptr value in our case.Definition TCollection.cxx:814; TIter::operator*TObject * operator*() constDefinition TCollection.h:273; TIter::NextTObject * Next()Definition TCollection.h:251; TIter::Resetvoid Reset()Definition TCollection.h:254; TIter::operator++TIter & operator++()Definition TCollection.h:255; TIter::TIterTIter(TIterator *it)Definition TCollection.h:246; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::TIterTIter(const TCollection *col, Bool_t dir=kIterForward)Definition TCollection.h:244; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TIterator::GetOptionvirtual Option_t * GetOption() constDefinition TIterator.h:40; TIterator::GetCollectionvirtual const TCollection * GetCollection() const =0; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPRegexpDefinition TPRegexp.h:36; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutio",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:26735,Security,hash,hash,26735,"h:273; TIter::NextTObject * Next()Definition TCollection.h:251; TIter::Resetvoid Reset()Definition TCollection.h:254; TIter::operator++TIter & operator++()Definition TCollection.h:255; TIter::TIterTIter(TIterator *it)Definition TCollection.h:246; TIter::operator=TIter & operator=(const TIter &rhs)Assigning an TIter to another.Definition TCollection.cxx:789; TIter::TIterTIter(const TCollection *col, Bool_t dir=kIterForward)Definition TCollection.h:244; TIter::fIteratorTIterator * fIteratorDefinition TCollection.h:238; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::Resetvirtual void Reset()=0; TIterator::Nextvirtual TObject * Next()=0; TIterator::GetOptionvirtual Option_t * GetOption() constDefinition TIterator.h:40; TIterator::GetCollectionvirtual const TCollection * GetCollection() const =0; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TPRegexpDefinition TPRegexp.h:36; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOT::Internal::ContaineeInheritsFrombool ContaineeInheritsFrom(TClass *cl, TClass *base)Return true if 'cl' inherits from 'base'.Definition TCollection.cxx:831; ROOT::Internal::EmptyCollectionconst TCollection & EmptyCollection()Return an empty collection for use with nullptr TRangeCast.Definition TCollection.cxx:822; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Drawth1 Draw(). corecontincTCollection.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:08 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TCollection_8h_source.html:12708,Testability,assert,assert,12708,"inherits from TObject and a new constructor; 305/// that takes the TCollection by pointer.; 306/// \tparam T The new type to convert to.; 307/// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; 308namespace Detail {; 309 ; 310template <typename T, bool isDynamic>; 311class TRangeCast : public ROOT::RRangeCast<T*, isDynamic, TCollection const&> {; 312public:; 313 TRangeCast(TCollection const& col) : ROOT::RRangeCast<T*, isDynamic, TCollection const&>{col} {; 314 static_assert(std::is_base_of<TObject, T>::value, ""Containee type must inherit from TObject"");; 315 }; 316 TRangeCast(TCollection const* col) : TRangeCast{col != nullptr ? *col : ROOT::Internal::EmptyCollection()} {}; 317};; 318 ; 319/// @brief TRangeStaticCast is an adapter class that allows the typed iteration; 320/// through a TCollection. This requires the collection to contain elements; 321/// of the type requested (or a derived class). Any deviation from this expectation; 322/// will only be caught/reported by an assert in debug builds.; 323///; 324/// This is best used with a TClonesArray, for other cases prefered TRangeDynCast.; 325///; 326/// The typical use is:; 327/// ```{.cpp}; 328/// for(auto bcl : TRangeStaticCast<TBaseClass>( *tbaseClassClonesArrayPtr )) {; 329/// ... use bcl as a TBaseClass*; 330/// }; 331/// for(auto bcl : TRangeStaticCast<TBaseClass>( tbaseClassClonesArrayPtr )) {; 332/// ... use bcl as a TBaseClass*; 333/// }; 334/// ```; 335/// \tparam T The new type to convert to.; 336template <typename T>; 337using TRangeStaticCast = TRangeCast<T, false>;; 338 ; 339} // namespace Detail; 340} // namespace ROOT; 341 ; 342/// @brief TRangeDynCast is an adapter class that allows the typed iteration; 343/// through a TCollection.; 344///; 345/// The typical use is:; 346/// ```{.cpp}; 347/// for(auto bcl : TRangeDynCast<TBaseClass>( *cl->GetListOfBases() )) {; 348/// if (!bcl) continue;; 349/// ... use bcl as a TBaseClass*; 350/// }; 351/// for(auto bcl : ",MatchSource.WIKI,doc/master/TCollection_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html
https://root.cern/doc/master/TColorWheel_8h_source.html:6777,Usability,simpl,simple,6777,"n TColorWheel.h:36; TColorWheel::fRmaxDouble_t fRmaxMaximum radius for rectangles.Definition TColorWheel.h:27; TColorWheel::PaintGrayvoid PaintGray() constDraw the gray colors + white + black.Definition TColorWheel.cxx:389; TColorWheel::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideReturn the color number pointed by the mouse.Definition TColorWheel.cxx:155; TColorWheel::Paintvoid Paint(Option_t *option="""") overridePaint the color wheel.Definition TColorWheel.cxx:225; TColorWheel::PaintCirclesvoid PaintCircles(Int_t coffset, Double_t angle) constDraw all colors of type circle.Definition TColorWheel.cxx:279; TColorWheel::fDrDouble_t fDrCircles radius.Definition TColorWheel.h:29; TColorWheel::PaintRectanglesvoid PaintRectangles(Int_t coffset, Double_t angle) constDraw all colors of type rectangle.Definition TColorWheel.cxx:306; TColorWheel::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overridealways return the color wheelDefinition TColorWheel.cxx:106; TColorWheel::Rotatevoid Rotate(Double_t x, Double_t y, Double_t &u, Double_t &v, Double_t ang) constRotate point x,y with an angle=ang.Definition TColorWheel.cxx:428; TColorWheel::fGraphTGraph * fGraph! pointer to utility graphDefinition TColorWheel.h:37; TColorWheel::~TColorWheel~TColorWheel() overridedestructorDefinition TColorWheel.cxx:94; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTextBase class for several text objects.Definition TText.h:22; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; Drawth1 Draw(). graf2dgpadincTColorWheel.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:17 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TColorWheel_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColorWheel_8h_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:6395,Availability,avail,available,6395,"s is the following:; 166 ; 167~~~ {.cpp}; 168kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; 169kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; 170kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; 171~~~; 172 ; 173Note the special role of color `kWhite` (color number 0). It is the default; 174background color also. For instance in a PDF or PS files (as paper is usually white); 175it is simply not painted. To have a white color behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` re",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7153,Availability,avail,available,7153,"3\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7316,Availability,avail,available,7316,"in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:14810,Availability,down,downloaded,14810,"a 2D plot (not so much in a 3D surfaces).; 363 ; 364The `kCMYK` palette, is also not great because it's dark, then lighter, then; 365half-dark again. Some others, like `kAquamarine`, have almost no contrast therefore it would; 366be almost impossible (for a color blind person) to see something with a such palette.; 367 ; 368Therefore the palettes are classified in two categories: those which are Colour Vision Deficiency; 369friendly and those which are not.; 370 ; 371An easy way to classify the palettes is to turn them into grayscale using TCanvas::SetGrayscale().; 372The grayscale version of a palette should be as proportional as possible, and monotonously; 373increasing or decreasing.; 374 ; 375Unless it is symmetrical, then it is fine to have white in the; 376borders and black in the centre (for example an axis that goes between; 377-40 degrees and +40 degrees, the 0 has a meaning in the perceptualcolormap.C example).; 378 ; 379A full set of colour-vision deficiency friendly and perceptually uniform colour maps can be; 380[downloaded](https://doi.org/10.5281/zenodo.4491293) and used with ROOT (since 6.26) via:; 381`gStyle->SetPalette(""filename.txt"")` or `TColor::CreateColorTableFromFile(""filename.txt"")`.; 382Remember to increase the number of contours for a smoother result, e.g.:; 383`gStyle->SetNumberContours(99)` if you are drawing with ""surf1z"" or `gStyle->SetNumberContours(256)`; 384if with ""colz"".; 385 ; 386\anchor C06a; 387### Colour Vision Deficiency (CVD) friendly palettes; 388 ; 389<table border=0>; 390<tr><td>; 391Begin_Macro; 392{; 393 auto c = new TCanvas(""c"",""c"",0,0,300,300);; 394 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.002,0.999,3.002);; 395 f2->SetContour(99); gStyle->SetPalette(kBird);; 396 f2->Draw(""surf2Z""); f2->SetTitle(""kBird (default)"");; 397}; 398End_Macro; 399</td><td>; 400Begin_Macro; 401{; 402 auto c = new TCanvas(""c"",""c"",0,0,300,300);; 403 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.0",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:37199,Availability,avail,available,37199,"019 ; 1020An example of transparency usage with parallel coordinates can be found; 1021in parallelcoordtrans.C.; 1022 ; 1023To ease the creation of a transparent color the static method; 1024`GetColorTransparent(Int_t color, Float_t a)` is provided.; 1025In the following example the `trans_red` color index point to; 1026a red color 30% opaque (70% transparent). The alpha value of; 1027the color index `kRed` is not modified.; 1028 ; 1029~~~ {.cpp}; 1030 Int_t trans_red = GetColorTransparent(kRed, 0.3);; 1031~~~; 1032 ; 1033This function is also used in the methods; 1034`SetFillColorAlpha()`, `SetLineColorAlpha()`,; 1035`SetMarkerColorAlpha()` and `SetTextColorAlpha()`.; 1036In the following example the fill color of the histogram `histo`; 1037is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 1038(The color `kBlue` itself is internally stored as fully opaque.); 1039 ; 1040~~~ {.cpp}; 1041 histo->SetFillColorAlpha(kBlue, 0.35);; 1042~~~; 1043 ; 1044The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 1045in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 1046it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 1047 ; 1048Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 1049Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 1050 ; 1051The following macro gives an example of transparency usage:; 1052 ; 1053Begin_Macro(source); 1054../../../tutorials/graphics/transparency.C; 1055End_Macro; 1056 ; 1057*/; 1058 ; 1059////////////////////////////////////////////////////////////////////////////////; 1060/// Default constructor.; 1061 ; 1062TColor::TColor(): TNamed(); 1063{; 1064 fNumber = -1;; 1065 fRed = fGreen = fBlue = fHue = fLight = fSaturation = -1;; 1066 fAlpha = 1;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:70344,Availability,avail,available,70344," ; 1942Int_t TColor::GetColor(Float_t r, Float_t g, Float_t b, Float_t a); 1943{; 1944 return GetColor(Int_t(r * 255), Int_t(g * 255), Int_t(b * 255), a);; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// Static method returning color number for color specified by; 1949/// system dependent pixel value. Pixel values can be obtained, e.g.,; 1950/// from the GUI color picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:95312,Availability,error,error,95312,"r = (TColor*) iColor())); 2605 color->Allocate();; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// \brief Static function creating a color palette based on an input text file.; 2610///; 2611/// Every color in the file will take the same amount of space in the palette.; 2612///; 2613/// \see https://doi.org/10.1038/s41467-020-19160-7; 2614/// \note This function is designed to load into ROOT the colour-vision; 2615/// deficiency friendly and perceptually uniform colour maps specially designed; 2616/// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; 2617/// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; 2618///; 2619/// \param fileName: Name of a .txt file (ASCII) containing three floats per; 2620/// line, separated by spaces, namely the r g b fractions of the color, each; 2621/// value being in the range [0,1].; 2622/// \param alpha the global opacity for all colors within this palette; 2623/// \return a positive value on success and -1 on error.; 2624/// \author Fernando Hueso-González; 2625Int_t TColor::CreateColorTableFromFile(TString fileName, Float_t alpha); 2626{; 2627 std::ifstream f(fileName.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Float_t> reds, greens, blues;; 2636 while (f >> r >> g >> b) {; 2637 nLines++;; 2638 if (r < 0. || r > 1.) {; 2639 ::Error(""TColor::CreateColorPalette(const TString)"", ""Red value %f outside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. |",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:98251,Availability,error,error,98251,"/////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true by default). If false,; 2692/// the caller is in charge of calling TColor::SetPalette using the; 2693/// return value of the function (first palette color index) and; 2694/// reconstructing the Int_t palette[NColors+1] array.; 2695///; 2696/// Returns a positive value (the index of the first color of the palette) on; 2697/// success and -1 on error.; 2698///; 2699/// The table is constructed by tracing lines between the given points in; 2700/// RGB space. Each color value may have a value between 0 and 1. The; 2701/// difference between consecutive ""Stops"" values gives the fraction of; 2702/// space in the whole table that should be used for the interval between; 2703/// the corresponding color values.; 2704///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 2714/// UInt_t Number = 3;; 2715/// Double_t Red[3] = { 0.0, 1.0, 1.0 };; 2716/// Double_t Green[3] = { 0.0, 0.0, 1.0 };; 2717/// Double_t Blue[3] = { 1.0, 0.0, 1.0 };; 27",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:102863,Availability,avail,available,102863,"Draw(""col"") draws a 2-D histogram with cells; 2794/// represented by a box filled with a color CI function of the cell content.; 2795/// if the cell content is N, the color CI used will be the color number; 2796/// in colors[N],etc. If the maximum cell content is > ncolors, all; 2797/// cell contents are scaled to ncolors.; 2798///; 2799/// `if ncolors <= 0` a default palette (see below) of 50 colors is; 2800/// defined. The colors defined in this palette are OK for coloring pads, labels.; 2801///; 2802/// ~~~ {.cpp}; 2803/// index 0->9 : grey colors from light to dark grey; 2804/// index 10->19 : ""brown"" colors; 2805/// index 20->29 : ""blueish"" colors; 2806/// index 30->39 : ""redish"" colors; 2807/// index 40->49 : basic colors; 2808/// ~~~; 2809///; 2810/// `if ncolors == 1 && colors == 0`, a Rainbow Color map is created; 2811/// with 50 colors. It is kept for backward compatibility. Better palettes like; 2812/// kBird are recommended.; 2813///; 2814/// High quality predefined palettes with 255 colors are available when `colors == 0`.; 2815/// The following value of `ncolors` give access to:; 2816///; 2817/// ~~~ {.cpp}; 2818/// if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2819/// if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2820/// if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2821/// if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); 2822/// if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2823/// if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; 2824/// if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; 2825/// if ncolors = 58 and colors=0, a Cubehelix palette is used; 2826/// (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); 2827/// if ncolors = 59 and colors=0, a Green Red Violet palette is used.; 2828/// if ncolors = 60 and colors=0, a B",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:162239,Availability,error,error,162239,"ideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRadialGradientDefinition TColorGradient.h:124; TRadialGradient::Classstatic TClass * Class(); TRadialGradient::kSimple@ kSimpleDefinition TColorGradient.h:127; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition T",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7855,Deployability,toggle,toggle,7855," like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:9426,Deployability,continuous,continuous,9426,"vas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; 250 TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 251 Int_t palette[5];; 252 palette[0] = 15;; 253 palette[1] = 20;; 254 palette[2] = 23;; 255 palette[3] = 30;; 256 palette[4] = 32;; 257 gStyle->SetPalette(5,palette);; 258 f1->Draw(""colz"");; 259 return c1;; 260}; 261End_Macro; 262 ; 263To define more a complex palette with a continuous gradient of color, one; 264should use the static function `TColor::CreateGradientColorTable()`.; 265The following example demonstrates how to proceed:; 266 ; 267Begin_Macro(source); 268{; 269 auto c2 = new TCanvas(""c2"",""c2"",0,0,600,400);; 270 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 271 const Int_t Number = 3;; 272 Double_t Red[Number] = { 1.00, 0.00, 0.00};; 273 Double_t Green[Number] = { 0.00, 1.00, 0.00};; 274 Double_t Blue[Number] = { 1.00, 0.00, 1.00};; 275 Double_t Length[Number] = { 0.00, 0.50, 1.00 };; 276 Int_t nb=50;; 277 TColor::CreateGradientColorTable(Number,Length,Red,Green,Blue,nb);; 278 f2->SetContour(nb);; 279 f2->SetLineWidth(1);; 280 f2->SetLineColor(kBlack);; 281 f2->Draw(""surf1z"");; 282 return c2;; 283}; 284End_Macro; 285 ; 286The function `TColor::CreateGradientColorTable()` automatically; 287calls `gStyle->SetPalett",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:2589,Energy Efficiency,green,green,2589,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:41629,Energy Efficiency,green,green,41629,"tte.Set(0);; 1144 fgPalette=0;; 1145 }; 1146}; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Color copy constructor.; 1150 ; 1151TColor::TColor(const TColor &color) : TNamed(color); 1152{; 1153 color.TColor::Copy(*this);; 1154}; 1155 ; 1156TColor &TColor::operator=(const TColor &color); 1157{; 1158 if (this != &color); 1159 color.TColor::Copy(*this);; 1160 return *this;; 1161}; 1162 ; 1163////////////////////////////////////////////////////////////////////////////////; 1164/// Initialize colors used by the TCanvas based graphics (via TColor objects).; 1165/// This method should be called before the ApplicationImp is created (which; 1166/// initializes the GUI colors).; 1167 ; 1168void TColor::InitializeColors(); 1169{; 1170 static Bool_t initDone = kFALSE;; 1171 ; 1172 if (initDone) return;; 1173 initDone = kTRUE;; 1174 ; 1175 if (gROOT->GetListOfColors()->First() == nullptr) {; 1176 ; 1177 new TColor(kWhite,1,1,1,""background"");; 1178 new TColor(kBlack,0,0,0,""black"");; 1179 new TColor(2,1,0,0,""red"");; 1180 new TColor(3,0,1,0,""green"");; 1181 new TColor(4,0,0,1,""blue"");; 1182 new TColor(5,1,1,0,""yellow"");; 1183 new TColor(6,1,0,1,""magenta"");; 1184 new TColor(7,0,1,1,""cyan"");; 1185 new TColor(10,0.999,0.999,0.999,""white"");; 1186 new TColor(11,0.754,0.715,0.676,""editcol"");; 1187 ; 1188 // The color white above is defined as being nearly white.; 1189 // Sets the associated dark color also to white.; 1190 TColor::GetColorDark(10);; 1191 TColor *c110 = gROOT->GetColor(110);; 1192 if (c110) c110->SetRGB(0.999,0.999,.999);; 1193 ; 1194 // Initialize Custom colors; 1195 new TColor(20,0.8,0.78,0.67);; 1196 new TColor(31,0.54,0.66,0.63);; 1197 new TColor(41,0.83,0.81,0.53);; 1198 new TColor(30,0.52,0.76,0.64);; 1199 new TColor(32,0.51,0.62,0.55);; 1200 new TColor(24,0.70,0.65,0.59);; 1201 new TColor(21,0.8,0.78,0.67);; 1202 new TColor(47,0.67,0.56,0.58);; 1203 new TColor(35,0.46,0.54,0.57);; 1204 new TColor(33,0.68,0.74,0.7",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:51791,Energy Efficiency,green,green,51791,,MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:54494,Energy Efficiency,green,green,54494,",255, 0, 102,255, 51, 51,204, 0, 51,255, 0; 1467 ,204,255,153, 153,204,102, 102,153, 51, 102,153, 0, 153,204, 51; 1468 ,204,255,102, 153,255, 0, 204,255, 51, 153,204, 0, 204,255, 0};; 1469 ; 1470 UChar_t teal[60] = {153,255,204, 102,204,153, 51,153,102, 0,153,102, 51,204,153; 1471 ,102,255,204, 0,255,102, 51,255,204, 0,204,153, 0,255,204; 1472 , 51,255,153, 0,204,102, 0,102, 51, 0,153, 51, 51,204,102; 1473 ,102,255,153, 0,255,153, 51,255,102, 0,204, 51, 0,255, 51};; 1474 ; 1475 UChar_t azure[60] ={153,204,255, 102,153,204, 51,102,153, 0, 51,153, 51,102,204; 1476 ,102,153,255, 0,102,255, 51,102,255, 0, 51,204, 0, 51,255; 1477 , 51,153,255, 0,102,204, 0, 51,102, 0,102,153, 51,153,204; 1478 ,102,204,255, 0,153,255, 51,204,255, 0,153,204, 0,204,255};; 1479 ; 1480 UChar_t violet[60]={204,153,255, 153,102,204, 102, 51,153, 102, 0,153, 153, 51,204; 1481 ,204,102,255, 153, 0,255, 204, 51,255, 153, 0,204, 204, 0,255; 1482 ,153, 51,255, 102, 0,204, 51, 0,102, 51, 0,153, 102, 51,204; 1483 ,153,102,255, 102, 0,255, 102, 51,255, 51, 0,204, 51, 0,255};; 1484 ; 1485 TColor::CreateColorsCircle(kMagenta,""kMagenta"",magenta);; 1486 TColor::CreateColorsCircle(kRed, ""kRed"", red);; 1487 TColor::CreateColorsCircle(kYellow, ""kYellow"", yellow);; 1488 TColor::CreateColorsCircle(kGreen, ""kGreen"", green);; 1489 TColor::CreateColorsCircle(kCyan, ""kCyan"", cyan);; 1490 TColor::CreateColorsCircle(kBlue, ""kBlue"", blue);; 1491 ; 1492 TColor::CreateColorsRectangle(kPink, ""kPink"", pink);; 1493 TColor::CreateColorsRectangle(kOrange,""kOrange"",orange);; 1494 TColor::CreateColorsRectangle(kSpring,""kSpring"",spring);; 1495 TColor::CreateColorsRectangle(kTeal, ""kTeal"", teal);; 1496 TColor::CreateColorsRectangle(kAzure, ""kAzure"", azure);; 1497 TColor::CreateColorsRectangle(kViolet,""kViolet"",violet);; 1498 ; 1499 TColor::CreateColorsGray();; 1500}; 1501 ; 1502////////////////////////////////////////////////////////////////////////////////; 1503/// Static function returning the color number i in current palette.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:66527,Energy Efficiency,allocate,allocate,66527,"ors = (TObjArray*) gROOT->GetListOfColors();; 1835 ; 1836 if (nd >= 0) {; 1837 TColor *colord = (TColor*)colors->At(nd);; 1838 colord->TNamed::SetName(TString::Format(""%s_dark"",fName.Data()).Data());; 1839 }; 1840 ; 1841 if (nb >= 0) {; 1842 TColor *colorb = (TColor*)colors->At(nb);; 1843 colorb->TNamed::SetName(TString::Format(""%s_bright"",fName.Data()).Data());; 1844 }; 1845}; 1846 ; 1847 ; 1848////////////////////////////////////////////////////////////////////////////////; 1849/// Initialize this color and its ""dark"" and ""bright"" associated colors.; 1850 ; 1851void TColor::SetRGB(Float_t r, Float_t g, Float_t b); 1852{; 1853 TColor::InitializeColors();; 1854 fRed = r;; 1855 fGreen = g;; 1856 fBlue = b;; 1857 ; 1858 if (fRed < 0) return;; 1859 ; 1860 RGBtoHLS(r, g, b, fHue, fLight, fSaturation);; 1861 SetTitle(AsHexString());; 1862 ; 1863 Int_t nplanes = 16;; 1864 if (gVirtualX) gVirtualX->GetPlanes(nplanes);; 1865 if (nplanes == 0) nplanes = 16;; 1866 ; 1867 // allocate color now (can be delayed when we have a large colormap); 1868#ifndef R__WIN32; 1869 if (nplanes < 15); 1870#endif; 1871 Allocate();; 1872 ; 1873 // change the dark and bright associated colors if they exist; 1874 Float_t dr, dg, db, lr, lg, lb;; 1875 ; 1876 // get the list of all defined colors; 1877 auto colors = (TObjArray*) gROOT->GetListOfColors();; 1878 ; 1879 // set dark color; 1880 Int_t nd = GetColorByName(TString::Format(""%s_dark"",GetName()).Data());; 1881 if (nd >= 0) {; 1882 HLStoRGB(fHue, 0.7f*fLight, fSaturation, dr, dg, db);; 1883 TColor *colord = (TColor*)colors->At(nd);; 1884 if (nplanes > 8) colord->SetRGB(dr, dg, db);; 1885 else colord->SetRGB(0.3f,0.3f,0.3f);; 1886 colord->SetTitle(colord->AsHexString());; 1887 }; 1888 ; 1889 // set bright color; 1890 Int_t nb = GetColorByName(TString::Format(""%s_bright"",GetName()).Data());; 1891 if (nb >= 0) {; 1892 HLStoRGB(fHue, 1.2f*fLight, fSaturation, lr, lg, lb);; 1893 TColor *colorb = (TColor*)colors->At(nb);; 1894 if (nplanes > 8) color",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:95737,Energy Efficiency,green,greens,95737,"sion; 2615/// deficiency friendly and perceptually uniform colour maps specially designed; 2616/// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; 2617/// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; 2618///; 2619/// \param fileName: Name of a .txt file (ASCII) containing three floats per; 2620/// line, separated by spaces, namely the r g b fractions of the color, each; 2621/// value being in the range [0,1].; 2622/// \param alpha the global opacity for all colors within this palette; 2623/// \return a positive value on success and -1 on error.; 2624/// \author Fernando Hueso-González; 2625Int_t TColor::CreateColorTableFromFile(TString fileName, Float_t alpha); 2626{; 2627 std::ifstream f(fileName.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Float_t> reds, greens, blues;; 2636 while (f >> r >> g >> b) {; 2637 nLines++;; 2638 if (r < 0. || r > 1.) {; 2639 ::Error(""TColor::CreateColorPalette(const TString)"", ""Red value %f outside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. || b > 1.) {; 2651 ::Error(""TColor::CreateColorPalette(const TString)"", ""Blue value %f outside [0,1] on line %d of %s "", b,; 2652 nLines, fileName.Data());; 2653 f.close();; 2654 return -1;; 2655 }; 2656 reds.emplace_back(r);; 2657 greens.emplace_back(g);; 2658 blues.emplace_back(b);; 2659 }; 2660 f.close();; 2661 if (nLines < 2) {; 2662 ::Error(""TColor::CreateColorPalette(const TString)"", ""Found insufficient color lines (%d) on %s"", nLines,; 2663 fileName.Data());",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:96480,Energy Efficiency,green,greens,96480,"me.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Float_t> reds, greens, blues;; 2636 while (f >> r >> g >> b) {; 2637 nLines++;; 2638 if (r < 0. || r > 1.) {; 2639 ::Error(""TColor::CreateColorPalette(const TString)"", ""Red value %f outside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. || b > 1.) {; 2651 ::Error(""TColor::CreateColorPalette(const TString)"", ""Blue value %f outside [0,1] on line %d of %s "", b,; 2652 nLines, fileName.Data());; 2653 f.close();; 2654 return -1;; 2655 }; 2656 reds.emplace_back(r);; 2657 greens.emplace_back(g);; 2658 blues.emplace_back(b);; 2659 }; 2660 f.close();; 2661 if (nLines < 2) {; 2662 ::Error(""TColor::CreateColorPalette(const TString)"", ""Found insufficient color lines (%d) on %s"", nLines,; 2663 fileName.Data());; 2664 return -1;; 2665 }; 2666 ; 2667 TColor::InitializeColors();; 2668 Int_t *palette = new Int_t[nLines];; 2669 ; 2670 for (Int_t i = 0; i < nLines; ++i) {; 2671 new TColor(reds.at(i), greens.at(i), blues.at(i), alpha);; 2672 palette[i] = gHighestColorIndex;; 2673 }; 2674 TColor::SetPalette(nLines, palette);; 2675 delete[] palette;; 2676 return gHighestColorIndex + 1 - nLines;; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors s",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:96905,Energy Efficiency,green,greens,96905,"utside [0,1] on line %d of %s "", r,; 2640 nLines, fileName.Data());; 2641 f.close();; 2642 return -1;; 2643 }; 2644 if (g < 0. || g > 1.) {; 2645 ::Error(""TColor::CreateColorPalette(const TString)"", ""Green value %f outside [0,1] on line %d of %s "", g,; 2646 nLines, fileName.Data());; 2647 f.close();; 2648 return -1;; 2649 }; 2650 if (b < 0. || b > 1.) {; 2651 ::Error(""TColor::CreateColorPalette(const TString)"", ""Blue value %f outside [0,1] on line %d of %s "", b,; 2652 nLines, fileName.Data());; 2653 f.close();; 2654 return -1;; 2655 }; 2656 reds.emplace_back(r);; 2657 greens.emplace_back(g);; 2658 blues.emplace_back(b);; 2659 }; 2660 f.close();; 2661 if (nLines < 2) {; 2662 ::Error(""TColor::CreateColorPalette(const TString)"", ""Found insufficient color lines (%d) on %s"", nLines,; 2663 fileName.Data());; 2664 return -1;; 2665 }; 2666 ; 2667 TColor::InitializeColors();; 2668 Int_t *palette = new Int_t[nLines];; 2669 ; 2670 for (Int_t i = 0; i < nLines; ++i) {; 2671 new TColor(reds.at(i), greens.at(i), blues.at(i), alpha);; 2672 palette[i] = gHighestColorIndex;; 2673 }; 2674 TColor::SetPalette(nLines, palette);; 2675 delete[] palette;; 2676 return gHighestColorIndex + 1 - nLines;; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:97955,Energy Efficiency,charge,charge,97955,"tte);; 2675 delete[] palette;; 2676 return gHighestColorIndex + 1 - nLines;; 2677}; 2678 ; 2679////////////////////////////////////////////////////////////////////////////////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true by default). If false,; 2692/// the caller is in charge of calling TColor::SetPalette using the; 2693/// return value of the function (first palette color index) and; 2694/// reconstructing the Int_t palette[NColors+1] array.; 2695///; 2696/// Returns a positive value (the index of the first color of the palette) on; 2697/// success and -1 on error.; 2698///; 2699/// The table is constructed by tracing lines between the given points in; 2700/// RGB space. Each color value may have a value between 0 and 1. The; 2701/// difference between consecutive ""Stops"" values gives the fraction of; 2702/// space in the whole table that should be used for the interval between; 2703/// the corresponding color values.; 2704///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 27",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:99684,Energy Efficiency,allocate,allocated,99684,"///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 2714/// UInt_t Number = 3;; 2715/// Double_t Red[3] = { 0.0, 1.0, 1.0 };; 2716/// Double_t Green[3] = { 0.0, 0.0, 1.0 };; 2717/// Double_t Blue[3] = { 1.0, 0.0, 1.0 };; 2718/// Double_t Stops[3] = { 0.0, 0.4, 1.0 };; 2719/// ~~~; 2720/// This defines a table in which there are three color end points:; 2721/// RGB = {0, 0, 1}, {1, 0, 0}, and {1, 1, 1} = blue, red, white; 2722/// The first 40% of the table is used to go linearly from blue to red.; 2723/// The remaining 60% of the table is used to go linearly from red to white.; 2724///; 2725/// If you define a very short interval such that less than one color fits; 2726/// in it, no colors at all will be allocated. If this occurs for all; 2727/// intervals, ROOT will revert to the default palette.; 2728///; 2729/// Original code by Andreas Zoglauer (zog@mpe.mpg.de); 2730 ; 2731Int_t TColor::CreateGradientColorTable(UInt_t Number, Double_t* Stops,; 2732 Double_t* Red, Double_t* Green,; 2733 Double_t* Blue, UInt_t NColors, Float_t alpha,; 2734 Bool_t setPalette); 2735{; 2736 TColor::InitializeColors();; 2737 ; 2738 UInt_t g, c;; 2739 UInt_t nPalette = 0;; 2740 Int_t *palette = new Int_t[NColors+1];; 2741 UInt_t nColorsGradient;; 2742 ; 2743 if(Number < 2 || NColors < 1){; 2744 delete [] palette;; 2745 return -1;; 2746 }; 2747 ; 2748 // Check if all RGB values are between 0.0 and 1.0 and; 2749 // Stops goes from 0.0 to 1.0 in increasing order.; 2750 for (c = 0; c < Number; c++) {; 2751 if (Red[c] < 0 || Red[c] > 1.0 ||; 2752 Green[c] < 0 || Green[c] > 1.0 ||; 2753 Blue[c] < 0 || Blue[c] > 1.0 ||; 2754 Stops[c] < 0 || Stops[c] > 1",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:111721,Energy Efficiency,green,green,111721,"sList.fArray[ncolors-51]-Idx);; 2962 Bool_t same_alpha = TMath::Abs(alpha-alphas) < 0.0001;; 2963 if (paletteType == ncolors && same_alpha) return; // The current palette is already this one.; 2964 fgPalette.Set(255); // High quality palettes have 255 entries; 2965 for (i=0;i<255;i++) fgPalette.fArray[i] = Idx+i;; 2966 paletteType = ncolors;; 2967 ; 2968 // restore the palette transparency if needed; 2969 if (alphas>0 && !same_alpha) {; 2970 TColor *ca;; 2971 for (i=0;i<255;i++) {; 2972 ca = gROOT->GetColor(Idx+i);; 2973 ca->SetAlpha(alpha);; 2974 }; 2975 fgPalettesList.fArray[paletteType-51] = (Double_t)Idx+alpha/10.;; 2976 }; 2977 return;; 2978 }; 2979 ; 2980 TColor::InitializeColors();; 2981 Double_t stops[9] = { 0.0000, 0.1250, 0.2500, 0.3750, 0.5000, 0.6250, 0.7500, 0.8750, 1.0000};; 2982 ; 2983 switch (ncolors) {; 2984 // Deep Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:112006,Energy Efficiency,green,green,112006,"66 paletteType = ncolors;; 2967 ; 2968 // restore the palette transparency if needed; 2969 if (alphas>0 && !same_alpha) {; 2970 TColor *ca;; 2971 for (i=0;i<255;i++) {; 2972 ca = gROOT->GetColor(Idx+i);; 2973 ca->SetAlpha(alpha);; 2974 }; 2975 fgPalettesList.fArray[paletteType-51] = (Double_t)Idx+alpha/10.;; 2976 }; 2977 return;; 2978 }; 2979 ; 2980 TColor::InitializeColors();; 2981 Double_t stops[9] = { 0.0000, 0.1250, 0.2500, 0.3750, 0.5000, 0.6250, 0.7500, 0.8750, 1.0000};; 2982 ; 2983 switch (ncolors) {; 2984 // Deep Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:112239,Energy Efficiency,green,green,112239,");; 2973 ca->SetAlpha(alpha);; 2974 }; 2975 fgPalettesList.fArray[paletteType-51] = (Double_t)Idx+alpha/10.;; 2976 }; 2977 return;; 2978 }; 2979 ; 2980 TColor::InitializeColors();; 2981 Double_t stops[9] = { 0.0000, 0.1250, 0.2500, 0.3750, 0.5000, 0.6250, 0.7500, 0.8750, 1.0000};; 2982 ; 2983 switch (ncolors) {; 2984 // Deep Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:112529,Energy Efficiency,green,green,112529,"Sea; 2985 case 51:; 2986 {; 2987 Double_t red[9] = { 0./255., 9./255., 13./255., 17./255., 24./255., 32./255., 27./255., 25./255., 29./255.};; 2988 Double_t green[9] = { 0./255., 0./255., 0./255., 2./255., 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 30",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:112771,Energy Efficiency,green,green,112771," 37./255., 74./255., 113./255., 160./255., 221./255.};; 2989 Double_t blue[9] = { 28./255., 42./255., 59./255., 78./255., 98./255., 129./255., 154./255., 184./255., 221./255.};; 2990 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 2991 }; 2992 break;; 2993 ; 2994 // Grey Scale; 2995 case 52:; 2996 {; 2997 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:113050,Energy Efficiency,green,green,113050,"7 Double_t red[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2998 Double_t green[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradie",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:113335,Energy Efficiency,green,green,113335,", 255./255.};; 2999 Double_t blue[9] = { 0./255., 32./255., 64./255., 96./255., 128./255., 160./255., 192./255., 224./255., 255./255.};; 3000 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3001 }; 3002 break;; 3003 ; 3004 // Dark Body Radiator; 3005 case 53:; 3006 {; 3007 Double_t red[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:113621,Energy Efficiency,green,green,113621,"d[9] = { 0./255., 45./255., 99./255., 156./255., 212./255., 230./255., 237./255., 234./255., 242./255.};; 3008 Double_t green[9] = { 0./255., 0./255., 0./255., 45./255., 101./255., 168./255., 238./255., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:113851,Energy Efficiency,green,green,113851,"55., 238./255., 243./255.};; 3009 Double_t blue[9] = { 0./255., 1./255., 1./255., 3./255., 9./255., 8./255., 11./255., 95./255., 230./255.};; 3010 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3011 }; 3012 break;; 3013 ; 3014 // Two-color hue (dark blue through neutral gray to bright yellow); 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:114136,Energy Efficiency,green,green,114136,"; 3015 case 54:; 3016 {; 3017 Double_t red[9] = { 0./255., 22./255., 44./255., 68./255., 93./255., 124./255., 160./255., 192./255., 237./255.};; 3018 Double_t green[9] = { 0./255., 16./255., 41./255., 67./255., 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:114387,Energy Efficiency,green,green,114387," 93./255., 125./255., 162./255., 194./255., 241./255.};; 3019 Double_t blue[9] = { 97./255., 100./255., 99./255., 99./255., 93./255., 68./255., 44./255., 26./255., 74./255.};; 3020 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3021 }; 3022 break;; 3023 ; 3024 // Rain Bow; 3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:114666,Energy Efficiency,green,green,114666,"3025 case 55:; 3026 {; 3027 Double_t red[9] = { 0./255., 5./255., 15./255., 35./255., 102./255., 196./255., 208./255., 199./255., 110./255.};; 3028 Double_t green[9] = { 0./255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:114871,Energy Efficiency,green,green,114871,"255., 48./255., 124./255., 192./255., 206./255., 226./255., 97./255., 16./255., 0./255.};; 3029 Double_t blue[9] = { 99./255., 142./255., 198./255., 201./255., 90./255., 22./255., 13./255., 8./255., 2./255.};; 3030 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:115117,Energy Efficiency,green,green,115117,"ue, 255, alpha);; 3031 }; 3032 break;; 3033 ; 3034 // Inverted Dark Body Radiator; 3035 case 56:; 3036 {; 3037 Double_t red[9] = { 242./255., 234./255., 237./255., 230./255., 212./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 307",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:115327,Energy Efficiency,green,green,115327,"./255., 156./255., 99./255., 45./255., 0./255.};; 3038 Double_t green[9] = { 243./255., 238./255., 238./255., 168./255., 101./255., 45./255., 0./255., 0./255., 0./255.};; 3039 Double_t blue[9] = { 230./255., 95./255., 11./255., 8./255., 9./255., 3./255., 1./255., 1./255., 0./255.};; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:115573,Energy Efficiency,green,green,115573,"; 3040 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3041 }; 3042 break;; 3043 ; 3044 // Bird; 3045 case 57:; 3046 {; 3047 Double_t red[9] = { 0.2082, 0.0592, 0.0780, 0.0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, gre",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:115811,Energy Efficiency,green,green,115811,"0232, 0.1802, 0.5301, 0.8186, 0.9956, 0.9764};; 3048 Double_t green[9] = { 0.1664, 0.3599, 0.5041, 0.6419, 0.7178, 0.7492, 0.7328, 0.7862, 0.9832};; 3049 Double_t blue[9] = { 0.5293, 0.8684, 0.8385, 0.7914, 0.6425, 0.4662, 0.3499, 0.1968, 0.0539};; 3050 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:116088,Energy Efficiency,green,green,116088,"n, blue, 255, alpha);; 3051 }; 3052 break;; 3053 ; 3054 // Cubehelix; 3055 case 58:; 3056 {; 3057 Double_t red[9] = { 0.0000, 0.0956, 0.0098, 0.2124, 0.6905, 0.9242, 0.7914, 0.7596, 1.0000};; 3058 Double_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blu",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:116326,Energy Efficiency,green,green,116326,"_t green[9] = { 0.0000, 0.1147, 0.3616, 0.5041, 0.4577, 0.4691, 0.6905, 0.9237, 1.0000};; 3059 Double_t blue[9] = { 0.0000, 0.2669, 0.3121, 0.1318, 0.2236, 0.6741, 0.9882, 0.9593, 1.0000};; 3060 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3061 }; 3062 break;; 3063 ; 3064 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:116602,Energy Efficiency,green,green,116602,"4 // Green Red Violet; 3065 case 59:; 3066 {; 3067 Double_t red[9] = {13./255., 23./255., 25./255., 63./255., 76./255., 104./255., 137./255., 161./255., 206./255.};; 3068 Double_t green[9] = {95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:116824,Energy Efficiency,green,green,116824,"95./255., 67./255., 37./255., 21./255., 0./255., 12./255., 35./255., 52./255., 79./255.};; 3069 Double_t blue[9] = { 4./255., 3./255., 2./255., 6./255., 11./255., 22./255., 49./255., 98./255., 208./255.};; 3070 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3071 }; 3072 break;; 3073 ; 3074 // Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:117111,Energy Efficiency,green,green,117111,"// Blue Red Yellow; 3075 case 60:; 3076 {; 3077 Double_t red[9] = {0./255., 61./255., 89./255., 122./255., 143./255., 160./255., 185./255., 204./255., 231./255.};; 3078 Double_t green[9] = {0./255., 0./255., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, s",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:117355,Energy Efficiency,green,green,117355,"., 0./255., 0./255., 14./255., 37./255., 72./255., 132./255., 235./255.};; 3079 Double_t blue[9] = {0./255., 140./255., 224./255., 144./255., 4./255., 5./255., 6./255., 9./255., 13./255.};; 3080 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3081 }; 3082 break;; 3083 ; 3084 // Ocean; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:117640,Energy Efficiency,green,green,117640,"n; 3085 case 61:; 3086 {; 3087 Double_t red[9] = { 14./255., 7./255., 2./255., 0./255., 5./255., 11./255., 55./255., 131./255., 229./255.};; 3088 Double_t green[9] = {105./255., 56./255., 26./255., 1./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradie",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:117869,Energy Efficiency,green,green,117869,"./255., 42./255., 74./255., 131./255., 171./255., 229./255.};; 3089 Double_t blue[9] = { 2./255., 21./255., 35./255., 60./255., 92./255., 113./255., 160./255., 185./255., 229./255.};; 3090 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3091 }; 3092 break;; 3093 ; 3094 // Color Printable On Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 1",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:118160,Energy Efficiency,green,green,118160," Grey; 3095 case 62:; 3096 {; 3097 Double_t red[9] = { 0./255., 0./255., 0./255., 70./255., 148./255., 231./255., 235./255., 237./255., 244./255.};; 3098 Double_t green[9] = { 0./255., 0./255., 0./255., 0./255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGrad",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:118398,Energy Efficiency,green,green,118398,"/255., 0./255., 69./255., 67./255., 216./255., 244./255.};; 3099 Double_t blue[9] = { 0./255., 102./255., 228./255., 231./255., 177./255., 124./255., 137./255., 20./255., 244./255.};; 3100 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3101 }; 3102 break;; 3103 ; 3104 // Alpine; 3105 case 63:; 3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:118698,Energy Efficiency,green,green,118698,"3106 {; 3107 Double_t red[9] = { 50./255., 56./255., 63./255., 68./255., 93./255., 121./255., 165./255., 192./255., 241./255.};; 3108 Double_t green[9] = { 66./255., 81./255., 91./255., 96./255., 111./255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColor",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:118927,Energy Efficiency,green,green,118927,"/255., 128./255., 155./255., 189./255., 241./255.};; 3109 Double_t blue[9] = { 97./255., 91./255., 75./255., 65./255., 77./255., 103./255., 143./255., 167./255., 217./255.};; 3110 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3111 }; 3112 break;; 3113 ; 3114 // Aquamarine; 3115 case 64:; 3116 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:119222,Energy Efficiency,green,green,119222,"16 {; 3117 Double_t red[9] = { 145./255., 166./255., 167./255., 156./255., 131./255., 114./255., 101./255., 112./255., 132./255.};; 3118 Double_t green[9] = { 158./255., 178./255., 179./255., 181./255., 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:119454,Energy Efficiency,green,green,119454,", 163./255., 154./255., 144./255., 152./255., 159./255.};; 3119 Double_t blue[9] = { 190./255., 199./255., 201./255., 192./255., 176./255., 169./255., 160./255., 166./255., 190./255.};; 3120 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3121 }; 3122 break;; 3123 ; 3124 // Army; 3125 case 65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:119748,Energy Efficiency,green,green,119748,"65:; 3126 {; 3127 Double_t red[9] = { 93./255., 91./255., 99./255., 108./255., 130./255., 125./255., 132./255., 155./255., 174./255.};; 3128 Double_t green[9] = { 126./255., 124./255., 128./255., 129./255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:119978,Energy Efficiency,green,green,119978,"/255., 131./255., 121./255., 119./255., 153./255., 173./255.};; 3129 Double_t blue[9] = { 103./255., 94./255., 87./255., 85./255., 80./255., 85./255., 107./255., 120./255., 146./255.};; 3130 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3131 }; 3132 break;; 3133 ; 3134 // Atlantic; 3135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 1",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:120267,Energy Efficiency,green,green,120267,"135 case 66:; 3136 {; 3137 Double_t red[9] = { 24./255., 40./255., 69./255., 90./255., 104./255., 114./255., 120./255., 132./255., 103./255.};; 3138 Double_t green[9] = { 29./255., 52./255., 94./255., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:120495,Energy Efficiency,green,green,120495,"5., 127./255., 150./255., 162./255., 159./255., 151./255., 101./255.};; 3139 Double_t blue[9] = { 29./255., 52./255., 96./255., 132./255., 162./255., 181./255., 184./255., 186./255., 131./255.};; 3140 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3141 }; 3142 break;; 3143 ; 3144 // Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:120781,Energy Efficiency,green,green,120781," Aurora; 3145 case 67:; 3146 {; 3147 Double_t red[9] = { 46./255., 38./255., 61./255., 92./255., 113./255., 121./255., 132./255., 150./255., 191./255.};; 3148 Double_t green[9] = { 46./255., 36./255., 40./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradient",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:121014,Energy Efficiency,green,green,121014,"./255., 69./255., 110./255., 135./255., 131./255., 92./255., 34./255.};; 3149 Double_t blue[9] = { 46./255., 80./255., 74./255., 70./255., 81./255., 105./255., 165./255., 211./255., 225./255.};; 3150 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3151 }; 3152 break;; 3153 ; 3154 // Avocado; 3155 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:121309,Energy Efficiency,green,green,121309,"55 case 68:; 3156 {; 3157 Double_t red[9] = { 0./255., 4./255., 12./255., 30./255., 52./255., 101./255., 142./255., 190./255., 237./255.};; 3158 Double_t green[9] = { 0./255., 40./255., 86./255., 121./255., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientC",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:121547,Energy Efficiency,green,green,121547,"., 140./255., 172./255., 187./255., 213./255., 240./255.};; 3159 Double_t blue[9] = { 0./255., 9./255., 14./255., 18./255., 21./255., 23./255., 27./255., 35./255., 101./255.};; 3160 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3161 }; 3162 break;; 3163 ; 3164 // Beach; 3165 case 69:; 3166 {; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:121837,Energy Efficiency,green,green,121837,"; 3167 Double_t red[9] = { 198./255., 206./255., 206./255., 211./255., 198./255., 181./255., 161./255., 171./255., 244./255.};; 3168 Double_t green[9] = { 103./255., 133./255., 150./255., 172./255., 178./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradient",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:122075,Energy Efficiency,green,green,122075,"8./255., 174./255., 163./255., 175./255., 244./255.};; 3169 Double_t blue[9] = { 49./255., 54./255., 55./255., 66./255., 91./255., 130./255., 184./255., 224./255., 244./255.};; 3170 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3171 }; 3172 break;; 3173 ; 3174 // Black Body; 3175 case 70:; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:122366,Energy Efficiency,green,green,122366,"; 3176 {; 3177 Double_t red[9] = { 243./255., 243./255., 240./255., 240./255., 241./255., 239./255., 186./255., 151./255., 129./255.};; 3178 Double_t green[9] = { 0./255., 46./255., 99./255., 149./255., 194./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientC",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:122602,Energy Efficiency,green,green,122602,"94./255., 220./255., 183./255., 166./255., 147./255.};; 3179 Double_t blue[9] = { 6./255., 8./255., 36./255., 91./255., 169./255., 235./255., 246./255., 240./255., 233./255.};; 3180 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3181 }; 3182 break;; 3183 ; 3184 // Blue Green Yellow; 3185 case 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:122898,Energy Efficiency,green,green,122898,"se 71:; 3186 {; 3187 Double_t red[9] = { 22./255., 19./255., 19./255., 25./255., 35./255., 53./255., 88./255., 139./255., 210./255.};; 3188 Double_t green[9] = { 0./255., 32./255., 69./255., 108./255., 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColor",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:123127,Energy Efficiency,green,green,123127,", 135./255., 159./255., 183./255., 198./255., 215./255.};; 3189 Double_t blue[9] = { 77./255., 96./255., 110./255., 116./255., 110./255., 100./255., 90./255., 78./255., 70./255.};; 3190 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3191 }; 3192 break;; 3193 ; 3194 // Brown Cyan; 3195 case 72:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:123423,Energy Efficiency,green,green,123423,"2:; 3196 {; 3197 Double_t red[9] = { 68./255., 116./255., 165./255., 182./255., 189./255., 180./255., 145./255., 111./255., 71./255.};; 3198 Double_t green[9] = { 37./255., 82./255., 135./255., 178./255., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTabl",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:123655,Energy Efficiency,green,green,123655,"., 204./255., 225./255., 221./255., 202./255., 147./255.};; 3199 Double_t blue[9] = { 16./255., 55./255., 105./255., 147./255., 196./255., 226./255., 232./255., 224./255., 178./255.};; 3200 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3201 }; 3202 break;; 3203 ; 3204 // CMYK; 3205 case 73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 1",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:123948,Energy Efficiency,green,green,123948,"73:; 3206 {; 3207 Double_t red[9] = { 61./255., 99./255., 136./255., 181./255., 213./255., 225./255., 198./255., 136./255., 24./255.};; 3208 Double_t green[9] = { 149./255., 140./255., 96./255., 83./255., 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:124181,Energy Efficiency,green,green,124181,", 132./255., 178./255., 190./255., 135./255., 22./255.};; 3209 Double_t blue[9] = { 214./255., 203./255., 168./255., 135./255., 110./255., 100./255., 111./255., 113./255., 22./255.};; 3210 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3211 }; 3212 break;; 3213 ; 3214 // Candy; 3215 case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:124469,Energy Efficiency,green,green,124469,"case 74:; 3216 {; 3217 Double_t red[9] = { 76./255., 120./255., 156./255., 183./255., 197./255., 180./255., 162./255., 154./255., 140./255.};; 3218 Double_t green[9] = { 34./255., 35./255., 42./255., 69./255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTa",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:124702,Energy Efficiency,green,green,124702,"/255., 102./255., 137./255., 164./255., 188./255., 197./255.};; 3219 Double_t blue[9] = { 64./255., 69./255., 78./255., 105./255., 142./255., 177./255., 205./255., 217./255., 198./255.};; 3220 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3221 }; 3222 break;; 3223 ; 3224 // Cherry; 3225 case 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:124993,Energy Efficiency,green,green,124993,"se 75:; 3226 {; 3227 Double_t red[9] = { 37./255., 102./255., 157./255., 188./255., 196./255., 214./255., 223./255., 235./255., 251./255.};; 3228 Double_t green[9] = { 37./255., 29./255., 25./255., 37./255., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:125230,Energy Efficiency,green,green,125230,"55., 67./255., 91./255., 132./255., 185./255., 251./255.};; 3229 Double_t blue[9] = { 37./255., 32./255., 33./255., 45./255., 66./255., 98./255., 137./255., 187./255., 251./255.};; 3230 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3231 }; 3232 break;; 3233 ; 3234 // Coffee; 3235 case 76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:125518,Energy Efficiency,green,green,125518,"76:; 3236 {; 3237 Double_t red[9] = { 79./255., 100./255., 119./255., 137./255., 153./255., 172./255., 192./255., 205./255., 250./255.};; 3238 Double_t green[9] = { 63./255., 79./255., 93./255., 103./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, gr",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:125750,Energy Efficiency,green,green,125750,"./255., 115./255., 135./255., 167./255., 196./255., 250./255.};; 3239 Double_t blue[9] = { 51./255., 59./255., 66./255., 61./255., 62./255., 70./255., 110./255., 160./255., 250./255.};; 3240 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3241 }; 3242 break;; 3243 ; 3244 // Dark Rain Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:126035,Energy Efficiency,green,green,126035,"in Bow; 3245 case 77:; 3246 {; 3247 Double_t red[9] = { 43./255., 44./255., 50./255., 66./255., 125./255., 172./255., 178./255., 155./255., 157./255.};; 3248 Double_t green[9] = { 63./255., 63./255., 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, st",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:126263,Energy Efficiency,green,green,126263," 85./255., 101./255., 138./255., 163./255., 122./255., 51./255., 39./255.};; 3249 Double_t blue[9] = { 121./255., 101./255., 58./255., 44./255., 47./255., 55./255., 57./255., 44./255., 43./255.};; 3250 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3251 }; 3252 break;; 3253 ; 3254 // Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:126548,Energy Efficiency,green,green,126548," Dark Terrain; 3255 case 78:; 3256 {; 3257 Double_t red[9] = { 0./255., 41./255., 62./255., 79./255., 90./255., 87./255., 99./255., 140./255., 228./255.};; 3258 Double_t green[9] = { 0./255., 57./255., 81./255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:126787,Energy Efficiency,green,green,126787,"255., 93./255., 85./255., 70./255., 71./255., 125./255., 228./255.};; 3259 Double_t blue[9] = { 95./255., 91./255., 91./255., 82./255., 60./255., 43./255., 44./255., 112./255., 228./255.};; 3260 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3261 }; 3262 break;; 3263 ; 3264 // Fall; 3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:127074,Energy Efficiency,green,green,127074,"3265 case 79:; 3266 {; 3267 Double_t red[9] = { 49./255., 59./255., 72./255., 88./255., 114./255., 141./255., 176./255., 205./255., 222./255.};; 3268 Double_t green[9] = { 78./255., 72./255., 66./255., 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColor",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:127306,Energy Efficiency,green,green,127306," 57./255., 59./255., 75./255., 106./255., 142./255., 173./255.};; 3269 Double_t blue[9] = { 78./255., 55./255., 46./255., 40./255., 39./255., 39./255., 40./255., 41./255., 47./255.};; 3270 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3271 }; 3272 break;; 3273 ; 3274 // Fruit Punch; 3275 case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:127597,Energy Efficiency,green,green,127597,"case 80:; 3276 {; 3277 Double_t red[9] = { 243./255., 222./255., 201./255., 185./255., 165./255., 158./255., 166./255., 187./255., 219./255.};; 3278 Double_t green[9] = { 94./255., 108./255., 132./255., 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradien",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:127832,Energy Efficiency,green,green,127832," 135./255., 125./255., 96./255., 68./255., 51./255., 61./255.};; 3279 Double_t blue[9] = { 7./255., 9./255., 12./255., 19./255., 45./255., 89./255., 118./255., 146./255., 118./255.};; 3280 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3281 }; 3282 break;; 3283 ; 3284 // Fuchsia; 3285 case 81:; 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:128125,Energy Efficiency,green,green,128125," 3286 {; 3287 Double_t red[9] = { 19./255., 44./255., 74./255., 105./255., 137./255., 166./255., 194./255., 206./255., 220./255.};; 3288 Double_t green[9] = { 19./255., 28./255., 40./255., 55./255., 82./255., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTabl",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:128368,Energy Efficiency,green,green,128368,"., 110./255., 159./255., 181./255., 220./255.};; 3289 Double_t blue[9] = { 19./255., 42./255., 68./255., 96./255., 129./255., 157./255., 188./255., 203./255., 220./255.};; 3290 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3291 }; 3292 break;; 3293 ; 3294 // Grey Yellow; 3295 case 82:; 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:128656,Energy Efficiency,green,green,128656," 3296 {; 3297 Double_t red[9] = { 33./255., 44./255., 70./255., 99./255., 140./255., 165./255., 199./255., 211./255., 216./255.};; 3298 Double_t green[9] = { 38./255., 50./255., 76./255., 105./255., 140./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:128889,Energy Efficiency,green,green,128889,"0./255., 165./255., 191./255., 189./255., 167./255.};; 3299 Double_t blue[9] = { 55./255., 67./255., 97./255., 124./255., 140./255., 166./255., 163./255., 129./255., 52./255.};; 3300 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3301 }; 3302 break;; 3303 ; 3304 // Green Brown Terrain; 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:129178,Energy Efficiency,green,green,129178," 3305 case 83:; 3306 {; 3307 Double_t red[9] = { 0./255., 33./255., 73./255., 124./255., 136./255., 152./255., 159./255., 171./255., 223./255.};; 3308 Double_t green[9] = { 0./255., 43./255., 92./255., 124./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradient",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:129412,Energy Efficiency,green,green,129412,"24./255., 134./255., 126./255., 121./255., 144./255., 223./255.};; 3309 Double_t blue[9] = { 0./255., 43./255., 68./255., 76./255., 73./255., 64./255., 72./255., 114./255., 223./255.};; 3310 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3311 }; 3312 break;; 3313 ; 3314 // Green Pink; 3315 case 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:129709,Energy Efficiency,green,green,129709,"ase 84:; 3316 {; 3317 Double_t red[9] = { 5./255., 18./255., 45./255., 124./255., 193./255., 223./255., 205./255., 128./255., 49./255.};; 3318 Double_t green[9] = { 48./255., 134./255., 207./255., 230./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::Creat",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:129938,Energy Efficiency,green,green,129938,"0./255., 193./255., 113./255., 28./255., 0./255., 7./255.};; 3319 Double_t blue[9] = { 6./255., 15./255., 41./255., 121./255., 193./255., 226./255., 208./255., 130./255., 49./255.};; 3320 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3321 }; 3322 break;; 3323 ; 3324 // Island; 3325 case 85:; 3326 {; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:130234,Energy Efficiency,green,green,130234,"{; 3327 Double_t red[9] = { 180./255., 106./255., 104./255., 135./255., 164./255., 188./255., 189./255., 165./255., 144./255.};; 3328 Double_t green[9] = { 72./255., 126./255., 154./255., 184./255., 198./255., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TCol",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:130477,Energy Efficiency,green,green,130477,"., 207./255., 205./255., 190./255., 179./255.};; 3329 Double_t blue[9] = { 41./255., 120./255., 158./255., 188./255., 194./255., 181./255., 145./255., 100./255., 62./255.};; 3330 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3331 }; 3332 break;; 3333 ; 3334 // Lake; 3335 case 86:; 3336 {; 3337 Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 15",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:130773,Energy Efficiency,green,green,130773,"Double_t red[9] = { 57./255., 72./255., 94./255., 117./255., 136./255., 154./255., 174./255., 192./255., 215./255.};; 3338 Double_t green[9] = { 0./255., 33./255., 68./255., 109./255., 140./255., 171./255., 192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::Cr",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:131014,Energy Efficiency,green,green,131014,"192./255., 196./255., 209./255.};; 3339 Double_t blue[9] = { 116./255., 137./255., 173./255., 201./255., 200./255., 201./255., 203./255., 190./255., 187./255.};; 3340 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3341 }; 3342 break;; 3343 ; 3344 // Light Temperature; 3345 case 87:; 3346 {; 3347 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:131313,Energy Efficiency,green,green,131313,"7 Double_t red[9] = { 31./255., 71./255., 123./255., 160./255., 210./255., 222./255., 214./255., 199./255., 183./255.};; 3348 Double_t green[9] = { 40./255., 117./255., 171./255., 211./255., 231./255., 220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColor",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:131545,Energy Efficiency,green,green,131545,"220./255., 190./255., 132./255., 65./255.};; 3349 Double_t blue[9] = { 234./255., 214./255., 228./255., 222./255., 210./255., 160./255., 105./255., 60./255., 34./255.};; 3350 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3351 }; 3352 break;; 3353 ; 3354 // Light Terrain; 3355 case 88:; 3356 {; 3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:131845,Energy Efficiency,green,green,131845,"3357 Double_t red[9] = { 123./255., 108./255., 109./255., 126./255., 154./255., 172./255., 188./255., 196./255., 218./255.};; 3358 Double_t green[9] = { 184./255., 138./255., 130./255., 133./255., 154./255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColor",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:132077,Energy Efficiency,green,green,132077,"255., 175./255., 188./255., 196./255., 218./255.};; 3359 Double_t blue[9] = { 208./255., 130./255., 109./255., 99./255., 110./255., 122./255., 150./255., 171./255., 218./255.};; 3360 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3361 }; 3362 break;; 3363 ; 3364 // Mint; 3365 case 89:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:132363,Energy Efficiency,green,green,132363,"9:; 3366 {; 3367 Double_t red[9] = { 105./255., 106./255., 122./255., 143./255., 159./255., 172./255., 176./255., 181./255., 207./255.};; 3368 Double_t green[9] = { 252./255., 197./255., 194./255., 187./255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::Creat",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:132596,Energy Efficiency,green,green,132596,"/255., 174./255., 162./255., 153./255., 136./255., 125./255.};; 3369 Double_t blue[9] = { 146./255., 133./255., 144./255., 155./255., 163./255., 167./255., 166./255., 162./255., 174./255.};; 3370 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3371 }; 3372 break;; 3373 ; 3374 // Neon; 3375 case 90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:132895,Energy Efficiency,green,green,132895,"90:; 3376 {; 3377 Double_t red[9] = { 171./255., 141./255., 145./255., 152./255., 154./255., 159./255., 163./255., 158./255., 177./255.};; 3378 Double_t green[9] = { 236./255., 143./255., 100./255., 63./255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:133128,Energy Efficiency,green,green,133128,"255., 53./255., 55./255., 44./255., 31./255., 6./255.};; 3379 Double_t blue[9] = { 59./255., 48./255., 46./255., 44./255., 42./255., 54./255., 82./255., 112./255., 179./255.};; 3380 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3381 }; 3382 break;; 3383 ; 3384 // Pastel; 3385 case 91:; 3386 {; 3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:133428,Energy Efficiency,green,green,133428,"3387 Double_t red[9] = { 180./255., 190./255., 209./255., 223./255., 204./255., 228./255., 205./255., 152./255., 91./255.};; 3388 Double_t green[9] = { 93./255., 125./255., 147./255., 172./255., 181./255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, gree",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:133657,Energy Efficiency,green,green,133657,"/255., 224./255., 233./255., 198./255., 158./255.};; 3389 Double_t blue[9] = { 236./255., 218./255., 160./255., 133./255., 114./255., 132./255., 162./255., 220./255., 218./255.};; 3390 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3391 }; 3392 break;; 3393 ; 3394 // Pearl; 3395 case 92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:133947,Energy Efficiency,green,green,133947,"92:; 3396 {; 3397 Double_t red[9] = { 225./255., 183./255., 162./255., 135./255., 115./255., 111./255., 119./255., 145./255., 211./255.};; 3398 Double_t green[9] = { 205./255., 177./255., 166./255., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:134172,Energy Efficiency,green,green,134172,"5., 135./255., 124./255., 117./255., 117./255., 132./255., 172./255.};; 3399 Double_t blue[9] = { 186./255., 165./255., 155./255., 135./255., 126./255., 130./255., 150./255., 178./255., 226./255.};; 3400 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3401 }; 3402 break;; 3403 ; 3404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 13",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:134454,Energy Efficiency,green,green,134454,"404 // Pigeon; 3405 case 93:; 3406 {; 3407 Double_t red[9] = { 39./255., 43./255., 59./255., 63./255., 80./255., 116./255., 153./255., 177./255., 223./255.};; 3408 Double_t green[9] = { 39./255., 43./255., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, r",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:134686,Energy Efficiency,green,green,134686,"55., 59./255., 74./255., 91./255., 114./255., 139./255., 165./255., 223./255.};; 3409 Double_t blue[9] = { 39./255., 50./255., 59./255., 70./255., 85./255., 115./255., 151./255., 176./255., 223./255.};; 3410 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3411 }; 3412 break;; 3413 ; 3414 // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:134978,Energy Efficiency,green,green,134978," // Plum; 3415 case 94:; 3416 {; 3417 Double_t red[9] = { 0./255., 38./255., 60./255., 76./255., 84./255., 89./255., 101./255., 128./255., 204./255.};; 3418 Double_t green[9] = { 0./255., 10./255., 15./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, bl",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:135207,Energy Efficiency,green,green,135207,"./255., 23./255., 35./255., 57./255., 83./255., 123./255., 199./255.};; 3419 Double_t blue[9] = { 0./255., 11./255., 22./255., 40./255., 63./255., 86./255., 97./255., 94./255., 85./255.};; 3420 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3421 }; 3422 break;; 3423 ; 3424 // Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:135489,Energy Efficiency,green,green,135489,"Red Blue; 3425 case 95:; 3426 {; 3427 Double_t red[9] = { 94./255., 112./255., 141./255., 165./255., 167./255., 140./255., 91./255., 49./255., 27./255.};; 3428 Double_t green[9] = { 27./255., 46./255., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:135717,Energy Efficiency,green,green,135717,"5., 88./255., 135./255., 166./255., 161./255., 135./255., 97./255., 58./255.};; 3429 Double_t blue[9] = { 42./255., 52./255., 81./255., 106./255., 139./255., 158./255., 155./255., 137./255., 116./255.};; 3430 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3431 }; 3432 break;; 3433 ; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:135998,Energy Efficiency,green,green,135998,"; 3434 // Rose; 3435 case 96:; 3436 {; 3437 Double_t red[9] = { 30./255., 49./255., 79./255., 117./255., 135./255., 151./255., 146./255., 138./255., 147./255.};; 3438 Double_t green[9] = { 63./255., 60./255., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:136237,Energy Efficiency,green,green,136237,"5., 72./255., 90./255., 94./255., 94./255., 68./255., 46./255., 16./255.};; 3439 Double_t blue[9] = { 18./255., 28./255., 41./255., 56./255., 62./255., 63./255., 50./255., 36./255., 21./255.};; 3440 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3441 }; 3442 break;; 3443 ; 3444 // Rust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:136524,Energy Efficiency,green,green,136524,"ust; 3445 case 97:; 3446 {; 3447 Double_t red[9] = { 0./255., 30./255., 63./255., 101./255., 143./255., 152./255., 169./255., 187./255., 230./255.};; 3448 Double_t green[9] = { 0./255., 14./255., 28./255., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, re",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:136757,Energy Efficiency,green,green,136757,"., 42./255., 58./255., 61./255., 67./255., 74./255., 91./255.};; 3449 Double_t blue[9] = { 39./255., 26./255., 21./255., 18./255., 15./255., 14./255., 14./255., 13./255., 13./255.};; 3450 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3451 }; 3452 break;; 3453 ; 3454 // Sandy Terrain; 3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:137047,Energy Efficiency,green,green,137047,"3455 case 98:; 3456 {; 3457 Double_t red[9] = { 149./255., 140./255., 164./255., 179./255., 182./255., 181./255., 131./255., 87./255., 61./255.};; 3458 Double_t green[9] = { 62./255., 70./255., 107./255., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:137280,Energy Efficiency,green,green,137280,"., 136./255., 144./255., 138./255., 117./255., 87./255., 74./255.};; 3459 Double_t blue[9] = { 40./255., 38./255., 45./255., 49./255., 49./255., 49./255., 38./255., 32./255., 34./255.};; 3460 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3461 }; 3462 break;; 3463 ; 3464 // Sienna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:137557,Energy Efficiency,green,green,137557,"enna; 3465 case 99:; 3466 {; 3467 Double_t red[9] = { 99./255., 112./255., 148./255., 165./255., 179./255., 182./255., 183./255., 183./255., 208./255.};; 3468 Double_t green[9] = { 39./255., 40./255., 57./255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientCo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:137794,Energy Efficiency,green,green,137794,"/255., 79./255., 104./255., 127./255., 148./255., 161./255., 198./255.};; 3469 Double_t blue[9] = { 15./255., 16./255., 18./255., 33./255., 51./255., 79./255., 103./255., 129./255., 177./255.};; 3470 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3471 }; 3472 break;; 3473 ; 3474 // Solar; 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:138083,Energy Efficiency,green,green,138083," 3475 case 100:; 3476 {; 3477 Double_t red[9] = { 99./255., 116./255., 154./255., 174./255., 200./255., 196./255., 201./255., 201./255., 230./255.};; 3478 Double_t green[9] = { 0./255., 0./255., 8./255., 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:138320,Energy Efficiency,green,green,138320," 32./255., 58./255., 83./255., 119./255., 136./255., 173./255.};; 3479 Double_t blue[9] = { 5./255., 6./255., 7./255., 9./255., 9./255., 14./255., 17./255., 19./255., 24./255.};; 3480 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3481 }; 3482 break;; 3483 ; 3484 // South West; 3485 case 101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:138613,Energy Efficiency,green,green,138613,"101:; 3486 {; 3487 Double_t red[9] = { 82./255., 106./255., 126./255., 141./255., 155./255., 163./255., 142./255., 107./255., 66./255.};; 3488 Double_t green[9] = { 62./255., 44./255., 69./255., 107./255., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientCo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:138845,Energy Efficiency,green,green,138845,"55., 135./255., 152./255., 149./255., 132./255., 119./255.};; 3489 Double_t blue[9] = { 39./255., 25./255., 31./255., 60./255., 73./255., 68./255., 49./255., 72./255., 188./255.};; 3490 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3491 }; 3492 break;; 3493 ; 3494 // Starry Night; 3495 case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:139131,Energy Efficiency,green,green,139131,"case 102:; 3496 {; 3497 Double_t red[9] = { 18./255., 29./255., 44./255., 72./255., 116./255., 158./255., 184./255., 208./255., 221./255.};; 3498 Double_t green[9] = { 27./255., 46./255., 71./255., 105./255., 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGrad",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:139373,Energy Efficiency,green,green,139373,", 146./255., 177./255., 189./255., 190./255., 183./255.};; 3499 Double_t blue[9] = { 39./255., 55./255., 80./255., 108./255., 130./255., 133./255., 124./255., 100./255., 76./255.};; 3500 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3501 }; 3502 break;; 3503 ; 3504 // Sunset; 3505 case 103:; 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255.,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:139667,Energy Efficiency,green,green,139667," 3506 {; 3507 Double_t red[9] = { 0./255., 48./255., 119./255., 173./255., 212./255., 224./255., 228./255., 228./255., 245./255.};; 3508 Double_t green[9] = { 0./255., 13./255., 30./255., 47./255., 79./255., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:139905,Energy Efficiency,green,green,139905,"5., 127./255., 167./255., 205./255., 245./255.};; 3509 Double_t blue[9] = { 0./255., 68./255., 75./255., 43./255., 16./255., 22./255., 55./255., 128./255., 245./255.};; 3510 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3511 }; 3512 break;; 3513 ; 3514 // Temperature Map; 3515 case 104:; 3516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:140196,Energy Efficiency,green,green,140196,"516 {; 3517 Double_t red[9] = { 34./255., 70./255., 129./255., 187./255., 225./255., 226./255., 216./255., 193./255., 179./255.};; 3518 Double_t green[9] = { 48./255., 91./255., 147./255., 194./255., 226./255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, sto",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:140433,Energy Efficiency,green,green,140433,"/255., 229./255., 196./255., 110./255., 12./255.};; 3519 Double_t blue[9] = { 234./255., 212./255., 216./255., 224./255., 206./255., 110./255., 53./255., 40./255., 29./255.};; 3520 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3521 }; 3522 break;; 3523 ; 3524 // Thermometer; 3525 case 105:; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:140722,Energy Efficiency,green,green,140722,"; 3526 {; 3527 Double_t red[9] = { 30./255., 55./255., 103./255., 147./255., 174./255., 203./255., 188./255., 151./255., 105./255.};; 3528 Double_t green[9] = { 0./255., 65./255., 138./255., 182./255., 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:140959,Energy Efficiency,green,green,140959,", 187./255., 175./255., 121./255., 53./255., 9./255.};; 3529 Double_t blue[9] = { 191./255., 202./255., 212./255., 208./255., 171./255., 140./255., 97./255., 57./255., 30./255.};; 3530 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3531 }; 3532 break;; 3533 ; 3534 // Valentine; 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:141237,Energy Efficiency,green,green,141237," 3535 case 106:; 3536 {; 3537 Double_t red[9] = { 112./255., 97./255., 113./255., 125./255., 138./255., 159./255., 178./255., 188./255., 225./255.};; 3538 Double_t green[9] = { 16./255., 17./255., 24./255., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:141473,Energy Efficiency,green,green,141473,"5., 37./255., 56./255., 81./255., 110./255., 136./255., 189./255.};; 3539 Double_t blue[9] = { 38./255., 35./255., 46./255., 59./255., 78./255., 103./255., 130./255., 152./255., 201./255.};; 3540 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3541 }; 3542 break;; 3543 ; 3544 // Visible Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:141764,Energy Efficiency,green,green,141764,"Spectrum; 3545 case 107:; 3546 {; 3547 Double_t red[9] = { 18./255., 72./255., 5./255., 23./255., 29./255., 201./255., 200./255., 98./255., 29./255.};; 3548 Double_t green[9] = { 0./255., 0./255., 43./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:141992,Energy Efficiency,green,green,141992,"3./255., 167./255., 211./255., 117./255., 0./255., 0./255., 0./255.};; 3549 Double_t blue[9] = { 51./255., 203./255., 177./255., 26./255., 10./255., 9./255., 8./255., 3./255., 0./255.};; 3550 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3551 }; 3552 break;; 3553 ; 3554 // Water Melon; 3555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255.",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:142285,Energy Efficiency,green,green,142285,"555 case 108:; 3556 {; 3557 Double_t red[9] = { 19./255., 42./255., 64./255., 88./255., 118./255., 147./255., 175./255., 187./255., 205./255.};; 3558 Double_t green[9] = { 19./255., 55./255., 89./255., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:142515,Energy Efficiency,green,green,142515,"., 125./255., 154./255., 169./255., 161./255., 129./255., 70./255.};; 3559 Double_t blue[9] = { 19./255., 32./255., 47./255., 70./255., 100./255., 128./255., 145./255., 130./255., 75./255.};; 3560 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3561 }; 3562 break;; 3563 ; 3564 // Cool; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 14",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:142799,Energy Efficiency,green,green,142799,"l; 3565 case 109:; 3566 {; 3567 Double_t red[9] = { 33./255., 31./255., 42./255., 68./255., 86./255., 111./255., 141./255., 172./255., 227./255.};; 3568 Double_t green[9] = { 255./255., 175./255., 145./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stop",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:143032,Energy Efficiency,green,green,143032,"./255., 106./255., 88./255., 55./255., 15./255., 0./255., 0./255.};; 3569 Double_t blue[9] = { 255./255., 205./255., 202./255., 203./255., 208./255., 205./255., 203./255., 206./255., 231./255.};; 3570 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3571 }; 3572 break;; 3573 ; 3574 // Copper; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:143321,Energy Efficiency,green,green,143321,"per; 3575 case 110:; 3576 {; 3577 Double_t red[9] = { 0./255., 25./255., 50./255., 79./255., 110./255., 145./255., 181./255., 201./255., 254./255.};; 3578 Double_t green[9] = { 0./255., 16./255., 30./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, s",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:143550,Energy Efficiency,green,green,143550,"0./255., 46./255., 63./255., 82./255., 101./255., 124./255., 179./255.};; 3579 Double_t blue[9] = { 0./255., 12./255., 21./255., 29./255., 39./255., 49./255., 61./255., 74./255., 103./255.};; 3580 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3581 }; 3582 break;; 3583 ; 3584 // Gist Earth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:143839,Energy Efficiency,green,green,143839,"rth; 3585 case 111:; 3586 {; 3587 Double_t red[9] = { 0./255., 13./255., 30./255., 44./255., 72./255., 120./255., 156./255., 200./255., 247./255.};; 3588 Double_t green[9] = { 0./255., 36./255., 84./255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;; 3619 if (Idx>0) fgPalettesList.fArray[paletteType-51] = (Double_t)Idx;; 3620 else fgPalettesList.fArray[paletteType-51] = 0.;; 3621 if (alpha > 0.) fgPalettesList.fArray[paletteType-51] += alpha/10.0f;; 3622 return;; 3623 }; 3624 ; 3625 // set user defined palette; 3626 if (colors) {; 3627 fgPalette.Set(ncolors);; 36",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:144069,Energy Efficiency,green,green,144069,"255., 117./255., 141./255., 153./255., 151./255., 158./255., 247./255.};; 3589 Double_t blue[9] = { 0./255., 94./255., 100./255., 82./255., 56./255., 66./255., 76./255., 131./255., 247./255.};; 3590 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3591 }; 3592 break;; 3593 ; 3594 // Viridis; 3595 case 112:; 3596 {; 3597 Double_t red[9] = { 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;; 3619 if (Idx>0) fgPalettesList.fArray[paletteType-51] = (Double_t)Idx;; 3620 else fgPalettesList.fArray[paletteType-51] = 0.;; 3621 if (alpha > 0.) fgPalettesList.fArray[paletteType-51] += alpha/10.0f;; 3622 return;; 3623 }; 3624 ; 3625 // set user defined palette; 3626 if (colors) {; 3627 fgPalette.Set(ncolors);; 3628 for (i=0;i<ncolors;i++) fgPalette.fArray[i] = colors[i];; 3629 } else {; 3630 fgPalette.Set(TMath::Min(50,ncolors));; 3631 for (i=0;i<TMath::Min(50,ncolors);i++) fgPalette.fArray[i] = palette[i];;",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:144363,Energy Efficiency,green,green,144363," 26./255., 51./255., 43./255., 33./255., 28./255., 35./255., 74./255., 144./255., 246./255.};; 3598 Double_t green[9] = { 9./255., 24./255., 55./255., 87./255., 118./255., 150./255., 180./255., 200./255., 222./255.};; 3599 Double_t blue[9] = { 30./255., 96./255., 112./255., 114./255., 112./255., 101./255., 72./255., 35./255., 0./255.};; 3600 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3601 }; 3602 break;; 3603 ; 3604 // Cividis; 3605 case 113:; 3606 {; 3607 Double_t red[9] = { 0./255., 5./255., 65./255., 97./255., 124./255., 156./255., 189./255., 224./255., 255./255.};; 3608 Double_t green[9] = { 32./255., 54./255., 77./255., 100./255., 123./255., 148./255., 175./255., 203./255., 234./255.};; 3609 Double_t blue[9] = { 77./255., 110./255., 107./255., 111./255., 120./255., 119./255., 111./255., 94./255., 70./255.};; 3610 Idx = TColor::CreateGradientColorTable(9, stops, red, green, blue, 255, alpha);; 3611 }; 3612 break;; 3613 ; 3614 default:; 3615 ::Error(""SetPalette"", ""Unknown palette number %d"", ncolors);; 3616 return;; 3617 }; 3618 paletteType = ncolors;; 3619 if (Idx>0) fgPalettesList.fArray[paletteType-51] = (Double_t)Idx;; 3620 else fgPalettesList.fArray[paletteType-51] = 0.;; 3621 if (alpha > 0.) fgPalettesList.fArray[paletteType-51] += alpha/10.0f;; 3622 return;; 3623 }; 3624 ; 3625 // set user defined palette; 3626 if (colors) {; 3627 fgPalette.Set(ncolors);; 3628 for (i=0;i<ncolors;i++) fgPalette.fArray[i] = colors[i];; 3629 } else {; 3630 fgPalette.Set(TMath::Min(50,ncolors));; 3631 for (i=0;i<TMath::Min(50,ncolors);i++) fgPalette.fArray[i] = palette[i];; 3632 }; 3633 paletteType = 3;; 3634}; 3635 ; 3636 ; 3637////////////////////////////////////////////////////////////////////////////////; 3638/// Invert the current color palette.; 3639/// The top of the palette becomes the bottom and vice versa.; 3640 ; 3641void TColor::InvertPalette(); 3642{; 3643 std::reverse(fgPalette.fArray, fgPalette.fArray + fgPalette.GetSize());",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:69677,Integrability,depend,dependent,69677,"ex between [0,FF].; 1920 ; 1921Int_t TColor::GetColor(const char *hexcolor); 1922{; 1923 if (hexcolor && *hexcolor == '#') {; 1924 Int_t r, g, b;; 1925 if (sscanf(hexcolor+1, ""%02x%02x%02x"", &r, &g, &b) == 3); 1926 return GetColor(r, g, b);; 1927 }; 1928 ::Error(""TColor::GetColor(const char*)"", ""incorrect color string"");; 1929 return 0;; 1930}; 1931 ; 1932////////////////////////////////////////////////////////////////////////////////; 1933/// Static method returning color number for color specified by; 1934/// r, g and b. The r,g,b should be in the range [0,1].; 1935///; 1936/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1937///; 1938/// If specified color does not exist it will be created; 1939/// with as name ""#rrggbb"" with rr, gg and bb in hex between; 1940/// [0,FF].; 1941 ; 1942Int_t TColor::GetColor(Float_t r, Float_t g, Float_t b, Float_t a); 1943{; 1944 return GetColor(Int_t(r * 255), Int_t(g * 255), Int_t(b * 255), a);; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// Static method returning color number for color specified by; 1949/// system dependent pixel value. Pixel values can be obtained, e.g.,; 1950/// from the GUI color picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:70317,Integrability,depend,depending,70317," ; 1942Int_t TColor::GetColor(Float_t r, Float_t g, Float_t b, Float_t a); 1943{; 1944 return GetColor(Int_t(r * 255), Int_t(g * 255), Int_t(b * 255), a);; 1945}; 1946 ; 1947////////////////////////////////////////////////////////////////////////////////; 1948/// Static method returning color number for color specified by; 1949/// system dependent pixel value. Pixel values can be obtained, e.g.,; 1950/// from the GUI color picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993/////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:89049,Integrability,depend,dependent,89049,"--+--------------------+--------------------+\n"");; 2425 printf("" | Number of possible colors = %4d |\n"",ncolors);; 2426 printf("" | Number of defined colors between %4d and %4d = %4d |\n"",ci,last,nc);; 2427 printf("" | Number of free indeces between %4d and %4d = %4d |\n"",ci,last,last-ci-nc);; 2428 printf("" +--------------------------------------------------------------------------------+\n\n"");; 2429 ; 2430}; 2431 ; 2432////////////////////////////////////////////////////////////////////////////////; 2433/// Static method that given a color index number, returns the corresponding; 2434/// pixel value. This pixel value can be used in the GUI classes. This call; 2435/// does not work in batch mode since it needs to communicate with the; 2436/// graphics system.; 2437 ; 2438ULong_t TColor::Number2Pixel(Int_t ci); 2439{; 2440 TColor::InitializeColors();; 2441 TColor *color = gROOT->GetColor(ci);; 2442 if (color); 2443 return color->GetPixel();; 2444 else; 2445 ::Warning(""TColor::Number2Pixel"", ""color with index %d not defined"", ci);; 2446 ; 2447 return 0;; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Convert r,g,b to graphics system dependent pixel value.; 2452/// The r,g,b triplet must be [0,1].; 2453 ; 2454ULong_t TColor::RGB2Pixel(Float_t r, Float_t g, Float_t b); 2455{; 2456 if (r < 0) r = 0;; 2457 if (g < 0) g = 0;; 2458 if (b < 0) b = 0;; 2459 if (r > 1) r = 1;; 2460 if (g > 1) g = 1;; 2461 if (b > 1) b = 1;; 2462 ; 2463 ColorStruct_t color;; 2464 color.fRed = UShort_t(r * 65535);; 2465 color.fGreen = UShort_t(g * 65535);; 2466 color.fBlue = UShort_t(b * 65535);; 2467 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2468 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2469 return color.fPixel;; 2470}; 2471 ; 2472////////////////////////////////////////////////////////////////////////////////; 2473/// Convert r,g,b to graphics system dependent pixel value.; 2474/// The r,g,b triplet must be [0,255].;",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:89773,Integrability,depend,dependent,89773,"olor *color = gROOT->GetColor(ci);; 2442 if (color); 2443 return color->GetPixel();; 2444 else; 2445 ::Warning(""TColor::Number2Pixel"", ""color with index %d not defined"", ci);; 2446 ; 2447 return 0;; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Convert r,g,b to graphics system dependent pixel value.; 2452/// The r,g,b triplet must be [0,1].; 2453 ; 2454ULong_t TColor::RGB2Pixel(Float_t r, Float_t g, Float_t b); 2455{; 2456 if (r < 0) r = 0;; 2457 if (g < 0) g = 0;; 2458 if (b < 0) b = 0;; 2459 if (r > 1) r = 1;; 2460 if (g > 1) g = 1;; 2461 if (b > 1) b = 1;; 2462 ; 2463 ColorStruct_t color;; 2464 color.fRed = UShort_t(r * 65535);; 2465 color.fGreen = UShort_t(g * 65535);; 2466 color.fBlue = UShort_t(b * 65535);; 2467 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2468 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2469 return color.fPixel;; 2470}; 2471 ; 2472////////////////////////////////////////////////////////////////////////////////; 2473/// Convert r,g,b to graphics system dependent pixel value.; 2474/// The r,g,b triplet must be [0,255].; 2475 ; 2476ULong_t TColor::RGB2Pixel(Int_t r, Int_t g, Int_t b); 2477{; 2478 if (r < 0) r = 0;; 2479 if (g < 0) g = 0;; 2480 if (b < 0) b = 0;; 2481 if (r > 255) r = 255;; 2482 if (g > 255) g = 255;; 2483 if (b > 255) b = 255;; 2484 ; 2485 ColorStruct_t color;; 2486 color.fRed = UShort_t(r * 257); // 65535/255; 2487 color.fGreen = UShort_t(g * 257);; 2488 color.fBlue = UShort_t(b * 257);; 2489 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2490 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2491 return color.fPixel;; 2492}; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2496/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2497/// The r,g,b triplet will be [0,1].; 2498 ; 2499void TColor::Pixel2RGB(ULong_t pixel, ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:90495,Integrability,depend,dependent,90495,"5);; 2467 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2468 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2469 return color.fPixel;; 2470}; 2471 ; 2472////////////////////////////////////////////////////////////////////////////////; 2473/// Convert r,g,b to graphics system dependent pixel value.; 2474/// The r,g,b triplet must be [0,255].; 2475 ; 2476ULong_t TColor::RGB2Pixel(Int_t r, Int_t g, Int_t b); 2477{; 2478 if (r < 0) r = 0;; 2479 if (g < 0) g = 0;; 2480 if (b < 0) b = 0;; 2481 if (r > 255) r = 255;; 2482 if (g > 255) g = 255;; 2483 if (b > 255) b = 255;; 2484 ; 2485 ColorStruct_t color;; 2486 color.fRed = UShort_t(r * 257); // 65535/255; 2487 color.fGreen = UShort_t(g * 257);; 2488 color.fBlue = UShort_t(b * 257);; 2489 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2490 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2491 return color.fPixel;; 2492}; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2496/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2497/// The r,g,b triplet will be [0,1].; 2498 ; 2499void TColor::Pixel2RGB(ULong_t pixel, Float_t &r, Float_t &g, Float_t &b); 2500{; 2501 ColorStruct_t color;; 2502 color.fPixel = pixel;; 2503 gVirtualX->QueryColor(gVirtualX->GetColormap(), color);; 2504 r = (Float_t)color.fRed / 65535.0f;; 2505 g = (Float_t)color.fGreen / 65535.0f;; 2506 b = (Float_t)color.fBlue / 65535.0f;; 2507}; 2508 ; 2509////////////////////////////////////////////////////////////////////////////////; 2510/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2511/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2512/// The r,g,b triplet will be [0,255].; 2513 ; 2514void TColor::Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b); 2515{; 2516 ColorStruct_t color;; 2517 color.fPixel = pixel;; 2518 gVirtualX->QueryColor(gVirtualX->GetColormap(), colo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:91123,Integrability,depend,dependent,91123,"= UShort_t(r * 257); // 65535/255; 2487 color.fGreen = UShort_t(g * 257);; 2488 color.fBlue = UShort_t(b * 257);; 2489 color.fMask = kDoRed | kDoGreen | kDoBlue;; 2490 gVirtualX->AllocColor(gVirtualX->GetColormap(), color);; 2491 return color.fPixel;; 2492}; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2496/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2497/// The r,g,b triplet will be [0,1].; 2498 ; 2499void TColor::Pixel2RGB(ULong_t pixel, Float_t &r, Float_t &g, Float_t &b); 2500{; 2501 ColorStruct_t color;; 2502 color.fPixel = pixel;; 2503 gVirtualX->QueryColor(gVirtualX->GetColormap(), color);; 2504 r = (Float_t)color.fRed / 65535.0f;; 2505 g = (Float_t)color.fGreen / 65535.0f;; 2506 b = (Float_t)color.fBlue / 65535.0f;; 2507}; 2508 ; 2509////////////////////////////////////////////////////////////////////////////////; 2510/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2511/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2512/// The r,g,b triplet will be [0,255].; 2513 ; 2514void TColor::Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b); 2515{; 2516 ColorStruct_t color;; 2517 color.fPixel = pixel;; 2518 gVirtualX->QueryColor(gVirtualX->GetColormap(), color);; 2519 r = color.fRed / 257;; 2520 g = color.fGreen / 257;; 2521 b = color.fBlue / 257;; 2522}; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2526/// via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; 2527/// This string can be directly passed to, for example,; 2528/// TGClient::GetColorByName(). String will be reused so copy immediately; 2529/// if needed.; 2530 ; 2531const char *TColor::PixelAsHexString(ULong_t pixel); 2532{; 2533 static TString tempbuf;; 2534 Int_t r, g, b;; 25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:91705,Integrability,depend,dependent,91705,"t pixel, Float_t &r, Float_t &g, Float_t &b); 2500{; 2501 ColorStruct_t color;; 2502 color.fPixel = pixel;; 2503 gVirtualX->QueryColor(gVirtualX->GetColormap(), color);; 2504 r = (Float_t)color.fRed / 65535.0f;; 2505 g = (Float_t)color.fGreen / 65535.0f;; 2506 b = (Float_t)color.fBlue / 65535.0f;; 2507}; 2508 ; 2509////////////////////////////////////////////////////////////////////////////////; 2510/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2511/// via Number2Pixel() or via TColor::GetPixel()) to r,g,b triplet.; 2512/// The r,g,b triplet will be [0,255].; 2513 ; 2514void TColor::Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b); 2515{; 2516 ColorStruct_t color;; 2517 color.fPixel = pixel;; 2518 gVirtualX->QueryColor(gVirtualX->GetColormap(), color);; 2519 r = color.fRed / 257;; 2520 g = color.fGreen / 257;; 2521 b = color.fBlue / 257;; 2522}; 2523 ; 2524////////////////////////////////////////////////////////////////////////////////; 2525/// Convert machine dependent pixel value (obtained via RGB2Pixel or; 2526/// via Number2Pixel() or via TColor::GetPixel()) to a hexadecimal string.; 2527/// This string can be directly passed to, for example,; 2528/// TGClient::GetColorByName(). String will be reused so copy immediately; 2529/// if needed.; 2530 ; 2531const char *TColor::PixelAsHexString(ULong_t pixel); 2532{; 2533 static TString tempbuf;; 2534 Int_t r, g, b;; 2535 Pixel2RGB(pixel, r, g, b);; 2536 tempbuf.Form(""#%02x%02x%02x"", r, g, b);; 2537 return tempbuf;; 2538}; 2539 ; 2540////////////////////////////////////////////////////////////////////////////////; 2541/// Save a color with index > 228 as a C++ statement(s) on output stream out.; 2542/// Return kFALSE if color not saved in the output stream; 2543 ; 2544Bool_t TColor::SaveColor(std::ostream &out, Int_t ci); 2545{; 2546 if (ci <= 228); 2547 return kFALSE;; 2548 ; 2549 char quote = '""';; 2550 ; 2551 TColor *c = gROOT->GetColor(ci);; 2552 if (!c); 2553 return kFALSE;; 2554 ; 25",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:154401,Integrability,depend,dependent,154401,"ientstatic Int_t GetRadialGradient(Double_t r, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})Static function: Returns the radial gradient color number corresponding to specified parameters.Definition TColor.cxx:2287; TColor::GetColorPalettestatic Int_t GetColorPalette(Int_t i)Static function returning the color number i in current palette.Definition TColor.cxx:1504; TColor::GetPalettestatic const TArrayI & GetPalette()Static function returning the current active palette.Definition TColor.cxx:1516; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::lsvoid ls(Option_t *option="""") const overrideList this color with its attributes.Definition TColor.cxx:1698; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::fLightFloat_t fLightLight.Definition TColor.h:29; TColor::RGB2Pixelstatic ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b)Convert r,g,b to graphics system dependent pixel value.Definition TColor.cxx:2475; TColor::Number2Pixelstatic ULong_t Number2Pixel(Int_t ci)Static method that given a color index number, returns the corresponding pixel value.Definition TColor.cxx:2437; TColor::RGB2HSVstatic void RGB2HSV(Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &s, Float_t &v)Static method to compute HSV from RGB.Definition TColor.cxx:1771; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TColor::HSV2RGBstatic void HSV2RGB(Float_t h, Float_t s, Float_t v, Float_t &r, Float_t &g, Float_t &b)Static method to compute RGB from HSV:Definition TColor.cxx:1642; TColor::fAlphaFloat_t fAlphaAlpha (transparency)Definition",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:156559,Integrability,depend,dependent,156559,"r palette.Definition TColor.cxx:3640; TColor::fHueFloat_t fHueHue.Definition TColor.h:28; TColor::CreateColorWheelstatic void CreateColorWheel()Static function steering the creation of all colors in the color wheel.Definition TColor.cxx:1416; TColor::GetColorByNamestatic Int_t GetColorByName(const char *colorname)Static method returning color index for a color specified by name.Definition TColor.cxx:2073; TColor::SetNamevoid SetName(const char *name) overrideSet the color name and change also the name of the ""dark"" and ""bright"" associated colors if they exis...Definition TColor.cxx:1826; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::IsGrayscalestatic Bool_t IsGrayscale()Return whether all colors return grayscale values.Definition TColor.cxx:2584; TColor::Pixel2RGBstatic void Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2513; TColor::AsHexStringconst char * AsHexString() constReturn color as hexadecimal string.Definition TColor.cxx:1325; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130; TColor::GetAlphaFloat_t GetAlpha() constDefinition TColor.h:66; TColor::CreateGradientColorTablestatic Int_t CreateGradientColorTable(UInt_t Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kTRUE)Static function creating a color table with several connected linear gradients.Definition TColor.cxx:2730; TColor::PixelAsHexStringstatic const char * PixelAsHexString(ULong_t pixel)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition ",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:157449,Integrability,depend,dependent,157449,"n TColor.cxx:2584; TColor::Pixel2RGBstatic void Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2513; TColor::AsHexStringconst char * AsHexString() constReturn color as hexadecimal string.Definition TColor.cxx:1325; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130; TColor::GetAlphaFloat_t GetAlpha() constDefinition TColor.h:66; TColor::CreateGradientColorTablestatic Int_t CreateGradientColorTable(UInt_t Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kTRUE)Static function creating a color table with several connected linear gradients.Definition TColor.cxx:2730; TColor::PixelAsHexStringstatic const char * PixelAsHexString(ULong_t pixel)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2530; TColor::Classstatic TClass * Class(); TColor::Allocatevoid Allocate()Make this color known to the graphics system.Definition TColor.cxx:1904; TColor::GetPixelULong_t GetPixel() constReturn pixel value corresponding to this color.Definition TColor.cxx:1559; TColor::CreateColorTableFromFilestatic Int_t CreateColorTableFromFile(TString fileName, Float_t alpha=1.)Static function creating a color palette based on an input text file.Definition TColor.cxx:2624; TColor::SetColorThresholdstatic void SetColorThreshold(Float_t t)This method specifies the color threshold used by GetColor to retrieve a color.Definition TColor.cxx:1987; TColor::DefinedColorsstatic Bool_t DefinedColors(Int_t set_always_on=0)Static method returning kTRUE if some new colors have been defined after initialisation or since the ...Definition TColor.cxx:1537; TColor::GetLightFloat_t GetLight() constDef",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:162115,Integrability,message,message,162115,"TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::Copyvoid Copy(TObject &named) const overrideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRadialGradientDefinition TColorGradient.h:124; TRadialGradient::Classstatic TClass * Class(); TRadialGradient::kSimple@ kSimpleDefinition TColorGradient.h:127; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:162245,Integrability,message,message,162245,"ideCopy this to obj.Definition TNamed.cxx:94; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AddAtAndExpandvirtual void AddAtAndExpand(TObject *obj, Int_t idx)Add object at position idx.Definition TObjArray.cxx:235; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRadialGradientDefinition TColorGradient.h:124; TRadialGradient::Classstatic TClass * Class(); TRadialGradient::kSimple@ kSimpleDefinition TColorGradient.h:127; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; bool; double; int; unsigned int; nconst Int_t nDefinition legend1.C:16; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition T",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:8529,Modifiability,variab,variable,8529,"ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1"",0,0,600,400);; 250 TF2 *f1 = new TF2(""f1"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",1,3,1,3);; 251 Int_t palette[5];; 252 palette[0] = 15;; 253 palette[1] = 20;; 254 palette[2] = 23;; 255 palette[3] = 30;; 256 palette[4] = 32;; 257 gStyle->SetPalette(5,palette);; 258 f1->Draw(""colz"");; 259 return c1;; 260}; 261End_Macro; 262 ; 263To d",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:11753,Performance,tune,tuned,11753,"00];; 296 Double_t Red[] = {0., 0.0, 1.0, 1.0, 1.0};; 297 Double_t Green[] = {0., 0.0, 0.0, 1.0, 1.0};; 298 Double_t Blue[] = {0., 1.0, 0.0, 0.0, 1.0};; 299 Double_t Length[] = {0., .25, .50, .75, 1.0};; 300 Int_t FI = TColor::CreateGradientColorTable(5, Length, Red, Green, Blue, 100);; 301 for (int i=0;i<100;i++) MyPalette[i] = FI+i;; 302~~~; 303 ; 304Later on to reuse the palette `MyPalette` it will be enough to do; 305 ; 306~~~ {.cpp}; 307 gStyle->SetPalette(100, MyPalette);; 308~~~; 309 ; 310As only one palette is active, one need to use `TExec` to be able to; 311display plots using different palettes on the same pad.; 312The tutorial multipalette.C illustrates this feature.; 313 ; 314Begin_Macro(source); 315../../../tutorials/graphs/multipalette.C; 316End_Macro; 317 ; 318\since **6.26:**; 319The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; 320palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; 321the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; 322between adjacent colors. The palette will contain the exact colors stored in the file, that; 323comprises one line per color in the format ""r g b"" as floats.; 324 ; 325\anchor C06; 326## High quality predefined palettes; 327\since **6.04:**; 32863 high quality palettes are predefined with 255 colors each.; 329 ; 330These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; 331`num` can be taken within the following enum:; 332 ; 333~~~ {.cpp}; 334kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 335kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 336kBird=57, kCubehelix=58, kGreenRedViolet=59,; 337kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 338kAlpine=63, kAquamarine=64, kArmy=65,; 339kAtlantic=66, kAurora=67, kAvocado=68,; 340kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 341kBrownCyan=72, kCMYK=73, kCandy=74,; 342kCherry=75, kCoffee=76, kDark",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:94688,Performance,load,load,94688,"rn fgGrayscaleMode;; 2588}; 2589 ; 2590////////////////////////////////////////////////////////////////////////////////; 2591/// Set whether all colors should return grayscale values.; 2592 ; 2593void TColor::SetGrayscale(Bool_t set /*= kTRUE*/); 2594{; 2595 if (fgGrayscaleMode == set) return;; 2596 ; 2597 fgGrayscaleMode = set;; 2598 ; 2599 if (!gVirtualX || gROOT->IsBatch()) return;; 2600 ; 2601 TColor::InitializeColors();; 2602 TIter iColor(gROOT->GetListOfColors());; 2603 TColor* color = nullptr;; 2604 while ((color = (TColor*) iColor())); 2605 color->Allocate();; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// \brief Static function creating a color palette based on an input text file.; 2610///; 2611/// Every color in the file will take the same amount of space in the palette.; 2612///; 2613/// \see https://doi.org/10.1038/s41467-020-19160-7; 2614/// \note This function is designed to load into ROOT the colour-vision; 2615/// deficiency friendly and perceptually uniform colour maps specially designed; 2616/// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; 2617/// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; 2618///; 2619/// \param fileName: Name of a .txt file (ASCII) containing three floats per; 2620/// line, separated by spaces, namely the r g b fractions of the color, each; 2621/// value being in the range [0,1].; 2622/// \param alpha the global opacity for all colors within this palette; 2623/// \return a positive value on success and -1 on error.; 2624/// \author Fernando Hueso-González; 2625Int_t TColor::CreateColorTableFromFile(TString fileName, Float_t alpha); 2626{; 2627 std::ifstream f(fileName.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Flo",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:56186,Safety,avoid,avoid,56186,"t_t TColor::GetColorPalette(Int_t i); 1506{; 1507 Int_t ncolors = fgPalette.fN;; 1508 if (ncolors == 0) return 0;; 1509 Int_t icol = i%ncolors;; 1510 if (icol < 0) icol = 0;; 1511 return fgPalette.fArray[icol];; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Static function returning the current active palette.; 1516 ; 1517const TArrayI& TColor::GetPalette(); 1518{; 1519 return fgPalette;; 1520}; 1521 ; 1522////////////////////////////////////////////////////////////////////////////////; 1523/// Static function returning number of colors in the color palette.; 1524 ; 1525Int_t TColor::GetNumberOfColors(); 1526{; 1527 return fgPalette.fN;; 1528}; 1529 ; 1530////////////////////////////////////////////////////////////////////////////////; 1531/// Static method returning kTRUE if some new colors have been defined after; 1532/// initialisation or since the last call to this method. This allows to avoid; 1533/// the colors and palette streaming in TCanvas::Streamer if not needed.; 1534/// If method called once with set_always_on = 1, all next canvases will be; 1535// saved with color palette - disregard if new colors created or not.; 1536/// To reset such mode, just call methoid once with set_always_on = -1; 1537 ; 1538Bool_t TColor::DefinedColors(Int_t set_always_on); 1539{; 1540 if (set_always_on > 0); 1541 gLastDefinedColors = -1;; 1542 else if (set_always_on < 0); 1543 gLastDefinedColors = gDefinedColors;; 1544 ; 1545 if (gLastDefinedColors < 0); 1546 return kTRUE;; 1547 ; 1548 // After initialization gDefinedColors == 649. If it is bigger it means some new; 1549 // colors have been defined; 1550 Bool_t hasChanged = (gDefinedColors - gLastDefinedColors) > 50;; 1551 gLastDefinedColors = gDefinedColors;; 1552 return hasChanged;; 1553}; 1554 ; 1555////////////////////////////////////////////////////////////////////////////////; 1556/// Return pixel value corresponding to this color. This pixel value can; 1557//",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:6952,Security,access,accessibility,6952,"olor behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular color",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7203,Security,access,accessible-color-cycles,7203,"s are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 2",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7565,Security,access,accessiblecolorschemes,7565,"{.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:7985,Security,access,access,7985,"mes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1""",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:8110,Security,access,access,8110,"mes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; 221image below shows the ROOT color wheel in grayscale mode.; 222 ; 223Begin_Macro(source); 224{; 225 auto w = new TColorWheel();; 226 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 227 cw->GetCanvas()->SetGrayscale();; 228 w->SetCanvas(cw);; 229 w->Draw();; 230}; 231End_Macro; 232 ; 233\anchor C05; 234## Color palettes; 235It is often very useful to represent a variable with a color map. The concept; 236of ""color palette"" allows to do that. One color palette is active at any time.; 237This ""current palette"" is set using:; 238 ; 239~~~ {.cpp}; 240gStyle->SetPalette(...);; 241~~~; 242 ; 243This function has two parameters: the number of colors in the palette and an; 244array of containing the indices of colors in the palette. The following small; 245example demonstrates how to define and use the color palette:; 246 ; 247Begin_Macro(source); 248{; 249 auto c1 = new TCanvas(""c1"",""c1""",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:12143,Security,access,accessed,12143,"le->SetPalette(100, MyPalette);; 308~~~; 309 ; 310As only one palette is active, one need to use `TExec` to be able to; 311display plots using different palettes on the same pad.; 312The tutorial multipalette.C illustrates this feature.; 313 ; 314Begin_Macro(source); 315../../../tutorials/graphs/multipalette.C; 316End_Macro; 317 ; 318\since **6.26:**; 319The function `TColor::CreateColorTableFromFile(""filename.txt"")` allows you to create a color; 320palette based on an input ASCII file. In contrast to `TColor::CreateGradientColorTable()`, here; 321the length (spacing) is constant and can not be tuned. There is no gradient being interpolated; 322between adjacent colors. The palette will contain the exact colors stored in the file, that; 323comprises one line per color in the format ""r g b"" as floats.; 324 ; 325\anchor C06; 326## High quality predefined palettes; 327\since **6.04:**; 32863 high quality palettes are predefined with 255 colors each.; 329 ; 330These palettes can be accessed ""by name"" with `gStyle->SetPalette(num)`.; 331`num` can be taken within the following enum:; 332 ; 333~~~ {.cpp}; 334kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 335kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 336kBird=57, kCubehelix=58, kGreenRedViolet=59,; 337kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 338kAlpine=63, kAquamarine=64, kArmy=65,; 339kAtlantic=66, kAurora=67, kAvocado=68,; 340kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 341kBrownCyan=72, kCMYK=73, kCandy=74,; 342kCherry=75, kCoffee=76, kDarkRainBow=77,; 343kDarkTerrain=78, kFall=79, kFruitPunch=80,; 344kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; 345kGreenPink=84, kIsland=85, kLake=86,; 346kLightTemperature=87, kLightTerrain=88, kMint=89,; 347kNeon=90, kPastel=91, kPearl=92,; 348kPigeon=93, kPlum=94, kRedBlue=95,; 349kRose=96, kRust=97, kSandyTerrain=98,; 350kSienna=99, kSolar=100, kSouthWest=101,; 351kStarryNight=102, kSunset=103, kTemperatureMap=104,; 352kThermometer=105, k",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:102940,Security,access,access,102940,"or CI function of the cell content.; 2795/// if the cell content is N, the color CI used will be the color number; 2796/// in colors[N],etc. If the maximum cell content is > ncolors, all; 2797/// cell contents are scaled to ncolors.; 2798///; 2799/// `if ncolors <= 0` a default palette (see below) of 50 colors is; 2800/// defined. The colors defined in this palette are OK for coloring pads, labels.; 2801///; 2802/// ~~~ {.cpp}; 2803/// index 0->9 : grey colors from light to dark grey; 2804/// index 10->19 : ""brown"" colors; 2805/// index 20->29 : ""blueish"" colors; 2806/// index 30->39 : ""redish"" colors; 2807/// index 40->49 : basic colors; 2808/// ~~~; 2809///; 2810/// `if ncolors == 1 && colors == 0`, a Rainbow Color map is created; 2811/// with 50 colors. It is kept for backward compatibility. Better palettes like; 2812/// kBird are recommended.; 2813///; 2814/// High quality predefined palettes with 255 colors are available when `colors == 0`.; 2815/// The following value of `ncolors` give access to:; 2816///; 2817/// ~~~ {.cpp}; 2818/// if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2819/// if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2820/// if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2821/// if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); 2822/// if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2823/// if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; 2824/// if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; 2825/// if ncolors = 58 and colors=0, a Cubehelix palette is used; 2826/// (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); 2827/// if ncolors = 59 and colors=0, a Green Red Violet palette is used.; 2828/// if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; 2829/// if ncolors = 61 and colors=0, an Ocean palette is u",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:107524,Security,access,accessed,107524,"f ncolors = 100 and colors=0, a Solar palette is used.; 2869/// if ncolors = 101 and colors=0, a South West palette is used.; 2870/// if ncolors = 102 and colors=0, a Starry Night palette is used.; 2871/// if ncolors = 103 and colors=0, a Sunset palette is used.; 2872/// if ncolors = 104 and colors=0, a Temperature Map palette is used.; 2873/// if ncolors = 105 and colors=0, a Thermometer palette is used.; 2874/// if ncolors = 106 and colors=0, a Valentine palette is used.; 2875/// if ncolors = 107 and colors=0, a Visible Spectrum palette is used.; 2876/// if ncolors = 108 and colors=0, a Water Melon palette is used.; 2877/// if ncolors = 109 and colors=0, a Cool palette is used.; 2878/// if ncolors = 110 and colors=0, a Copper palette is used.; 2879/// if ncolors = 111 and colors=0, a Gist Earth palette is used.; 2880/// if ncolors = 112 and colors=0, a Viridis palette is used.; 2881/// if ncolors = 113 and colors=0, a Cividis palette is used.; 2882/// ~~~; 2883/// These palettes can also be accessed by names:; 2884/// ~~~ {.cpp}; 2885/// kDeepSea=51, kGreyScale=52, kDarkBodyRadiator=53,; 2886/// kBlueYellow= 54, kRainBow=55, kInvertedDarkBodyRadiator=56,; 2887/// kBird=57, kCubehelix=58, kGreenRedViolet=59,; 2888/// kBlueRedYellow=60, kOcean=61, kColorPrintableOnGrey=62,; 2889/// kAlpine=63, kAquamarine=64, kArmy=65,; 2890/// kAtlantic=66, kAurora=67, kAvocado=68,; 2891/// kBeach=69, kBlackBody=70, kBlueGreenYellow=71,; 2892/// kBrownCyan=72, kCMYK=73, kCandy=74,; 2893/// kCherry=75, kCoffee=76, kDarkRainBow=77,; 2894/// kDarkTerrain=78, kFall=79, kFruitPunch=80,; 2895/// kFuchsia=81, kGreyYellow=82, kGreenBrownTerrain=83,; 2896/// kGreenPink=84, kIsland=85, kLake=86,; 2897/// kLightTemperature=87, kLightTerrain=88, kMint=89,; 2898/// kNeon=90, kPastel=91, kPearl=92,; 2899/// kPigeon=93, kPlum=94, kRedBlue=95,; 2900/// kRose=96, kRust=97, kSandyTerrain=98,; 2901/// kSienna=99, kSolar=100, kSouthWest=101,; 2902/// kStarryNight=102, kSunset=103, kTemperatureMap=104,",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:70726,Testability,test,test,70726,"olor picker.; 1951///; 1952/// The color retrieval is done using a threshold defined by SetColorThreshold.; 1953 ; 1954 ; 1955Int_t TColor::GetColor(ULong_t pixel); 1956{; 1957 Int_t r, g, b;; 1958 ; 1959 Pixel2RGB(pixel, r, g, b);; 1960 ; 1961 return GetColor(r, g, b);; 1962}; 1963 ; 1964////////////////////////////////////////////////////////////////////////////////; 1965/// This method specifies the color threshold used by GetColor to retrieve a color.; 1966///; 1967/// \param[in] t Color threshold. By default is equal to 1./31. or 1./255.; 1968/// depending on the number of available color planes.; 1969///; 1970/// When GetColor is called, it scans the defined colors and compare them to the; 1971/// requested color.; 1972/// If the Red Green and Blue values passed to GetColor are Rr Gr Br; 1973/// and Rd Gd Bd the values of a defined color. These two colors are considered equal; 1974/// if (abs(Rr-Rd) < t & abs(Br-Bd) < t & abs(Br-Bd) < t). If this test passes,; 1975/// the color defined by Rd Gd Bd is returned by GetColor.; 1976///; 1977/// To make sure GetColor will return a color having exactly the requested; 1978/// R G B values it is enough to specify a nul :; 1979/// ~~~ {.cpp}; 1980/// TColor::SetColorThreshold(0.);; 1981/// ~~~; 1982///; 1983/// To reset the color threshold to its default value it is enough to do:; 1984/// ~~~ {.cpp}; 1985/// TColor::SetColorThreshold(-1.);; 1986/// ~~~; 1987 ; 1988void TColor::SetColorThreshold(Float_t t); 1989{; 1990 gColorThreshold = t;; 1991}; 1992 ; 1993////////////////////////////////////////////////////////////////////////////////; 1994/// Static method returning color number for color specified by; 1995/// r, g and b. The r,g,b should be in the range [0,255].; 1996/// If the specified color does not exist it will be created; 1997/// with as name ""#rrggbb"" with rr, gg and bb in hex between; 1998/// [0,FF].; 1999///; 2000/// The color retrieval is done using a threshold defined by SetColorThreshold.; 2001 ; 2002Int_",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:2616,Usability,simpl,simply,2616,"D globalPalettesList(0);; 41 return globalPalettesList;; 42 }; 43}; 44 ; 45static Int_t gHighestColorIndex = 0; ///< Highest color index defined; 46static Float_t gColorThreshold = -1.; ///< Color threshold used by GetColor; 47static Int_t gDefinedColors = 0; ///< Number of defined colors.; 48static Int_t gLastDefinedColors = 649; ///< Previous number of defined colors; 49 ; 50#define fgGrayscaleMode TColor__GrayScaleMode(); 51#define fgPalette TColor__Palette(); 52#define fgPalettesList TColor__PalettesList(); 53 ; 54using std::floor;; 55 ; 56/** \class TColor; 57\ingroup Base; 58\ingroup GraphicsAtt; 59 ; 60The color creation and management class.; 61 ; 62 - [Introduction](\ref C00); 63 - [Basic colors](\ref C01); 64 - [The color wheel](\ref C02); 65 - [Bright and dark colors](\ref C03); 66 - [Accessible Color Schemes](\ref C031); 67 - [Gray scale view of of canvas with colors](\ref C04); 68 - [Color palettes](\ref C05); 69 - [High quality predefined palettes](\ref C06); 70 - [Colour Vision Deficiency (CVD) friendly palettes](\ref C06a); 71 - [Non Colour Vision Deficiency (CVD) friendly palettes](\ref C06b); 72 - [Palette inversion](\ref C061); 73 - [Color transparency](\ref C07); 74 ; 75\anchor C00; 76## Introduction; 77 ; 78Colors are defined by their red, green and blue components, simply called the; 79RGB components. The colors are also known by the hue, light and saturation; 80components also known as the HLS components. When a new color is created the; 81components of both color systems are computed.; 82 ; 83At initialization time, a table of colors is generated. An existing color can; 84be retrieved by its index:; 85 ; 86~~~ {.cpp}; 87 TColor *color = gROOT->GetColor(10);; 88~~~; 89 ; 90Then it can be manipulated. For example its RGB components can be modified:; 91 ; 92~~~ {.cpp}; 93 color->SetRGB(0.1, 0.2, 0.3);; 94~~~; 95 ; 96A new color can be created the following way:; 97 ; 98~~~ {.cpp}; 99 Int_t ci = 1756; // color index; 100 auto color = new TColor(ci",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8cxx_source.html:5874,Usability,simpl,simply,5874,"ellow, kPink, etc are defined in the header file; 147Rtypes.h that is included in all ROOT other header files. It is better; 148to use these keywords in user code instead of hardcoded color numbers, e.g.:; 149 ; 150~~~ {.cpp}; 151 myObject.SetFillColor(kRed);; 152 myObject.SetFillColor(kYellow-10);; 153 myLine.SetLineColor(kMagenta+2);; 154~~~; 155 ; 156Begin_Macro(source); 157{; 158 auto w = new TColorWheel();; 159 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 160 w->SetCanvas(cw);; 161 w->Draw();; 162}; 163End_Macro; 164 ; 165The complete list of predefined color names is the following:; 166 ; 167~~~ {.cpp}; 168kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; 169kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; 170kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; 171~~~; 172 ; 173Note the special role of color `kWhite` (color number 0). It is the default; 174background color also. For instance in a PDF or PS files (as paper is usually white); 175it is simply not painted. To have a white color behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198i",MatchSource.WIKI,doc/master/TColor_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html
https://root.cern/doc/master/TColor_8h.html:227,Integrability,depend,dependency,227,". ROOT: core/base/inc/TColor.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TColor.h File Reference. #include ""TNamed.h""; #include <vector>. Include dependency graph for TColor.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TColor;  The color creation and management class. More...;  . Enumerations; enum  EColorPalette { ;   kDeepSea =51; , kGreyScale =52; , kDarkBodyRadiator =53; , kBlueYellow = 54; , ;   kRainBow =55; , kInvertedDarkBodyRadiator =56; , kBird =57; , kCubehelix =58; , ;   kGreenRedViolet =59; , kBlueRedYellow =60; , kOcean =61; , kColorPrintableOnGrey =62; , ;   kAlpine =63; , kAquamarine =64; , kArmy =65; , kAtlantic =66; , ;   kAurora =67; , kAvocado =68; , kBeach =69; , kBlackBody =70; , ;   kBlueGreenYellow =71; , kBrownCyan =72; , kCMYK =73; , kCandy =74; , ;   kCherry =75; , kCoffee =76; , kDarkRainBow =77; , kDarkTerrain =78; , ;   kFall =79; , kFruitPunch =80; , kFuchsia =81; , kGreyYellow =82; , ;   kGreenBrownTerrain =83; , kGreenPink =84; , kIsland =85; , kLake =86; , ;   kLightTemperature =87; , kLightTerrain =88; , kMint =89; , kNeon =90; , ;   kPastel =91; , kPearl =92; , kPigeon =93; , kPlum =94; , ;   kRedBlue =95; , kRose =96; , kRust =97; , kSandyTerrain =98; , ;   kSienna =99; , kSolar =100; , kSouthWest =101; , kStarryNight =102; , ;   kSunset =103; , kTemperatureMap =104; , kThermometer =105; , kValentine =106; , ;   kVisibleSpectrum =107; , kWaterMelon =108; , kCool =109; , kCopper =110; , ;   kGistEarth =111; , kViridis =112; , kCividis =113; , kRainbow =kRainBow; , ;   kDarkRainbow =kDarkRainBow. };  . Enumeration Type Documentation. ◆ EColorPalette. enum EColorPalette. EnumeratorkDeepSea ; kGreyScale ; kDarkBodyRadiator ; kBlueYellow ; kRa",MatchSource.WIKI,doc/master/TColor_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h.html
https://root.cern/doc/master/TColor_8h_source.html:14946,Integrability,depend,dependent,14946,"ientstatic Int_t GetRadialGradient(Double_t r, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})Static function: Returns the radial gradient color number corresponding to specified parameters.Definition TColor.cxx:2287; TColor::GetColorPalettestatic Int_t GetColorPalette(Int_t i)Static function returning the color number i in current palette.Definition TColor.cxx:1504; TColor::GetPalettestatic const TArrayI & GetPalette()Static function returning the current active palette.Definition TColor.cxx:1516; TColor::GetRedFloat_t GetRed() constDefinition TColor.h:60; TColor::lsvoid ls(Option_t *option="""") const overrideList this color with its attributes.Definition TColor.cxx:1698; TColor::SaveColorstatic Bool_t SaveColor(std::ostream &out, Int_t ci)Save a color with index > 228 as a C++ statement(s) on output stream out.Definition TColor.cxx:2543; TColor::fLightFloat_t fLightLight.Definition TColor.h:29; TColor::RGB2Pixelstatic ULong_t RGB2Pixel(Int_t r, Int_t g, Int_t b)Convert r,g,b to graphics system dependent pixel value.Definition TColor.cxx:2475; TColor::Number2Pixelstatic ULong_t Number2Pixel(Int_t ci)Static method that given a color index number, returns the corresponding pixel value.Definition TColor.cxx:2437; TColor::RGB2HSVstatic void RGB2HSV(Float_t r, Float_t g, Float_t b, Float_t &h, Float_t &s, Float_t &v)Static method to compute HSV from RGB.Definition TColor.cxx:1771; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::InitializeColorsstatic void InitializeColors()Initialize colors used by the TCanvas based graphics (via TColor objects).Definition TColor.cxx:1167; TColor::HSV2RGBstatic void HSV2RGB(Float_t h, Float_t s, Float_t v, Float_t &r, Float_t &g, Float_t &b)Static method to compute RGB from HSV:Definition TColor.cxx:1642; TColor::fAlphaFloat_t fAlphaAlpha (transparency)Definition",MatchSource.WIKI,doc/master/TColor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h_source.html
https://root.cern/doc/master/TColor_8h_source.html:17203,Integrability,depend,dependent,17203,"reateColorWheelstatic void CreateColorWheel()Static function steering the creation of all colors in the color wheel.Definition TColor.cxx:1416; TColor::GetHLSvirtual void GetHLS(Float_t &h, Float_t &l, Float_t &s) constDefinition TColor.h:56; TColor::GetColorByNamestatic Int_t GetColorByName(const char *colorname)Static method returning color index for a color specified by name.Definition TColor.cxx:2073; TColor::SetNamevoid SetName(const char *name) overrideSet the color name and change also the name of the ""dark"" and ""bright"" associated colors if they exis...Definition TColor.cxx:1826; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::IsGrayscalestatic Bool_t IsGrayscale()Return whether all colors return grayscale values.Definition TColor.cxx:2584; TColor::Pixel2RGBstatic void Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2513; TColor::AsHexStringconst char * AsHexString() constReturn color as hexadecimal string.Definition TColor.cxx:1325; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130; TColor::GetAlphaFloat_t GetAlpha() constDefinition TColor.h:66; TColor::CreateGradientColorTablestatic Int_t CreateGradientColorTable(UInt_t Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kTRUE)Static function creating a color table with several connected linear gradients.Definition TColor.cxx:2730; TColor::PixelAsHexStringstatic const char * PixelAsHexString(ULong_t pixel)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition ",MatchSource.WIKI,doc/master/TColor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h_source.html
https://root.cern/doc/master/TColor_8h_source.html:18093,Integrability,depend,dependent,18093,"n TColor.cxx:2584; TColor::Pixel2RGBstatic void Pixel2RGB(ULong_t pixel, Int_t &r, Int_t &g, Int_t &b)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2513; TColor::AsHexStringconst char * AsHexString() constReturn color as hexadecimal string.Definition TColor.cxx:1325; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130; TColor::GetAlphaFloat_t GetAlpha() constDefinition TColor.h:66; TColor::CreateGradientColorTablestatic Int_t CreateGradientColorTable(UInt_t Number, Double_t *Stops, Double_t *Red, Double_t *Green, Double_t *Blue, UInt_t NColors, Float_t alpha=1., Bool_t setPalette=kTRUE)Static function creating a color table with several connected linear gradients.Definition TColor.cxx:2730; TColor::PixelAsHexStringstatic const char * PixelAsHexString(ULong_t pixel)Convert machine dependent pixel value (obtained via RGB2Pixel or via Number2Pixel() or via TColor::Ge...Definition TColor.cxx:2530; TColor::Allocatevoid Allocate()Make this color known to the graphics system.Definition TColor.cxx:1904; TColor::GetPixelULong_t GetPixel() constReturn pixel value corresponding to this color.Definition TColor.cxx:1559; TColor::CreateColorTableFromFilestatic Int_t CreateColorTableFromFile(TString fileName, Float_t alpha=1.)Static function creating a color palette based on an input text file.Definition TColor.cxx:2624; TColor::SetColorThresholdstatic void SetColorThreshold(Float_t t)This method specifies the color threshold used by GetColor to retrieve a color.Definition TColor.cxx:1987; TColor::DefinedColorsstatic Bool_t DefinedColors(Int_t set_always_on=0)Static method returning kTRUE if some new colors have been defined after initialisation or since the ...Definition TColor.cxx:1537; TColor::GetLightFloat_t GetLight() constDefinition TColor.h:64; TColor::GetHueFlo",MatchSource.WIKI,doc/master/TColor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TColor_8h_source.html
https://root.cern/doc/master/TCurlyArc_8cxx_source.html:5145,Deployability,release,released,5145,"; 124{; 125 if (!gPad) return 9999;; 126 // Compute distance of point to center of arc; 127 Int_t pxc = gPad->XtoAbsPixel(fX1);; 128 Int_t pyc = gPad->YtoAbsPixel(fY1);; 129 Double_t dist = TMath::Sqrt(Long64_t(pxc-px)*(pxc-px)+Long64_t(pyc-py)*(pyc-py));; 130 Double_t cosa = (px - pxc)/dist;; 131 Double_t sina = (pyc - py)/dist;; 132 Double_t phi = TMath::ATan2(sina,cosa);; 133 if (phi < 0) phi += 2 * TMath::Pi();; 134 phi = phi * 180 / TMath::Pi();; 135 if (fPhimax > fPhimin){; 136 if (phi < fPhimin || phi > fPhimax) return 9999;; 137 } else {; 138 if (phi > fPhimin && phi < fPhimax) return 9999;; 139 }; 140 Int_t pxr = gPad->XtoPixel(fR1)- gPad->XtoPixel(0);; 141 Double_t distr = TMath::Abs(dist-pxr);; 142 return Int_t(distr);; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Execute action corresponding to one event.; 147///; 148/// This member function is called when a TCurlyArc is clicked with the locator; 149///; 150/// If Left button clicked on one of the line end points, this point; 151/// follows the cursor until button is released.; 152///; 153/// if Middle button clicked, the line is moved parallel to itself; 154/// until the button is released.; 155 ; 156void TCurlyArc::ExecuteEvent(Int_t event, Int_t px, Int_t py); 157{; 158 if (!gPad) return;; 159 ; 160 Int_t kMaxDiff = 10;; 161 const Int_t np = 10;; 162 const Double_t pi = TMath::Pi();; 163 static Int_t x[np+3], y[np+3];; 164 static Int_t px1,py1,npe,r1;; 165 static Int_t pxold, pyold;; 166 Int_t i, dpx, dpy;; 167 Double_t angle,dx,dy,dphi,rLx,rRx;; 168 Double_t phi0;; 169 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 170 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 171 ; 172 Bool_t opaque = gPad->OpaqueMoving();; 173 ; 174 switch (event) {; 175 ; 176 case kArrowKeyPress:; 177 case kButton1Down:; 178 if (!opaque) {; 179 gVirtualX->SetLineColor(-1);; 180 TAttLine::Modify();; 181 dphi = (fPhimax-fPhimin) * pi / 180;; 182 if (dphi<0) dphi += 2 * pi;",MatchSource.WIKI,doc/master/TCurlyArc_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyArc_8cxx_source.html
https://root.cern/doc/master/TCurlyArc_8cxx_source.html:5262,Deployability,release,released,5262,"29 Double_t dist = TMath::Sqrt(Long64_t(pxc-px)*(pxc-px)+Long64_t(pyc-py)*(pyc-py));; 130 Double_t cosa = (px - pxc)/dist;; 131 Double_t sina = (pyc - py)/dist;; 132 Double_t phi = TMath::ATan2(sina,cosa);; 133 if (phi < 0) phi += 2 * TMath::Pi();; 134 phi = phi * 180 / TMath::Pi();; 135 if (fPhimax > fPhimin){; 136 if (phi < fPhimin || phi > fPhimax) return 9999;; 137 } else {; 138 if (phi > fPhimin && phi < fPhimax) return 9999;; 139 }; 140 Int_t pxr = gPad->XtoPixel(fR1)- gPad->XtoPixel(0);; 141 Double_t distr = TMath::Abs(dist-pxr);; 142 return Int_t(distr);; 143}; 144 ; 145////////////////////////////////////////////////////////////////////////////////; 146/// Execute action corresponding to one event.; 147///; 148/// This member function is called when a TCurlyArc is clicked with the locator; 149///; 150/// If Left button clicked on one of the line end points, this point; 151/// follows the cursor until button is released.; 152///; 153/// if Middle button clicked, the line is moved parallel to itself; 154/// until the button is released.; 155 ; 156void TCurlyArc::ExecuteEvent(Int_t event, Int_t px, Int_t py); 157{; 158 if (!gPad) return;; 159 ; 160 Int_t kMaxDiff = 10;; 161 const Int_t np = 10;; 162 const Double_t pi = TMath::Pi();; 163 static Int_t x[np+3], y[np+3];; 164 static Int_t px1,py1,npe,r1;; 165 static Int_t pxold, pyold;; 166 Int_t i, dpx, dpy;; 167 Double_t angle,dx,dy,dphi,rLx,rRx;; 168 Double_t phi0;; 169 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 170 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 171 ; 172 Bool_t opaque = gPad->OpaqueMoving();; 173 ; 174 switch (event) {; 175 ; 176 case kArrowKeyPress:; 177 case kButton1Down:; 178 if (!opaque) {; 179 gVirtualX->SetLineColor(-1);; 180 TAttLine::Modify();; 181 dphi = (fPhimax-fPhimin) * pi / 180;; 182 if (dphi<0) dphi += 2 * pi;; 183 dphi /= np;; 184 phi0 = fPhimin * pi / 180;; 185 for (i=0;i<=np;i++) {; 186 angle = Double_t(i)*dphi + phi0;; 187 dx = fR1*TMath::Cos(angle);; 188 dy = fR1*TMath::Sin",MatchSource.WIKI,doc/master/TCurlyArc_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyArc_8cxx_source.html
https://root.cern/doc/master/TCurlyArc_8cxx_source.html:906,Modifiability,inherit,inheritance,906,". ROOT: graf2d/graf/src/TCurlyArc.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCurlyArc.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Otto Schaile 20/11/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCurlyArc; 13\ingroup BasicGraphics; 14 ; 15Implements curly or wavy arcs used to draw Feynman diagrams.; 16 ; 17Amplitudes and wavelengths may be specified in the constructors,; 18via commands or interactively from popup menus.; 19The class make use of TCurlyLine by inheritance, ExecuteEvent methods; 20are highly inspired from the methods used in TPolyLine and TArc.; 21The picture below has been generated by the tutorial feynman.; 22 ; 23Begin_Macro(source); 24../../../tutorials/graphics/feynman.C; 25End_Macro; 26*/; 27 ; 28#include <iostream>; 29#include ""TCurlyArc.h""; 30#include ""TROOT.h""; 31#include ""TVirtualPad.h""; 32#include ""TVirtualX.h""; 33#include ""TMath.h""; 34#include ""TPoint.h""; 35 ; 36Double_t TCurlyArc::fgDefaultWaveLength = 0.02;; 37Double_t TCurlyArc::fgDefaultAmplitude = 0.01;; 38Bool_t TCurlyArc::fgDefaultIsCurly = kTRUE;; 39 ; 40ClassImp(TCurlyArc);; 41 ; 42////////////////////////////////////////////////////////////////////////////////; 43/// Default constructor; 44 ; 45TCurlyArc::TCurlyArc(); 46{; 47 fR1 = 0.;; 48 fPhimin = 0.;; 49 fPhimax = 0.;; 50 fTheta = 0.;; 51}; 52 ; 53////////////////////////////////////////////////////////////////////////////////; 54/// Create a new TCurlyArc with center (x1, y1) and radius rad.; 55/// The wavelength and amplitude are given in percent of the line length; 56/// phimin and phimax ar",MatchSource.WIKI,doc/master/TCurlyArc_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyArc_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:6156,Deployability,release,released,6156,"ath::ATan2(py2-py1, px2-px1);; 147 if (angle < 0) angle += 2*TMath::Pi();; 148 ; 149 Double_t cosang = TMath::Cos(angle);; 150 Double_t sinang = TMath::Sin(angle);; 151 Double_t xx, yy;; 152 ; 153 for(i = 0; i < fNsteps; i++){; 154 xx = xv[i] * cosang - yv[i] * sinang;; 155 yy = xv[i] * sinang + yv[i] * cosang;; 156 if (gPad) {; 157 xx *= pixeltoX;; 158 yy *= pixeltoY;; 159 }; 160 xv[i] = xx + fX1;; 161 yv[i] = yy + fY1;; 162 }; 163 if (gPad) gPad->Modified();; 164}; 165 ; 166////////////////////////////////////////////////////////////////////////////////; 167/// Compute distance from point px,py to a line.; 168 ; 169Int_t TCurlyLine::DistancetoPrimitive(Int_t px, Int_t py); 170{; 171 return DistancetoLine(px,py,fX1,fY1,fX2,fY2);; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Execute action corresponding to one event.; 176///; 177/// This member function is called when a TCurlyLine is clicked with the locator; 178///; 179/// If Left button clicked on one of the line end points, this point; 180/// follows the cursor until button is released.; 181///; 182/// if Middle button clicked, the line is moved parallel to itself; 183/// until the button is released.; 184 ; 185void TCurlyLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 186{; 187 if (!gPad) return;; 188 ; 189 Int_t kMaxDiff = 20;; 190 static Int_t d1,d2,px1,px2,py1,py2;; 191 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 192 static Bool_t p1, p2, pL;; 193 Int_t dx, dy;; 194 ; 195 Bool_t opaque = gPad->OpaqueMoving();; 196 ; 197 switch (event) {; 198 ; 199 case kArrowKeyPress:; 200 case kButton1Down:; 201 if (!opaque) {; 202 gVirtualX->SetLineColor(-1);; 203 TAttLine::Modify(); //Change line attributes only if necessary; 204 }; 205 ; 206 // No break !!!; 207 ; 208 case kMouseMotion:; 209 ; 210 px1 = gPad->XtoAbsPixel(fX1);; 211 py1 = gPad->YtoAbsPixel(fY1);; 212 px2 = gPad->XtoAbsPixel(fX2);; 213 py2 = gPad->YtoAbsPixel(fY2);; 214 ; 215 p1 ",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:6273,Deployability,release,released,6273,"ble_t xx, yy;; 152 ; 153 for(i = 0; i < fNsteps; i++){; 154 xx = xv[i] * cosang - yv[i] * sinang;; 155 yy = xv[i] * sinang + yv[i] * cosang;; 156 if (gPad) {; 157 xx *= pixeltoX;; 158 yy *= pixeltoY;; 159 }; 160 xv[i] = xx + fX1;; 161 yv[i] = yy + fY1;; 162 }; 163 if (gPad) gPad->Modified();; 164}; 165 ; 166////////////////////////////////////////////////////////////////////////////////; 167/// Compute distance from point px,py to a line.; 168 ; 169Int_t TCurlyLine::DistancetoPrimitive(Int_t px, Int_t py); 170{; 171 return DistancetoLine(px,py,fX1,fY1,fX2,fY2);; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Execute action corresponding to one event.; 176///; 177/// This member function is called when a TCurlyLine is clicked with the locator; 178///; 179/// If Left button clicked on one of the line end points, this point; 180/// follows the cursor until button is released.; 181///; 182/// if Middle button clicked, the line is moved parallel to itself; 183/// until the button is released.; 184 ; 185void TCurlyLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 186{; 187 if (!gPad) return;; 188 ; 189 Int_t kMaxDiff = 20;; 190 static Int_t d1,d2,px1,px2,py1,py2;; 191 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 192 static Bool_t p1, p2, pL;; 193 Int_t dx, dy;; 194 ; 195 Bool_t opaque = gPad->OpaqueMoving();; 196 ; 197 switch (event) {; 198 ; 199 case kArrowKeyPress:; 200 case kButton1Down:; 201 if (!opaque) {; 202 gVirtualX->SetLineColor(-1);; 203 TAttLine::Modify(); //Change line attributes only if necessary; 204 }; 205 ; 206 // No break !!!; 207 ; 208 case kMouseMotion:; 209 ; 210 px1 = gPad->XtoAbsPixel(fX1);; 211 py1 = gPad->YtoAbsPixel(fY1);; 212 px2 = gPad->XtoAbsPixel(fX2);; 213 py2 = gPad->YtoAbsPixel(fY2);; 214 ; 215 p1 = p2 = pL = kFALSE;; 216 ; 217 d1 = TMath::Abs(px1 - px) + TMath::Abs(py1-py); //simply take sum of pixels differences; 218 if (d1 < kMaxDiff) { //*-*================>OK ta",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:913,Modifiability,inherit,inheritance,913,". ROOT: graf2d/graf/src/TCurlyLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TCurlyLine.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Otto Schaile 20/11/99; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TCurlyLine; 13\ingroup BasicGraphics; 14 ; 15Implements curly or wavy polylines used to draw Feynman diagrams.; 16 ; 17Amplitudes and wavelengths may be specified in the constructors,; 18via commands or interactively from popup menus.; 19The class make use of TPolyLine by inheritance, ExecuteEvent methods; 20are highly inspired from the methods used in TPolyLine and TArc.; 21The picture below has been generated by the tutorial feynman.; 22 ; 23Begin_Macro(source); 24../../../tutorials/graphics/feynman.C; 25End_Macro; 26*/; 27 ; 28#include ""TCurlyLine.h""; 29#include ""TROOT.h""; 30#include ""TVirtualPad.h""; 31#include ""TVirtualX.h""; 32#include ""TMath.h""; 33#include ""TPoint.h""; 34 ; 35#include <iostream>; 36 ; 37Double_t TCurlyLine::fgDefaultWaveLength = 0.02;; 38Double_t TCurlyLine::fgDefaultAmplitude = 0.01;; 39Bool_t TCurlyLine::fgDefaultIsCurly = kTRUE;; 40 ; 41ClassImp(TCurlyLine);; 42 ; 43////////////////////////////////////////////////////////////////////////////////; 44/// Default constructor.; 45 ; 46TCurlyLine::TCurlyLine(); 47{; 48 fX1 = 0.;; 49 fY1 = 0.;; 50 fX2 = 0.;; 51 fY2 = 0.;; 52 fWaveLength = 0.;; 53 fAmplitude = 0.;; 54 fIsCurly = fgDefaultIsCurly;; 55 fNsteps = 0;; 56}; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59/// Create a new TCurlyLine with starting point (x1, y1), end poi",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:25268,Modifiability,inherit,inherits,25268,"x:529; TCurlyLine::SetDefaultIsCurlystatic void SetDefaultIsCurly(Bool_t IsCurly)Set default ""IsCurly"".Definition TCurlyLine.cxx:432; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TCurlyLine::fgDefaultAmplitudestatic Double_t fgDefaultAmplitudedefault amplitudeDefinition TCurlyLine.h:32; TCurlyLine::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TCurlyLine.cxx:169; TCurlyLine::fX2Double_t fX2end xDefinition TCurlyLine.h:24; TCurlyLine::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TCurlyLine.cxx:185; TCurlyLine::fIsCurlyBool_t fIsCurlytrue: Gluon, false: GammaDefinition TCurlyLine.h:29; TCurlyLine::SetBBoxCenterYvoid SetBBoxCenterY(const Int_t y) overrideSet Y coordinate of the center of the BoundingBox.Definition TCurlyLine.cxx:546; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TPointDefinition TPoint.h:31; TPolyLine::GetXDouble_t * GetX() constDefinition TPolyLine.h:54; TPolyLine::GetYDouble_t * GetY() constDefinition TPolyLine.h:55; TPolyLine::SetPolyLinevirtual void SetPolyLine(Int_t n)Resize this polyline to size n.Definition TPolyLine.cxx:657; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definiti",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:7133,Usability,simpl,simply,7133,,MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCurlyLine_8cxx_source.html:7399,Usability,simpl,simply,7399," kMaxDiff = 20;; 190 static Int_t d1,d2,px1,px2,py1,py2;; 191 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 192 static Bool_t p1, p2, pL;; 193 Int_t dx, dy;; 194 ; 195 Bool_t opaque = gPad->OpaqueMoving();; 196 ; 197 switch (event) {; 198 ; 199 case kArrowKeyPress:; 200 case kButton1Down:; 201 if (!opaque) {; 202 gVirtualX->SetLineColor(-1);; 203 TAttLine::Modify(); //Change line attributes only if necessary; 204 }; 205 ; 206 // No break !!!; 207 ; 208 case kMouseMotion:; 209 ; 210 px1 = gPad->XtoAbsPixel(fX1);; 211 py1 = gPad->YtoAbsPixel(fY1);; 212 px2 = gPad->XtoAbsPixel(fX2);; 213 py2 = gPad->YtoAbsPixel(fY2);; 214 ; 215 p1 = p2 = pL = kFALSE;; 216 ; 217 d1 = TMath::Abs(px1 - px) + TMath::Abs(py1-py); //simply take sum of pixels differences; 218 if (d1 < kMaxDiff) { //*-*================>OK take point number 1; 219 px1old = px1; py1old = py1;; 220 p1 = kTRUE;; 221 gPad->SetCursor(kPointer);; 222 return;; 223 }; 224 d2 = TMath::Abs(px2 - px) + TMath::Abs(py2-py); //simply take sum of pixels differences; 225 if (d2 < kMaxDiff) { //*-*================>OK take point number 2; 226 px2old = px2; py2old = py2;; 227 p2 = kTRUE;; 228 gPad->SetCursor(kPointer);; 229 return;; 230 }; 231 ; 232 pL = kTRUE;; 233 pxold = px; pyold = py;; 234 gPad->SetCursor(kMove);; 235 ; 236 break;; 237 ; 238 case kArrowKeyRelease:; 239 case kButton1Motion:; 240 ; 241 if (p1) {; 242 if (!opaque) {; 243 gVirtualX->DrawLine(px1old, py1old, px2, py2);; 244 gVirtualX->DrawLine(px, py, px2, py2);; 245 }; 246 else this->SetStartPoint(gPad->AbsPixeltoX(px),gPad->AbsPixeltoY(py));; 247 px1old = px;; 248 py1old = py;; 249 }; 250 if (p2) {; 251 if (!opaque) {; 252 gVirtualX->DrawLine(px1, py1, px2old, py2old);; 253 gVirtualX->DrawLine(px1, py1, px, py);; 254 }; 255 else this->SetEndPoint(gPad->AbsPixeltoX(px), gPad->AbsPixeltoY(py));; 256 px2old = px;; 257 py2old = py;; 258 }; 259 if (pL) {; 260 if (!opaque) gVirtualX->DrawLine(px1, py1, px2, py2);; 261 dx = px-pxold; dy = py-pyold;; 262 p",MatchSource.WIKI,doc/master/TCurlyLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCurlyLine_8cxx_source.html
https://root.cern/doc/master/TCutG_8h.html:192,Integrability,depend,dependency,192,". ROOT: graf2d/graf/inc/TCutG.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TCutG.h File Reference. #include ""TGraph.h"". Include dependency graph for TCutG.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TCutG;  Graphical cut class. More...;  . graf2dgrafincTCutG.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TCutG_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h.html
https://root.cern/doc/master/TCutG_8h_source.html:788,Modifiability,variab,variable,788,"ching...; No Matches. TCutG.h. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Rene Brun 16/05/97; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCutG; 13#define ROOT_TCutG; 14 ; 15 ; 16#include ""TGraph.h""; 17 ; 18class TH2;; 19 ; 20class TCutG : public TGraph {; 21 ; 22protected:; 23 TString fVarX; ///< X variable; 24 TString fVarY; ///< Y variable; 25 TObject *fObjectX; ///<! pointer to an object corresponding to X; 26 TObject *fObjectY; ///<! pointer to an object corresponding to Y; 27 ; 28public:; 29 TCutG();; 30 TCutG(const TCutG &cutg);; 31 TCutG(const char *name, Int_t n=0);; 32 TCutG(const char *name, Int_t n, const Float_t *x, const Float_t *y);; 33 TCutG(const char *name, Int_t n, const Double_t *x, const Double_t *y);; 34 ~TCutG() override;; 35 ; 36 TCutG &operator=(const TCutG &);; 37 virtual Double_t Area() const;; 38 virtual void Center(Double_t &cx, Double_t &cy) const;; 39 TObject *GetObjectX() const {return fObjectX;}; 40 TObject *GetObjectY() const {return fObjectY;}; 41 const char *GetVarX() const {return fVarX.Data();}; 42 const char *GetVarY() const {return fVarY.Data();}; 43 virtual Double_t IntegralHist(TH2 *h, Option_t *option="""") const;; 44 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 45 virtual void SetObjectX(TObject *obj);; 46 virtual void SetObjectY(TObject *obj);; 47 virtual void SetVarX(const char *varx); // *MENU*; 48 virtual void SetVarY(const char *vary); // *MENU*; 49 ; 50 ClassDefOverride(TCutG,2) // A Graphical cut.; 51};; 52 ; 53#endif; h#define h(i)Definition RSha256.hxx:106; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdo",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TCutG_8h_source.html:823,Modifiability,variab,variable,823,"ching...; No Matches. TCutG.h. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Rene Brun 16/05/97; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TCutG; 13#define ROOT_TCutG; 14 ; 15 ; 16#include ""TGraph.h""; 17 ; 18class TH2;; 19 ; 20class TCutG : public TGraph {; 21 ; 22protected:; 23 TString fVarX; ///< X variable; 24 TString fVarY; ///< Y variable; 25 TObject *fObjectX; ///<! pointer to an object corresponding to X; 26 TObject *fObjectY; ///<! pointer to an object corresponding to Y; 27 ; 28public:; 29 TCutG();; 30 TCutG(const TCutG &cutg);; 31 TCutG(const char *name, Int_t n=0);; 32 TCutG(const char *name, Int_t n, const Float_t *x, const Float_t *y);; 33 TCutG(const char *name, Int_t n, const Double_t *x, const Double_t *y);; 34 ~TCutG() override;; 35 ; 36 TCutG &operator=(const TCutG &);; 37 virtual Double_t Area() const;; 38 virtual void Center(Double_t &cx, Double_t &cy) const;; 39 TObject *GetObjectX() const {return fObjectX;}; 40 TObject *GetObjectY() const {return fObjectY;}; 41 const char *GetVarX() const {return fVarX.Data();}; 42 const char *GetVarY() const {return fVarY.Data();}; 43 virtual Double_t IntegralHist(TH2 *h, Option_t *option="""") const;; 44 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 45 virtual void SetObjectX(TObject *obj);; 46 virtual void SetObjectY(TObject *obj);; 47 virtual void SetVarX(const char *varx); // *MENU*; 48 virtual void SetVarY(const char *vary); // *MENU*; 49 ; 50 ClassDefOverride(TCutG,2) // A Graphical cut.; 51};; 52 ; 53#endif; h#define h(i)Definition RSha256.hxx:106; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdo",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TCutG_8h_source.html:2685,Modifiability,variab,variable,2685,"vePrimitive(std::ostream &out, Option_t *option = """") override;; 45 virtual void SetObjectX(TObject *obj);; 46 virtual void SetObjectY(TObject *obj);; 47 virtual void SetVarX(const char *varx); // *MENU*; 48 virtual void SetVarY(const char *vary); // *MENU*; 49 ; 50 ClassDefOverride(TCutG,2) // A Graphical cut.; 51};; 52 ; 53#endif; h#define h(i)Definition RSha256.hxx:106; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TGraph.h; TCutGGraphical cut class.Definition TCutG.h:20; TCutG::IntegralHistvirtual Double_t IntegralHist(TH2 *h, Option_t *option="""") constCompute the integral of 2-d histogram h for all bins inside the cut if option ""width"" is specified,...Definition TCutG.cxx:311; TCutG::fVarYTString fVarYY variable.Definition TCutG.h:24; TCutG::Centervirtual void Center(Double_t &cx, Double_t &cy) constCompute the center x,y of this TCutG The algorithm uses Stoke's theorem over the border of the closed...Definition TCutG.cxx:289; TCutG::~TCutG~TCutG() overrideTCutG destructor.Definition TCutG.cxx:243; TCutG::TCutGTCutG()TCutG default constructor.Definition TCutG.cxx:99; TCutG::GetVarXconst char * GetVarX() constDefinition TCutG.h:41; TCutG::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TCutG.cxx:356; TCutG::fObjectYTObject * fObjectY! pointer to an object corresponding to YDefinition TCutG.h:26; TCutG::SetVarYvirtual void SetVarY(const char *vary)Set Y variable.Definition TCutG.cxx:412; TCutG::Areavirtual Double_t Area() constCompute the area inside this TCutG The algorithm uses Stoke's theorem over the border of the closed p...Definition TCutG.cxx:272; TCutG::fVarXTString ",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TCutG_8h_source.html:3447,Modifiability,variab,variable,3447,"lass.Definition TCutG.h:20; TCutG::IntegralHistvirtual Double_t IntegralHist(TH2 *h, Option_t *option="""") constCompute the integral of 2-d histogram h for all bins inside the cut if option ""width"" is specified,...Definition TCutG.cxx:311; TCutG::fVarYTString fVarYY variable.Definition TCutG.h:24; TCutG::Centervirtual void Center(Double_t &cx, Double_t &cy) constCompute the center x,y of this TCutG The algorithm uses Stoke's theorem over the border of the closed...Definition TCutG.cxx:289; TCutG::~TCutG~TCutG() overrideTCutG destructor.Definition TCutG.cxx:243; TCutG::TCutGTCutG()TCutG default constructor.Definition TCutG.cxx:99; TCutG::GetVarXconst char * GetVarX() constDefinition TCutG.h:41; TCutG::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TCutG.cxx:356; TCutG::fObjectYTObject * fObjectY! pointer to an object corresponding to YDefinition TCutG.h:26; TCutG::SetVarYvirtual void SetVarY(const char *vary)Set Y variable.Definition TCutG.cxx:412; TCutG::Areavirtual Double_t Area() constCompute the area inside this TCutG The algorithm uses Stoke's theorem over the border of the closed p...Definition TCutG.cxx:272; TCutG::fVarXTString fVarXX variable.Definition TCutG.h:23; TCutG::SetObjectYvirtual void SetObjectY(TObject *obj)Set the Y object (and delete the previous one if any).Definition TCutG.cxx:393; TCutG::SetVarXvirtual void SetVarX(const char *varx)Set X variable.Definition TCutG.cxx:402; TCutG::operator=TCutG & operator=(const TCutG &)Assignment operator.Definition TCutG.cxx:254; TCutG::GetObjectYTObject * GetObjectY() constDefinition TCutG.h:40; TCutG::SetObjectXvirtual void SetObjectX(TObject *obj)Set the X object (and delete the previous one if any).Definition TCutG.cxx:384; TCutG::GetObjectXTObject * GetObjectX() constDefinition TCutG.h:39; TCutG::fObjectXTObject * fObjectX! pointer to an object corresponding to XDefinition TCutG.h:25; TCutG::GetVarYconst c",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TCutG_8h_source.html:3679,Modifiability,variab,variable,3679,"fVarYTString fVarYY variable.Definition TCutG.h:24; TCutG::Centervirtual void Center(Double_t &cx, Double_t &cy) constCompute the center x,y of this TCutG The algorithm uses Stoke's theorem over the border of the closed...Definition TCutG.cxx:289; TCutG::~TCutG~TCutG() overrideTCutG destructor.Definition TCutG.cxx:243; TCutG::TCutGTCutG()TCutG default constructor.Definition TCutG.cxx:99; TCutG::GetVarXconst char * GetVarX() constDefinition TCutG.h:41; TCutG::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TCutG.cxx:356; TCutG::fObjectYTObject * fObjectY! pointer to an object corresponding to YDefinition TCutG.h:26; TCutG::SetVarYvirtual void SetVarY(const char *vary)Set Y variable.Definition TCutG.cxx:412; TCutG::Areavirtual Double_t Area() constCompute the area inside this TCutG The algorithm uses Stoke's theorem over the border of the closed p...Definition TCutG.cxx:272; TCutG::fVarXTString fVarXX variable.Definition TCutG.h:23; TCutG::SetObjectYvirtual void SetObjectY(TObject *obj)Set the Y object (and delete the previous one if any).Definition TCutG.cxx:393; TCutG::SetVarXvirtual void SetVarX(const char *varx)Set X variable.Definition TCutG.cxx:402; TCutG::operator=TCutG & operator=(const TCutG &)Assignment operator.Definition TCutG.cxx:254; TCutG::GetObjectYTObject * GetObjectY() constDefinition TCutG.h:40; TCutG::SetObjectXvirtual void SetObjectX(TObject *obj)Set the X object (and delete the previous one if any).Definition TCutG.cxx:384; TCutG::GetObjectXTObject * GetObjectX() constDefinition TCutG.h:39; TCutG::fObjectXTObject * fObjectX! pointer to an object corresponding to XDefinition TCutG.h:25; TCutG::GetVarYconst char * GetVarY() constDefinition TCutG.h:42; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TObjectMother of all ROOT objects.Definit",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TCutG_8h_source.html:3903,Modifiability,variab,variable,3903,"the closed...Definition TCutG.cxx:289; TCutG::~TCutG~TCutG() overrideTCutG destructor.Definition TCutG.cxx:243; TCutG::TCutGTCutG()TCutG default constructor.Definition TCutG.cxx:99; TCutG::GetVarXconst char * GetVarX() constDefinition TCutG.h:41; TCutG::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TCutG.cxx:356; TCutG::fObjectYTObject * fObjectY! pointer to an object corresponding to YDefinition TCutG.h:26; TCutG::SetVarYvirtual void SetVarY(const char *vary)Set Y variable.Definition TCutG.cxx:412; TCutG::Areavirtual Double_t Area() constCompute the area inside this TCutG The algorithm uses Stoke's theorem over the border of the closed p...Definition TCutG.cxx:272; TCutG::fVarXTString fVarXX variable.Definition TCutG.h:23; TCutG::SetObjectYvirtual void SetObjectY(TObject *obj)Set the Y object (and delete the previous one if any).Definition TCutG.cxx:393; TCutG::SetVarXvirtual void SetVarX(const char *varx)Set X variable.Definition TCutG.cxx:402; TCutG::operator=TCutG & operator=(const TCutG &)Assignment operator.Definition TCutG.cxx:254; TCutG::GetObjectYTObject * GetObjectY() constDefinition TCutG.h:40; TCutG::SetObjectXvirtual void SetObjectX(TObject *obj)Set the X object (and delete the previous one if any).Definition TCutG.cxx:384; TCutG::GetObjectXTObject * GetObjectX() constDefinition TCutG.h:39; TCutG::fObjectXTObject * fObjectX! pointer to an object corresponding to XDefinition TCutG.h:25; TCutG::GetVarYconst char * GetVarY() constDefinition TCutG.h:42; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definiti",MatchSource.WIKI,doc/master/TCutG_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TCutG_8h_source.html
https://root.cern/doc/master/TDataFrame_8hxx_source.html:976,Integrability,interface,interface,976,". ROOT: tree/dataframe/inc/ROOT/TDataFrame.hxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TDataFrame.hxx. Go to the documentation of this file. 1// Author: Enrico Guiraud, Danilo Piparo CERN 05/2018; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_TDATAFRAME; 12#define ROOT_TDATAFRAME; 13#include ""RDataFrame.hxx""; 14namespace ROOT {; 15 ; 16using TDataFrame = ROOT::RDataFrame;; 17 ; 18} // End NS ROOT; 19 ; 20#warning The TDataFrame.hxx header has been replaced by RDataFrame.hxx; 21 ; 22#endif; RDataFrame.hxx; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treedataframeincROOTTDataFrame.hxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:02 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDataFrame_8hxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDataFrame_8hxx_source.html
https://root.cern/doc/master/TDataType_8h.html:219,Integrability,depend,dependency,219,". ROOT: core/meta/inc/TDataType.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; TDataType.h File Reference. #include ""TDictionary.h"". Include dependency graph for TDataType.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDataType;  Basic data type descriptor (datatype information is obtained from CINT). More...;  . Enumerations; enum  EDataType { ;   kChar_t = 1; , kUChar_t = 11; , kShort_t = 2; , kUShort_t = 12; , ;   kInt_t = 3; , kUInt_t = 13; , kLong_t = 4; , kULong_t = 14; , ;   kFloat_t = 5; , kDouble_t = 8; , kDouble32_t = 9; , kchar = 10; , ;   kBool_t = 18; , kLong64_t = 16; , kULong64_t = 17; , kOther_t = -1; , ;   kNoType_t = 0; , kFloat16_t = 19; , kCounter = 6; , kCharStar = 7; , ;   kBits = 15; , kVoid_t = 20; , kDataTypeAliasUnsigned_t = 21; , kDataTypeAliasSignedChar_t = 22; , ;   kNumDataTypes. };  . Enumeration Type Documentation. ◆ EDataType. enum EDataType. EnumeratorkChar_t ; kUChar_t ; kShort_t ; kUShort_t ; kInt_t ; kUInt_t ; kLong_t ; kULong_t ; kFloat_t ; kDouble_t ; kDouble32_t ; kchar ; kBool_t ; kLong64_t ; kULong64_t ; kOther_t ; kNoType_t ; kFloat16_t ; kCounter ; kCharStar ; kBits ; kVoid_t ; kDataTypeAliasUnsigned_t ; kDataTypeAliasSignedChar_t ; kNumDataTypes . Definition at line 28 of file TDataType.h. coremetaincTDataType.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDataType_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDataType_8h.html
https://root.cern/doc/master/TDatime_8cxx_source.html:6600,Availability,error,error,6600," to GMT,; 174/// as in this example:; 175/// ~~~ {.cpp}; 176/// TDatime now;; 177/// now.Set(now.Convert(kTRUE));; 178/// ~~~; 179/// Caution: the time_t returned from Convert(kTRUE) is incompatible with; 180/// regular Unix time - it contains an artificial, locale-dependent offset.; 181 ; 182UInt_t TDatime::Convert(Bool_t toGMT) const; 183{; 184 UInt_t year = fDatime>>26;; 185 UInt_t month = (fDatime<<6)>>28;; 186 UInt_t day = (fDatime<<10)>>27;; 187 UInt_t hour = (fDatime<<15)>>27;; 188 UInt_t min = (fDatime<<20)>>26;; 189 UInt_t sec = (fDatime<<26)>>26;; 190 ; 191 struct tm tp;; 192 tp.tm_year = year+95;; 193 tp.tm_mon = month-1;; 194 tp.tm_mday = day;; 195 tp.tm_hour = hour;; 196 tp.tm_min = min;; 197 tp.tm_sec = sec;; 198 tp.tm_isdst = -1;; 199 ; 200 time_t t = mktime(&tp);; 201 if ((int)t == -1) {; 202 Error(""TDatime::Convert"", ""error converting fDatime to time_t"");; 203 return 0;; 204 }; 205 if (toGMT) {; 206#ifndef WIN32; 207 struct tm tg;; 208 struct tm *tgp = gmtime_r(&t, &tg);; 209#else; 210 struct tm *tgp = gmtime(&t);; 211#endif; 212 tgp->tm_isdst = -1;; 213 t = mktime(tgp);; 214 }; 215 return (UInt_t)t;; 216}; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219/// Copy this to datime.; 220 ; 221void TDatime::Copy(TDatime &datime) const; 222{; 223 datime.fDatime = fDatime;; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Encode Date/Time into buffer, used by I/O system.; 228 ; 229void TDatime::FillBuffer(char *&buffer); 230{; 231 tobuf(buffer, fDatime);; 232}; 233 ; 234////////////////////////////////////////////////////////////////////////////////; 235/// Return raw date/time as encoded by TDatime. Note, this value cannot; 236/// be used to e.g. calculate time differences, as it is an encoded value.; 237/// To calculate time differences use the Convert() method to get a time; 238/// in seconds and then subtract the values.; 239 ; 240UInt_t TDatime::Get() ",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:16088,Availability,failure,failure,16088,"at (as obtained via; 464/// TDatime::GetDate()).; 465 ; 466Int_t TDatime::GetDateFromGlobalDay(Int_t day); 467{; 468 Long64_t ld = day;; 469 Int_t y = int((10000*ld + 14780)/3652425);; 470 Int_t ddd = day - (y*365 + y/4 - y/100 + y/400);; 471 if (ddd < 0) {; 472 y--;; 473 ddd = day - (y*365 + y/4 - y/100 + y/400);; 474 }; 475 Int_t mi = (52 + 100*ddd)/3060;; 476 Int_t dy = y + (mi + 2)/12;; 477 Int_t dm = (mi + 2)%12 + 1;; 478 Int_t dd = ddd - (mi*306 + 5)/10 + 1;; 479 ; 480 return dy*10000 + dm*100 + dd;; 481}; 482 ; 483////////////////////////////////////////////////////////////////////////////////; 484/// Static function that returns the global day number from date. The input is; 485/// in TDatime format yyyymmdd (as obtained via TDatime::GetDate()).; 486/// This algorithm is only accurate for dates later than October 1582; 487/// (earliest date on Gregorian calendar) and it is checked that the date; 488/// is larger than 15821001 and conversion is correct.; 489/// In case of conversion failure 0 is returned.; 490/// No need to use when you know dates are larger than October 1582.; 491 ; 492Int_t TDatime::GetLegalGlobalDayFromDate(Int_t date); 493{; 494 static Int_t calstart = 0;; 495 if (!calstart); 496 calstart = TDatime::GetGlobalDayFromDate(15821001);; 497 Int_t d = TDatime::GetGlobalDayFromDate(date);; 498 if (d < calstart); 499 ::Warning(""TDatime::GetLegalGlobalDayFromDate"", ""dates before Oct. 1582 are inaccurate."");; 500 Int_t dte = TDatime::GetDateFromGlobalDay(d);; 501 if (dte != date) {; 502 ::Error(""TDatime::GetLegalGlobalDayFromDate"", ""illegal date %d"", dte);; 503 return 0;; 504 }; 505 return d;; 506}; 507 ; 508////////////////////////////////////////////////////////////////////////////////; 509/// Print a TDatime at the prompt.; 510 ; 511std::string cling::printValue(const TDatime* val) {; 512 char buf[30];; 513 return std::string(val->AsString(buf));; 514}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(cha",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:17516,Availability,error,error,17516," 1582 are inaccurate."");; 500 Int_t dte = TDatime::GetDateFromGlobalDay(d);; 501 if (dte != date) {; 502 ::Error(""TDatime::GetLegalGlobalDayFromDate"", ""illegal date %d"", dte);; 503 return 0;; 504 }; 505 return d;; 506}; 507 ; 508////////////////////////////////////////////////////////////////////////////////; 509/// Print a TDatime at the prompt.; 510 ; 511std::string cling::printValue(const TDatime* val) {; 512 char buf[30];; 513 return std::string(val->AsString(buf));; 514}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; RConfig.hxx; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TBuffer.h; TDatime.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TString.h; Windows4Root.h; snprintf#define snprintfDefinition civetweb.c:1540; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetGlobalDayFromDatestatic Int_t GetGlobalDayFromDate(Int_t date)Static function that returns the global day number from date.Definition TDatime.cxx:449; TDatime::GetDateFromGlobalDaystatic Int_t GetDateFromGlobalDay(Int_t day)Static function that returns the date from the global day number.Definition TDatime.cxx:466; TDatime::Copyvoid Copy(TDatime &datime) constCopy this to datime.Definition TDatime.cxx:221; TDatime::GetLegalGlobalDayFromDatestatic Int_t GetLegalGlobalDayFromDate(Int_t date)Static function tha",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:3372,Energy Efficiency,allocate,allocated,3372,"ur, Int_t min, Int_t sec); 70{; 71 Set(year, month, day, hour, min, sec);; 72}; 73 ; 74////////////////////////////////////////////////////////////////////////////////; 75/// Expects as input a string in SQL date/time compatible format, like:; 76/// yyyy-mm-dd hh:mm:ss.; 77 ; 78TDatime::TDatime(const char *sqlDateTime); 79{; 80 Set(sqlDateTime);; 81}; 82 ; 83////////////////////////////////////////////////////////////////////////////////; 84/// Returns day of week, with Monday being day 1 and Sunday day 7.; 85 ; 86Int_t TDatime::GetDayOfWeek() const; 87{; 88 static TString weekDays[7] = { ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat"", ""Sun"" };; 89 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {;",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:6019,Integrability,depend,dependent,6019,"g() const; 153{; 154 static char sqldate[20];; 155 ; 156 UInt_t year = fDatime>>26;; 157 UInt_t month = (fDatime<<6)>>28;; 158 UInt_t day = (fDatime<<10)>>27;; 159 UInt_t hour = (fDatime<<15)>>27;; 160 UInt_t min = (fDatime<<20)>>26;; 161 UInt_t sec = (fDatime<<26)>>26;; 162 ; 163 snprintf(sqldate,20, ""%04d-%02d-%02d %02d:%02d:%02d"", (year+1995), month, day,; 164 hour, min, sec);; 165 ; 166 return sqldate;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Convert fDatime from TDatime format to the standard time_t format.; 171/// If toGMT is true, the time offset of the current local time zone is; 172/// subtracted from the returned time_t. One use of such a non-standard time_t; 173/// value is to convert a TDatime object that contains local time to GMT,; 174/// as in this example:; 175/// ~~~ {.cpp}; 176/// TDatime now;; 177/// now.Set(now.Convert(kTRUE));; 178/// ~~~; 179/// Caution: the time_t returned from Convert(kTRUE) is incompatible with; 180/// regular Unix time - it contains an artificial, locale-dependent offset.; 181 ; 182UInt_t TDatime::Convert(Bool_t toGMT) const; 183{; 184 UInt_t year = fDatime>>26;; 185 UInt_t month = (fDatime<<6)>>28;; 186 UInt_t day = (fDatime<<10)>>27;; 187 UInt_t hour = (fDatime<<15)>>27;; 188 UInt_t min = (fDatime<<20)>>26;; 189 UInt_t sec = (fDatime<<26)>>26;; 190 ; 191 struct tm tp;; 192 tp.tm_year = year+95;; 193 tp.tm_mon = month-1;; 194 tp.tm_mday = day;; 195 tp.tm_hour = hour;; 196 tp.tm_min = min;; 197 tp.tm_sec = sec;; 198 tp.tm_isdst = -1;; 199 ; 200 time_t t = mktime(&tp);; 201 if ((int)t == -1) {; 202 Error(""TDatime::Convert"", ""error converting fDatime to time_t"");; 203 return 0;; 204 }; 205 if (toGMT) {; 206#ifndef WIN32; 207 struct tm tg;; 208 struct tm *tgp = gmtime_r(&t, &tg);; 209#else; 210 struct tm *tgp = gmtime(&t);; 211#endif; 212 tgp->tm_isdst = -1;; 213 t = mktime(tgp);; 214 }; 215 return (UInt_t)t;; 216}; 217 ; 218///////////////////////////////////////",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:1024,Modifiability,portab,portable,1024,"ce Guide ; .  . Loading...; Searching...; No Matches. TDatime.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Rene Brun 05/01/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TDatime; 13\ingroup Base; 14 ; 15This class stores the date and time with a precision of one second; 16in an unsigned 32 bit word (950130 124559).; 17The date is stored with the origin being the 1st January 1995.; 18 ; 19This class has no support for time zones. The time is assumed; 20to be in the local time of the machine where the object was created.; 21As a result, TDatime objects are not portable between machines; 22operating in different time zones and unsuitable for storing the; 23date/time of data taking events and the like. If absolute time is; 24required, use TTimeStamp.; 25*/; 26 ; 27#include <ROOT/RConfig.hxx>; 28 ; 29#include <ctime>; 30 ; 31#ifdef WIN32; 32#include ""Windows4Root.h""; 33#include <string.h>; 34#endif; 35 ; 36#include ""TBuffer.h""; 37#include ""Strlen.h""; 38#include ""snprintf.h""; 39#include ""TDatime.h""; 40#include ""TError.h""; 41#include ""Bytes.h""; 42#include ""TString.h""; 43 ; 44 ; 45ClassImp(TDatime);; 46 ; 47////////////////////////////////////////////////////////////////////////////////; 48/// Create a TDatime and set it to the current time.; 49 ; 50TDatime::TDatime(); 51{; 52 Set();; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// Create a TDatime and set it to the specified date and time.; 57/// See Set(Int_t, Int_t) about the date, time format.; 58 ; 59TDatime::TDatime(Int_t date, Int_t time); 60{; 61 Set(date, time);; 62}; 63 ; 64////////////",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8cxx_source.html:4004,Safety,safe,safe,4004,"9 TString wd = AsString();; 90 int day;; 91 for (day = 0; day < 7; day++) {; 92 if (wd(0, 3) == weekDays[day]); 93 break;; 94 }; 95 return (day < 7) ? day+1: -1;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Return the date & time as a string (ctime() format).; 100/// Copy result because it points to a statically allocated string.; 101 ; 102const char *TDatime::AsString() const; 103{; 104 time_t t = Convert();; 105 char *retStr = ctime(&t);; 106 if (retStr) {; 107 *(retStr + 24) = 0;; 108 return retStr;; 109 } else {; 110 static const char *defaulttime = ""15/06/96"";; 111 Error(""TDatime::AsString"", ""could not get time string"");; 112 return defaulttime;; 113 }; 114}; 115 ; 116////////////////////////////////////////////////////////////////////////////////; 117/// Return the date & time as a string (ctime() format).; 118/// Result is copied into out (and out is returned). Make sure; 119/// out can at least contain 26 characters. Thread safe.; 120 ; 121const char *TDatime::AsString(char *out) const; 122{; 123 time_t t = Convert();; 124#ifndef WIN32; 125#if defined(R__SOLARIS) && (_POSIX_C_SOURCE - 0 < 199506L); 126 char *retStr = ctime_r(&t, out, 26);; 127#else; 128 char *retStr = ctime_r(&t, out);; 129#endif; 130#else; 131 char *retStr = ctime(&t);; 132#endif; 133 if (retStr) {; 134 *(retStr + 24) = 0;; 135#ifdef WIN32; 136 strcpy(out, retStr);; 137#endif; 138 return retStr;; 139 } else {; 140 static const char *defaulttime = ""15/06/96"";; 141 strcpy(out, defaulttime);; 142 Error(""TDatime::AsString"", ""could not get time string"");; 143 return defaulttime;; 144 }; 145}; 146 ; 147////////////////////////////////////////////////////////////////////////////////; 148/// Return the date & time in SQL compatible string format, like:; 149/// 1997-01-15 20:16:28. The returned string buffer is static and; 150/// will be reused.; 151 ; 152const char *TDatime::AsSQLString() const; 153{; 154 static char sqldate[20];; 155 ; 156 UIn",MatchSource.WIKI,doc/master/TDatime_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8cxx_source.html
https://root.cern/doc/master/TDatime_8h_source.html:1210,Modifiability,portab,portable,1210,"***********************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TDatime; 13#define ROOT_TDatime; 14 ; 15#include <string>; 16 ; 17//////////////////////////////////////////////////////////////////////////; 18// //; 19// TDatime //; 20// //; 21// This class stores the date and time with a precision of one second //; 22// in an unsigned 32 bit word (e.g. 950130 124559). The date is stored //; 23// with the origin being the 1st january 1995. //; 24// //; 25// This class has no support for time zones. The time is assumed //; 26// to be in the local time of the machine where the object was created. //; 27// As a result, TDatime objects are not portable between machines //; 28// operating in different time zones and unsuitable for storing the //; 29// date/time of data taking events and the like. If absolute time is //; 30// required, use TTimeStamp. //; 31// //; 32//////////////////////////////////////////////////////////////////////////; 33 ; 34#include ""Rtypes.h""; 35 ; 36 ; 37class TDatime {; 38 ; 39private:; 40 ; 41protected:; 42 UInt_t fDatime; //Date (relative to 1995) + time; 43 ; 44public:; 45 TDatime();; 46 TDatime(const TDatime &d): fDatime(d.fDatime) { }; 47 TDatime(UInt_t tloc, Bool_t dosDate = kFALSE): fDatime(0); 48 { Set(tloc, dosDate); }; 49 TDatime(Int_t date, Int_t time);; 50 TDatime(Int_t year, Int_t month, Int_t day,; 51 Int_t hour, Int_t min, Int_t sec);; 52 TDatime(const char *sqlDateTime);; 53 virtual ~TDatime() { }; 54 ; 55 TDatime& operator=(const TDatime &d);; 56 ; 57 const char *AsString() const;; 58 const char *AsString(char *out) const;; 59 const char *AsSQLString() const;; 60 UInt_t Convert(Bool_t toGMT = kFALSE) const;; 61 void Copy(TDatime &datime",MatchSource.WIKI,doc/master/TDatime_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDatime_8h_source.html
https://root.cern/doc/master/TDictionary_8h.html:255,Integrability,depend,dependency,255,". ROOT: core/meta/inc/TDictionary.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Enumerations ; TDictionary.h File Reference. #include ""TNamed.h""; #include ""ESTLType.h"". Include dependency graph for TDictionary.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDictionary;  This class defines an abstract interface that must be implemented by all classes that contain dictionary information. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Enumerations; enum  EClassProperty { ;   kClassIsValid = 0x00000001; , kClassHasExplicitCtor = 0x00000010; , kClassHasImplicitCtor = 0x00000020; , kClassHasCtor = 0x00000030; , ;   kClassHasDefaultCtor = 0x00000040; , kClassHasAssignOpr = 0x00000080; , kClassHasExplicitDtor = 0x00000100; , kClassHasImplicitDtor = 0x00000200; , ;   kClassHasDtor = 0x00000300; , kClassHasVirtual = 0x00001000; , kClassIsAbstract = 0x00002000; , kClassIsAggregate = 0x00004000. };  ; enum  ROOT::EFunctionMatchMode { ROOT::kExactMatch = 0; , ROOT::kConversionMatch = 1; };  ; enum  EFunctionProperty { ;   kIsConstructor = 0x00000001; , kIsConversion = 0x00000002; , kIsDestructor = 0x00000004; , kIsOperator = 0x00000008; , ;   kIsInlined = 0x00000010; , kIsTemplateSpec = 0x00000020. };  ; enum  EProperty { ;   kIsClass = 0x00000001; , kIsStruct = 0x00000002; , kIsUnion = 0x00000004; , kIsEnum = 0x00000008; , ;   kIsTypedef = 0x00000010; , kIsFundamental = 0x00000020; , kIsAbstract = 0x00000040; , kIsVirtual = 0x00000080; , ;   kIsPureVirtual = 0x00000100; , kIsUnionMember = 0x00000100; , kIsPublic = 0x00000200; , kIsProtec",MatchSource.WIKI,doc/master/TDictionary_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h.html
https://root.cern/doc/master/TDictionary_8h.html:595,Integrability,interface,interface,595,". ROOT: core/meta/inc/TDictionary.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Enumerations ; TDictionary.h File Reference. #include ""TNamed.h""; #include ""ESTLType.h"". Include dependency graph for TDictionary.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDictionary;  This class defines an abstract interface that must be implemented by all classes that contain dictionary information. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Enumerations; enum  EClassProperty { ;   kClassIsValid = 0x00000001; , kClassHasExplicitCtor = 0x00000010; , kClassHasImplicitCtor = 0x00000020; , kClassHasCtor = 0x00000030; , ;   kClassHasDefaultCtor = 0x00000040; , kClassHasAssignOpr = 0x00000080; , kClassHasExplicitDtor = 0x00000100; , kClassHasImplicitDtor = 0x00000200; , ;   kClassHasDtor = 0x00000300; , kClassHasVirtual = 0x00001000; , kClassIsAbstract = 0x00002000; , kClassIsAggregate = 0x00004000. };  ; enum  ROOT::EFunctionMatchMode { ROOT::kExactMatch = 0; , ROOT::kConversionMatch = 1; };  ; enum  EFunctionProperty { ;   kIsConstructor = 0x00000001; , kIsConversion = 0x00000002; , kIsDestructor = 0x00000004; , kIsOperator = 0x00000008; , ;   kIsInlined = 0x00000010; , kIsTemplateSpec = 0x00000020. };  ; enum  EProperty { ;   kIsClass = 0x00000001; , kIsStruct = 0x00000002; , kIsUnion = 0x00000004; , kIsEnum = 0x00000008; , ;   kIsTypedef = 0x00000010; , kIsFundamental = 0x00000020; , kIsAbstract = 0x00000040; , kIsVirtual = 0x00000080; , ;   kIsPureVirtual = 0x00000100; , kIsUnionMember = 0x00000100; , kIsPublic = 0x00000200; , kIsProtec",MatchSource.WIKI,doc/master/TDictionary_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h.html
https://root.cern/doc/master/TDictionary_8h_source.html:3342,Availability,avail,available,3342,"t;; 61class TypedefInfo_t;; 62class TDictAttributeMap;; 63 ; 64enum EProperty {; 65 kIsClass = 0x00000001,; 66 kIsStruct = 0x00000002,; 67 kIsUnion = 0x00000004,; 68 kIsEnum = 0x00000008,; 69 kIsTypedef = 0x00000010,; 70 kIsFundamental = 0x00000020,; 71 kIsAbstract = 0x00000040,; 72 kIsVirtual = 0x00000080,; 73 kIsPureVirtual = 0x00000100,; 74 kIsUnionMember = 0x00000100,; 75 kIsPublic = 0x00000200,; 76 kIsProtected = 0x00000400,; 77 kIsPrivate = 0x00000800,; 78 kIsPointer = 0x00001000,; 79 kIsArray = 0x00002000,; 80 kIsStatic = 0x00004000,; 81 kIsDefault = 0x00008000,; 82 kIsReference = 0x00010000,; 83 kIsDirectInherit = 0x00020000,; 84 kIsCCompiled = 0x00040000,; 85 kIsCPPCompiled = kIsCCompiled,; 86 kIsCompiled = kIsCCompiled,; 87 kIsNotReacheable = 0x00080000, // Indicate that the entity can not be used from the Global Namespace; 88 kIsConstant = 0x00100000,; 89 kIsVirtualBase = 0x00200000,; 90 kIsConstPointer = 0x00400000,; 91 kIsScopedEnum = 0x00800000,; 92 // 0x01000000 is available; 93 kIsConstexpr = 0x02000000,; 94 kIsExplicit = 0x04000000,; 95 kIsNamespace = 0x08000000,; 96 kIsConstMethod = 0x10000000,; 97 kIsUsing = 0x20000000,; 98 kIsDefinedInStd = 0x40000000; 99 // 0x80000000 is available; 100};; 101 ; 102enum EFunctionProperty {; 103/* The following are already defined; 104 in EProperty and 'could' be part of this enums */; 105/*; 106 kIsAbstract = 0x00000040,; 107 kIsVirtual = 0x00000080,; 108 kIsPureVirtual = 0x00000100,; 109 kIsPublic = 0x00000200,; 110 kIsProtected = 0x00000400,; 111 kIsPrivate = 0x00000800,; 112 kIsStatic = 0x00004000,; 113 kIsDefault = 0x00008000,; 114 kIsConstexpr = 0x02000000; 115 kIsExplicit = 0x04000000,; 116 kIsConstMethod = 0x10000000,; 117*/; 118/* The following are already defined; 119 in EProperty and related to the type of the return value */; 120/*; 121 kIsConstant = 0x00100000,; 122 kIsPointer = 0x00001000,; 123 kIsArray = 0x00002000,; 124 kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsCo",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:3558,Availability,avail,available,3558,"; 70 kIsFundamental = 0x00000020,; 71 kIsAbstract = 0x00000040,; 72 kIsVirtual = 0x00000080,; 73 kIsPureVirtual = 0x00000100,; 74 kIsUnionMember = 0x00000100,; 75 kIsPublic = 0x00000200,; 76 kIsProtected = 0x00000400,; 77 kIsPrivate = 0x00000800,; 78 kIsPointer = 0x00001000,; 79 kIsArray = 0x00002000,; 80 kIsStatic = 0x00004000,; 81 kIsDefault = 0x00008000,; 82 kIsReference = 0x00010000,; 83 kIsDirectInherit = 0x00020000,; 84 kIsCCompiled = 0x00040000,; 85 kIsCPPCompiled = kIsCCompiled,; 86 kIsCompiled = kIsCCompiled,; 87 kIsNotReacheable = 0x00080000, // Indicate that the entity can not be used from the Global Namespace; 88 kIsConstant = 0x00100000,; 89 kIsVirtualBase = 0x00200000,; 90 kIsConstPointer = 0x00400000,; 91 kIsScopedEnum = 0x00800000,; 92 // 0x01000000 is available; 93 kIsConstexpr = 0x02000000,; 94 kIsExplicit = 0x04000000,; 95 kIsNamespace = 0x08000000,; 96 kIsConstMethod = 0x10000000,; 97 kIsUsing = 0x20000000,; 98 kIsDefinedInStd = 0x40000000; 99 // 0x80000000 is available; 100};; 101 ; 102enum EFunctionProperty {; 103/* The following are already defined; 104 in EProperty and 'could' be part of this enums */; 105/*; 106 kIsAbstract = 0x00000040,; 107 kIsVirtual = 0x00000080,; 108 kIsPureVirtual = 0x00000100,; 109 kIsPublic = 0x00000200,; 110 kIsProtected = 0x00000400,; 111 kIsPrivate = 0x00000800,; 112 kIsStatic = 0x00004000,; 113 kIsDefault = 0x00008000,; 114 kIsConstexpr = 0x02000000; 115 kIsExplicit = 0x04000000,; 116 kIsConstMethod = 0x10000000,; 117*/; 118/* The following are already defined; 119 in EProperty and related to the type of the return value */; 120/*; 121 kIsConstant = 0x00100000,; 122 kIsPointer = 0x00001000,; 123 kIsArray = 0x00002000,; 124 kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsConstructor = 0x00000001,; 128 kIsConversion = 0x00000002,; 129 kIsDestructor = 0x00000004,; 130 kIsOperator = 0x00000008,; 131 kIsInlined = 0x00000010,; 132 kIsTemplateSpec= 0x00000020; 133};; 134 ; 135enum EClassProp",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:5646,Deployability,update,updated,5646," kIsReference = 0x00010000,; 125 kIsConstPointer = 0x00400000,; 126*/; 127 kIsConstructor = 0x00000001,; 128 kIsConversion = 0x00000002,; 129 kIsDestructor = 0x00000004,; 130 kIsOperator = 0x00000008,; 131 kIsInlined = 0x00000010,; 132 kIsTemplateSpec= 0x00000020; 133};; 134 ; 135enum EClassProperty {; 136 kClassIsValid = 0x00000001,; 137 kClassHasExplicitCtor = 0x00000010,; 138 kClassHasImplicitCtor = 0x00000020,; 139 kClassHasCtor = 0x00000030,; 140 kClassHasDefaultCtor = 0x00000040,; 141 kClassHasAssignOpr = 0x00000080,; 142 kClassHasExplicitDtor = 0x00000100,; 143 kClassHasImplicitDtor = 0x00000200,; 144 kClassHasDtor = 0x00000300,; 145 kClassHasVirtual = 0x00001000,; 146 kClassIsAbstract = 0x00002000,; 147 kClassIsAggregate = 0x00004000; 148};; 149 ; 150enum ERefTypeValues {; 151 kParaNormal = 0, // not used; 152 kParaReference = 1,; 153 kParaP2P = 2, // not used; 154 kParaP2P2P = 3, // not used; 155 kParaRef = 100,; 156 kParaRefP2P = 102, // not used; 157 kParaRefP2P2P = 103 // not used; 158};; 159 ; 160namespace ROOT {; 161 enum EFunctionMatchMode {; 162 kExactMatch = 0,; 163 kConversionMatch = 1; 164 };; 165}; 166 ; 167 ; 168class TDictionary : public TNamed {; 169 ; 170private:; 171 TDictAttributeMap *fAttributeMap{nullptr}; //pointer to a class attribute map; 172 ULong64_t fUpdatingTransactionCount{0}; //!the Cling ID of the transaction that last updated the object; 173 ; 174protected:; 175 Bool_t UpdateInterpreterStateMarker();; 176 ; 177public:; 178 TDictionary(): fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 179 TDictionary(const char* name): TNamed(name, """"), fAttributeMap(nullptr), fUpdatingTransactionCount(0) { }; 180 TDictionary(const TDictionary& dict);; 181 virtual ~TDictionary();; 182 ; 183 TDictionary& operator=(const TDictionary& other);; 184 ; 185 void CreateAttributeMap();; 186 TDictAttributeMap *GetAttributeMap() const; 187 {; 188 //Get the TDictAttributeMap pointer to be able to add attribute; 189 //pairs key-value to the TClass.",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:13199,Deployability,update,updated,13199,GWin32VirtualXProxy.cxx:247; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TDictAttributeMapThe ROOT object has a list of properties which are stored and retrieved using TDictAttributeMap.Definition TDictAttributeMap.h:30; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::Propertyvirtual Long_t Property() const =0; TDictionary::fAttributeMapTDictAttributeMap * fAttributeMapDefinition TDictionary.h:171; TDictionary::WantsRegularMembersstatic bool WantsRegularMembers(EMemberSelection sel)Definition TDictionary.h:221; TDictionary::GetAttributeMapTDictAttributeMap * GetAttributeMap() constDefinition TDictionary.h:186; TDictionary::TDictionaryTDictionary(const char *name)Definition TDictionary.h:179; TDictionary::fUpdatingTransactionCountULong64_t fUpdatingTransactionCountDefinition TDictionary.h:172; TDictionary::UpdateInterpreterStateMarkerBool_t UpdateInterpreterStateMarker()the Cling ID of the transaction that last updated the objectDefinition TDictionary.cxx:124; TDictionary::ESTLTypeESTLTypeDefinition TDictionary.h:198; TDictionary::kForwardlist@ kForwardlistDefinition TDictionary.h:202; TDictionary::kMultimap@ kMultimapDefinition TDictionary.h:205; TDictionary::kDeque@ kDequeDefinition TDictionary.h:203; TDictionary::kMap@ kMapDefinition TDictionary.h:204; TDictionary::kUnorderedSet@ kUnorderedSetDefinition TDictionary.h:208; TDictionary::kUnorderedMultimap@ kUnorderedMultimapDefinition TDictionary.h:211; TDictionary::kBitset@ kBitsetDefinition TDictionary.h:212; TDictionary::kVector@ kVectorDefinition TDictionary.h:200; TDictionary::kMultiset@ kMultisetDefinition TDictionary.h:207; TDictionary::kNone@ kNoneDefinition TDictionary.h:199; TDictionary::kUnorderedMap@ kUnorderedMapDefinition TDictionary.h:210; TDictionary::kUnorderedMultiset@ kUnorderedMultisetDefinition TDictionary.h:209; TDictionary::kList@ kListDefinition TDictionary.h:201; TDictionary,MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:845,Integrability,interface,interface,845,". ROOT: core/meta/inc/TDictionary.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TDictionary.h. Go to the documentation of this file. 1// @(#)root/meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific impleme",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:1376,Integrability,interface,interface,1376,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:12428,Integrability,interface,interface,12428,e GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t selDefinition TGWin32VirtualXProxy.cxx:247; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TDictAttributeMapThe ROOT object has a list of properties which are stored and retrieved using TDictAttributeMap.Definition TDictAttributeMap.h:30; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TDictionary::Propertyvirtual Long_t Property() const =0; TDictionary::fAttributeMapTDictAttributeMap * fAttributeMapDefinition TDictionary.h:171; TDictionary::WantsRegularMembersstatic bool WantsRegularMembers(EMemberSelection sel)Definition TDictionary.h:221; TDictionary::GetAttributeMapTDictAttributeMap * GetAttributeMap() constDefinition TDictionary.h:186; TDictionary::TDictionaryTDictionary(const char *name)Definition TDictionary.h:179; TDictionary::fUpdatingTransactionCountULong64_t fUpdatingTransactionCountDefinition TDictionary.h:172; TDictionary::UpdateInterpreterStateMarkerBool_t UpdateInterpreterStateMarker()the Cling ID of the transaction that last updated the objectDefinition TDictionary.cxx:124; TDictionary::ESTLTypeESTLTypeDefinition TDictionary.h:198; TDictionary::kForwardlist@ kForwardlistDefinition TDictionary.h:202; TDictionary::kMultimap@ kMultimapDefinition TDictionary.h:205; ,MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:1078,Modifiability,variab,variables,1078,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDictionary_8h_source.html:1440,Modifiability,inherit,inheritance,1440,"meta:$Id$; 2// Author: Fons Rademakers 20/06/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13#ifndef ROOT_TDictionary; 14#define ROOT_TDictionary; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TDictionary //; 19// //; 20// This class defines an abstract interface that must be implemented //; 21// by all classes that contain dictionary information. //; 22// //; 23// The dictionary is defined by the followling classes: //; 24// TDataType (typedef definitions) //; 25// TGlobal (global variables) //; 26// TFunction (global functions) //; 27// TClass (classes) //; 28// TBaseClass (base classes) //; 29// TDataMember (class datamembers) //; 30// TMethod (class methods) //; 31// TMethodArg (method arguments) //; 32// //; 33// All the above classes implement the TDictionary abstract interface //; 34// (note: the indentation shows aggregation not inheritance). //; 35// The ROOT dictionary system provides a very extensive RTTI //; 36// environment that facilitates a.o. object inspectors, object I/O, //; 37// ROOT Trees, etc. Most of the type information is provided by the //; 38// CINT C++ interpreter. //; 39// //; 40// TMethodCall (method call environment) //; 41// //; 42//////////////////////////////////////////////////////////////////////////; 43 ; 44#include ""TNamed.h""; 45 ; 46#include ""ESTLType.h""; 47 ; 48// The following are opaque type and are never really declared; 49// The specific implementation of TInterpreter will cast the; 50// value of pointer to this types to the correct type (possibly; 51// distinct from these); 52class CallFunc_t;; 53class ClassInfo_t;; 54class BaseClassInf",MatchSource.WIKI,doc/master/TDictionary_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDictionary_8h_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:4629,Availability,redundant,redundant,4629," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:12654,Availability,error,error,12654,"changed appropriately; 367 // by a cd() or needs to be set to zero.; 368 if (gFile == this) {; 369 gFile = nullptr;; 370 }; 371 ; 372 TDirectory::CleanTargets();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Make a clone of an object using the Streamer facility.; 377///; 378/// If the object derives from TNamed, this function is called; 379/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:15540,Availability,error,error,15540,"/////////////////; 443/// Scan the memory lists of all files for an object with name; 444 ; 445TObject *TDirectoryFile::FindObjectAnyFile(const char *name) const; 446{; 447 TFile *f;; 448 R__LOCKGUARD(gROOTMutex);; 449 TIter next(gROOT->GetListOfFiles());; 450 while ((f = (TFile*)next())) {; 451 TObject *obj = f->GetList()->FindObject(name);; 452 if (obj) return obj;; 453 }; 454 return nullptr;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Find a directory named ""apath"".; 459///; 460/// It apath is null or empty, returns ""this"" directory.; 461/// Otherwise use the name ""apath"" to find a directory.; 462/// The absolute path syntax is:; 463///; 464/// file.root:/dir1/dir2; 465///; 466/// where file.root is the file and /dir1/dir2 the desired subdirectory; 467/// in the file. Relative syntax is relative to ""this"" directory. E.g:; 468/// ../aa.; 469/// Returns 0 in case path does not exist.; 470/// If printError is true, use Error with 'funcname' to issue an error message.; 471 ; 472TDirectory *TDirectoryFile::GetDirectory(const char *apath,; 473 Bool_t printError, const char *funcname); 474{; 475 Int_t nch = 0;; 476 if (apath) nch = strlen(apath);; 477 if (!nch) {; 478 return this;; 479 }; 480 ; 481 if (funcname==0 || strlen(funcname)==0) funcname = ""GetDirectory"";; 482 ; 483 TDirectory *result = this;; 484 ; 485 char *path = new char[nch+1]; path[0] = 0;; 486 if (nch) strlcpy(path,apath,nch+1);; 487 char *s = (char*)strchr(path, ':');; 488 if (s) {; 489 *s = '\0';; 490 R__LOCKGUARD(gROOTMutex);; 491 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 492 // Check if this is a duplicate (2nd opening) on this file and prefer; 493 // this file.; 494 if (GetFile()) {; 495 auto url = GetFile()->GetEndpointUrl();; 496 if (f && 0 == url->Compare(f->GetFile()->GetEndpointUrl())) {; 497 result = GetDirectory(s+1,printError,funcname);; 498 delete [] path;; 499 return result;; 500 }; 501 }; 502 if (",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:35593,Availability,error,error,35593," 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; 1041/// ~~~{.cpp}; 1042/// auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; 1043/// if (objPtr) { ... we found what we are looking for ... }; 1044/// ~~~; 1045 ; 1046void *TDirectoryFile::GetObjectChecked(const char *namecycle, const TClass* expectedClass); 1047{; 1048 ; 1049 // If the name is invalid, issue an error message and return a nullptr; 1050 if (!namecycle || '\0' == namecycle[0]) {; 1051 Error(""GetObjectChecked"", ""The provided key name is invalid."");; 1052 return nullptr;; 1053 }; 1054 ; 1055 Short_t cycle;; 1056 char name[kMaxLen];; 1057 ; 1058 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 1059 Int_t nch = strlen(name);; 1060 for (Int_t i = nch-1; i > 0; i--) {; 1061 if (name[i] == '/') {; 1062 name[i] = 0;; 1063 TDirectory* dirToSearch=GetDirectory(name);; 1064 const char *subnamecycle = namecycle + i + 1;; 1065 name[i] = '/';; 1066 if (dirToSearch) {; 1067 return dirToSearch->GetObjectChecked(subnamecycle, expectedClass);; 1068 } else {; 1069 return nullptr;; 1070 }; 1071 }; 1072 }; 1073 const char *namobj = name;; 1074 ; 1075//*-*---------------------Case of Object in memory---------------------; 1076// ========================; 1077 if (expectedClass==0 || expectedClass->IsTObject()) {; 1078 TObject *objcur = fList ? fList->FindObject(namobj) : nullptr;; 1079",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:41975,Availability,error,error,41975," if (!reg.IsNull() && s.Index(re) == kNPOS); 1216 continue;; 1217 bool first = (lnk->Prev() == nullptr) || (s != lnk->Prev()->GetObject()->GetName());; 1218 bool hasbackup = (lnk->Next() != nullptr) && (s == lnk->Next()->GetObject()->GetName());; 1219 if (first); 1220 if (hasbackup); 1221 key->ls(true);; 1222 else; 1223 key->ls();; 1224 else; 1225 key->ls(false);; 1226 }; 1227 }; 1228 TROOT::DecreaseDirLevel();; 1229}; 1230 ; 1231////////////////////////////////////////////////////////////////////////////////; 1232/// Interface to TFile::Open; 1233 ; 1234TFile *TDirectoryFile::OpenFile(const char *name, Option_t *option,const char *ftitle, Int_t compress, Int_t netopt); 1235{; 1236 return TFile::Open(name,option,ftitle,compress,netopt);; 1237 ; 1238}; 1239 ; 1240////////////////////////////////////////////////////////////////////////////////; 1241/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1242///; 1243/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1244/// name already exists.; 1245/// returnExistingDirectory returns a pointer to an already existing sub-directory instead of 0.; 1246/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1247/// the hierarchy (in the above example, the returned TDirectory * always points; 1248/// to ""a"").; 1249 ; 1250TDirectory *TDirectoryFile::mkdir(const char *name, const char *title, Bool_t returnExistingDirectory); 1251{; 1252 if (!name || !title || !name[0]) return nullptr;; 1253 if (!title[0]) title = name;; 1254 if (GetKey(name)) {; 1255 if (returnExistingDirectory); 1256 return (TDirectoryFile*) GetDirectory(name);; 1257 else {; 1258 Error(""mkdir"",""An object with name %s exists already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(work",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:47564,Availability,failure,failure,47564,"1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buffer);; 1408 frombuf(buffer, &fNbytesKeys);; 1409 frombuf(buffer, &fNbytesName);; 1410 if (versiondir > 1000) {; 1411 frombuf(buffer, &fSeekDir);; 1412 frombuf(buffer, &fSeekParent);; 1413 frombuf(buffer, &fSeekKeys);; 1414 } else {; 1415 Int_t sdir,sparent,skeys;; 1416 frombuf(buffer, &sdir); fSeekDir = (Long64_t)sdir;; 1417 frombuf(buffer, &sparent); fSeekParent = (Long64_t)sparent;; 1418 frombuf(buffer, &skeys); fSeekKeys = (Long64_t)skeys;; 1419 }; 1420 delete []",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:52506,Availability,mask,mask,52506," content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;*"");; 1540 ; 1541void TDirectoryFile::rmdir(const char *name); 1542{; 1543 if (!name || (*name==0)) return;; 1544 ; 1545 TString mask(name);; 1546 mask += "";*"";; 1547 Delete(mask);; 1548}; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Save recursively all directory keys and headers; 1552 ; 1553void TDirectoryFile::Save(); 1554{; 1555 TDirectory::TContext ctxt(this);; 1556 ; 1557 SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:52524,Availability,mask,mask,52524," content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;*"");; 1540 ; 1541void TDirectoryFile::rmdir(const char *name); 1542{; 1543 if (!name || (*name==0)) return;; 1544 ; 1545 TString mask(name);; 1546 mask += "";*"";; 1547 Delete(mask);; 1548}; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Save recursively all directory keys and headers; 1552 ; 1553void TDirectoryFile::Save(); 1554{; 1555 TDirectory::TContext ctxt(this);; 1556 ; 1557 SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:52551,Availability,mask,mask,52551," content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;*"");; 1540 ; 1541void TDirectoryFile::rmdir(const char *name); 1542{; 1543 if (!name || (*name==0)) return;; 1544 ; 1545 TString mask(name);; 1546 mask += "";*"";; 1547 Delete(mask);; 1548}; 1549 ; 1550////////////////////////////////////////////////////////////////////////////////; 1551/// Save recursively all directory keys and headers; 1552 ; 1553void TDirectoryFile::Save(); 1554{; 1555 TDirectory::TContext ctxt(this);; 1556 ; 1557 SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:66291,Availability,error,error,66291,"tainer with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1919 return 0;; 1920 }; 1921 ; 1922 if (!fFile->IsWritable()) {; 1923 if (!fFile->TestBit(TFile::kWriteError)) {; 1924 // Do not print the error if the file already had a SysError.; 1925 Error(""WriteTObject"",""Directory %s is not writable"", fFile->GetName());; 1926 }; 1927 return 0;; 1928 }; 1929 ; 1930 if (!obj) return 0;; 1931 ; 1932 TString opt = option;; 1933 opt.ToLower();; 1934 ; 1935 TKey *key=0, *oldkey=0;; 1936 Int_t bsize = GetBufferSize();; 1937 if (bufsize > 0) bsize = bufsize;; 1938 ; 1939 const char *oname;; 1940 if (name && *name); 1941 oname = name;; 1942 else; 1943 oname = obj->GetName();; 1944 ; 1945 // Remove trailing blanks in object name; 1946 Int_t nch = strlen(oname);; 1947 char *newName = nullptr;; 1948 if (nch && oname[nch-1] == ' ') {; 1949 newName = new char[nch+1];; 1950 strlcpy(newName,oname,nch+1);; 1951 for (Int_t i=0;i<nch;i++) {; 1952 if (newName[nch-i-1] != ' ') break;; 1953 newName[nch-i-1] = 0;; 1954 }; 1955 oname = newName;; 1956 }; 1957 ; 1958 if (opt.Contains(""overwrite"")) {; 1959 //One must use GetKey. FindObject would retur",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:70731,Availability,error,error,70731," return 0;; 2032 } else {; 2033 cl = info->GetClass();; 2034 }; 2035 }; 2036 return WriteObjectAny(obj,cl,name,option,bufsize);; 2037}; 2038 ; 2039////////////////////////////////////////////////////////////////////////////////; 2040/// Write object of class with dictionary cl in this directory.; 2041///; 2042/// obj may not derive from TObject; 2043/// To get the TClass* cl pointer, one can use; 2044///; 2045/// TClass *cl = TClass::GetClass(""classname"");; 2046///; 2047/// An alternative is to call the function WriteObjectAny above.; 2048/// see TDirectoryFile::WriteTObject for comments; 2049 ; 2050Int_t TDirectoryFile::WriteObjectAny(const void *obj, const TClass *cl, const char *name, Option_t *option, Int_t bufsize); 2051{; 2052 TDirectory::TContext ctxt(this);; 2053 ; 2054 if (!fFile) return 0;; 2055 ; 2056 if (!cl) {; 2057 Error(""WriteObject"",""Unknown type for %s, it can not be written."",name);; 2058 return 0;; 2059 }; 2060 ; 2061 if (!fFile->IsWritable()) {; 2062 if (!fFile->TestBit(TFile::kWriteError)) {; 2063 // Do not print the error if the file already had a SysError.; 2064 Error(""WriteObject"",""File %s is not writable"", fFile->GetName());; 2065 }; 2066 return 0;; 2067 }; 2068 ; 2069 if (!obj) return 0;; 2070 ; 2071 const char *className = cl->GetName();; 2072 const char *oname;; 2073 if (name && *name); 2074 oname = name;; 2075 else; 2076 oname = className;; 2077 ; 2078 if (cl && cl->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(cl->GetCollectionProxy())) {; 2079 Error(""WriteObjectAny"",; 2080 ""The class requested (%s) for the key name \""%s\""""; 2081 "" is an instance of an stl collection and does not have a compiled CollectionProxy.""; 2082 "" Please generate the dictionary for this collection (%s). No data will be written."",; 2083 className, oname, className);; 2084 return 0;; 2085 }; 2086 ; 2087 TKey *key, *oldkey = nullptr;; 2088 Int_t bsize = GetBufferSize();; 2089 if (bufsize > 0) bsize = bufsize;; 2090 ; 2091 TString opt = option;; 209",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:76867,Availability,mask,maskDefinition,76867,ion RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TBrowser.h; TBufferFile.h; TBufferJSON.h; TClassTable.h; TClass.h; kIterBackwardconst Bool_t kIterBackwardDefinition TCollection.h:43; kMaxLenconst Int_t kMaxLenDefinition TDirectoryFile.cxx:52; kIsBigFileconst UInt_t kIsBigFileDefinition TDirectoryFile.cxx:51; TDirectoryFile.h; kMaxLenconst Int_t kMaxLenDefinition TDirectory.cxx:34; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEmulatedCollectionProxy.h; TError.h; TFile.h; gFile#define gFileDefinition TFile.h:347; TFree.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Poin,MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:102955,Availability,error,error,102955,"Object.cxx:213; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:103091,Availability,error,error,103091,"n TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:27",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:46803,Deployability,update,updates,46803,"ject(key->GetName());; 1349 if (thing) { delete thing; }; 1350 key->ReadObj();; 1351 }; 1352}; 1353 ; 1354////////////////////////////////////////////////////////////////////////////////; 1355/// Read the linked list of keys.; 1356///; 1357/// Every directory has a linked list (fKeys). This linked list has been; 1358/// written on the file via WriteKeys as a single data record.; 1359///; 1360/// It is interesting to call this function in the following situation.; 1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buff",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:47253,Deployability,update,updated,47253,"1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buffer);; 1408 frombuf(buffer, &fNbytesKeys);; 1409 frombuf(buffer, &fNbytesName);; 1410 if (versiondir > 1000) {; 1411 frombuf(buffer, &fSeekDir);; 1412 frombuf(buffer, &fSeekParent);; 1413 frombuf(buffer, &fSeekKeys);; 1414 } else {; 1415 Int_t sdir,sparent,skeys;; 1416 frombuf(buffer, &sdir); fSeekDir = (Long64_t)sdir;; 1417 frombuf(buffer, &sparent); fSeekParent = (Long64_t)sparent;; 1418 frombuf(buffer, &skeys); fSeekKeys = (Long64_t)skeys;; 1419 }; 1420 delete []",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:51099,Deployability,update,updated,51099,"///////////////////////////////////////////////////////////////////////; 1488/// Reset the TDirectory after its content has been merged into another; 1489/// Directory.; 1490///; 1491/// This returns the TDirectoryFile object back to its state; 1492/// before any data has been written to the file.; 1493/// The object in the in-memory list are assumed to also have been reset.; 1494 ; 1495void TDirectoryFile::ResetAfterMerge(TFileMergeInfo *info); 1496{; 1497 // There is nothing to reset in the base class (TDirectory) since; 1498 // we do want to key the list of in-memory object as is.; 1499 fModified = kFALSE;; 1500 // Does not change: fWritable; 1501 fDatimeC.Set();; 1502 fDatimeM.Set();; 1503 fNbytesKeys = 0; // updated when the keys are written; 1504 fNbytesName = 0; // updated by Init; 1505 // Does not change (user customization): fBufferSize;; 1506 fSeekDir = 0; // updated by Init; 1507 fSeekParent = 0; // updated by Init; 1508 fSeekKeys = 0; // updated by Init; 1509 // Does not change: fFile; 1510 TKey *key = fKeys ? (TKey*)fKeys->FindObject(fName) : nullptr;; 1511 TClass *cl = IsA();; 1512 if (key) {; 1513 cl = TClass::GetClass(key->GetClassName());; 1514 }; 1515 // NOTE: We should check that the content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:51159,Deployability,update,updated,51159,"///////////////////////////////////////////////////////////////////////; 1488/// Reset the TDirectory after its content has been merged into another; 1489/// Directory.; 1490///; 1491/// This returns the TDirectoryFile object back to its state; 1492/// before any data has been written to the file.; 1493/// The object in the in-memory list are assumed to also have been reset.; 1494 ; 1495void TDirectoryFile::ResetAfterMerge(TFileMergeInfo *info); 1496{; 1497 // There is nothing to reset in the base class (TDirectory) since; 1498 // we do want to key the list of in-memory object as is.; 1499 fModified = kFALSE;; 1500 // Does not change: fWritable; 1501 fDatimeC.Set();; 1502 fDatimeM.Set();; 1503 fNbytesKeys = 0; // updated when the keys are written; 1504 fNbytesName = 0; // updated by Init; 1505 // Does not change (user customization): fBufferSize;; 1506 fSeekDir = 0; // updated by Init; 1507 fSeekParent = 0; // updated by Init; 1508 fSeekKeys = 0; // updated by Init; 1509 // Does not change: fFile; 1510 TKey *key = fKeys ? (TKey*)fKeys->FindObject(fName) : nullptr;; 1511 TClass *cl = IsA();; 1512 if (key) {; 1513 cl = TClass::GetClass(key->GetClassName());; 1514 }; 1515 // NOTE: We should check that the content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:51258,Deployability,update,updated,51258,"///////////////////////////////////////////////////////////////////////; 1488/// Reset the TDirectory after its content has been merged into another; 1489/// Directory.; 1490///; 1491/// This returns the TDirectoryFile object back to its state; 1492/// before any data has been written to the file.; 1493/// The object in the in-memory list are assumed to also have been reset.; 1494 ; 1495void TDirectoryFile::ResetAfterMerge(TFileMergeInfo *info); 1496{; 1497 // There is nothing to reset in the base class (TDirectory) since; 1498 // we do want to key the list of in-memory object as is.; 1499 fModified = kFALSE;; 1500 // Does not change: fWritable; 1501 fDatimeC.Set();; 1502 fDatimeM.Set();; 1503 fNbytesKeys = 0; // updated when the keys are written; 1504 fNbytesName = 0; // updated by Init; 1505 // Does not change (user customization): fBufferSize;; 1506 fSeekDir = 0; // updated by Init; 1507 fSeekParent = 0; // updated by Init; 1508 fSeekKeys = 0; // updated by Init; 1509 // Does not change: fFile; 1510 TKey *key = fKeys ? (TKey*)fKeys->FindObject(fName) : nullptr;; 1511 TClass *cl = IsA();; 1512 if (key) {; 1513 cl = TClass::GetClass(key->GetClassName());; 1514 }; 1515 // NOTE: We should check that the content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:51300,Deployability,update,updated,51300,"///////////////////////////////////////////////////////////////////////; 1488/// Reset the TDirectory after its content has been merged into another; 1489/// Directory.; 1490///; 1491/// This returns the TDirectoryFile object back to its state; 1492/// before any data has been written to the file.; 1493/// The object in the in-memory list are assumed to also have been reset.; 1494 ; 1495void TDirectoryFile::ResetAfterMerge(TFileMergeInfo *info); 1496{; 1497 // There is nothing to reset in the base class (TDirectory) since; 1498 // we do want to key the list of in-memory object as is.; 1499 fModified = kFALSE;; 1500 // Does not change: fWritable; 1501 fDatimeC.Set();; 1502 fDatimeM.Set();; 1503 fNbytesKeys = 0; // updated when the keys are written; 1504 fNbytesName = 0; // updated by Init; 1505 // Does not change (user customization): fBufferSize;; 1506 fSeekDir = 0; // updated by Init; 1507 fSeekParent = 0; // updated by Init; 1508 fSeekKeys = 0; // updated by Init; 1509 // Does not change: fFile; 1510 TKey *key = fKeys ? (TKey*)fKeys->FindObject(fName) : nullptr;; 1511 TClass *cl = IsA();; 1512 if (key) {; 1513 cl = TClass::GetClass(key->GetClassName());; 1514 }; 1515 // NOTE: We should check that the content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:51340,Deployability,update,updated,51340,"///////////////////////////////////////////////////////////////////////; 1488/// Reset the TDirectory after its content has been merged into another; 1489/// Directory.; 1490///; 1491/// This returns the TDirectoryFile object back to its state; 1492/// before any data has been written to the file.; 1493/// The object in the in-memory list are assumed to also have been reset.; 1494 ; 1495void TDirectoryFile::ResetAfterMerge(TFileMergeInfo *info); 1496{; 1497 // There is nothing to reset in the base class (TDirectory) since; 1498 // we do want to key the list of in-memory object as is.; 1499 fModified = kFALSE;; 1500 // Does not change: fWritable; 1501 fDatimeC.Set();; 1502 fDatimeM.Set();; 1503 fNbytesKeys = 0; // updated when the keys are written; 1504 fNbytesName = 0; // updated by Init; 1505 // Does not change (user customization): fBufferSize;; 1506 fSeekDir = 0; // updated by Init; 1507 fSeekParent = 0; // updated by Init; 1508 fSeekKeys = 0; // updated by Init; 1509 // Does not change: fFile; 1510 TKey *key = fKeys ? (TKey*)fKeys->FindObject(fName) : nullptr;; 1511 TClass *cl = IsA();; 1512 if (key) {; 1513 cl = TClass::GetClass(key->GetClassName());; 1514 }; 1515 // NOTE: We should check that the content is really mergeable and in; 1516 // the in-mmeory list, before deleting the keys.; 1517 if (fKeys) {; 1518 fKeys->Delete(""slow"");; 1519 }; 1520 ; 1521 InitDirectoryFile(cl);; 1522 ; 1523 // Do the same with the sub-directories.; 1524 TIter next(GetList());; 1525 TObject *idcur;; 1526 while ((idcur = next())) {; 1527 if (idcur->IsA() == TDirectoryFile::Class()) {; 1528 ((TDirectoryFile*)idcur)->ResetAfterMerge(info);; 1529 }; 1530 }; 1531 ; 1532}; 1533 ; 1534////////////////////////////////////////////////////////////////////////////////; 1535/// Removes subdirectory from the directory; 1536///; 1537/// When directory is deleted, all keys in all subdirectories will be; 1538/// read first and deleted from file (if exists); 1539/// Equivalent call is Delete(""name;",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:54888,Deployability,update,update,54888,"d and saved in the text file. Such file can be used in; 1585/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1586/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1587 ; 1588Int_t TDirectoryFile::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1589{; 1590 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1591 ; 1592 if (!obj) return 0;; 1593 TString fname, opt = option;; 1594 if (filename && *filename); 1595 fname = filename;; 1596 else; 1597 fname.Form(""%s.root"", obj->GetName());; 1598 opt.ToLower();; 1599 ; 1600 Int_t nbytes = 0;; 1601 if (fname.Index("".json"") > 0) {; 1602 nbytes = TBufferJSON::ExportToFile(fname, obj, option);; 1603 } else {; 1604 TContext ctxt; // The TFile::Open will change the current directory.; 1605 auto *local = TFile::Open(fname.Data(), opt.Contains(""a"") ? ""update"" : ""recreate"");; 1606 if (!local) return 0;; 1607 nbytes = obj->Write();; 1608 delete local;; 1609 }; 1610 if (!opt.Contains(""q"") && !gSystem->AccessPathName(fname.Data())); 1611 obj->Info(""SaveAs"", ""ROOT file %s has been created"", fname.Data());; 1612 return nbytes;; 1613}; 1614 ; 1615////////////////////////////////////////////////////////////////////////////////; 1616/// Save Directory keys and header; 1617///; 1618/// If the directory has been modified (fModified set), write the keys; 1619/// and the directory header. This function assumes the cd is correctly set.; 1620///; 1621/// It is recommended to use this function in the following situation:; 1622/// Assume a process1 using a directory in Update mode; 1623/// - New objects or modified objects have been written to the directory.; 1624/// - You do not want to close the file.; 1625/// - You want your changes be visible from another process2 already connected; 1626/// to this directory in read mode.; 1627/// - Call this function.; 1628/// - In process2, use TDirectoryFile::R",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:18948,Energy Efficiency,allocate,allocated,18948,"if (mom); 545 result = mom->GetDirectory(slash+1,printError,funcname);; 546 delete [] path; return result;; 547 }; 548 GetObject(subdir,obj);; 549 if (!obj) {; 550 if (printError) Error(funcname,""Unknown directory %s"", subdir.Data());; 551 delete [] path; return nullptr;; 552 }; 553 ; 554 result = ((TDirectory*)obj)->GetDirectory(slash+1,printError,funcname);; 555 delete [] path; return result;; 556}; 557 ; 558////////////////////////////////////////////////////////////////////////////////; 559/// Delete all objects from memory and directory structure itself.; 560 ; 561void TDirectoryFile::Close(Option_t *option); 562{; 563 if (!fList || !fSeekDir) {; 564 return;; 565 }; 566 ; 567 // Save the directory key list and header; 568 Save();; 569 ; 570 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 571 ; 572 if (!nodelete) {; 573 Bool_t fast = kTRUE;; 574 TObjLink *lnk = fList->FirstLink();; 575 while (lnk) {; 576 if (lnk->GetObject()->IsA() == TDirectoryFile::Class()) {fast = kFALSE;break;}; 577 lnk = lnk->Next();; 578 }; 579 // Delete objects from directory list, this in turn, recursively closes all; 580 // sub-directories (that were allocated on the heap); 581 // if this dir contains subdirs, we must use the slow option for Delete!; 582 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 583 // with a large number of objects (eg >10^5) would take for ever.; 584 {; 585 if (fast) fList->Delete();; 586 else fList->Delete(""slow"");; 587 }; 588 }; 589 ; 590 // Delete keys from key list (but don't delete the list header); 591 if (fKeys) {; 592 fKeys->Delete(""slow"");; 593 }; 594 ; 595 TDirectoryFile::CleanTargets();; 596}; 597 ; 598////////////////////////////////////////////////////////////////////////////////; 599/// Delete Objects or/and keys in a directory; 600///; 601/// Properties of the namecycle string:; 602/// - namecycle has the format name;cycle; 603/// - namecycle = """" is same as namecycle =""T*""; 604/// - ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:43718,Energy Efficiency,reduce,reduce,43718,"already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(workname.Data(), tmpdir);; 1267 if (!tmpdir) {; 1268 tmpdir = (TDirectoryFile*)mkdir(workname.Data(),title);; 1269 if (!tmpdir) return nullptr;; 1270 }; 1271 if (!newdir) newdir = tmpdir;; 1272 tmpdir->mkdir(slash+1);; 1273 return newdir;; 1274 }; 1275 ; 1276 TDirectory::TContext ctxt(this);; 1277 ; 1278 newdir = new TDirectoryFile(name, title, """", this);; 1279 ; 1280 return newdir;; 1281}; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Purge lowest key cycles in a directory.; 1285///; 1286/// By default, only the highest cycle of a key is kept. Keys for which; 1287/// the ""KEEP"" flag has been set are not removed. See TKey::Keep().; 1288/// NOTE: This does not reduce the size of a TFile--; 1289/// the space is simply freed up to be overwritten.; 1290 ; 1291void TDirectoryFile::Purge(Short_t); 1292{; 1293 if (!IsWritable()) return;; 1294 ; 1295 TDirectory::TContext ctxt(this);; 1296 ; 1297 TKey *key;; 1298 TIter prev(GetListOfKeys(), kIterBackward);; 1299 ; 1300 while ((key = (TKey*)prev())) { // reverse loop on keys; 1301 TKey *keyprev = (TKey*)GetListOfKeys()->Before(key);; 1302 if (!keyprev) break;; 1303 if (key->GetKeep() == 0) {; 1304 if (strcmp(key->GetName(), keyprev->GetName()) == 0) {; 1305 key->Delete(); // Remove from the file.; 1306 delete key; // Remove from memory.; 1307 }; 1308 }; 1309 }; 1310 TFile *f = GetFile();; 1311 if (fModified && f) {; 1312 WriteKeys(); // Write new keys structure; 1313 WriteDirHeader(); // Write new directory header; 1314 f->WriteFree(); // Write new free segments list; 1315 f->WriteHeader(); // Write new file header; 1316 }; 1317}; 1318 ; 1319////////////////////////////////////////////////////////////////////////////////; 1320/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:46729,Energy Efficiency,efficient,efficient,46729,"ject(key->GetName());; 1349 if (thing) { delete thing; }; 1350 key->ReadObj();; 1351 }; 1352}; 1353 ; 1354////////////////////////////////////////////////////////////////////////////////; 1355/// Read the linked list of keys.; 1356///; 1357/// Every directory has a linked list (fKeys). This linked list has been; 1358/// written on the file via WriteKeys as a single data record.; 1359///; 1360/// It is interesting to call this function in the following situation.; 1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buff",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:80830,Energy Efficiency,allocate,allocated,80830,"; TBufferIO::MapObjectvoid MapObject(const TObject *obj, UInt_t offset=1) overrideAdd object to the fMap container.Definition TBufferIO.cxx:163; TBufferIO::ResetMapvoid ResetMap() overrideDelete existing fMap and reset map counter.Definition TBufferIO.cxx:288; TBufferJSON::ExportToFilestatic Int_t ExportToFile(const char *filename, const TObject *obj, const char *option=nullptr)Convert object into JSON and store in text file Returns size of the produce file Used in TObject::Sav...Definition TBufferJSON.cxx:751; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() c",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:3349,Integrability,interface,interface,3349,"///////////////////////////////////////////////; 70/// Create a new TDirectoryFile; 71///; 72/// A new directory with a name and a title is created in the current directory.; 73/// The directory header information is immediately saved on the file; 74/// A new key is added in the parent directory.; 75/// When this constructor is called from a class directly derived; 76/// from TDirectoryFile, the third argument, classname, MUST be specified.; 77/// In this case, classname must be the name of the derived class.; 78///; 79/// Note that the directory name cannot contain slashes.; 80 ; 81TDirectoryFile::TDirectoryFile(const char *name, const char *title, Option_t *classname, TDirectory* initMotherDir); 82{; 83 // We must not publish this objects to the list of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nul",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:15546,Integrability,message,message,15546,"/////////////////; 443/// Scan the memory lists of all files for an object with name; 444 ; 445TObject *TDirectoryFile::FindObjectAnyFile(const char *name) const; 446{; 447 TFile *f;; 448 R__LOCKGUARD(gROOTMutex);; 449 TIter next(gROOT->GetListOfFiles());; 450 while ((f = (TFile*)next())) {; 451 TObject *obj = f->GetList()->FindObject(name);; 452 if (obj) return obj;; 453 }; 454 return nullptr;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Find a directory named ""apath"".; 459///; 460/// It apath is null or empty, returns ""this"" directory.; 461/// Otherwise use the name ""apath"" to find a directory.; 462/// The absolute path syntax is:; 463///; 464/// file.root:/dir1/dir2; 465///; 466/// where file.root is the file and /dir1/dir2 the desired subdirectory; 467/// in the file. Relative syntax is relative to ""this"" directory. E.g:; 468/// ../aa.; 469/// Returns 0 in case path does not exist.; 470/// If printError is true, use Error with 'funcname' to issue an error message.; 471 ; 472TDirectory *TDirectoryFile::GetDirectory(const char *apath,; 473 Bool_t printError, const char *funcname); 474{; 475 Int_t nch = 0;; 476 if (apath) nch = strlen(apath);; 477 if (!nch) {; 478 return this;; 479 }; 480 ; 481 if (funcname==0 || strlen(funcname)==0) funcname = ""GetDirectory"";; 482 ; 483 TDirectory *result = this;; 484 ; 485 char *path = new char[nch+1]; path[0] = 0;; 486 if (nch) strlcpy(path,apath,nch+1);; 487 char *s = (char*)strchr(path, ':');; 488 if (s) {; 489 *s = '\0';; 490 R__LOCKGUARD(gROOTMutex);; 491 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 492 // Check if this is a duplicate (2nd opening) on this file and prefer; 493 // this file.; 494 if (GetFile()) {; 495 auto url = GetFile()->GetEndpointUrl();; 496 if (f && 0 == url->Compare(f->GetFile()->GetEndpointUrl())) {; 497 result = GetDirectory(s+1,printError,funcname);; 498 delete [] path;; 499 return result;; 500 }; 501 }; 502 if (",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:35599,Integrability,message,message,35599," 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; 1041/// ~~~{.cpp}; 1042/// auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; 1043/// if (objPtr) { ... we found what we are looking for ... }; 1044/// ~~~; 1045 ; 1046void *TDirectoryFile::GetObjectChecked(const char *namecycle, const TClass* expectedClass); 1047{; 1048 ; 1049 // If the name is invalid, issue an error message and return a nullptr; 1050 if (!namecycle || '\0' == namecycle[0]) {; 1051 Error(""GetObjectChecked"", ""The provided key name is invalid."");; 1052 return nullptr;; 1053 }; 1054 ; 1055 Short_t cycle;; 1056 char name[kMaxLen];; 1057 ; 1058 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 1059 Int_t nch = strlen(name);; 1060 for (Int_t i = nch-1; i > 0; i--) {; 1061 if (name[i] == '/') {; 1062 name[i] = 0;; 1063 TDirectory* dirToSearch=GetDirectory(name);; 1064 const char *subnamecycle = namecycle + i + 1;; 1065 name[i] = '/';; 1066 if (dirToSearch) {; 1067 return dirToSearch->GetObjectChecked(subnamecycle, expectedClass);; 1068 } else {; 1069 return nullptr;; 1070 }; 1071 }; 1072 }; 1073 const char *namobj = name;; 1074 ; 1075//*-*---------------------Case of Object in memory---------------------; 1076// ========================; 1077 if (expectedClass==0 || expectedClass->IsTObject()) {; 1078 TObject *objcur = fList ? fList->FindObject(namobj) : nullptr;; 1079",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:53774,Integrability,message,message,53774,"ectory::TContext ctxt(this);; 1556 ; 1557 SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/// to the existing ROOT file.; 1580/// If the operation is successful, it returns the number of bytes written to the file; 1581/// otherwise it returns 0.; 1582/// By default a message is printed. Use option ""q"" to not print the message.; 1583/// If filename contains "".json"" extension, JSON representation of the object; 1584/// will be created and saved in the text file. Such file can be used in; 1585/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1586/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1587 ; 1588Int_t TDirectoryFile::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1589{; 1590 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1591 ; 1592 if (!obj) return 0;; 1593 TString fname, opt = option;; 1594 if (filename && *filename); 1595 fname = filename;; 1596 else; 1597 fname.Form(""%s.root"", obj->GetName());; 1598 opt.ToLower();; 1599 ; 1600 Int_t nbytes = 0;; 1601 if (fname.Index("".json"") > 0) {; 1602 nbytes = TBufferJSON::ExportToFile(fname, obj, option);; 1603 } else {; 1604 TContext ctxt; // Th",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:53826,Integrability,message,message,53826," SaveSelf();; 1558 ; 1559 // recursively save all sub-directories; 1560 if (fList && fList->FirstLink()) {; 1561 auto lnk = fList->FirstLink()->shared_from_this();; 1562 while (lnk) {; 1563 TObject *idcur = lnk->GetObject();; 1564 if (idcur && idcur->InheritsFrom(TDirectoryFile::Class())) {; 1565 TDirectoryFile *dir = (TDirectoryFile *)idcur;; 1566 dir->Save();; 1567 }; 1568 lnk = lnk->NextSP();; 1569 }; 1570 }; 1571}; 1572 ; 1573////////////////////////////////////////////////////////////////////////////////; 1574/// Save object in filename.; 1575///; 1576/// If filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1577/// The name of the key is the object name.; 1578/// By default new file will be created. Using option ""a"", one can append object; 1579/// to the existing ROOT file.; 1580/// If the operation is successful, it returns the number of bytes written to the file; 1581/// otherwise it returns 0.; 1582/// By default a message is printed. Use option ""q"" to not print the message.; 1583/// If filename contains "".json"" extension, JSON representation of the object; 1584/// will be created and saved in the text file. Such file can be used in; 1585/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1586/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1587 ; 1588Int_t TDirectoryFile::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1589{; 1590 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1591 ; 1592 if (!obj) return 0;; 1593 TString fname, opt = option;; 1594 if (filename && *filename); 1595 fname = filename;; 1596 else; 1597 fname.Form(""%s.root"", obj->GetName());; 1598 opt.ToLower();; 1599 ; 1600 Int_t nbytes = 0;; 1601 if (fname.Index("".json"") > 0) {; 1602 nbytes = TBufferJSON::ExportToFile(fname, obj, option);; 1603 } else {; 1604 TContext ctxt; // The TFile::Open will change the current dire",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:80973,Integrability,wrap,wrapper,80973,"apvoid ResetMap() overrideDelete existing fMap and reset map counter.Definition TBufferIO.cxx:288; TBufferJSON::ExportToFilestatic Int_t ExportToFile(const char *filename, const TObject *obj, const char *option=nullptr)Convert object into JSON and store in text file Returns size of the produce file Used in TObject::Sav...Definition TBufferJSON.cxx:751; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, B",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:102961,Integrability,message,message,102961,"Object.cxx:213; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:103097,Integrability,message,message,103097,"n TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:27",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:103692,Integrability,message,message,103692,"n TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStreamerElementDefinition TStreamerElement.h:32; TStreamerElement::GetOffsetInt_t GetOffset() constDefinition TStreamerElement.h:119; TStreamerElement::GetExecIDvirtual Int_t GetExecID() constReturns the TExec id for the EXEC instruction in the comment field of a TRef data member.Definition TStreamerElement.cxx:308; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStreamerInfo::GetElementsTObjArray * GetElements() const overrideDefinition TStreamerInfo.h:163; TStringBasic string class.Definiti",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:12880,Modifiability,inherit,inherit,12880,"changed appropriately; 367 // by a cd() or needs to be set to zero.; 368 if (gFile == this) {; 369 gFile = nullptr;; 370 }; 371 ; 372 TDirectory::CleanTargets();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Make a clone of an object using the Streamer facility.; 377///; 378/// If the object derives from TNamed, this function is called; 379/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:13111,Modifiability,inherit,inheritance,13111,"/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self reference; 413 {; 414 Bool_t isRef = obj->TestBit(kIsReferenced);; 415 ((TObject*)obj)->ResetBit(kIsReferenced);; 416 ; 417 ((TObject*)obj)->Streamer(buffer);; 418 ; 419 if (isRef) ((TObject*)obj)->SetBit(kIsReferenced);; 420 }; 421 ; 422 // read new object from buffer; 423 buffer.SetReadMode();; 424 buffer.ResetMap();; 425 buffer.SetBufferOffset(0);; 426 buffer.MapObject(newobj); //register obj i",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:30656,Modifiability,inherit,inherits,30656,"e format name;cycle; 892/// - name = * is illegal, cycle = * is illegal; 893/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 894///; 895/// Examples:; 896/// | %Pattern | Explanation |; 897/// |----------|-------------|; 898/// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; 899/// | foo;1 | get cycle 1 of foo on file |; 900///; 901/// The retrieved object should in principle derive from TObject.; 902/// If not, the function TDirectoryFile::Get<T> should be called.; 903/// However, this function will still work for a non-TObject, provided that; 904/// the calling application cast the return type to the correct type (which; 905/// is the actual type of the object).; 906///; 907/// ### The Get<T> Method; 908/// The method Get<T> offers better protection and avoids the need for any; 909/// cast:; 910/// ~~~{.cpp}; 911/// auto objPtr = directory->Get<MyClass>(""some object"");; 912/// if (objPtr) { ... the object exist and inherits from MyClass ... }; 913/// ~~~; 914///; 915/// ### Very important note about inheritance; 916/// In case the class of this object derives from TObject but not; 917/// as a first inheritance, one must use dynamic_cast<>().; 918///; 919/// #### Example 1 - Normal case:; 920///; 921/// class MyClass : public TObject, public AnotherClass; 922///; 923/// then on return, one can adopt a C style cast:; 924///; 925/// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; 926///; 927/// #### Example 2 - Special case:; 928///; 929/// class MyClass : public AnotherClass, public TObject; 930///; 931/// then on return, one must do:; 932///; 933/// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 934///; 935/// Of course, dynamic_cast<> can also be used in the example 1.; 936///; 937 ; 938TObject *TDirectoryFile::Get(const char *namecycle); 939{; 940 Short_t cycle;; 941 char name[kMaxLen];; 942 ; 943 DecodeNameCycle(namecycle, name, cycle, kMaxLen",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:30742,Modifiability,inherit,inheritance,30742,"ory object; 894///; 895/// Examples:; 896/// | %Pattern | Explanation |; 897/// |----------|-------------|; 898/// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; 899/// | foo;1 | get cycle 1 of foo on file |; 900///; 901/// The retrieved object should in principle derive from TObject.; 902/// If not, the function TDirectoryFile::Get<T> should be called.; 903/// However, this function will still work for a non-TObject, provided that; 904/// the calling application cast the return type to the correct type (which; 905/// is the actual type of the object).; 906///; 907/// ### The Get<T> Method; 908/// The method Get<T> offers better protection and avoids the need for any; 909/// cast:; 910/// ~~~{.cpp}; 911/// auto objPtr = directory->Get<MyClass>(""some object"");; 912/// if (objPtr) { ... the object exist and inherits from MyClass ... }; 913/// ~~~; 914///; 915/// ### Very important note about inheritance; 916/// In case the class of this object derives from TObject but not; 917/// as a first inheritance, one must use dynamic_cast<>().; 918///; 919/// #### Example 1 - Normal case:; 920///; 921/// class MyClass : public TObject, public AnotherClass; 922///; 923/// then on return, one can adopt a C style cast:; 924///; 925/// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; 926///; 927/// #### Example 2 - Special case:; 928///; 929/// class MyClass : public AnotherClass, public TObject; 930///; 931/// then on return, one must do:; 932///; 933/// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 934///; 935/// Of course, dynamic_cast<> can also be used in the example 1.; 936///; 937 ; 938TObject *TDirectoryFile::Get(const char *namecycle); 939{; 940 Short_t cycle;; 941 char name[kMaxLen];; 942 ; 943 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 944 Int_t nch = strlen(name);; 945 for (Int_t i = nch-1; i > 0; i--) {; 946 if (name[i] == '/') {; 947 name[i] = 0;; 948 TD",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:30843,Modifiability,inherit,inheritance,30843,"ory object; 894///; 895/// Examples:; 896/// | %Pattern | Explanation |; 897/// |----------|-------------|; 898/// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; 899/// | foo;1 | get cycle 1 of foo on file |; 900///; 901/// The retrieved object should in principle derive from TObject.; 902/// If not, the function TDirectoryFile::Get<T> should be called.; 903/// However, this function will still work for a non-TObject, provided that; 904/// the calling application cast the return type to the correct type (which; 905/// is the actual type of the object).; 906///; 907/// ### The Get<T> Method; 908/// The method Get<T> offers better protection and avoids the need for any; 909/// cast:; 910/// ~~~{.cpp}; 911/// auto objPtr = directory->Get<MyClass>(""some object"");; 912/// if (objPtr) { ... the object exist and inherits from MyClass ... }; 913/// ~~~; 914///; 915/// ### Very important note about inheritance; 916/// In case the class of this object derives from TObject but not; 917/// as a first inheritance, one must use dynamic_cast<>().; 918///; 919/// #### Example 1 - Normal case:; 920///; 921/// class MyClass : public TObject, public AnotherClass; 922///; 923/// then on return, one can adopt a C style cast:; 924///; 925/// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; 926///; 927/// #### Example 2 - Special case:; 928///; 929/// class MyClass : public AnotherClass, public TObject; 930///; 931/// then on return, one must do:; 932///; 933/// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 934///; 935/// Of course, dynamic_cast<> can also be used in the example 1.; 936///; 937 ; 938TObject *TDirectoryFile::Get(const char *namecycle); 939{; 940 Short_t cycle;; 941 char name[kMaxLen];; 942 ; 943 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 944 Int_t nch = strlen(name);; 945 for (Int_t i = nch-1; i > 0; i--) {; 946 if (name[i] == '/') {; 947 name[i] = 0;; 948 TD",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:35328,Modifiability,inherit,inheriting,35328,"021 return GetObjectChecked(namecycle,TClass::GetClass(classname));; 1022}; 1023 ; 1024 ; 1025////////////////////////////////////////////////////////////////////////////////; 1026/// Return pointer to object identified by namecycle if and only if the actual; 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; 1041/// ~~~{.cpp}; 1042/// auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; 1043/// if (objPtr) { ... we found what we are looking for ... }; 1044/// ~~~; 1045 ; 1046void *TDirectoryFile::GetObjectChecked(const char *namecycle, const TClass* expectedClass); 1047{; 1048 ; 1049 // If the name is invalid, issue an error message and return a nullptr; 1050 if (!namecycle || '\0' == namecycle[0]) {; 1051 Error(""GetObjectChecked"", ""The provided key name is invalid."");; 1052 return nullptr;; 1053 }; 1054 ; 1055 Short_t cycle;; 1056 char name[kMaxLen];; 1057 ; 1058 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 1059 Int_t nch = strlen(name);; 1060 for (Int_t i = nch-1; i > 0; i--) {; 1061 if (name[i] == '/') {; 1062 name[i] = 0;; 1063 TDirectory* dirToSearch=GetDirectory(name);; 1064 const char *subnamecycle = namecycle + i + 1;; 1065 name[i] = '/';; 1066 if (dirToSearch) {; 1067 return dirToSearch->GetObjectChecked(subnamecycle, expectedClass);; 1068 } else {; 1069 return nullptr;; 1070 }; 1071 }; 1072 }; 1073 const char *namobj ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:68923,Modifiability,inherit,inheritance,68923," = key->WriteFile(0);; 1981 if (fFile->TestBit(TFile::kWriteError)) {; 1982 if (bufsize) fFile->SetBufferSize(bufsize);; 1983 return 0;; 1984 }; 1985 if (oldkey) {; 1986 oldkey->Delete();; 1987 delete oldkey;; 1988 }; 1989 if (bufsize) fFile->SetBufferSize(bufsize);; 1990 ; 1991 return nbytes;; 1992}; 1993 ; 1994////////////////////////////////////////////////////////////////////////////////; 1995/// Write object from pointer of class classname in this directory.; 1996///; 1997/// obj may not derive from TObject. See TDirectoryFile::WriteTObject for comments; 1998///; 1999/// ## Very important note; 2000/// The value passed as 'obj' needs to be from a pointer to the type described by classname.; 2001/// For example:; 2002/// ~~~{.cpp}; 2003/// TopClass *top;; 2004/// BottomClass *bottom;; 2005/// top = bottom;; 2006/// ~~~; 2007/// you can do:; 2008/// ~~~{.cpp}; 2009/// directory->WriteObjectAny(top,""top"",""name of object"");; 2010/// directory->WriteObjectAny(bottom,""bottom"",""name of object"");; 2011/// ~~~; 2012/// <b>BUT YOU CAN NOT DO</b> the following since it will fail with multiple inheritance:; 2013/// ~~~{.cpp}; 2014/// directory->WriteObjectAny(top,""bottom"",""name of object"");; 2015/// ~~~; 2016/// We <b>STRONGLY</b> recommend to use; 2017/// ~~~{.cpp}; 2018/// TopClass *top = ....;; 2019/// directory->WriteObject(top,""name of object""); 2020/// ~~~; 2021/// See also remarks in TDirectoryFile::WriteTObject; 2022 ; 2023Int_t TDirectoryFile::WriteObjectAny(const void *obj, const char *classname, const char *name, Option_t *option, Int_t bufsize); 2024{; 2025 TClass *cl = TClass::GetClass(classname);; 2026 if (!cl) {; 2027 TObject *info_obj = *(TObject**)obj;; 2028 TVirtualStreamerInfo *info = dynamic_cast<TVirtualStreamerInfo*>(info_obj);; 2029 if (!info) {; 2030 Error(""WriteObjectAny"",""Unknown class: %s"",classname);; 2031 return 0;; 2032 } else {; 2033 cl = info->GetClass();; 2034 }; 2035 }; 2036 return WriteObjectAny(obj,cl,name,option,bufsize);; 2037}; 2038 ; ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:81277,Modifiability,inherit,inherits,81277,"Used in TObject::Sav...Definition TBufferJSON.cxx:751; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Def",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:102807,Modifiability,inherit,inherits,102807,"ffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h:106; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t Incr",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:34709,Performance,perform,performed,34709,"95 ; 996////////////////////////////////////////////////////////////////////////////////; 997/// Return pointer to object identified by namecycle.; 998///; 999/// The returned object may or may not derive from TObject.; 1000///; 1001/// - namecycle has the format name;cycle; 1002/// - name = * is illegal, cycle = * is illegal; 1003/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1004///; 1005/// ## Very important note; 1006/// The calling application must cast the returned object to; 1007/// the final type, e.g.; 1008///; 1009/// auto objPtr = (MyClass*)directory->GetObject(""some object of MyClass"");; 1010 ; 1011void *TDirectoryFile::GetObjectUnchecked(const char *namecycle); 1012{; 1013 return GetObjectChecked(namecycle,(TClass*)nullptr);; 1014}; 1015 ; 1016////////////////////////////////////////////////////////////////////////////////; 1017/// See documentation of TDirectoryFile::GetObjectCheck(const char *namecycle, const TClass *cl); 1018 ; 1019void *TDirectoryFile::GetObjectChecked(const char *namecycle, const char* classname); 1020{; 1021 return GetObjectChecked(namecycle,TClass::GetClass(classname));; 1022}; 1023 ; 1024 ; 1025////////////////////////////////////////////////////////////////////////////////; 1026/// Return pointer to object identified by namecycle if and only if the actual; 1027/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 1028/// If expectedClass is null, no check is performed.; 1029///; 1030/// - namecycle has the format name;cycle; 1031/// - name = * is illegal, cycle = * is illegal; 1032/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 1033///; 1034/// ### Very important note; 1035/// The calling application must cast the returned pointer to; 1036/// the type described by the 2 arguments (i.e. cl):; 1037///; 1038/// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 1039///; 1040/// Note: We recommend using the method TDirectoryFile::Get<T>:; ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:81937,Performance,load,load,81937,"oAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::AsSQLStringconst char * AsSQLString() constReturn the date & time in SQL compatible string format, like: 1997-01-15 20:16:28.Definition TDatime.cxx:152; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object o",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:4629,Safety,redund,redundant,4629," of RecursiveRemove (indirectly done; 84 // by 'Appending' this object to it's mother) before the object is completely; 85 // initialized.; 86 // However a better option would be to delay the publishing until the very end,; 87 // but it is currently done in the middle of the initialization (by Build which; 88 // is a public interface) ....; 89 R__LOCKGUARD(gROOTMutex);; 90 ; 91 fName = name;; 92 fTitle = title;; 93 ; 94 if (!initMotherDir) initMotherDir = gDirectory;; 95 ; 96 if (strchr(name,'/')) {; 97 ::Error(""TDirectoryFile"",""directory name (%s) cannot contain a slash"", name);; 98 gDirectory = nullptr;; 99 return;; 100 }; 101 if (strlen(GetName()) == 0) {; 102 ::Error(""TDirectoryFile"",""directory name cannot be \""\"""");; 103 gDirectory = nullptr;; 104 return;; 105 }; 106 ; 107 BuildDirectoryFile(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 108 ; 109 TDirectory* motherdir = GetMotherDir();; 110 TFile* f = TDirectoryFile::GetFile();; 111 ; 112 if (!motherdir || !f) return;; 113 if (!f->IsWritable()) return; //*-* in case of a directory in memory; 114 if (motherdir->GetKey(name)) {; 115 Error(""TDirectoryFile"",""An object with name %s exists already"", name);; 116 return;; 117 }; 118 TClass *cl = nullptr;; 119 if (classname[0]) {; 120 cl = TClass::GetClass(classname);; 121 if (!cl) {; 122 Error(""TDirectoryFile"",""Invalid class name: %s"",classname);; 123 return;; 124 }; 125 } else {; 126 cl = TDirectoryFile::IsA();; 127 }; 128 ; 129 fBufferSize = 0;; 130 fWritable = kTRUE;; 131 ; 132 InitDirectoryFile(cl);; 133 ; 134 fModified = kFALSE;; 135 ; 136 // Temporarily redundant, see comment on lock early in the function.; 137 // R__LOCKGUARD(gROOTMutex);; 138 gROOT->GetUUIDs()->AddUUID(fUUID,this);; 139 // We should really be doing this now rather than in Build, see; 140 // comment at the start of the function.; 141 // if (initMotherDir && strlen(GetName()) != 0) initMotherDir->Append(this);; 142}; 143 ; 144////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:13094,Safety,detect,detection,13094,"/// by TNamed::Clone. TNamed::Clone uses the optional argument newname to set; 380/// a new name to the newly created object.; 381///; 382/// If autoadd is true and if the object class has a; 383/// DirectoryAutoAdd function, it will be called at the end of the; 384/// function with the parameter gDirectory. This usually means that; 385/// the object will be appended to the current ROOT directory.; 386 ; 387TObject *TDirectoryFile::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 388{; 389 // if no default ctor return immediately (error issued by New()); 390 char *pobj = (char*)obj->IsA()->New();; 391 if (!pobj) return nullptr;; 392 ; 393 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 394 if (baseOffset==-1) {; 395 // cl does not inherit from TObject.; 396 // Since this is not supported in this function, the only reason we could reach this code; 397 // is because something is screwed up in the ROOT code.; 398 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 399 obj->IsA()->GetName());; 400 }; 401 TObject *newobj = (TObject*)(pobj+baseOffset);; 402 ; 403 //create a buffer where the object will be streamed; 404 {; 405 // NOTE: do we still need to make this change to gFile?; 406 // NOTE: This can not be 'gDirectory=0' as at least roofit expect gDirectory to not be null; 407 // during the streaming ....; 408 TFile *filsav = gFile;; 409 gFile = nullptr;; 410 const Int_t bufsize = 10000;; 411 TBufferFile buffer(TBuffer::kWrite,bufsize);; 412 buffer.MapObject(obj); //register obj in map to handle self reference; 413 {; 414 Bool_t isRef = obj->TestBit(kIsReferenced);; 415 ((TObject*)obj)->ResetBit(kIsReferenced);; 416 ; 417 ((TObject*)obj)->Streamer(buffer);; 418 ; 419 if (isRef) ((TObject*)obj)->SetBit(kIsReferenced);; 420 }; 421 ; 422 // read new object from buffer; 423 buffer.SetReadMode();; 424 buffer.ResetMap();; 425 buffer.SetBufferOffset(0);; 426 buffer.MapObject(newobj); //register obj i",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:19065,Safety,avoid,avoid,19065,"if (mom); 545 result = mom->GetDirectory(slash+1,printError,funcname);; 546 delete [] path; return result;; 547 }; 548 GetObject(subdir,obj);; 549 if (!obj) {; 550 if (printError) Error(funcname,""Unknown directory %s"", subdir.Data());; 551 delete [] path; return nullptr;; 552 }; 553 ; 554 result = ((TDirectory*)obj)->GetDirectory(slash+1,printError,funcname);; 555 delete [] path; return result;; 556}; 557 ; 558////////////////////////////////////////////////////////////////////////////////; 559/// Delete all objects from memory and directory structure itself.; 560 ; 561void TDirectoryFile::Close(Option_t *option); 562{; 563 if (!fList || !fSeekDir) {; 564 return;; 565 }; 566 ; 567 // Save the directory key list and header; 568 Save();; 569 ; 570 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 571 ; 572 if (!nodelete) {; 573 Bool_t fast = kTRUE;; 574 TObjLink *lnk = fList->FirstLink();; 575 while (lnk) {; 576 if (lnk->GetObject()->IsA() == TDirectoryFile::Class()) {fast = kFALSE;break;}; 577 lnk = lnk->Next();; 578 }; 579 // Delete objects from directory list, this in turn, recursively closes all; 580 // sub-directories (that were allocated on the heap); 581 // if this dir contains subdirs, we must use the slow option for Delete!; 582 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 583 // with a large number of objects (eg >10^5) would take for ever.; 584 {; 585 if (fast) fList->Delete();; 586 else fList->Delete(""slow"");; 587 }; 588 }; 589 ; 590 // Delete keys from key list (but don't delete the list header); 591 if (fKeys) {; 592 fKeys->Delete(""slow"");; 593 }; 594 ; 595 TDirectoryFile::CleanTargets();; 596}; 597 ; 598////////////////////////////////////////////////////////////////////////////////; 599/// Delete Objects or/and keys in a directory; 600///; 601/// Properties of the namecycle string:; 602/// - namecycle has the format name;cycle; 603/// - namecycle = """" is same as namecycle =""T*""; 604/// - ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:30491,Safety,avoid,avoids,30491,"//////////////////////////////////////////////////////////////////////////; 888/// Return pointer to object identified by namecycle.; 889///; 890/// Properties:; 891/// - namecycle has the format name;cycle; 892/// - name = * is illegal, cycle = * is illegal; 893/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 894///; 895/// Examples:; 896/// | %Pattern | Explanation |; 897/// |----------|-------------|; 898/// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; 899/// | foo;1 | get cycle 1 of foo on file |; 900///; 901/// The retrieved object should in principle derive from TObject.; 902/// If not, the function TDirectoryFile::Get<T> should be called.; 903/// However, this function will still work for a non-TObject, provided that; 904/// the calling application cast the return type to the correct type (which; 905/// is the actual type of the object).; 906///; 907/// ### The Get<T> Method; 908/// The method Get<T> offers better protection and avoids the need for any; 909/// cast:; 910/// ~~~{.cpp}; 911/// auto objPtr = directory->Get<MyClass>(""some object"");; 912/// if (objPtr) { ... the object exist and inherits from MyClass ... }; 913/// ~~~; 914///; 915/// ### Very important note about inheritance; 916/// In case the class of this object derives from TObject but not; 917/// as a first inheritance, one must use dynamic_cast<>().; 918///; 919/// #### Example 1 - Normal case:; 920///; 921/// class MyClass : public TObject, public AnotherClass; 922///; 923/// then on return, one can adopt a C style cast:; 924///; 925/// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; 926///; 927/// #### Example 2 - Special case:; 928///; 929/// class MyClass : public AnotherClass, public TObject; 930///; 931/// then on return, one must do:; 932///; 933/// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 934///; 935/// Of course, dynamic_cast<> can also be used in the exa",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:65098,Safety,safe,safer,65098,"he corresponding space in the file by looking in the; 1880/// TFree list of free blocks of the file.; 1881/// - The buffer is written to the file.; 1882///; 1883/// By default, the buffersize will be taken from the average buffer size; 1884/// of all objects written to the current file so far.; 1885/// Use TDirectoryFile::SetBufferSize to force a given buffer size.; 1886///; 1887/// If a name is specified, it will be the name of the key.; 1888/// If name is not given, the name of the key will be the name as returned; 1889/// by obj->GetName().; 1890///; 1891/// The option can be a combination of:; 1892/// - ""SingleKey""; 1893/// - ""Overwrite""; 1894/// - ""WriteDelete""; 1895/// Using the ""Overwrite"" option a previous key with the same name is; 1896/// overwritten. The previous key is deleted before writing the new object.; 1897/// Using the ""WriteDelete"" option a previous key with the same name is; 1898/// deleted only after the new object has been written. This option; 1899/// is safer than kOverwrite but it is slower.; 1900/// The ""SingleKey"" option is only used by TCollection::Write() to write; 1901/// a container with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:65558,Safety,avoid,avoid,65558,"is not given, the name of the key will be the name as returned; 1889/// by obj->GetName().; 1890///; 1891/// The option can be a combination of:; 1892/// - ""SingleKey""; 1893/// - ""Overwrite""; 1894/// - ""WriteDelete""; 1895/// Using the ""Overwrite"" option a previous key with the same name is; 1896/// overwritten. The previous key is deleted before writing the new object.; 1897/// Using the ""WriteDelete"" option a previous key with the same name is; 1898/// deleted only after the new object has been written. This option; 1899/// is safer than kOverwrite but it is slower.; 1900/// The ""SingleKey"" option is only used by TCollection::Write() to write; 1901/// a container with a single key instead of each object in the container; 1902/// with its own key.; 1903/// An object is read from this directory via TDirectoryFile::Get.; 1904/// The function returns the total number of bytes written to the directory.; 1905/// It returns 0 if the object cannot be written.; 1906///; 1907/// WARNING: avoid special characters like '^','$','.' in the name as they; 1908/// are used by the regular expression parser (see TRegexp).; 1909 ; 1910Int_t TDirectoryFile::WriteTObject(const TObject *obj, const char *name, Option_t *option, Int_t bufsize); 1911{; 1912 TDirectory::TContext ctxt(this);; 1913 ; 1914 if (fFile==0) {; 1915 const char *objname = ""no name specified"";; 1916 if (name) objname = name;; 1917 else if (obj) objname = obj->GetName();; 1918 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1919 return 0;; 1920 }; 1921 ; 1922 if (!fFile->IsWritable()) {; 1923 if (!fFile->TestBit(TFile::kWriteError)) {; 1924 // Do not print the error if the file already had a SysError.; 1925 Error(""WriteTObject"",""Directory %s is not writable"", fFile->GetName());; 1926 }; 1927 return 0;; 1928 }; 1929 ; 1930 if (!obj) return 0;; 1931 ; 1932 TString opt = option;; 1933 opt.ToLower();; 1934 ; 1935 TKey *key=0, *oldke",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:82242,Safety,safe,safe,82242,"st of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::AsSQLStringconst char * AsSQLString() constReturn the date & time in SQL compatible string format, like: 1997-01-15 20:16:28.Definition TDatime.cxx:152; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object of type TDatime.Definition TDatime.cxx:416; TDatime::Setvoid Set()Set Date/Time to current time as reported by the system.Definition TDatime.cxx:289; TDatime::ReadBuffervoid ReadBuffer(char *&buffer)Deco",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:7875,Security,hash,hash,7875,"TObject *obj, Bool_t replace /* = kFALSE */); 211{; 212 if (!obj || !fList) return;; 213 ; 214 TDirectory::Append(obj,replace);; 215 ; 216 if (!fMother) return;; 217 if (fMother->IsA() == TMapFile::Class()) {; 218 TMapFile *mfile = (TMapFile*)fMother;; 219 mfile->Add(obj);; 220 }; 221}; 222 ; 223////////////////////////////////////////////////////////////////////////////////; 224/// Insert key in the linked list of keys of this directory.; 225 ; 226Int_t TDirectoryFile::AppendKey(TKey *key); 227{; 228 if (!fKeys) {; 229 Error(""AppendKey"",""TDirectoryFile not initialized yet."");; 230 return 0;; 231 }; 232 ; 233 fModified = kTRUE;; 234 ; 235 key->SetMotherDir(this);; 236 ; 237 // This is a fast hash lookup in case the key does not already exist; 238 TKey *oldkey = (TKey*)fKeys->FindObject(key->GetName());; 239 if (!oldkey) {; 240 fKeys->Add(key);; 241 return 1;; 242 }; 243 ; 244 // If the key name already exists we have to make a scan for it; 245 // and insert the new key ahead of the current one; 246 TObjLink *lnk = fKeys->FirstLink();; 247 while (lnk) {; 248 oldkey = (TKey*)lnk->GetObject();; 249 if (!strcmp(oldkey->GetName(), key->GetName())); 250 break;; 251 lnk = lnk->Next();; 252 }; 253 ; 254 fKeys->AddBefore(lnk, key);; 255 return oldkey->GetCycle() + 1;; 256}; 257 ; 258////////////////////////////////////////////////////////////////////////////////; 259/// Browse the content of the directory.; 260 ; 261void TDirectoryFile::Browse(TBrowser *b); 262{; 263 TString name;; 264 ; 265 if (b) {; 266 TObject *obj = nullptr;; 267 TIter nextin(fList);; 268 TKey *key = nullptr, *keyo = nullptr;; 269 TIter next(fKeys);; 270 ; 271 cd();; 272 ; 273 //Add objects that are only in memory; 274 while ((obj = nextin())) {; 275 if (fKeys->FindObject(obj->GetName())) continue;; 276 b->Add(obj, obj->GetName());; 277 }; 278 ; 279 //Add keys; 280 while ((key = (TKey *) next())) {; 281 int skip = 0;; 282 if (!keyo || (keyo && strcmp(keyo->GetName(), key->GetName()))) {; 283 skip = 0;; 2",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:82217,Security,access,access,82217,"st of persistent data members.Definition TClass.cxx:2098; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::AsSQLStringconst char * AsSQLString() constReturn the date & time in SQL compatible string format, like: 1997-01-15 20:16:28.Definition TDatime.cxx:152; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object of type TDatime.Definition TDatime.cxx:416; TDatime::Setvoid Set()Set Date/Time to current time as reported by the system.Definition TDatime.cxx:289; TDatime::ReadBuffervoid ReadBuffer(char *&buffer)Deco",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:97461,Security,hash,hash,97461,"rtual Long64_t GetSize() constReturns the current file size.Definition TFile.cxx:1347; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::SumBuffervoid SumBuffer(Int_t bufsize)Increment statistics for buffer sizes of objects in this file.Definition TFile.cxx:2417; TFile::CurrentFilestatic TFile *& CurrentFile()Return the current ROOT file if any.Definition TFile.cxx:1067; TFile::GetEndpointUrlvirtual const TUrl * GetEndpointUrl() constDefinition TFile.h:235; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::kReproducible@ kReproducibleDefinition TFile.h:197; TFile::kWriteError@ kWriteErrorDefinition TFile.h:194; TFile::ReadBuffervirtual Bool_t ReadBuffer(char *buf, Int_t len)Read a buffer from the file.Definition TFile.cxx:1770; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TKey::Deletevoid Delete(Option_t *option="""") overrideDelete an object from the file.Definition TKey.cxx:539; TKey::GetSeekKeyvirtual Long64_t GetSeekKey() constDefinition TKey.h:89; TKey::SizeofInt_t Sizeof() const overrideReturn the size in bytes of the key header structure.Definition TKey.cxx:1342; TKey::GetKeylenInt_t GetKeylen() constDefinition TKey.h:84; TKey::GetObjlenInt_t GetObjlen() constDefinition TKey.h:87; TKey::GetNbytesInt_t GetNbytes() constDefinition TKey.h:86; TKey::GetKeepShort_t GetKeep() constReturns the ""KEEP"" status.Definition TKey.cxx:594; TKey::GetClassNamevirtual const char * GetClassName() constDefinition TKey.h:75; TKey::ReadFilevirtual Bool_t ReadFile()Read the key structure from the f",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:105868,Security,access,access,105868,"Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::Streamervirtual void Streamer(TBuffer &); TUUID::AsStringconst char * AsString() constReturn UUID as string. Copy string immediately since it will be reused.Definition TUUID.cxx:571; TUUID::SizeofInt_t Sizeof() constDefinition TUUID.h:85; TUUID::FillBuffervoid FillBuffer(char *&buffer)Stream UUID into output buffer.Definition TUUID.cxx:275; TUUID::StreamerV1void StreamerV1(TBuffer &b)Stream UUID from input buffer.Definition TUUID.cxx:309; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::GetClassvirtual TClass * GetClass() const =0; bool; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:105902,Security,access,access,105902,"Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TUUIDThis class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDent...Definition TUUID.h:42; TUUID::Streamervirtual void Streamer(TBuffer &); TUUID::AsStringconst char * AsString() constReturn UUID as string. Copy string immediately since it will be reused.Definition TUUID.cxx:571; TUUID::SizeofInt_t Sizeof() constDefinition TUUID.h:85; TUUID::FillBuffervoid FillBuffer(char *&buffer)Stream UUID into output buffer.Definition TUUID.cxx:275; TUUID::StreamerV1void StreamerV1(TBuffer &b)Stream UUID from input buffer.Definition TUUID.cxx:309; TVirtualStreamerInfoAbstract Interface class describing Streamer information for one class.Definition TVirtualStreamerInfo.h:44; TVirtualStreamerInfo::GetClassvirtual TClass * GetClass() const =0; bool; int; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:2155,Testability,test,tests,2155,"/; 25 ; 26#include <iostream>; 27#include ""Strlen.h""; 28#include ""strlcpy.h""; 29#include ""TDirectoryFile.h""; 30#include ""TFile.h""; 31#include ""TBufferFile.h""; 32#include ""TBufferJSON.h""; 33#include ""TMapFile.h""; 34#include ""TClassTable.h""; 35#include ""TInterpreter.h""; 36#include ""THashList.h""; 37#include ""TBrowser.h""; 38#include ""TFree.h""; 39#include ""TKey.h""; 40#include ""TStreamerInfo.h""; 41#include ""TROOT.h""; 42#include ""TError.h""; 43#include ""Bytes.h""; 44#include ""TClass.h""; 45#include ""TRegexp.h""; 46#include ""TSystem.h""; 47#include ""TStreamerElement.h""; 48#include ""TProcessUUID.h""; 49#include ""TVirtualMutex.h""; 50#include ""TEmulatedCollectionProxy.h""; 51 ; 52const UInt_t kIsBigFile = BIT(16);; 53const Int_t kMaxLen = 2048;; 54 ; 55ClassImp(TDirectoryFile);; 56 ; 57 ; 58////////////////////////////////////////////////////////////////////////////////; 59/// Default TDirectoryFile constructor; 60 ; 61TDirectoryFile::TDirectoryFile(); 62{; 63 /// Intentionally placed here; 64 /// when TDirectoryFile() = default; used, mac1014/cxx17 fails on some tests; 65 /// Problem with TObject::IsOnHeap() failing; 66}; 67 ; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// Create a new TDirectoryFile; 71///; 72/// A new directory with a name and a title is created in the current directory.; 73/// The directory header information is immediately saved on the file; 74/// A new key is added in the parent directory.; 75/// When this constructor is called from a class directly derived; 76/// from TDirectoryFile, the third argument, classname, MUST be specified.; 77/// In this case, classname must be the name of the derived class.; 78///; 79/// Note that the directory name cannot contain slashes.; 80 ; 81TDirectoryFile::TDirectoryFile(const char *name, const char *title, Option_t *classname, TDirectory* initMotherDir); 82{; 83 // We must not publish this objects to the list of RecursiveRemove (indirectly done; 84 // by 'Appending' this object ",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:43769,Usability,simpl,simply,43769,"already"",name);; 1259 return nullptr;; 1260 }; 1261 }; 1262 TDirectoryFile *newdir = nullptr;; 1263 if (const char *slash = strchr(name,'/')) {; 1264 TString workname(name, Long_t(slash-name));; 1265 TDirectoryFile *tmpdir = nullptr;; 1266 GetObject(workname.Data(), tmpdir);; 1267 if (!tmpdir) {; 1268 tmpdir = (TDirectoryFile*)mkdir(workname.Data(),title);; 1269 if (!tmpdir) return nullptr;; 1270 }; 1271 if (!newdir) newdir = tmpdir;; 1272 tmpdir->mkdir(slash+1);; 1273 return newdir;; 1274 }; 1275 ; 1276 TDirectory::TContext ctxt(this);; 1277 ; 1278 newdir = new TDirectoryFile(name, title, """", this);; 1279 ; 1280 return newdir;; 1281}; 1282 ; 1283////////////////////////////////////////////////////////////////////////////////; 1284/// Purge lowest key cycles in a directory.; 1285///; 1286/// By default, only the highest cycle of a key is kept. Keys for which; 1287/// the ""KEEP"" flag has been set are not removed. See TKey::Keep().; 1288/// NOTE: This does not reduce the size of a TFile--; 1289/// the space is simply freed up to be overwritten.; 1290 ; 1291void TDirectoryFile::Purge(Short_t); 1292{; 1293 if (!IsWritable()) return;; 1294 ; 1295 TDirectory::TContext ctxt(this);; 1296 ; 1297 TKey *key;; 1298 TIter prev(GetListOfKeys(), kIterBackward);; 1299 ; 1300 while ((key = (TKey*)prev())) { // reverse loop on keys; 1301 TKey *keyprev = (TKey*)GetListOfKeys()->Before(key);; 1302 if (!keyprev) break;; 1303 if (key->GetKeep() == 0) {; 1304 if (strcmp(key->GetName(), keyprev->GetName()) == 0) {; 1305 key->Delete(); // Remove from the file.; 1306 delete key; // Remove from memory.; 1307 }; 1308 }; 1309 }; 1310 TFile *f = GetFile();; 1311 if (fModified && f) {; 1312 WriteKeys(); // Write new keys structure; 1313 WriteDirHeader(); // Write new directory header; 1314 f->WriteFree(); // Write new free segments list; 1315 f->WriteHeader(); // Write new file header; 1316 }; 1317}; 1318 ; 1319////////////////////////////////////////////////////////////////////////////////; 1320/",MatchSource.WIKI,doc/master/TDirectoryFile_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:12656,Availability,error,error,12656,"Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self referen",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:15972,Availability,error,error,15972,"l shared_ptr_type currentDirectory =; 424 std::make_shared<shared_ptr_type::element_type>(ROOT::Internal::gROOTLocal);; 425 ; 426 return currentDirectory;; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// Return the current directory for the current thread.; 431 ; 432std::atomic<TDirectory*> &TDirectory::CurrentDirectory(); 433{; 434 return *GetSharedLocalCurrentDirectory().get();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Find a directory using apath.; 439/// It apath is null or empty, returns ""this"" directory.; 440/// Otherwise use apath to find a directory.; 441/// The absolute path syntax is: `file.root:/dir1/dir2`; 442///; 443/// where file.root is the file and /dir1/dir2 the desired subdirectory; 444/// in the file. Relative syntax is relative to ""this"" directory. E.g: `../aa`.; 445/// Returns 0 in case path does not exist.; 446/// If printError is true, use Error with 'funcname' to issue an error message.; 447 ; 448TDirectory *TDirectory::GetDirectory(const char *apath,; 449 Bool_t printError, const char *funcname); 450{; 451 Int_t nch = 0;; 452 if (apath) nch = strlen(apath);; 453 if (!nch) {; 454 return this;; 455 }; 456 ; 457 if (funcname==nullptr || strlen(funcname)==0) funcname = ""GetDirectory"";; 458 ; 459 TDirectory *result = this;; 460 ; 461 char *path = new char[nch+1]; path[0] = 0;; 462 if (nch) strlcpy(path,apath,nch+1);; 463 char *s = (char*)strrchr(path, ':');; 464 if (s) {; 465 *s = '\0';; 466 R__LOCKGUARD(gROOTMutex);; 467 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 468 if (!f && !strcmp(gROOT->GetName(), path)) f = gROOT;; 469 if (s) *s = ':';; 470 if (f) {; 471 result = f;; 472 if (s && *(s+1)) result = f->GetDirectory(s+1,printError,funcname);; 473 delete [] path; return result;; 474 } else {; 475 if (printError) Error(funcname, ""No such file %s"", path);; 476 delete [] path; return nullptr;; 477 };",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:37248,Availability,error,error,37248,"ath of the directory. E.g. `file:/dir1/dir2`.; 1046/// The returned path will be re-used by the next call to GetPath().; 1047 ; 1048const char *TDirectory::GetPath() const; 1049{; 1050 FillFullPath(fPathBuffer);; 1051 ; 1052 if (!GetMotherDir()) // case of file; 1053 fPathBuffer.Append(""/"");; 1054 ; 1055 return fPathBuffer.Data();; 1056}; 1057 ; 1058////////////////////////////////////////////////////////////////////////////////; 1059/// Recursive method to fill full path for directory.; 1060 ; 1061void TDirectory::FillFullPath(TString& buf) const; 1062{; 1063 TDirectory* mom = GetMotherDir();; 1064 if (mom) {; 1065 mom->FillFullPath(buf);; 1066 buf += ""/"";; 1067 buf += GetName();; 1068 } else {; 1069 buf = GetName();; 1070 buf += "":"";; 1071 }; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1076///; 1077/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1078/// name already exists.; 1079/// returnExistingDirectory returns a pointer to an already existing sub-directory with the same name.; 1080/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1081/// the hierarchy (in the above example, the returned TDirectory * always points; 1082/// to ""a"").; 1083/// In particular, the steps to create first a/b/c and then a/b/d without receiving; 1084/// errors are:; 1085/// ~~~ {.cpp}; 1086/// TFile * file = new TFile(""afile"",""RECREATE"");; 1087/// file->mkdir(""a"");; 1088/// file->cd(""a"");; 1089/// gDirectory->mkdir(""b/c"");; 1090/// gDirectory->cd(""b"");; 1091/// gDirectory->mkdir(""d"");; 1092/// ~~~; 1093/// or; 1094/// ~~~ {.cpp}; 1095/// TFile * file = new TFile(""afile"",""RECREATE"");; 1096/// file->mkdir(""a"");; 1097/// file->cd(""a"");; 1098/// gDirectory->mkdir(""b/c"");; 1099/// gDirectory->mkdir(""b/d"", """", true);; 1100/// ~~~; 1101 ; 1102TDirectory *TDirectory::mkdir(const char *name",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:37734,Availability,error,errors,37734,"//////; 1059/// Recursive method to fill full path for directory.; 1060 ; 1061void TDirectory::FillFullPath(TString& buf) const; 1062{; 1063 TDirectory* mom = GetMotherDir();; 1064 if (mom) {; 1065 mom->FillFullPath(buf);; 1066 buf += ""/"";; 1067 buf += GetName();; 1068 } else {; 1069 buf = GetName();; 1070 buf += "":"";; 1071 }; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1076///; 1077/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1078/// name already exists.; 1079/// returnExistingDirectory returns a pointer to an already existing sub-directory with the same name.; 1080/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1081/// the hierarchy (in the above example, the returned TDirectory * always points; 1082/// to ""a"").; 1083/// In particular, the steps to create first a/b/c and then a/b/d without receiving; 1084/// errors are:; 1085/// ~~~ {.cpp}; 1086/// TFile * file = new TFile(""afile"",""RECREATE"");; 1087/// file->mkdir(""a"");; 1088/// file->cd(""a"");; 1089/// gDirectory->mkdir(""b/c"");; 1090/// gDirectory->cd(""b"");; 1091/// gDirectory->mkdir(""d"");; 1092/// ~~~; 1093/// or; 1094/// ~~~ {.cpp}; 1095/// TFile * file = new TFile(""afile"",""RECREATE"");; 1096/// file->mkdir(""a"");; 1097/// file->cd(""a"");; 1098/// gDirectory->mkdir(""b/c"");; 1099/// gDirectory->mkdir(""b/d"", """", true);; 1100/// ~~~; 1101 ; 1102TDirectory *TDirectory::mkdir(const char *name, const char *title, Bool_t returnExistingDirectory); 1103{; 1104 if (returnExistingDirectory) {; 1105 auto existingdir = GetDirectory(name);; 1106 if (existingdir); 1107 return existingdir;; 1108 }; 1109 if (!name || !title || !name[0]) return nullptr;; 1110 if (!title[0]) title = name;; 1111 if (const char *slash = strchr(name,'/')) {; 1112 Long_t size = Long_t(slash-name);; 1113 char *workname = new char[size+1];; 1114 ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:42225,Availability,mask,mask,42225,"///////////////////////; 1193/// Print the path of the directory.; 1194 ; 1195void TDirectory::pwd() const; 1196{; 1197 Printf(""%s"", GetPath());; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Recursively remove object from a Directory.; 1202 ; 1203void TDirectory::RecursiveRemove(TObject *obj); 1204{; 1205 if (fList); 1206 fList->RecursiveRemove(obj);; 1207}; 1208 ; 1209////////////////////////////////////////////////////////////////////////////////; 1210/// Remove an object from the in-memory list.; 1211 ; 1212TObject *TDirectory::Remove(TObject* obj); 1213{; 1214 TObject *p = nullptr;; 1215 if (fList) {; 1216 p = fList->Remove(obj);; 1217 }; 1218 return p;; 1219}; 1220 ; 1221////////////////////////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247///",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:42243,Availability,mask,mask,42243,"///////////////////////; 1193/// Print the path of the directory.; 1194 ; 1195void TDirectory::pwd() const; 1196{; 1197 Printf(""%s"", GetPath());; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Recursively remove object from a Directory.; 1202 ; 1203void TDirectory::RecursiveRemove(TObject *obj); 1204{; 1205 if (fList); 1206 fList->RecursiveRemove(obj);; 1207}; 1208 ; 1209////////////////////////////////////////////////////////////////////////////////; 1210/// Remove an object from the in-memory list.; 1211 ; 1212TObject *TDirectory::Remove(TObject* obj); 1213{; 1214 TObject *p = nullptr;; 1215 if (fList) {; 1216 p = fList->Remove(obj);; 1217 }; 1218 return p;; 1219}; 1220 ; 1221////////////////////////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247///",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:42268,Availability,mask,mask,42268,"///////////////////////; 1193/// Print the path of the directory.; 1194 ; 1195void TDirectory::pwd() const; 1196{; 1197 Printf(""%s"", GetPath());; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Recursively remove object from a Directory.; 1202 ; 1203void TDirectory::RecursiveRemove(TObject *obj); 1204{; 1205 if (fList); 1206 fList->RecursiveRemove(obj);; 1207}; 1208 ; 1209////////////////////////////////////////////////////////////////////////////////; 1210/// Remove an object from the in-memory list.; 1211 ; 1212TObject *TDirectory::Remove(TObject* obj); 1213{; 1214 TObject *p = nullptr;; 1215 if (fList) {; 1216 p = fList->Remove(obj);; 1217 }; 1218 return p;; 1219}; 1220 ; 1221////////////////////////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247///",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:52536,Availability,mask,maskDefinition,52536,"ar Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TBrowser.h; TBuffer.h; TClassTable.h; TClass.h; tcling_callfunc_Wrapper_tvoid(* tcling_callfunc_Wrapper_t)(void *, int, void **, void *)Definition TClingCallFunc.h:56; GetCurrentDirectoryLockstatic std::atomic_flag * GetCurrentDirectoryLock()Definition TDirectory.cxx:36; R__CreateBufferstatic TBuffer * R__CreateBuffer()Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having a compile time circular dep...Definition TDirectory.cxx:336; kMaxLenconst Int_t kMaxLenDefinition TDirectory.cxx:34; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Poin",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:70316,Availability,error,error,70316,"har * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887;",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:70452,Availability,error,error,70452,"ject of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::De",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:7235,Deployability,update,update,7235,"dDirectoryStatus(); 189{; 190 return fgAddDirectory;; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Append object to this directory.; 195///; 196/// If `replace` is true:; 197/// remove any existing objects with the same name (if the name is not """"); 198 ; 199void TDirectory::Append(TObject *obj, Bool_t replace /* = kFALSE */); 200{; 201 if (!obj || !fList) return;; 202 ; 203 if (replace && obj->GetName() && obj->GetName()[0]) {; 204 TObject *old;; 205 while (nullptr != (old = GetList()->FindObject(obj->GetName()))) {; 206 Warning(""Append"",""Replacing existing %s: %s (Potential memory leak)."",; 207 obj->IsA()->GetName(),obj->GetName());; 208 ROOT::DirAutoAdd_t func = old->IsA()->GetDirectoryAutoAdd();; 209 if (func) {; 210 func(old,nullptr);; 211 } else {; 212 Remove(old);; 213 }; 214 }; 215 }; 216 ; 217 fList->Add(obj);; 218 // A priori, a `TDirectory` object is assumed to not have shared ownership.; 219 // If it is, let's rely on the user to update the bit.; 220 if (!dynamic_cast<TDirectory*>(obj)); 221 obj->SetBit(kMustCleanup);; 222}; 223 ; 224////////////////////////////////////////////////////////////////////////////////; 225/// Browse the content of the directory.; 226 ; 227void TDirectory::Browse(TBrowser *b); 228{; 229 if (b) {; 230 TObject *obj = nullptr;; 231 TIter nextin(fList);; 232 ; 233 cd();; 234 ; 235 //Add objects that are only in memory; 236 while ((obj = nextin())) {; 237 b->Add(obj, obj->GetName());; 238 }; 239 }; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// Initialise directory to defaults.; 244///; 245/// If directory is created via default ctor (when dir is read from file); 246/// don't add it here to the directory since its name is not yet known.; 247/// It will be added to the directory in TKey::ReadObj().; 248 ; 249void TDirectory::BuildDirectory(TFile* /*motherFile*/, TDirectory* motherDir); 250{; 251 fList = new THashList(1",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:10501,Deployability,update,update,10501,"xt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:43977,Deployability,update,update,43977,"e can be used in; 1247/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1248/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1249 ; 1250Int_t TDirectory::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1251{; 1252 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1253 ; 1254 if (!obj) return 0;; 1255 Int_t nbytes = 0;; 1256 TString fname, opt = option, cmd;; 1257 if (filename && *filename); 1258 fname = filename;; 1259 else; 1260 fname.Form(""%s.root"", obj->GetName());; 1261 opt.ToLower();; 1262 ; 1263 if (fname.Index("".json"") > 0) {; 1264 cmd.Form(""TBufferJSON::ExportToFile(\""%s\"", (TObject *) 0x%zx, \""%s\"");"", fname.Data(), (size_t) obj, (option ? option : """"));; 1265 nbytes = gROOT->ProcessLine(cmd);; 1266 } else {; 1267 cmd.Form(""TFile::Open(\""%s\"",\""%s\"");"", fname.Data(), opt.Contains(""a"") ? ""update"" : ""recreate"");; 1268 TContext ctxt; // The TFile::Open will change the current directory.; 1269 TDirectory *local = (TDirectory*)gROOT->ProcessLine(cmd);; 1270 if (!local) return 0;; 1271 nbytes = obj->Write();; 1272 delete local;; 1273 }; 1274 if (!opt.Contains(""q"") && !gSystem->AccessPathName(fname.Data())); 1275 obj->Info(""SaveAs"", ""ROOT file %s has been created"", fname.Data());; 1276 return nbytes;; 1277}; 1278 ; 1279////////////////////////////////////////////////////////////////////////////////; 1280/// Set the name for directory; 1281/// If the directory name is changed after the directory was written once,; 1282/// ROOT currently would NOT change the name of correspondent key in the; 1283/// mother directory.; 1284/// DO NOT use this method to 'rename a directory'.; 1285/// Renaming a directory is currently NOT supported.; 1286 ; 1287void TDirectory::SetName(const char* newname); 1288{; 1289 TNamed::SetName(newname);; 1290}; 1291 ; 1292//////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:23322,Energy Efficiency,allocate,allocated,23322,"emory and directory structure itself.; 641/// if option is ""slow"", iterate through the containers in a way to can handle; 642/// 'external' modification (induced by recursions); 643/// if option is ""nodelete"", write the TDirectory but do not delete the contained; 644/// objects.; 645void TDirectory::Close(Option_t *option); 646{; 647 if (!fList) {; 648 return;; 649 }; 650 ; 651 // Save the directory key list and header; 652 Save();; 653 ; 654 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 655 ; 656 if (!nodelete) {; 657 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 658 if (!slow) {; 659 // Check if it is wise to use the fast deletion path.; 660 TObjLink *lnk = fList->FirstLink();; 661 while (lnk) {; 662 if (lnk->GetObject()->IsA() == TDirectory::Class()) {; 663 slow = kTRUE;; 664 break;; 665 }; 666 lnk = lnk->Next();; 667 }; 668 }; 669 ; 670 // Delete objects from directory list, this in turn, recursively closes all; 671 // sub-directories (that were allocated on the heap); 672 // if this dir contains subdirs, we must use the slow option for Delete!; 673 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 674 // with a large number of objects (eg >10^5) would take for ever.; 675 if (slow) fList->Delete(""slow"");; 676 else fList->Delete();; 677 }; 678 ; 679 TDirectory::CleanTargets();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Delete all objects from memory.; 684 ; 685void TDirectory::DeleteAll(Option_t *); 686{; 687 fList->Delete(""slow"");; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Delete Objects or/and keys in a directory.; 692///; 693/// - namecycle has the format name;cycle; 694/// - namecycle = """" same as namecycle =""T*""; 695/// - name = * means all; 696/// - cycle = * means all cycles (memory and keys); 697/// - cycle = """" or cycle = 9999 ==> apply to",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:56636,Energy Efficiency,allocate,allocated,56636," *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::SetByteCountvirtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion=kFALSE)=0; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::ResetMapvirtual void ResetMap()=0; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:11219,Integrability,depend,dependency,11219,"!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if (!creator) {; 341 R__LOCKGUARD(gROOTMutex);; 342 TClass *c = TClass::GetClass(""TBufferFile"");; 343 TMethod *m = c->GetMethodWithPrototype(""TBufferFile"",""TBuffer::EMode,Int_t"",kFALSE,ROOT::kExactMatch);; 344 creator = (tcling_callfunc_Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// Th",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:11306,Integrability,interface,interface,11306,"ocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if (!creator) {; 341 R__LOCKGUARD(gROOTMutex);; 342 TClass *c = TClass::GetClass(""TBufferFile"");; 343 TMethod *m = c->GetMethodWithPrototype(""TBufferFile"",""TBuffer::EMode,Int_t"",kFALSE,ROOT::kExactMatch);; 344 creator = (tcling_callfunc_Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:14886,Integrability,rout,routine,14886,"();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_t func = obj->IsA()->GetDirectoryAutoAdd();; 406 if (func) {; 407 func(newobj,this);; 408 }; 409 }; 410 return newobj;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Return the (address of) a shared pointer to the struct holding the; 415/// actual thread local gDirectory pointer and the atomic_flag for its lock.; 416TDirectory::SharedGDirectory_t &TDirectory::GetSharedLocalCurrentDirectory(); 417{; 418 using shared_ptr_type = TDirectory::SharedGDirectory_t;; 419 ; 420 // Note in previous implementation every time gDirectory was lookup in; 421 // a thread, if it was set to nullptr it would be reset to gROOT. This; 422 // was unexpected and this routine is not re-introducing this issue.; 423 thread_local shared_ptr_type currentDirectory =; 424 std::make_shared<shared_ptr_type::element_type>(ROOT::Internal::gROOTLocal);; 425 ; 426 return currentDirectory;; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// Return the current directory for the current thread.; 431 ; 432std::atomic<TDirectory*> &TDirectory::CurrentDirectory(); 433{; 434 return *GetSharedLocalCurrentDirectory().get();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Find a directory using apath.; 439/// It apath is null or empty, returns ""this"" directory.; 440/// Otherwise use apath to find a directory.; 441/// The absolute path syntax is: `file.root:/dir1/dir2`; 442///; 443/// where file.root is the file and /dir1/dir2 the desired subdirectory; 444/// in the file. Relative syntax is relative to ""this"" directory. E.g: `../aa`.; 445/// Returns 0 in case path d",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:15978,Integrability,message,message,15978,"l shared_ptr_type currentDirectory =; 424 std::make_shared<shared_ptr_type::element_type>(ROOT::Internal::gROOTLocal);; 425 ; 426 return currentDirectory;; 427}; 428 ; 429////////////////////////////////////////////////////////////////////////////////; 430/// Return the current directory for the current thread.; 431 ; 432std::atomic<TDirectory*> &TDirectory::CurrentDirectory(); 433{; 434 return *GetSharedLocalCurrentDirectory().get();; 435}; 436 ; 437////////////////////////////////////////////////////////////////////////////////; 438/// Find a directory using apath.; 439/// It apath is null or empty, returns ""this"" directory.; 440/// Otherwise use apath to find a directory.; 441/// The absolute path syntax is: `file.root:/dir1/dir2`; 442///; 443/// where file.root is the file and /dir1/dir2 the desired subdirectory; 444/// in the file. Relative syntax is relative to ""this"" directory. E.g: `../aa`.; 445/// Returns 0 in case path does not exist.; 446/// If printError is true, use Error with 'funcname' to issue an error message.; 447 ; 448TDirectory *TDirectory::GetDirectory(const char *apath,; 449 Bool_t printError, const char *funcname); 450{; 451 Int_t nch = 0;; 452 if (apath) nch = strlen(apath);; 453 if (!nch) {; 454 return this;; 455 }; 456 ; 457 if (funcname==nullptr || strlen(funcname)==0) funcname = ""GetDirectory"";; 458 ; 459 TDirectory *result = this;; 460 ; 461 char *path = new char[nch+1]; path[0] = 0;; 462 if (nch) strlcpy(path,apath,nch+1);; 463 char *s = (char*)strrchr(path, ':');; 464 if (s) {; 465 *s = '\0';; 466 R__LOCKGUARD(gROOTMutex);; 467 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 468 if (!f && !strcmp(gROOT->GetName(), path)) f = gROOT;; 469 if (s) *s = ':';; 470 if (f) {; 471 result = f;; 472 if (s && *(s+1)) result = f->GetDirectory(s+1,printError,funcname);; 473 delete [] path; return result;; 474 } else {; 475 if (printError) Error(funcname, ""No such file %s"", path);; 476 delete [] path; return nullptr;; 477 };",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:42812,Integrability,message,message,42812,"////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1248/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1249 ; 1250Int_t TDirectory::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1251{; 1252 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1253 ; 1254 if (!obj) return 0;; 1255 Int_t nbytes = 0;; 1256 TString fname, opt = option, cmd;; 1257 if (filename && *filename); 1258 fname = filename;; 1259 else; 1260 fname.Form(""%s.root"", obj->GetName());; 1261 opt.ToLower();; 1262 ; 1263 if (fname.Index("".json"") > 0) {; 1264 cmd.Form(""TBufferJSON::ExportToFile(\""%s\"", (TObject *) 0x%zx, \""%s\"");"", fname.Data(), (size_t)",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:42864,Integrability,message,message,42864,"///////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247/// JavaScript ROOT (https://root.cern/js/) to display object in web browser; 1248/// When creating JSON file, option string may contain compression level from 0 to 3 (default 0); 1249 ; 1250Int_t TDirectory::SaveObjectAs(const TObject *obj, const char *filename, Option_t *option) const; 1251{; 1252 // option can contain single letter args: ""a"" for append, ""q"" for quiet in any combinations; 1253 ; 1254 if (!obj) return 0;; 1255 Int_t nbytes = 0;; 1256 TString fname, opt = option, cmd;; 1257 if (filename && *filename); 1258 fname = filename;; 1259 else; 1260 fname.Form(""%s.root"", obj->GetName());; 1261 opt.ToLower();; 1262 ; 1263 if (fname.Index("".json"") > 0) {; 1264 cmd.Form(""TBufferJSON::ExportToFile(\""%s\"", (TObject *) 0x%zx, \""%s\"");"", fname.Data(), (size_t) obj, (option ? option : """"));; 1265 nbyte",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:56779,Integrability,wrap,wrapper,56779,"TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::ResetMapvirtual void ResetMap()=0; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingR",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:69599,Integrability,message,message,69599,"the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overrideStream an object of class TObject.; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TNamed::IsATClass * IsA() const overrideDefinition TNamed.h:58; TObjLinkWrapper around a TObject so it can be stored in a TList.Definition TList.h:123; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Optio",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:70322,Integrability,message,message,70322,"har * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887;",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:70458,Integrability,message,message,70458,"ject of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::De",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:71161,Integrability,message,message,71161,"E if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:4318,Modifiability,variab,variable,4318," 96 ; 97TDirectory::~TDirectory(); 98{; 99 // Use gROOTLocal to avoid triggering undesired initialization of gROOT.; 100 // For example in compiled C++ programs that don't use it directly.; 101 if (!ROOT::Internal::gROOTLocal) {; 102 delete fList;; 103 return; //when called by TROOT destructor; 104 }; 105 ; 106 if (fList) {; 107 if (!fList->IsUsingRWLock()); 108 Fatal(""~TDirectory"",""In %s:%p the fList (%p) is not using the RWLock\n"",; 109 GetName(),this,fList);; 110 fList->Delete(""slow"");; 111 SafeDelete(fList);; 112 }; 113 ; 114 TDirectory::CleanTargets();; 115 ; 116 TDirectory* mom = GetMotherDir();; 117 ; 118 if (mom) {; 119 mom->Remove(this);; 120 }; 121 ; 122 if (gDebug) {; 123 Info(""~TDirectory"", ""dtor called for %s"", GetName());; 124 }; 125}; 126 ; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Set the current directory to null.; 130/// This is called from the TContext destructor. Since the destructor is; 131/// inline, we do not want to have it directly use a global variable.; 132 ; 133void TDirectory::TContext::CdNull(); 134{; 135 gDirectory = nullptr;; 136}; 137 ; 138////////////////////////////////////////////////////////////////////////////////; 139/// Destructor.; 140///; 141/// Reset the current directory to its previous state.; 142 ; 143TDirectory::TContext::~TContext(); 144{; 145 fActiveDestructor = true;; 146 if (fDirectory) {; 147 // UnregisterContext must not be virtual to allow; 148 // this to work even with fDirectory set to nullptr.; 149 (*fDirectory).UnregisterContext(this);; 150 // While we were waiting for the lock, the TDirectory; 151 // may have been deleted by another thread, so; 152 // we need to recheck the value of fDirectory.; 153 if (fDirectory); 154 (*fDirectory).cd();; 155 else; 156 CdNull();; 157 } else {; 158 CdNull();; 159 }; 160 fActiveDestructor = false;; 161 while(fDirectoryWait);; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:12953,Modifiability,inherit,inherit,12953,"Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self referen",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:13184,Modifiability,inherit,inheritance,13184," This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self reference; 392 const_cast<TObject*>(obj)->Streamer(*buffer);; 393 ; 394 // read new object from buffer; 395 buffer->SetReadMode();; 396 buffer->ResetMap();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:29412,Modifiability,inherit,inherits,29412,"o object identified by namecycle.; 818///; 819/// namecycle has the format name;cycle; 820/// - name = * is illegal, cycle = * is illegal; 821/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 822///; 823/// examples:; 824/// - foo : get object named foo in memory; 825/// if object is not in memory, try with highest cycle from file; 826/// - foo;1 : get cycle 1 of foo on file; 827///; 828/// The retrieved object should in principle derive from TObject.; 829/// If not, the function TDirectory::GetObject should be called.; 830/// However, this function will still work for a non-TObject, providing that; 831/// the calling application cast the return type to the correct type (which; 832/// is the actual type of the object).; 833///; 834/// NOTE:; 835///; 836/// The method GetObject offer better protection and avoid the need; 837/// for any cast:; 838/// ~~~ {.cpp}; 839/// MyClass *obj;; 840/// directory->GetObject(""some object"",obj);; 841/// if (obj) { ... the object exist and inherits from MyClass ... }; 842/// ~~~; 843///; 844/// VERY IMPORTANT NOTE:; 845///; 846/// In case the class of this object derives from TObject but not; 847/// as a first inheritance, one must use dynamic_cast<>().; 848/// #### Example 1: Normal case:; 849/// ~~~ {.cpp}; 850/// class MyClass : public TObject, public AnotherClass; 851/// ~~~; 852/// then on return, one can do:; 853/// ~~~ {.cpp}; 854/// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; 855/// ~~~; 856/// #### Example 2: Special case:; 857/// ~~~ {.cpp}; 858/// class MyClass : public AnotherClass, public TObject; 859/// ~~~; 860/// then on return, one must do:; 861/// ~~~ {.cpp}; 862/// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 863/// ~~~; 864/// Of course, dynamic_cast<> can also be used in the example 1.; 865 ; 866TObject *TDirectory::Get(const char *namecycle); 867{; 868 Short_t cycle;; 869 char name[kMaxLen];; 870 ; 871 DecodeNameCycle(namecycle, name, cycle",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:29586,Modifiability,inherit,inheritance,29586,"e = * is illegal; 821/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 822///; 823/// examples:; 824/// - foo : get object named foo in memory; 825/// if object is not in memory, try with highest cycle from file; 826/// - foo;1 : get cycle 1 of foo on file; 827///; 828/// The retrieved object should in principle derive from TObject.; 829/// If not, the function TDirectory::GetObject should be called.; 830/// However, this function will still work for a non-TObject, providing that; 831/// the calling application cast the return type to the correct type (which; 832/// is the actual type of the object).; 833///; 834/// NOTE:; 835///; 836/// The method GetObject offer better protection and avoid the need; 837/// for any cast:; 838/// ~~~ {.cpp}; 839/// MyClass *obj;; 840/// directory->GetObject(""some object"",obj);; 841/// if (obj) { ... the object exist and inherits from MyClass ... }; 842/// ~~~; 843///; 844/// VERY IMPORTANT NOTE:; 845///; 846/// In case the class of this object derives from TObject but not; 847/// as a first inheritance, one must use dynamic_cast<>().; 848/// #### Example 1: Normal case:; 849/// ~~~ {.cpp}; 850/// class MyClass : public TObject, public AnotherClass; 851/// ~~~; 852/// then on return, one can do:; 853/// ~~~ {.cpp}; 854/// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; 855/// ~~~; 856/// #### Example 2: Special case:; 857/// ~~~ {.cpp}; 858/// class MyClass : public AnotherClass, public TObject; 859/// ~~~; 860/// then on return, one must do:; 861/// ~~~ {.cpp}; 862/// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 863/// ~~~; 864/// Of course, dynamic_cast<> can also be used in the example 1.; 865 ; 866TObject *TDirectory::Get(const char *namecycle); 867{; 868 Short_t cycle;; 869 char name[kMaxLen];; 870 ; 871 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 872 char *namobj = name;; 873 Int_t nch = strlen(name);; 874 for (Int_t i = nch-1; i > 0; i--) {; 875 if (n",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:33455,Modifiability,inherit,inheriting,33455,"n GetObjectChecked(namecycle, TClass::GetClass(classname));; 932}; 933 ; 934 ; 935////////////////////////////////////////////////////////////////////////////////; 936/// Return pointer to object identified by namecycle if and only if the actual; 937/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 938/// If expectedClass is null, no check is performed.; 939///; 940/// namecycle has the format `name;cycle`; 941/// - name = * is illegal, cycle = * is illegal; 942/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 943///; 944/// VERY IMPORTANT NOTE:; 945///; 946/// The calling application must cast the returned pointer to; 947/// the type described by the 2 arguments (i.e. cl):; 948/// ~~~ {.cpp}; 949/// MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 950/// ~~~; 951/// Note: We recommend using the method TDirectory::GetObject:; 952/// ~~~ {.cpp}; 953/// MyClass *obj = nullptr;; 954/// directory->GetObject(""some object inheriting from MyClass"",obj);; 955/// if (obj) { ... we found what we are looking for ... }; 956/// ~~~; 957 ; 958void *TDirectory::GetObjectChecked(const char *namecycle, const TClass* expectedClass); 959{; 960 Short_t cycle;; 961 char name[kMaxLen];; 962 ; 963 DecodeNameCycle(namecycle, name, cycle, kMaxLen);; 964 char *namobj = name;; 965 Int_t nch = strlen(name);; 966 for (Int_t i = nch-1; i > 0; i--) {; 967 if (name[i] == '/') {; 968 name[i] = 0;; 969 TDirectory* dirToSearch=GetDirectory(name);; 970 namobj = name + i + 1;; 971 name[i] = '/';; 972 if (dirToSearch) {; 973 return dirToSearch->GetObjectChecked(namobj, expectedClass);; 974 } else {; 975 return nullptr;; 976 }; 977 }; 978 }; 979 ; 980//*-*---------------------Case of Object in memory---------------------; 981// ========================; 982 if (!expectedClass || expectedClass->IsTObject()) {; 983 TObject *objcur = fList->FindObject(namobj);; 984 if (objcur) {; 985 if (objcur==this && strlen(namobj)!=0) {;",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:56921,Modifiability,inherit,inherits,56921,"Count(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::ResetMapvirtual void ResetMap()=0; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definiti",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:57068,Modifiability,inherit,inherits,57068,"virtual void ResetMap()=0; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::SetReadModevoid SetReadMode()Set buffer in read mode.Definition TBuffer.cxx:302; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TBuffer::MapObjectvirtual void MapObject(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definitio",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:70168,Modifiability,inherit,inherits,70168," GetObject() constDefinition TList.h:145; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Classstatic TClass * Class(); TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Deletevirtual void Delete(Option_t *option="""")Delete this object.Definition TObject.cxx:254; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Infovirtual void Info(const char *method, const ch",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:10035,Performance,load,load,10035,"ext will call Unregister on gROOT.; 278 // Then unregister of this ctxt and its Previous context can actually be run; 279 // in parallel (this takes the gROOT lock, Previous takes the lock of fDirectory); 280 // and thus step on each other.; 281 ctxt->fDirectory = nullptr; // Can not be gROOT; 282 ; 283 if (ctxt->fActiveDestructor) {; 284 extraWait.push_back(fContext);; 285 } else {; 286 ctxt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332///",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:12197,Performance,load,load,12197,"ile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 335 ; 336static TBuffer* R__CreateBuffer(); 337{; 338 typedef void (*tcling_callfunc_Wrapper_t)(void*, int, void**, void*);; 339 static tcling_callfunc_Wrapper_t creator = nullptr;; 340 if (!creator) {; 341 R__LOCKGUARD(gROOTMutex);; 342 TClass *c = TClass::GetClass(""TBufferFile"");; 343 TMethod *m = c->GetMethodWithPrototype(""TBufferFile"",""TBuffer::EMode,Int_t"",kFALSE,ROOT::kExactMatch);; 344 creator = (tcling_callfunc_Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from T",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:13499,Performance,load,load,13499,"is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self reference; 392 const_cast<TObject*>(obj)->Streamer(*buffer);; 393 ; 394 // read new object from buffer; 395 buffer->SetReadMode();; 396 buffer->ResetMap();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_t func = obj->IsA()->GetDirectoryAutoAdd();; 406 if (func) {; 407 func(newobj,this);; 408 }; 409 }; 410 return newobj;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Return the (address of) a shared pointer to the struct holding the; 415/// actual thread local gDirectory pointer and the atomic_flag for its lock.; 416TDirectory::SharedGDirectory_t &TDirectory::GetSharedLocalCurrentDirectory(); 417{; 418 using shared_ptr_type = TDirectory::SharedGDirectory_t;; 419 ; 420 // Note in previous implementation every time gDirectory was lookup in; 421 // a thread, if it was set to nullptr it would be reset to gROOT. This; 422 // was unexpected and this routine is not re-introducing this issue.; 423 thread_local shared_ptr_type currentDirectory =; 424 std::make",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:32814,Performance,perform,performed,32814,"03}; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// Return pointer to object identified by namecycle.; 907/// The returned object may or may not derive from TObject.; 908///; 909/// - namecycle has the format name;cycle; 910/// - name = * is illegal, cycle = * is illegal; 911/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 912///; 913/// VERY IMPORTANT NOTE:; 914///; 915/// The calling application must cast the returned object to; 916/// the final type, e.g.; 917/// ~~~ {.cpp}; 918/// MyClass *obj = (MyClass*)directory->GetObject(""some object of MyClass"");; 919/// ~~~; 920 ; 921void *TDirectory::GetObjectUnchecked(const char *namecycle); 922{; 923 return GetObjectChecked(namecycle,(TClass *)nullptr);; 924}; 925 ; 926////////////////////////////////////////////////////////////////////////////////; 927/// See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl); 928 ; 929void *TDirectory::GetObjectChecked(const char *namecycle, const char* classname); 930{; 931 return GetObjectChecked(namecycle, TClass::GetClass(classname));; 932}; 933 ; 934 ; 935////////////////////////////////////////////////////////////////////////////////; 936/// Return pointer to object identified by namecycle if and only if the actual; 937/// object is a type suitable to be stored as a pointer to a ""expectedClass""; 938/// If expectedClass is null, no check is performed.; 939///; 940/// namecycle has the format `name;cycle`; 941/// - name = * is illegal, cycle = * is illegal; 942/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 943///; 944/// VERY IMPORTANT NOTE:; 945///; 946/// The calling application must cast the returned pointer to; 947/// the type described by the 2 arguments (i.e. cl):; 948/// ~~~ {.cpp}; 949/// MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; 950/// ~~~; 951/// Note: We recommend using the method TDirectory::GetObject:; 952",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:46805,Performance,load,load,46805,"er[len];; 1320 }; 1321 ; 1322 if (namesize) {; 1323 if (len > namesize-1ul) len = namesize-1; // accommodate string terminator; 1324 } else {; 1325 ::Warning(""TDirectory::DecodeNameCycle"",; 1326 ""Using unsafe version: invoke this method by specifying the buffer size"");; 1327 }; 1328 ; 1329 strncpy(name, buffer, len);; 1330 name[len] = '\0';; 1331 ; 1332 if (*ni == '*'); 1333 cycle = 10000;; 1334 else if (isdigit(*ni)) {; 1335 long parsed = strtol(ni,nullptr,10);; 1336 if (parsed >= (long) std::numeric_limits<Short_t>::max()); 1337 cycle = 0;; 1338 else; 1339 cycle = (Short_t)parsed;; 1340 } else; 1341 cycle = 9999;; 1342}; 1343 ; 1344void TDirectory::TContext::RegisterCurrentDirectory(); 1345{; 1346 // peg the current directory; 1347 TDirectory *current;; 1348 {; 1349 ROOT::Internal::TSpinLockGuard slg(*GetCurrentDirectoryLock());; 1350 current = TDirectory::CurrentDirectory().load();; 1351 // Don't peg if there is no current directory or if the current; 1352 // directory's destruction has already started (in another thread); 1353 // and is waiting for this thread to leave the critical section.; 1354 if (!current || !current->IsBuilt()); 1355 return;; 1356 ++(current->fContextPeg);; 1357 }; 1358 current->RegisterContext(this);; 1359 --(current->fContextPeg);; 1360}; 1361 ; 1362///////////////////////////////////////////////////////////////////////////////; 1363/// Register a TContext pointing to this TDirectory object; 1364 ; 1365void TDirectory::RegisterContext(TContext *ctxt) {; 1366 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1367 ; 1368 if (!IsBuilt() || this == ROOT::Internal::gROOTLocal); 1369 return;; 1370 if (fContext) {; 1371 TContext *current = fContext;; 1372 while(current->fNext) {; 1373 current = current->fNext;; 1374 }; 1375 current->fNext = ctxt;; 1376 ctxt->fPrevious = current;; 1377 } else {; 1378 fContext = ctxt;; 1379 }; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Register a std::a",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:48344,Performance,load,load,48344,":RegisterContext(TContext *ctxt) {; 1366 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1367 ; 1368 if (!IsBuilt() || this == ROOT::Internal::gROOTLocal); 1369 return;; 1370 if (fContext) {; 1371 TContext *current = fContext;; 1372 while(current->fNext) {; 1373 current = current->fNext;; 1374 }; 1375 current->fNext = ctxt;; 1376 ctxt->fPrevious = current;; 1377 } else {; 1378 fContext = ctxt;; 1379 }; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Register a std::atomic<TDirectory*> that will soon be pointing to this TDirectory object; 1384 ; 1385void TDirectory::RegisterGDirectory(TDirectory::SharedGDirectory_t &gdirectory_ptr); 1386{; 1387 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1388 if (std::find(fGDirectories.begin(), fGDirectories.end(), gdirectory_ptr) == fGDirectories.end()) {; 1389 fGDirectories.emplace_back(gdirectory_ptr);; 1390 }; 1391 // FIXME:; 1392 // globalptr->load()->fGDirectories will still contain globalptr, but we cannot; 1393 // know whether globalptr->load() has been deleted by another thread in the meantime.; 1394}; 1395 ; 1396 ; 1397////////////////////////////////////////////////////////////////////////////////; 1398/// \copydoc TDirectory::WriteObject(const T*,const char*,Option_t*,Int_t).; 1399 ; 1400Int_t TDirectory::WriteTObject(const TObject *obj, const char *name, Option_t * /*option*/, Int_t /*bufsize*/); 1401{; 1402 const char *objname = ""no name specified"";; 1403 if (name) objname = name;; 1404 else if (obj) objname = obj->GetName();; 1405 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1406 return 0;; 1407}; 1408 ; 1409////////////////////////////////////////////////////////////////////////////////; 1410/// UnRegister a TContext pointing to this TDirectory object; 1411 ; 1412void TDirectory::UnregisterContext(TContext *ctxt) {; 1413 ; 1414 ROOT::Internal::TSpinLockGuard slg",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:48443,Performance,load,load,48443,":RegisterContext(TContext *ctxt) {; 1366 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1367 ; 1368 if (!IsBuilt() || this == ROOT::Internal::gROOTLocal); 1369 return;; 1370 if (fContext) {; 1371 TContext *current = fContext;; 1372 while(current->fNext) {; 1373 current = current->fNext;; 1374 }; 1375 current->fNext = ctxt;; 1376 ctxt->fPrevious = current;; 1377 } else {; 1378 fContext = ctxt;; 1379 }; 1380}; 1381 ; 1382////////////////////////////////////////////////////////////////////////////////; 1383/// Register a std::atomic<TDirectory*> that will soon be pointing to this TDirectory object; 1384 ; 1385void TDirectory::RegisterGDirectory(TDirectory::SharedGDirectory_t &gdirectory_ptr); 1386{; 1387 ROOT::Internal::TSpinLockGuard slg(fSpinLock);; 1388 if (std::find(fGDirectories.begin(), fGDirectories.end(), gdirectory_ptr) == fGDirectories.end()) {; 1389 fGDirectories.emplace_back(gdirectory_ptr);; 1390 }; 1391 // FIXME:; 1392 // globalptr->load()->fGDirectories will still contain globalptr, but we cannot; 1393 // know whether globalptr->load() has been deleted by another thread in the meantime.; 1394}; 1395 ; 1396 ; 1397////////////////////////////////////////////////////////////////////////////////; 1398/// \copydoc TDirectory::WriteObject(const T*,const char*,Option_t*,Int_t).; 1399 ; 1400Int_t TDirectory::WriteTObject(const TObject *obj, const char *name, Option_t * /*option*/, Int_t /*bufsize*/); 1401{; 1402 const char *objname = ""no name specified"";; 1403 if (name) objname = name;; 1404 else if (obj) objname = obj->GetName();; 1405 Error(""WriteTObject"",""The current directory (%s) is not associated with a file. The object (%s) has not been written."",GetName(),objname);; 1406 return 0;; 1407}; 1408 ; 1409////////////////////////////////////////////////////////////////////////////////; 1410/// UnRegister a TContext pointing to this TDirectory object; 1411 ; 1412void TDirectory::UnregisterContext(TContext *ctxt) {; 1413 ; 1414 ROOT::Internal::TSpinLockGuard slg",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:57356,Performance,load,load,57356,"ct(const TObject *obj, UInt_t offset=1)=0; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TCo",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:3342,Safety,avoid,avoid,3342,"e of the derived class.; 69///; 70/// Note that the directory name cannot contain slashes.; 71 ; 72TDirectory::TDirectory(const char *name, const char *title, Option_t * /*classname*/, TDirectory* initMotherDir); 73 : TNamed(name, title); 74{; 75 // MSVC doesn't support fSpinLock=ATOMIC_FLAG_INIT; in the class definition; 76 std::atomic_flag_clear( &fSpinLock );; 77 ; 78 if (!initMotherDir) initMotherDir = gDirectory;; 79 ; 80 if (strchr(name,'/')) {; 81 ::Error(""TDirectory::TDirectory"",""directory name (%s) cannot contain a slash"", name);; 82 gDirectory = nullptr;; 83 return;; 84 }; 85 if (strlen(GetName()) == 0) {; 86 ::Error(""TDirectory::TDirectory"",""directory name cannot be \""\"""");; 87 gDirectory = nullptr;; 88 return;; 89 }; 90 ; 91 BuildDirectory(initMotherDir ? initMotherDir->GetFile() : nullptr, initMotherDir);; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////////; 95/// Destructor.; 96 ; 97TDirectory::~TDirectory(); 98{; 99 // Use gROOTLocal to avoid triggering undesired initialization of gROOT.; 100 // For example in compiled C++ programs that don't use it directly.; 101 if (!ROOT::Internal::gROOTLocal) {; 102 delete fList;; 103 return; //when called by TROOT destructor; 104 }; 105 ; 106 if (fList) {; 107 if (!fList->IsUsingRWLock()); 108 Fatal(""~TDirectory"",""In %s:%p the fList (%p) is not using the RWLock\n"",; 109 GetName(),this,fList);; 110 fList->Delete(""slow"");; 111 SafeDelete(fList);; 112 }; 113 ; 114 TDirectory::CleanTargets();; 115 ; 116 TDirectory* mom = GetMotherDir();; 117 ; 118 if (mom) {; 119 mom->Remove(this);; 120 }; 121 ; 122 if (gDebug) {; 123 Info(""~TDirectory"", ""dtor called for %s"", GetName());; 124 }; 125}; 126 ; 127 ; 128////////////////////////////////////////////////////////////////////////////////; 129/// Set the current directory to null.; 130/// This is called from the TContext destructor. Since the destructor is; 131/// inline, we do not want to have it directly use a global variable.; 132 ; ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:13167,Safety,detect,detection,13167," This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self reference; 392 const_cast<TObject*>(obj)->Streamer(*buffer);; 393 ; 394 // read new object from buffer; 395 buffer->SetReadMode();; 396 buffer->ResetMap();; 397 buffer->SetBufferOffset(0);; 398 buffer->MapObject(newobj); //register obj in map to handle self reference; 399 newobj->Streamer(*buffer);; 400 newobj->ResetBit(kIsReferenced);; 401 newobj->ResetBit(kCanDelete);; 402 ; 403 delete buffer;; 404 if (autoadd) {; 405 ROOT::DirAutoAdd_",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:23439,Safety,avoid,avoid,23439,"emory and directory structure itself.; 641/// if option is ""slow"", iterate through the containers in a way to can handle; 642/// 'external' modification (induced by recursions); 643/// if option is ""nodelete"", write the TDirectory but do not delete the contained; 644/// objects.; 645void TDirectory::Close(Option_t *option); 646{; 647 if (!fList) {; 648 return;; 649 }; 650 ; 651 // Save the directory key list and header; 652 Save();; 653 ; 654 Bool_t nodelete = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 655 ; 656 if (!nodelete) {; 657 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 658 if (!slow) {; 659 // Check if it is wise to use the fast deletion path.; 660 TObjLink *lnk = fList->FirstLink();; 661 while (lnk) {; 662 if (lnk->GetObject()->IsA() == TDirectory::Class()) {; 663 slow = kTRUE;; 664 break;; 665 }; 666 lnk = lnk->Next();; 667 }; 668 }; 669 ; 670 // Delete objects from directory list, this in turn, recursively closes all; 671 // sub-directories (that were allocated on the heap); 672 // if this dir contains subdirs, we must use the slow option for Delete!; 673 // we must avoid ""slow"" as much as possible, in particular Delete(""slow""); 674 // with a large number of objects (eg >10^5) would take for ever.; 675 if (slow) fList->Delete(""slow"");; 676 else fList->Delete();; 677 }; 678 ; 679 TDirectory::CleanTargets();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Delete all objects from memory.; 684 ; 685void TDirectory::DeleteAll(Option_t *); 686{; 687 fList->Delete(""slow"");; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Delete Objects or/and keys in a directory.; 692///; 693/// - namecycle has the format name;cycle; 694/// - namecycle = """" same as namecycle =""T*""; 695/// - name = * means all; 696/// - cycle = * means all cycles (memory and keys); 697/// - cycle = """" or cycle = 9999 ==> apply to",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:29241,Safety,avoid,avoid,29241,"obj) {; 809 return subobj;; 810 }; 811 }; 812 }; 813 return nullptr;; 814}; 815 ; 816////////////////////////////////////////////////////////////////////////////////; 817/// Return pointer to object identified by namecycle.; 818///; 819/// namecycle has the format name;cycle; 820/// - name = * is illegal, cycle = * is illegal; 821/// - cycle = """" or cycle = 9999 ==> apply to a memory object; 822///; 823/// examples:; 824/// - foo : get object named foo in memory; 825/// if object is not in memory, try with highest cycle from file; 826/// - foo;1 : get cycle 1 of foo on file; 827///; 828/// The retrieved object should in principle derive from TObject.; 829/// If not, the function TDirectory::GetObject should be called.; 830/// However, this function will still work for a non-TObject, providing that; 831/// the calling application cast the return type to the correct type (which; 832/// is the actual type of the object).; 833///; 834/// NOTE:; 835///; 836/// The method GetObject offer better protection and avoid the need; 837/// for any cast:; 838/// ~~~ {.cpp}; 839/// MyClass *obj;; 840/// directory->GetObject(""some object"",obj);; 841/// if (obj) { ... the object exist and inherits from MyClass ... }; 842/// ~~~; 843///; 844/// VERY IMPORTANT NOTE:; 845///; 846/// In case the class of this object derives from TObject but not; 847/// as a first inheritance, one must use dynamic_cast<>().; 848/// #### Example 1: Normal case:; 849/// ~~~ {.cpp}; 850/// class MyClass : public TObject, public AnotherClass; 851/// ~~~; 852/// then on return, one can do:; 853/// ~~~ {.cpp}; 854/// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; 855/// ~~~; 856/// #### Example 2: Special case:; 857/// ~~~ {.cpp}; 858/// class MyClass : public AnotherClass, public TObject; 859/// ~~~; 860/// then on return, one must do:; 861/// ~~~ {.cpp}; 862/// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; 863/// ~~~; 864/// Of course, dynamic_cast<> can",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:46117,Safety,unsafe,unsafe,46117,"ing terminator) should be specified in; 1295/// namesize.; 1296/// @note Edge cases:; 1297/// - If the number after the `;` is larger than `SHORT_MAX`, cycle is set to `0`.; 1298/// - If name ends with `;*`, cycle is set to 10000`.; 1299/// - In all other cases, i.e. when number is not a digit or buffer is a nullptr, cycle is set to `9999`.; 1300 ; 1301void TDirectory::DecodeNameCycle(const char *buffer, char *name, Short_t &cycle,; 1302 const size_t namesize); 1303{; 1304 if (!buffer) {; 1305 cycle = 9999;; 1306 return;; 1307 }; 1308 ; 1309 size_t len = 0;; 1310 const char *ni = strchr(buffer, ';');; 1311 ; 1312 if (ni) {; 1313 // Found ';'; 1314 len = ni - buffer;; 1315 ++ni;; 1316 } else {; 1317 // No ';' found; 1318 len = strlen(buffer);; 1319 ni = &buffer[len];; 1320 }; 1321 ; 1322 if (namesize) {; 1323 if (len > namesize-1ul) len = namesize-1; // accommodate string terminator; 1324 } else {; 1325 ::Warning(""TDirectory::DecodeNameCycle"",; 1326 ""Using unsafe version: invoke this method by specifying the buffer size"");; 1327 }; 1328 ; 1329 strncpy(name, buffer, len);; 1330 name[len] = '\0';; 1331 ; 1332 if (*ni == '*'); 1333 cycle = 10000;; 1334 else if (isdigit(*ni)) {; 1335 long parsed = strtol(ni,nullptr,10);; 1336 if (parsed >= (long) std::numeric_limits<Short_t>::max()); 1337 cycle = 0;; 1338 else; 1339 cycle = (Short_t)parsed;; 1340 } else; 1341 cycle = 9999;; 1342}; 1343 ; 1344void TDirectory::TContext::RegisterCurrentDirectory(); 1345{; 1346 // peg the current directory; 1347 TDirectory *current;; 1348 {; 1349 ROOT::Internal::TSpinLockGuard slg(*GetCurrentDirectoryLock());; 1350 current = TDirectory::CurrentDirectory().load();; 1351 // Don't peg if there is no current directory or if the current; 1352 // directory's destruction has already started (in another thread); 1353 // and is waiting for this thread to leave the critical section.; 1354 if (!current || !current->IsBuilt()); 1355 return;; 1356 ++(current->fContextPeg);; 1357 }; 1358 current->Register",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:57661,Safety,safe,safe,57661,"kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:10343,Security,access,access,10343,"80 // and thus step on each other.; 281 ctxt->fDirectory = nullptr; // Can not be gROOT; 282 ; 283 if (ctxt->fActiveDestructor) {; 284 extraWait.push_back(fContext);; 285 } else {; 286 ctxt->fDirectoryWait = false;; 287 }; 288 fContext = next;; 289 }; 290 ; 291 // Now loop through the set of thread local 'gDirectory' that; 292 // have a one point or another pointed to this directory.; 293 for (auto &ptr : fGDirectories) {; 294 // If the thread local gDirectory still point to this directory; 295 // we need to reset it using the following sematic:; 296 // we fall back to the mother/owner of this directory or gROOTLocal; 297 // if there is no parent or nullptr if the current object is gROOTLocal.; 298 if (ptr->load() == this) {; 299 TDirectory *next = GetMotherDir();; 300 if (!next || next == this) {; 301 if (this == ROOT::Internal::gROOTLocal) { /// in that case next == this.; 302 next = nullptr;; 303 } else {; 304 next = ROOT::Internal::gROOTLocal;; 305 }; 306 } else {; 307 // We can not use 'cd' as this would access the current thread; 308 // rather than the thread corresponding to that gDirectory.; 309 next->RegisterGDirectory(ptr);; 310 }; 311 // Actually do the update of the thread local gDirectory; 312 // using its object specific lock.; 313 auto This = this;; 314 ptr->compare_exchange_strong(This, next);; 315 }; 316 }; 317 }; 318 for(auto &&context : extraWait) {; 319 // Wait until the TContext is done spinning; 320 // over the lock.; 321 while(context->fActiveDestructor);; 322 // And now let the TContext destructor finish.; 323 context->fDirectoryWait = false;; 324 }; 325 ; 326 // Wait until all register attempts are done.; 327 while(fContextPeg) {}; 328 ; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having; 333/// a compile time circular dependency ... alternatively we could (should?); 334/// introduce yet another abstract interface.; 3",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:57636,Security,access,access,57636,"kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:58446,Security,access,access,58446,"turning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::IsUsingRWLockR__ALWAYS_INLINE Bool_t IsUsingRWLock() constDefinition TCollection.h:212; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the implied list of context pointing to fPrevious.Definition TDirectory.h:95; TDirectory::TContext::fDirectorystd::atomic< TDirectory * > fDirectoryDefinition TDirectory.h:91; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::SharedGDirectory_tstd::shared_ptr< std::atomic< TDirectory * > > SharedGDirectory_tPointer to a list of TContext object pointing to this TDirectory.Definition TDirectory.h:147; TDirectory::cd1Bool_t cd1(const char *path)flag to add histograms, graphs,etc to the directoryDefinition TDirectory.cxx:581; TDirectory::Classstatic TClass * Class(); TDirectory::Deletevoid Delete(const char *namecycle="""") overrideDelete Objects or/and keys in a directory.Definition TDirectory.cxx:712; TDirectory::Closevirtual void Close(Option_t *option="""")Delete all objects from memory and d",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:67535,Security,hash,hash,67535,"ect *obj, Bool_t autoadd=kTRUE)Clone an object.Definition TDirectory.cxx:364; TDirectory::IsBuiltBool_t IsBuilt() constDefinition TDirectory.h:234; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TDirectory::RegisterContextvoid RegisterContext(TContext *ctxt)Register a TContext pointing to this TDirectory object.Definition TDirectory.cxx:1365; TDirectory::fListTList * fListDefinition TDirectory.h:142; TDirectory::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the directory.Definition TDirectory.cxx:1179; TDirectory::FindObjectAnyvirtual TObject * FindObjectAny(const char *name) constFind object by name in the list of memory objects of the current directory or its sub-directories.Definition TDirectory.cxx:796; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMethodEach ROOT class (see TClass) has ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:72806,Security,access,access,72806,"ierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TUUID::Streamervirtual void Streamer(TBuffer &); bool; int; unsigned int; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:119; ROOT::kExactMatch@ kExactMatchDefinition TDictionary.h:162; slashTCanvas * slash()Definition slash.C:1; Drawth1 Draw(); mTMarker mDefinition textangle.C:8. corebasesrcTDirectory.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8cxx_source.html:72840,Security,access,access,72840,"ierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kBoth@ kBothDefinition TString.h:276; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TUUID::Streamervirtual void Streamer(TBuffer &); bool; int; unsigned int; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::DirAutoAdd_tvoid(* DirAutoAdd_t)(void *, TDirectory *)Definition Rtypes.h:119; ROOT::kExactMatch@ kExactMatchDefinition TDictionary.h:162; slashTCanvas * slash()Definition slash.C:1; Drawth1 Draw(); mTMarker mDefinition textangle.C:8. corebasesrcTDirectory.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:06 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDirectory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html
https://root.cern/doc/master/TDirectory_8h.html:326,Integrability,depend,dependency,326,". ROOT: core/base/inc/TDirectory.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Macros ; TDirectory.h File Reference. #include ""TNamed.h""; #include ""TClass.h""; #include ""TUUID.h""; #include <atomic>; #include ""TList.h""; #include ""TBuffer.h"". Include dependency graph for TDirectory.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; struct  ROOT::Internal::TDirectoryAtomicAdapter;  Internal class used in the implementation of gDirectory The objects of type TDirectoryAtomicAdapter should only be used inside the thread that created them. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define gDirectory   (::ROOT::Internal::TDirectoryAtomicAdapter{});  . Macro Definition Documentation. ◆ gDirectory. #define gDirectory   (::ROOT::Internal::TDirectoryAtomicAdapter{}). Definition at line 384 of file TDirectory.h. corebaseincTDirectory.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TDirectory_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h.html
https://root.cern/doc/master/TDirectory_8h_source.html:3493,Performance,load,load,3493,"revious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).RegisterContext(this);; 115 if (newCurrent); 116 newCurrent->cd();; 117 else; 118 CdNull();; 119 }; 120 TContext() : fDirectory(TDirectory::CurrentDirectory().load()); 121 {; 122 // Store the current directory so we can restore it; 123 // later and cd to the new directory.; 124 RegisterCurrentDirectory();; 125 }; 126 TContext(TDirectory *newCurrent) : fDirectory(TDirectory::CurrentDirectory().load()); 127 {; 128 // Store the current directory so we can restore it; 129 // later and cd to the new directory.; 130 RegisterCurrentDirectory();; 131 if (newCurrent); 132 newCurrent->cd();; 133 else; 134 CdNull();; 135 }; 136 ~TContext();; 137 };; 138 ; 139protected:; 140 ; 141 TObject *fMother{nullptr}; // pointer to mother of the directory; 142 TList *fList{nullptr}; // List of objects in memory; 143 TUUID fUUID; // Unique identifier; 144 mutable TString fPathBuffer; //! Buffer for GetPath() function; 145 TContext *fContext{nullptr}; //! Pointer to a list of TContext object pointing to this TDirectory; 146 ; 147 using SharedGDirectory_t = std::shared_ptr<std::atomic<TDirectory *>>;; 148 ; 149 static SharedGDirectory_t &GetSharedLocalCurrentDirectory();; 150 ; 151 std::vector<SharedGDirectory_t> fGDirecto",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:3730,Performance,load,load,3730,"01 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).RegisterContext(this);; 115 if (newCurrent); 116 newCurrent->cd();; 117 else; 118 CdNull();; 119 }; 120 TContext() : fDirectory(TDirectory::CurrentDirectory().load()); 121 {; 122 // Store the current directory so we can restore it; 123 // later and cd to the new directory.; 124 RegisterCurrentDirectory();; 125 }; 126 TContext(TDirectory *newCurrent) : fDirectory(TDirectory::CurrentDirectory().load()); 127 {; 128 // Store the current directory so we can restore it; 129 // later and cd to the new directory.; 130 RegisterCurrentDirectory();; 131 if (newCurrent); 132 newCurrent->cd();; 133 else; 134 CdNull();; 135 }; 136 ~TContext();; 137 };; 138 ; 139protected:; 140 ; 141 TObject *fMother{nullptr}; // pointer to mother of the directory; 142 TList *fList{nullptr}; // List of objects in memory; 143 TUUID fUUID; // Unique identifier; 144 mutable TString fPathBuffer; //! Buffer for GetPath() function; 145 TContext *fContext{nullptr}; //! Pointer to a list of TContext object pointing to this TDirectory; 146 ; 147 using SharedGDirectory_t = std::shared_ptr<std::atomic<TDirectory *>>;; 148 ; 149 static SharedGDirectory_t &GetSharedLocalCurrentDirectory();; 150 ; 151 std::vector<SharedGDirectory_t> fGDirectories; //! thread local gDirectory pointing to this object.; 152 ; 153 std::atomic<size_t> fContextPeg{0}; //! Counter delaying the TDirectory destructor from finishing.; 154 mutable std::atomic_flag fSpinLock; //! MSVC doesn't support = ",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:14865,Performance,load,load,14865,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:14942,Performance,load,load,14942,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15007,Performance,load,load,15007,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15108,Performance,load,load,15108,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15212,Performance,load,load,15212,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15310,Performance,load,load,15310,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15408,Performance,load,load,15408,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:15681,Performance,load,load,15681,`; 329 /// dir = newvalue;; 330 /// ```; 331 /// leads to; 332 /// ```; 333 /// gDirectory == newvalue; 334 /// ```; 335 /// To prevent this we would need a new mechanism such that the type; 336 /// used by `auto` in that case is `TDirectory*` rather than the `Internal`; 337 /// type `TDirectoryAtomicAdapter`.; 338 struct TDirectoryAtomicAdapter {; 339 // The shared pointer's lifetime is that of the thread creating this object; 340 // (with the default constructor); 341 TDirectory::SharedGDirectory_t &fValue;; 342 ; 343 TDirectoryAtomicAdapter() : fValue(TDirectory::GetSharedLocalCurrentDirectory()) {}; 344 ; 345 template <typename T>; 346 explicit operator T*() const {; 347 return (T *)fValue->load();; 348 }; 349 ; 350 operator TDirectory*() const {; 351 return fValue->load();; 352 }; 353 ; 354 operator bool() const { return fValue->load() != nullptr; }; 355 ; 356 bool operator==(const TDirectory *other) const {; 357 return fValue->load() == other;; 358 }; 359 ; 360 bool operator!=(const TDirectory *other) const {; 361 return fValue->load() != other;; 362 }; 363 ; 364 bool operator==(TDirectory *other) const {; 365 return fValue->load() == other;; 366 }; 367 ; 368 bool operator!=(TDirectory *other) const {; 369 return fValue->load() != other;; 370 }; 371 ; 372 TDirectory *operator=(TDirectory *newvalue) {; 373 if (newvalue) {; 374 newvalue->RegisterGDirectory(fValue);; 375 }; 376 fValue->exchange(newvalue);; 377 return newvalue;; 378 }; 379 ; 380 TDirectory *operator->() const { return fValue->load(); }; 381 };; 382} // Internal; 383} // ROOT; 384#define gDirectory (::ROOT::Internal::TDirectoryAtomicAdapter{}); 385 ; 386#endif; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; O,MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:1898,Safety,safe,safe,1898,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:2418,Security,access,access,2418," public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).R",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:17571,Security,access,access,17571,":37; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectory::TContext::operator=TContext & operator=(TContext &)=delete; TDirectory::TContext::TContextTContext(TDirectory *previous, TDirectory *newCurrent)Definition TDirectory.h:108; TDirectory::TContext::fDirectoryWaitstd::atomic< bool > fDirectoryWaitSet to true during the destructor execution.Definition TDirectory.h:93; TDirectory::TContext::RegisterCurrentDirectoryvoid RegisterCurrentDirectory()Definition TDirectory.cxx:1344; TDirectory::TContext::CdNullvoid CdNull()Set the current directory to null.Definition TDirectory.cxx:133; TDirectory::TContext::TContextTContext(TDirectory *newCurrent)Definition TDirectory.h:126; TDirectory::TContext::~TContext~TContext()Destructor.Definition TDirectory.cxx:143; TDirectory::TContext::fPreviousTContext * fPreviousSet to true if a TDirectory might still access this object.Definition TDirectory.h:94; TDirectory::TContext::fActiveDestructorstd::atomic< bool > fActiveDestructorPointer to the previous current directory.Definition TDirectory.h:92; TDirectory::TContext::TContextTContext(TContext &)=deletePointer to the next TContext in the implied list of context pointing to fPrevious.; TDirectory::TContext::TContextTContext()Definition TDirectory.h:120; TDirectory::TContext::fNextTContext * fNextPointer to the next TContext in the implied list of context pointing to fPrevious.Definition TDirectory.h:95; TDirectory::TContext::fDirectorystd::atomic< TDirectory * > fDirectoryDefinition TDirectory.h:91; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::SharedGDirectory_tstd::shared_ptr< std::atomic< TDirectory * > > SharedGDirectory_tPointer to a list of TContext object pointing to this TDirectory.Definition TDirectory.h:147; TDirectory::GetSeekDirvirtual Long64_t G",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TDirectory_8h_source.html:1876,Usability,simpl,simpler,1876,"21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TNamed.h""; 25#include ""TClass.h""; 26#include ""TUUID.h""; 27#include <atomic>; 28 ; 29#ifdef R__LESS_INCLUDES; 30class TList;; 31#else; 32#include ""TList.h""; 33#include ""TBuffer.h""; 34// #include ""TDatime.h""; 35#endif; 36 ; 37class TBrowser;; 38class TKey;; 39class TFile;; 40namespace ROOT {; 41namespace Internal {; 42 struct TDirectoryAtomicAdapter;; 43}}; 44 ; 45class TDirectory : public TNamed {; 46public:; 47 ; 48/** \class TContext; 49\ingroup Base; 50 ; 51TDirectory::TContext keeps track and restore the current directory.; 52With this tool C++ exceptions will be guaranteed to properly restore the; 53current directory pointer.; 54 ; 55For example code like:; 56 ; 57~~~ {.cpp}; 58 TDirectory *sav = gDirectory;; 59 mydirectory->cd();; 60 if (...) {; 61 ....; 62 sav->cd();; 63 return;; 64 } else if (...) {; 65 ....; 66 sav->cd();; 67 return;; 68 }; 69 sav->cd;; 70 return;; 71~~~; 72 ; 73can be replaced with the simpler and exception safe:; 74 ; 75~~~ {.cpp}; 76 TDirectory::TContext context(gDirectory, mydirectory);; 77 if (...) {; 78 ....; 79 return;; 80 } else if (...) {; 81 ....; 82 return;; 83 }; 84 return;; 85~~~; 86 ; 87*/; 88 ; 89 class TContext {; 90 private:; 91 std::atomic<TDirectory*> fDirectory{nullptr}; //! Pointer to the previous current directory.; 92 std::atomic<bool> fActiveDestructor{false}; //! Set to true during the destructor execution; 93 std::atomic<bool> fDirectoryWait{false}; //! Set to true if a TDirectory might still access this object.; 94 TContext *fPrevious{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDi",MatchSource.WIKI,doc/master/TDirectory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html
https://root.cern/doc/master/TEfficiencyHelper_8h.html:287,Integrability,depend,dependency,287,". ROOT: hist/hist/src/TEfficiencyHelper.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TEfficiencyHelper.h File Reference. #include <algorithm>; #include <cmath>; #include <vector>; #include ""Math/PdfFuncMathCore.h"". Include dependency graph for TEfficiencyHelper.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  BinomialNeymanInterval< Sorter >;  Implement noncentral binomial confidence intervals using the Neyman construction. More...;  ; class  BinomialProbHelper;  Helper class impelementing the binomial probability and the likelihood ratio used for ordering the interval in the FeldmanCousins interval class. More...;  ; class  FeldmanCousinsBinomialInterval;  ; struct  FeldmanCousinsSorter;  . histhistsrcTEfficiencyHelper.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEfficiencyHelper_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiencyHelper_8h.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:3152,Availability,error,error,3152,"f EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\anchor EFF02; 96## II. Creating a TEfficiency object; 97If you start a new analysis, it is highly recommended to use the TEfficiency class; 98from the beginning. You can then use one of the constructors for fixed or; 99variable bin size and your desired dimen",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:10939,Availability,error,error,10939,"e can also be used as a value for the estimated efficiency. This can be done by calling; 238SetBit(kPosteriorMode) or TEfficiency::SetPosteriorMode. In this case, the estimated efficiency is:; 239 ; 240\f[; 241 \hat{\varepsilon} = \frac{k + \alpha -1}{N + \alpha + \beta - 2}; 242\f]; 243 ; 244In the case of a uniform prior distribution, B(x,1,1), the posterior mode is k/n, equivalent to the frequentist; 245estimate (the maximum likelihood value).; 246 ; 247The statistic options also specify which confidence interval is used for calculating; 248the uncertainties of the efficiency. The following properties define the error; 249calculation:; 250- **fConfLevel:** desired confidence level: 0 < fConfLevel < 1 (TEfficiency::GetConfidenceLevel / TEfficiency::SetConfidenceLevel); 251- **fStatisticOption** defines which method is used to calculate the boundaries of the confidence interval (TEfficiency::SetStatisticOption); 252- **fBeta_alpha, fBeta_beta:** parameters for the prior distribution which is only used in the bayesian case (TEfficiency::GetBetaAlpha / TEfficiency::GetBetaBeta / TEfficiency::SetBetaAlpha / TEfficiency::SetBetaBeta); 253- **kIsBayesian:** flag whether bayesian statistics are used or not (TEfficiency::UsesBayesianStat); 254- **kShortestInterval:** flag whether shortest interval (instead of central one) are used in case of Bayesian statistics (TEfficiency::UsesShortestInterval). Normally shortest interval should be used in combination with the mode (see TEfficiency::UsesPosteriorMode); 255- **fWeight:** global weight for this TEfficiency object which is used during combining or merging with other TEfficiency objects(TEfficiency::GetWeight / TEfficiency::SetWeight); 256 ; 257In the following table, the implemented confidence intervals are listed; 258with their corresponding statistic option. For more details on the calculation,; 259please have a look at the mentioned functions.; 260 ; 261 ; 262| name | statistic option | function | kIsBayesian | paramete",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:51441,Availability,toler,tolerance,51441,"/////////////////////////////////////////////////////; 1217/// Calculates the boundaries using the mid-P binomial; 1218/// interval (Lancaster method) from B. Cousing and J. Tucker.; 1219/// See http://arxiv.org/abs/0905.3831 for a description and references for the method; 1220///; 1221/// Modify equal_tailed to get the kind of interval you want.; 1222/// Can also be converted to interval on ratio of poisson means X/Y by the substitutions; 1223/// ~~~ {.cpp}; 1224/// X = passed; 1225/// total = X + Y; 1226/// lower_poisson = lower/(1 - lower); 1227/// upper_poisson = upper/(1 - upper); 1228/// ~~~; 1229 ; 1230Double_t TEfficiency::MidPInterval(Double_t total,Double_t passed,Double_t level,Bool_t bUpper); 1231{; 1232 const double alpha = 1. - level;; 1233 const bool equal_tailed = true; // change if you don;t want equal tailed interval; 1234 const double alpha_min = equal_tailed ? alpha/2 : alpha;; 1235 const double tol = 1e-9; // tolerance; 1236 double pmin = 0;; 1237 double pmax = 0;; 1238 double p = 0;; 1239 ; 1240 pmin = 0; pmax = 1;; 1241 ; 1242 ; 1243 // treat special case for 0<passed<1; 1244 // do a linear interpolation of the upper limit values; 1245 if ( passed > 0 && passed < 1) {; 1246 double p0 = MidPInterval(total,0.0,level,bUpper);; 1247 double p1 = MidPInterval(total,1.0,level,bUpper);; 1248 p = (p1 - p0) * passed + p0;; 1249 return p;; 1250 }; 1251 ; 1252 while (std::abs(pmax - pmin) > tol) {; 1253 p = (pmin + pmax)/2;; 1254 //double v = 0.5 * ROOT::Math::binomial_pdf(int(passed), p, int(total));; 1255 // make it work for non integer using the binomial - beta relationship; 1256 double v = 0.5 * ROOT::Math::beta_pdf(p, passed+1., total-passed+1)/(total+1);; 1257 //if (passed > 0) v += ROOT::Math::binomial_cdf(int(passed - 1), p, int(total));; 1258 // compute the binomial cdf at passed -1; 1259 if ( (passed-1) >= 0) v += ROOT::Math::beta_cdf_c(p, passed, total-passed+1);; 1260 ; 1261 double vmin = (bUpper) ? alpha_min : 1.- alpha_min;; 1262 if (v > vm",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:67287,Availability,toler,tolerance,67287,"; break;; 1621 case 3: nbins = (nbinsx + 2) * (nbinsy + 2) * (nbinsz + 2); break;; 1622 default: nbins = 0;; 1623 }; 1624 ; 1625 for(Int_t i = 0; i < nbins; ++i) {; 1626 if(pass.GetBinContent(i) > total.GetBinContent(i)) {; 1627 gROOT->Info(""TEfficiency::CheckEntries"",""Histograms are not consistent: passed bin content > total bin content"");; 1628 return false;; 1629 }; 1630 }; 1631 ; 1632 return true;; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Check if both histogram are weighted. If they are weighted a true is returned; 1637///; 1638Bool_t TEfficiency::CheckWeights(const TH1& pass,const TH1& total); 1639{; 1640 if (pass.GetSumw2N() == 0 && total.GetSumw2N() == 0) return false;; 1641 ; 1642 // check also that the total sum of weight and weight squares are consistent; 1643 Double_t statpass[TH1::kNstat];; 1644 Double_t stattotal[TH1::kNstat];; 1645 ; 1646 pass.GetStats(statpass);; 1647 total.GetStats(stattotal);; 1648 ; 1649 double tolerance = (total.IsA() == TH1F::Class() ) ? 1.E-5 : 1.E-12;; 1650 ; 1651 //require: sum of weights == sum of weights^2; 1652 if(!TMath::AreEqualRel(statpass[0],statpass[1],tolerance) ||; 1653 !TMath::AreEqualRel(stattotal[0],stattotal[1],tolerance) ) {; 1654 return true;; 1655 }; 1656 ; 1657 // histograms are not weighted; 1658 return false;; 1659 ; 1660}; 1661 ; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// Create the graph used be painted (for dim=1 TEfficiency); 1665/// The return object is managed by the caller; 1666 ; 1667TGraphAsymmErrors * TEfficiency::CreateGraph(Option_t * opt) const; 1668{; 1669 if (GetDimension() != 1) {; 1670 Error(""CreatePaintingGraph"",""Call this function only for dimension == 1"");; 1671 return nullptr;; 1672 }; 1673 ; 1674 Int_t npoints = fTotalHistogram->GetNbinsX();; 1675 TGraphAsymmErrors * graph = new TGraphAsymmErrors(npoints);; 1676 graph->SetName(""eff_graph"");; 1677 FillGraph(graph",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:67461,Availability,toler,tolerance,67461,,MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:67527,Availability,toler,tolerance,67527,,MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:96156,Availability,error,errors,96156,"::vector<Double_t> xlow(nbins_max);; 2337 std::vector<Double_t> xhigh(nbins_max);; 2338 std::vector<Double_t> eff(nbins_max);; 2339 std::vector<Double_t> efflow(nbins_max);; 2340 std::vector<Double_t> effhigh(nbins_max);; 2341 ; 2342 //parameters for combining:; 2343 //number of objects; 2344 Int_t num = vTotal.size();; 2345 std::vector<Int_t> pass(num);; 2346 std::vector<Int_t> total(num);; 2347 ; 2348 //loop over all bins; 2349 Double_t low = 0;; 2350 Double_t up = 0;; 2351 for(Int_t i=1; i <= nbins_max; ++i) {; 2352 //the binning of the x-axis is taken from the first total histogram; 2353 x[i-1] = vTotal.at(0)->GetBinCenter(i);; 2354 xlow[i-1] = x[i-1] - vTotal.at(0)->GetBinLowEdge(i);; 2355 xhigh[i-1] = vTotal.at(0)->GetBinWidth(i) - xlow[i-1];; 2356 ; 2357 for(Int_t j = 0; j < num; ++j) {; 2358 pass[j] = (Int_t)(vPassed.at(j)->GetBinContent(i) + 0.5);; 2359 total[j] = (Int_t)(vTotal.at(j)->GetBinContent(i) + 0.5);; 2360 }; 2361 ; 2362 //fill efficiency and errors; 2363 eff[i-1] = Combine(up,low,num,&pass[0],&total[0],alpha,beta,level,&vWeights[0],opt.Data());; 2364 //did an error occurred ?; 2365 if(eff[i-1] == -1) {; 2366 gROOT->Error(""TEfficiency::Combine"",""error occurred during combining"");; 2367 gROOT->Info(""TEfficiency::Combine"",""stop combining"");; 2368 return nullptr;; 2369 }; 2370 efflow[i-1]= eff[i-1] - low;; 2371 effhigh[i-1]= up - eff[i-1];; 2372 }//loop over all bins; 2373 ; 2374 TGraphAsymmErrors* gr = new TGraphAsymmErrors(nbins_max,&x[0],&eff[0],&xlow[0],&xhigh[0],&efflow[0],&effhigh[0]);; 2375 ; 2376 return gr;; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Compute distance from point px,py to a graph.; 2381///; 2382/// Compute the closest distance of approach from point px,py to this line.; 2383/// The distance is computed in pixels units.; 2384///; 2385/// Forward the call to the painted graph; 2386 ; 2387Int_t TEfficiency::DistancetoPrimitive(Int_t px, Int_t py); 2388{; 2389 if (fPai",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:96276,Availability,error,error,96276,");; 2347 ; 2348 //loop over all bins; 2349 Double_t low = 0;; 2350 Double_t up = 0;; 2351 for(Int_t i=1; i <= nbins_max; ++i) {; 2352 //the binning of the x-axis is taken from the first total histogram; 2353 x[i-1] = vTotal.at(0)->GetBinCenter(i);; 2354 xlow[i-1] = x[i-1] - vTotal.at(0)->GetBinLowEdge(i);; 2355 xhigh[i-1] = vTotal.at(0)->GetBinWidth(i) - xlow[i-1];; 2356 ; 2357 for(Int_t j = 0; j < num; ++j) {; 2358 pass[j] = (Int_t)(vPassed.at(j)->GetBinContent(i) + 0.5);; 2359 total[j] = (Int_t)(vTotal.at(j)->GetBinContent(i) + 0.5);; 2360 }; 2361 ; 2362 //fill efficiency and errors; 2363 eff[i-1] = Combine(up,low,num,&pass[0],&total[0],alpha,beta,level,&vWeights[0],opt.Data());; 2364 //did an error occurred ?; 2365 if(eff[i-1] == -1) {; 2366 gROOT->Error(""TEfficiency::Combine"",""error occurred during combining"");; 2367 gROOT->Info(""TEfficiency::Combine"",""stop combining"");; 2368 return nullptr;; 2369 }; 2370 efflow[i-1]= eff[i-1] - low;; 2371 effhigh[i-1]= up - eff[i-1];; 2372 }//loop over all bins; 2373 ; 2374 TGraphAsymmErrors* gr = new TGraphAsymmErrors(nbins_max,&x[0],&eff[0],&xlow[0],&xhigh[0],&efflow[0],&effhigh[0]);; 2375 ; 2376 return gr;; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Compute distance from point px,py to a graph.; 2381///; 2382/// Compute the closest distance of approach from point px,py to this line.; 2383/// The distance is computed in pixels units.; 2384///; 2385/// Forward the call to the painted graph; 2386 ; 2387Int_t TEfficiency::DistancetoPrimitive(Int_t px, Int_t py); 2388{; 2389 if (fPaintGraph) return fPaintGraph->DistancetoPrimitive(px,py);; 2390 if (fPaintHisto) return fPaintHisto->DistancetoPrimitive(px,py);; 2391 return 0;; 2392}; 2393 ; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Draws the current TEfficiency object; 2397///; 2398/// \param[in] opt; 2399/// - 1-dimensional case: same options as TGraphAsymmErr",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:96363,Availability,error,error,96363,");; 2347 ; 2348 //loop over all bins; 2349 Double_t low = 0;; 2350 Double_t up = 0;; 2351 for(Int_t i=1; i <= nbins_max; ++i) {; 2352 //the binning of the x-axis is taken from the first total histogram; 2353 x[i-1] = vTotal.at(0)->GetBinCenter(i);; 2354 xlow[i-1] = x[i-1] - vTotal.at(0)->GetBinLowEdge(i);; 2355 xhigh[i-1] = vTotal.at(0)->GetBinWidth(i) - xlow[i-1];; 2356 ; 2357 for(Int_t j = 0; j < num; ++j) {; 2358 pass[j] = (Int_t)(vPassed.at(j)->GetBinContent(i) + 0.5);; 2359 total[j] = (Int_t)(vTotal.at(j)->GetBinContent(i) + 0.5);; 2360 }; 2361 ; 2362 //fill efficiency and errors; 2363 eff[i-1] = Combine(up,low,num,&pass[0],&total[0],alpha,beta,level,&vWeights[0],opt.Data());; 2364 //did an error occurred ?; 2365 if(eff[i-1] == -1) {; 2366 gROOT->Error(""TEfficiency::Combine"",""error occurred during combining"");; 2367 gROOT->Info(""TEfficiency::Combine"",""stop combining"");; 2368 return nullptr;; 2369 }; 2370 efflow[i-1]= eff[i-1] - low;; 2371 effhigh[i-1]= up - eff[i-1];; 2372 }//loop over all bins; 2373 ; 2374 TGraphAsymmErrors* gr = new TGraphAsymmErrors(nbins_max,&x[0],&eff[0],&xlow[0],&xhigh[0],&efflow[0],&effhigh[0]);; 2375 ; 2376 return gr;; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Compute distance from point px,py to a graph.; 2381///; 2382/// Compute the closest distance of approach from point px,py to this line.; 2383/// The distance is computed in pixels units.; 2384///; 2385/// Forward the call to the painted graph; 2386 ; 2387Int_t TEfficiency::DistancetoPrimitive(Int_t px, Int_t py); 2388{; 2389 if (fPaintGraph) return fPaintGraph->DistancetoPrimitive(px,py);; 2390 if (fPaintHisto) return fPaintHisto->DistancetoPrimitive(px,py);; 2391 return 0;; 2392}; 2393 ; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Draws the current TEfficiency object; 2397///; 2398/// \param[in] opt; 2399/// - 1-dimensional case: same options as TGraphAsymmErr",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:98042,Availability,error,error,98042,"rors* gr = new TGraphAsymmErrors(nbins_max,&x[0],&eff[0],&xlow[0],&xhigh[0],&efflow[0],&effhigh[0]);; 2375 ; 2376 return gr;; 2377}; 2378 ; 2379////////////////////////////////////////////////////////////////////////////////; 2380/// Compute distance from point px,py to a graph.; 2381///; 2382/// Compute the closest distance of approach from point px,py to this line.; 2383/// The distance is computed in pixels units.; 2384///; 2385/// Forward the call to the painted graph; 2386 ; 2387Int_t TEfficiency::DistancetoPrimitive(Int_t px, Int_t py); 2388{; 2389 if (fPaintGraph) return fPaintGraph->DistancetoPrimitive(px,py);; 2390 if (fPaintHisto) return fPaintHisto->DistancetoPrimitive(px,py);; 2391 return 0;; 2392}; 2393 ; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Draws the current TEfficiency object; 2397///; 2398/// \param[in] opt; 2399/// - 1-dimensional case: same options as TGraphAsymmErrors::Draw(); 2400/// but as default ""AP"" is used; 2401/// - 2-dimensional case: by default use an histogram and in this case same options as TH2::Draw(); 2402/// if using instad option ""GRAPH"" a TGraph2DAsymmErrors is used and; 2403/// the same options as for TGraph2D applies; 2404/// - 3-dimensional case: not yet supported; 2405///; 2406/// Specific TEfficiency drawing options:; 2407/// - E0 - plot bins where the total number of passed events is zero; 2408/// (the error interval will be [0,1] ); 2409 ; 2410void TEfficiency::Draw(Option_t* opt); 2411{; 2412 //check options; 2413 TString option = opt;; 2414 option.ToLower();; 2415 ; 2416 if(gPad && !option.Contains(""same"")); 2417 gPad->Clear();; 2418 ; 2419 if (GetDimension() == 2) {; 2420 if (option.IsNull()) option = ""colz"";; 2421 } else {; 2422 // use by default ""AP""; 2423 if (option.IsNull()) option = ""ap"";; 2424 // add always ""a"" if not present; 2425 if (!option.Contains(""same"") && !option.Contains(""a"") ) option += ""a"";; 2426 // add always p to the option; 2427 if (!optio",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:109445,Availability,error,error,109445,"f the denominator is equal to 0, an efficiency of 0 is returned.; 2678/// - When \f$ passed + \alpha < 1 \f$ or \f$ total - passed + \beta < 1 \f$ the above; 2679/// formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.; 2680 ; 2681Double_t TEfficiency::GetEfficiency(Int_t bin) const; 2682{; 2683 Double_t total = fTotalHistogram->GetBinContent(bin);; 2684 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2685 ; 2686 if(TestBit(kIsBayesian)) {; 2687 ; 2688 // parameters for the beta prior distribution; 2689 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2690 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2691 ; 2692 Double_t aa,bb;; 2693 if(TestBit(kUseWeights)); 2694 {; 2695 Double_t tw = fTotalHistogram->GetBinContent(bin);; 2696 Double_t tw2 = fTotalHistogram->GetSumw2()->At(bin);; 2697 Double_t pw = fPassedHistogram->GetBinContent(bin);; 2698 ; 2699 if (tw2 <= 0 ) return pw/tw;; 2700 ; 2701 // tw/tw2 renormalize the weights; 2702 double norm = tw/tw2;; 2703 aa = pw * norm + alpha;; 2704 bb = (tw - pw) * norm + beta;; 2705 }; 2706 else; 2707 {; 2708 aa = passed + alpha;; 2709 bb = total - passed + beta;; 2710 }; 2711 ; 2712 if (!TestBit(kPosteriorMode) ); 2713 return BetaMean(aa,bb);; 2714 else; 2715 return BetaMode(aa,bb);; 2716 ; 2717 }; 2718 else; 2719 return (total)? ((Double_t)passed)/total : 0;; 2720}; 2721 ; 2722////////////////////////////////////////////////////////////////////////////////; 2723/// Returns the lower error on the efficiency in the given global bin; 2724///; 2725/// The result depends on the current confidence level fConfLevel and the; 2726/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2727/// more details.; 2728///; 2729/// Note: If the histograms are filled with weights, only bayesian methods and the; 2730/// normal approximation are supported.; 2731 ; 2732Double_t TEfficiency::GetEfficiencyErrorLow(In",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:111743,Availability,error,errors,111743,"; 2770 {; 2771 if(fStatisticOption != kFNormal); 2772 {; 2773 Warning(""GetEfficiencyErrorLow"",""frequentist confidence intervals for weights are only supported by the normal approximation"");; 2774 Info(""GetEfficiencyErrorLow"",""setting statistic option to kFNormal"");; 2775 const_cast<TEfficiency*>(this)->SetStatisticOption(kFNormal);; 2776 }; 2777 ; 2778 Double_t variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 2779 Double_t sigma = sqrt(variance);; 2780 ; 2781 Double_t prob = 0.5 * (1.- fConfLevel);; 2782 Double_t delta = ROOT::Math::normal_quantile_c(prob, sigma);; 2783 ; 2784 // avoid to return errors which makes eff-err < 0; 2785 return (eff - delta < 0) ? eff : delta;; 2786 }; 2787 }; 2788 else; 2789 {; 2790 if(TestBit(kIsBayesian)); 2791 {; 2792 // parameters for the beta prior distribution; 2793 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2794 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2795 return (eff - Bayesian(total,passed,fConfLevel,alpha,beta,false,TestBit(kShortestInterval)));; 2796 }; 2797 else; 2798 return (eff - fBoundary(total,passed,fConfLevel,false));; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Returns the upper error on the efficiency in the given global bin; 2804///; 2805/// The result depends on the current confidence level fConfLevel and the; 2806/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2807/// more details.; 2808///; 2809/// Note: If the histograms are filled with weights, only bayesian methods and the; 2810/// normal approximation are supported.; 2811 ; 2812Double_t TEfficiency::GetEfficiencyErrorUp(Int_t bin) const; 2813{; 2814 Double_t total = fTotalHistogram->GetBinContent(bin);; 2815 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2816 ; 2817 Double_t eff = GetEfficiency(bin);; 2818 ; 2819 // check whether weights have been used; 2820 i",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:112426,Availability,error,error,112426,"; 2770 {; 2771 if(fStatisticOption != kFNormal); 2772 {; 2773 Warning(""GetEfficiencyErrorLow"",""frequentist confidence intervals for weights are only supported by the normal approximation"");; 2774 Info(""GetEfficiencyErrorLow"",""setting statistic option to kFNormal"");; 2775 const_cast<TEfficiency*>(this)->SetStatisticOption(kFNormal);; 2776 }; 2777 ; 2778 Double_t variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 2779 Double_t sigma = sqrt(variance);; 2780 ; 2781 Double_t prob = 0.5 * (1.- fConfLevel);; 2782 Double_t delta = ROOT::Math::normal_quantile_c(prob, sigma);; 2783 ; 2784 // avoid to return errors which makes eff-err < 0; 2785 return (eff - delta < 0) ? eff : delta;; 2786 }; 2787 }; 2788 else; 2789 {; 2790 if(TestBit(kIsBayesian)); 2791 {; 2792 // parameters for the beta prior distribution; 2793 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2794 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2795 return (eff - Bayesian(total,passed,fConfLevel,alpha,beta,false,TestBit(kShortestInterval)));; 2796 }; 2797 else; 2798 return (eff - fBoundary(total,passed,fConfLevel,false));; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Returns the upper error on the efficiency in the given global bin; 2804///; 2805/// The result depends on the current confidence level fConfLevel and the; 2806/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2807/// more details.; 2808///; 2809/// Note: If the histograms are filled with weights, only bayesian methods and the; 2810/// normal approximation are supported.; 2811 ; 2812Double_t TEfficiency::GetEfficiencyErrorUp(Int_t bin) const; 2813{; 2814 Double_t total = fTotalHistogram->GetBinContent(bin);; 2815 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2816 ; 2817 Double_t eff = GetEfficiency(bin);; 2818 ; 2819 // check whether weights have been used; 2820 i",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:133330,Availability,avail,available,133330,"a_beta = beta;; 3351 else; 3352 Warning(""SetBetaBeta(Double_t)"",""invalid shape parameter %.2lf"",beta);; 3353}; 3354 ; 3355////////////////////////////////////////////////////////////////////////////////; 3356/// Sets different shape parameter &alpha; and &beta;; 3357/// for the prior distribution for each bin. By default the global parameter are used if they are not set; 3358/// for the specific bin; 3359/// The prior probability of the efficiency is given by the beta distribution:; 3360/// \f[; 3361/// f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}; 3362/// \f]; 3363///; 3364/// Note:; 3365/// - both shape parameters have to be positive (i.e. > 0); 3366/// - bin gives the global bin number (cf. GetGlobalBin); 3367 ; 3368void TEfficiency::SetBetaBinParameters(Int_t bin, Double_t alpha, Double_t beta); 3369{; 3370 if (!fPassedHistogram || !fTotalHistogram) return;; 3371 TH1 * h1 = fTotalHistogram;; 3372 // doing this I get h1->fN which is available only for a TH1D; 3373 UInt_t n = h1->GetBin(h1->GetNbinsX()+1, h1->GetNbinsY()+1, h1->GetNbinsZ()+1 ) + 1;; 3374 ; 3375 // in case vector is not created do with default alpha, beta params; 3376 if (fBeta_bin_params.size() != n ); 3377 fBeta_bin_params = std::vector<std::pair<Double_t, Double_t> >(n, std::make_pair(fBeta_alpha, fBeta_beta) );; 3378 ; 3379 // vector contains also values for under/overflows; 3380 fBeta_bin_params[bin] = std::make_pair(alpha,beta);; 3381 SetBit(kUseBinPrior,true);; 3382 ; 3383}; 3384 ; 3385////////////////////////////////////////////////////////////////////////////////; 3386/// Set the bins for the underlined passed and total histograms; 3387/// If the class have been already filled the previous contents will be lost; 3388 ; 3389Bool_t TEfficiency::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 3390{; 3391 if (GetDimension() != 1) {; 3392 Error(""SetBins"",""Using wrong SetBins function for a %d-d histogram"",GetDimension());; 3393 retur",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:156816,Availability,toler,tolerance,156816,"nition TROOT.h:406; TStyle.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; WrappedFunction.h; BinomialNeymanInterval::Lowerdouble Lower() constDefinition TEfficiencyHelper.h:163; BinomialNeymanInterval::Upperdouble Upper() constDefinition TEfficiencyHelper.h:164; BinomialNeymanInterval::Initvoid Init(double alpha)Definition TEfficiencyHelper.h:79; BinomialNeymanInterval::Calculatevoid Calculate(const double X, const double n)Definition TEfficiencyHelper.h:128; FeldmanCousinsBinomialIntervalDefinition TEfficiencyHelper.h:187; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; TArrayD::AtDouble_t At(Int_t i) constDefinition TArrayD.h:79; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::GetArrayconst Double_t * GetArray() constDefinition TArrayD.h:43; TArray::fNInt_t fNDefinition TArray.h:38; TAttFillFill Area Attributes class.Definition TAttFill.",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:166967,Availability,error,error,166967,"cy::GetDimensionInt_t GetDimension() constreturns the dimension of the current TEfficiency objectDefinition TEfficiency.cxx:2659; TEfficiency::fPaintGraph2DTGraph2DAsymmErrors * fPaintGraph2D! Temporary graph for paintingDefinition TEfficiency.h:56; TEfficiency::operator+=TEfficiency & operator+=(const TEfficiency &rhs)Adds the histograms of another TEfficiency object to current histograms.Definition TEfficiency.cxx:2979; TEfficiency::SetBinsBool_t SetBins(Int_t nx, Double_t xmin, Double_t xmax)Set the bins for the underlined passed and total histograms If the class have been already filled the...Definition TEfficiency.cxx:3389; TEfficiency::Buildvoid Build(const char *name, const char *title)Building standard data structure of a TEfficiency object.Definition TEfficiency.cxx:1505; TEfficiency::GetCopyPassedHistoTH1 * GetCopyPassedHisto() constReturns a cloned version of fPassedHistogram.Definition TEfficiency.cxx:2617; TEfficiency::GetEfficiencyErrorUpDouble_t GetEfficiencyErrorUp(Int_t bin) constReturns the upper error on the efficiency in the given global bin.Definition TEfficiency.cxx:2812; TEfficiency::fBeta_alphaDouble_t fBeta_alphaGlobal parameter for prior beta distribution (default = 1)Definition TEfficiency.h:47; TEfficiency::UsesBayesianStatBool_t UsesBayesianStat() constDefinition TEfficiency.h:161; TEfficiency::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *opt="""") overrideHave histograms fixed bins along each axis?Definition TEfficiency.cxx:3155; TEfficiency::SetBetaBetavoid SetBetaBeta(Double_t beta)Sets the shape parameter β.Definition TEfficiency.cxx:3347; TEfficiency::GetConfidenceLevelDouble_t GetConfidenceLevel() constDefinition TEfficiency.h:112; TEfficiency::CheckBinningstatic Bool_t CheckBinning(const TH1 &pass, const TH1 &total)Checks binning for each axis.Definition TEfficiency.cxx:1527; TEfficiency::SetNamevoid SetName(const char *name) overrideSets the name.Definition TEfficiency.cxx:3547; TEfficiency::CreateGraph2DTGraph2DAsym",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:174804,Availability,error,error,174804,"eta)Sets different shape parameter α and β for the prior distribution for each bin.Definition TEfficiency.cxx:3368; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::GetWeightDouble_t GetWeight() constDefinition TEfficiency.h:128; TEfficiency::GetCopyTotalHistoTH1 * GetCopyTotalHisto() constReturns a cloned version of fTotalHistogram.Definition TEfficiency.cxx:2647; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TEfficiency::SetConfidenceLevelvoid SetConfidenceLevel(Double_t level)Sets the confidence level (0 < level < 1) The default value is 1-sigma :~ 0.683.Definition TEfficiency.cxx:3511; TEfficiency::GetEfficiencyErrorLowDouble_t GetEfficiencyErrorLow(Int_t bin) constReturns the lower error on the efficiency in the given global bin.Definition TEfficiency.cxx:2732; TEfficiency::EStatOptionEStatOptionEnumeration type for different statistic options for calculating confidence intervals kF* ....Definition TEfficiency.h:33; TEfficiency::kBJeffrey@ kBJeffreyJeffrey interval (Prior ~ Beta(0.5,0.5)Definition TEfficiency.h:39; TEfficiency::kFWilson@ kFWilsonWilson interval.Definition TEfficiency.h:36; TEfficiency::kFAC@ kFACAgresti-Coull interval.Definition TEfficiency.h:37; TEfficiency::kMidP@ kMidPMid-P Lancaster interval.Definition TEfficiency.h:42; TEfficiency::kBUniform@ kBUniformPrior ~ Uniform = Beta(1,1)Definition TEfficiency.h:40; TEfficiency::kFFC@ kFFCFeldman-Cousins interval.Definition TEfficiency.h:38; TEfficiency::kBBayesian@ kBBayesianUser specified Prior ~ Beta(fBeta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal@ kFNormalNormal approximation.Definition TEfficiency.h:35; TEfficiency::kFCP@ kFCPClopper-Pearson",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:176624,Availability,error,errors,176624,"eta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal@ kFNormalNormal approximation.Definition TEfficiency.h:35; TEfficiency::kFCP@ kFCPClopper-Pearson interval (recommended by PDG)Definition TEfficiency.h:34; TEfficiency::SetTitlevoid SetTitle(const char *title) overrideSets the title.Definition TEfficiency.cxx:3726; TEfficiency::FitTFitResultPtr Fit(TF1 *f1, Option_t *opt="""")Fits the efficiency using the TBinomialEfficiencyFitter class.Definition TEfficiency.cxx:2555; TEfficiency::fPaintHistoTH2 * fPaintHisto! Temporary histogram for paintingDefinition TEfficiency.h:57; TF11-Dim function classDefinition TF1.h:233; TF1::Classstatic TClass * Class(); TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::IsATClass * IsA() const overrideDefinition TF1.h:755; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TGraph2DAsymmErrorsGraph 2D class with errors.Definition TGraph2DAsymmErrors.h:26; TGraph2D::Paintvoid Paint(Option_t *option="""") overridePaints this 2D graph with its current attributes.Definition TGraph2D.cxx:1270; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraph.cxx:879; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1F::Classstatic TC",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:176842,Availability,error,error,176842,"ency.h:34; TEfficiency::SetTitlevoid SetTitle(const char *title) overrideSets the title.Definition TEfficiency.cxx:3726; TEfficiency::FitTFitResultPtr Fit(TF1 *f1, Option_t *opt="""")Fits the efficiency using the TBinomialEfficiencyFitter class.Definition TEfficiency.cxx:2555; TEfficiency::fPaintHistoTH2 * fPaintHisto! Temporary histogram for paintingDefinition TEfficiency.h:57; TF11-Dim function classDefinition TF1.h:233; TF1::Classstatic TClass * Class(); TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::IsATClass * IsA() const overrideDefinition TF1.h:755; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TGraph2DAsymmErrorsGraph 2D class with errors.Definition TGraph2DAsymmErrors.h:26; TGraph2D::Paintvoid Paint(Option_t *option="""") overridePaints this 2D graph with its current attributes.Definition TGraph2D.cxx:1270; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraph::Paintvoid Paint(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:1977; TGraph::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TGraph.cxx:1056; TGraph::PaintStatsvirtual void PaintStats(TF1 *fit)Draw the stats.Definition TGraph.cxx:2004; TGraph::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a graph.Definition TGraph.cxx:879; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1F::Classstatic TClass * Class(); TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:178957,Availability,error,errors,178957,"SetNormFactor(Double_t factor=1)Definition TH1.h:410; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::GetStatsvirtual void GetStats(Double_t *stats) constfill the array stats from the contents of this histogram The array stats must be correctly dimensione...Definition TH1.cxx:7833; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(I",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:179452,Availability,error,errors,179452,"m The array stats must be correctly dimensione...Definition TH1.cxx:7833; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::GetDimensionvirtual Int_t GetDimension() constDefinition TH1.h:283; TH1::kIsAverage@ kIsAverageBin contents are average (used by Add)Definition TH1.h:171; TH1::Resetvirtual void Reset(Option_t *option="""")Reset this histogram: contents, errors, etc.Definition TH1.cxx:7103; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNcellsvirtual Int_t GetNcells() constDefinition TH1.h:300; TH1::GetBinvirtual Int_t GetBin(Int_t binx, Int_t biny=0, Int_t binz=0) constReturn Global bin number corresponding to binx,y,z.Definition TH1.cxx:4961; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Defi",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184221,Availability,error,error,184221,"estBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184357,Availability,error,error,184357,"h the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:18765,Deployability,continuous,continuously,18765," possible true efficiencies) coverage probability for; 414different number of total events is shown in the next picture.; 415 ; 416\image html av_cov.png ""Average Coverage""; 417 ; 418\anchor EFF05; 419## V. Merging and combining TEfficiency objects; 420In many applications, the efficiency should be calculated for an inhomogeneous; 421sample in the sense that it contains events with different weights. In order; 422to be able to determine the correct overall efficiency, it is necessary to; 423use for each subsample (= all events with the same weight) a different; 424TEfficiency object. After finishing your analysis you can then construct the; 425overall efficiency with its uncertainty.; 426 ; 427This procedure has the advantage that you can change the weight of one; 428subsample easily without rerunning the whole analysis. On the other hand, more; 429effort is needed to handle several TEfficiency objects instead of one; 430histogram. In the case of many different or even continuously distributed; 431weights, this approach becomes cumbersome. One possibility to overcome this; 432problem is the usage of binned weights.; 433 ; 434\anchor EFF05a; 435### Example; 436In particle physics weights arises from the fact that you want to; 437normalise your results to a certain reference value. A very common formula for; 438calculating weights is; 439 ; 440\f{eqnarray*}{; 441 w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; 442 &-& \sigma ...\ cross\ section \\; 443 &-& L ...\ luminosity \\; 444 &-& N_{gen}\ ... number\ of\ generated\ events \\; 445 &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; 446\f}; 447 ; 448The reason for different weights can therefore be:; 449- different processes; 450- other integrated luminosity; 451- varying trigger efficiency; 452- different sample sizes; 453- ...; 454- or even combination of them; 455 ; 456Depending on the actual meaning of different weights in your case, you; 457should either merge or combine them to get the overall effi",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:19509,Deployability,integrat,integrated,19509,"This procedure has the advantage that you can change the weight of one; 428subsample easily without rerunning the whole analysis. On the other hand, more; 429effort is needed to handle several TEfficiency objects instead of one; 430histogram. In the case of many different or even continuously distributed; 431weights, this approach becomes cumbersome. One possibility to overcome this; 432problem is the usage of binned weights.; 433 ; 434\anchor EFF05a; 435### Example; 436In particle physics weights arises from the fact that you want to; 437normalise your results to a certain reference value. A very common formula for; 438calculating weights is; 439 ; 440\f{eqnarray*}{; 441 w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; 442 &-& \sigma ...\ cross\ section \\; 443 &-& L ...\ luminosity \\; 444 &-& N_{gen}\ ... number\ of\ generated\ events \\; 445 &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; 446\f}; 447 ; 448The reason for different weights can therefore be:; 449- different processes; 450- other integrated luminosity; 451- varying trigger efficiency; 452- different sample sizes; 453- ...; 454- or even combination of them; 455 ; 456Depending on the actual meaning of different weights in your case, you; 457should either merge or combine them to get the overall efficiency.; 458 ; 459\anchor EFF051; 460### V.1 When should I use merging?; 461If the weights are artificial and do not represent real alternative hypotheses,; 462you should merge the different TEfficiency objects. That means especially for; 463the Bayesian case that the prior probability should be the same for all merged; 464TEfficiency objects. The merging can be done by invoking one of the following; 465operations:; 466- eff1.Add(eff2); 467- eff1 += eff2; 468- eff1 = eff1 + eff2; 469 ; 470The result of the merging is stored in the TEfficiency object which is marked; 471bold above. The contents of the internal histograms of both TEfficiency; 472objects are added and a new weight is assigned. The",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:20785,Deployability,integrat,integrated,20785," either merge or combine them to get the overall efficiency.; 458 ; 459\anchor EFF051; 460### V.1 When should I use merging?; 461If the weights are artificial and do not represent real alternative hypotheses,; 462you should merge the different TEfficiency objects. That means especially for; 463the Bayesian case that the prior probability should be the same for all merged; 464TEfficiency objects. The merging can be done by invoking one of the following; 465operations:; 466- eff1.Add(eff2); 467- eff1 += eff2; 468- eff1 = eff1 + eff2; 469 ; 470The result of the merging is stored in the TEfficiency object which is marked; 471bold above. The contents of the internal histograms of both TEfficiency; 472objects are added and a new weight is assigned. The statistic options are not; 473changed.; 474 ; 475\f[; 476 \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; 477\f]; 478 ; 479\anchor EFF05b; 480### Example:; 481If you use two samples with different numbers of generated events for the same; 482process and you want to normalise both to the same integrated luminosity and; 483trigger efficiency, the different weights then arise just from the fact that; 484you have different numbers of events. The TEfficiency objects should be merged; 485because the samples do not represent true alternatives. You expect the same; 486result as if you would have a big sample with all events in it.; 487 ; 488\f[; 489 w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}; 490\f]; 491 ; 492\anchor EFF052; 493### V.2 When should I use combining?; 494You should combine TEfficiency objects whenever the weights represent; 495alternatives processes for the efficiency. As the combination of two TEfficiency; 496objects is not always consistent with the representation by two internal; 497histograms, the result is not stored in a TEfficiency object but a TGraphAsymmErr",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:24940,Deployability,update,update,24940," operations; 538 ; 539\anchor EFF061; 540### VI.1 Information about the internal histograms; 541The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram; 542return a constant pointer to the internal histograms. They can be used to; 543obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...).; 544One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto.; 545The returned histograms are completely independent from the current; 546TEfficiency object. By default, they are not attached to a directory to; 547avoid the duplication of data and the user is responsible for deleting them.; 548 ; 549 ; 550~~~~~~~~~~~~~~~{.cpp}; 551//open a root file which contains a TEfficiency object; 552TFile* pFile = new TFile(""myfile.root"",""update"");; 553 ; 554//get TEfficiency object with name ""my_eff""; 555TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");; 556 ; 557//get clone of total histogram; 558TH1* clone = pEff->GetCopyTotalHisto();; 559 ; 560//change clone...; 561//save changes of clone directly; 562clone->Write();; 563//or append it to the current directory and write the file; 564//clone->SetDirectory(gDirectory);; 565//pFile->Write();; 566 ; 567//delete histogram object; 568delete clone;; 569clone = 0;; 570~~~~~~~~~~~~~~~; 571 ; 572It is also possible to set the internal total or passed histogram by using the; 573methods TEfficiency::SetPassedHistogram or TEfficiency::SetTotalHistogram.; 574 ; 575In order to ensure the validity of the TEfficiency object, the consistency of the; 576new histogram and the stored histogram is checked. It might be; 577impossible sometimes to change the histograms in a consistent way. Therefore one can force; 578the replacement by passing the ""f"" option. Then the user has to ensure that the; 579other internal histogram is replaced as well and that the TEfficiency object is; 580in a valid st",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:99061,Deployability,release,released,99061,"07/// - E0 - plot bins where the total number of passed events is zero; 2408/// (the error interval will be [0,1] ); 2409 ; 2410void TEfficiency::Draw(Option_t* opt); 2411{; 2412 //check options; 2413 TString option = opt;; 2414 option.ToLower();; 2415 ; 2416 if(gPad && !option.Contains(""same"")); 2417 gPad->Clear();; 2418 ; 2419 if (GetDimension() == 2) {; 2420 if (option.IsNull()) option = ""colz"";; 2421 } else {; 2422 // use by default ""AP""; 2423 if (option.IsNull()) option = ""ap"";; 2424 // add always ""a"" if not present; 2425 if (!option.Contains(""same"") && !option.Contains(""a"") ) option += ""a"";; 2426 // add always p to the option; 2427 if (!option.Contains(""p"") ) option += ""p"";; 2428 }; 2429 ; 2430 AppendPad(option.Data());; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Execute action corresponding to one event.; 2435///; 2436/// This member function is called when the drawn class is clicked with the locator; 2437/// If Left button clicked on one of the line end points, this point; 2438/// follows the cursor until button is released.; 2439///; 2440/// if Middle button clicked, the line is moved parallel to itself; 2441/// until the button is released.; 2442/// Forward the call to the underlying graph; 2443 ; 2444void TEfficiency::ExecuteEvent(Int_t event, Int_t px, Int_t py); 2445{; 2446 if (fPaintGraph) fPaintGraph->ExecuteEvent(event,px,py);; 2447 else if (fPaintHisto) fPaintHisto->ExecuteEvent(event,px,py);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// This function is used for filling the two histograms.; 2452///; 2453/// \param[in] bPassed flag whether the current event passed the selection; 2454/// - true: both histograms are filled; 2455/// - false: only the total histogram is filled; 2456/// \param[in] x x-value; 2457/// \param[in] y y-value (use default=0 for 1-D efficiencies); 2458/// \param[in] z z-value (use default=0 for 2-D or ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:99181,Deployability,release,released,99181," 2412 //check options; 2413 TString option = opt;; 2414 option.ToLower();; 2415 ; 2416 if(gPad && !option.Contains(""same"")); 2417 gPad->Clear();; 2418 ; 2419 if (GetDimension() == 2) {; 2420 if (option.IsNull()) option = ""colz"";; 2421 } else {; 2422 // use by default ""AP""; 2423 if (option.IsNull()) option = ""ap"";; 2424 // add always ""a"" if not present; 2425 if (!option.Contains(""same"") && !option.Contains(""a"") ) option += ""a"";; 2426 // add always p to the option; 2427 if (!option.Contains(""p"") ) option += ""p"";; 2428 }; 2429 ; 2430 AppendPad(option.Data());; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Execute action corresponding to one event.; 2435///; 2436/// This member function is called when the drawn class is clicked with the locator; 2437/// If Left button clicked on one of the line end points, this point; 2438/// follows the cursor until button is released.; 2439///; 2440/// if Middle button clicked, the line is moved parallel to itself; 2441/// until the button is released.; 2442/// Forward the call to the underlying graph; 2443 ; 2444void TEfficiency::ExecuteEvent(Int_t event, Int_t px, Int_t py); 2445{; 2446 if (fPaintGraph) fPaintGraph->ExecuteEvent(event,px,py);; 2447 else if (fPaintHisto) fPaintHisto->ExecuteEvent(event,px,py);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// This function is used for filling the two histograms.; 2452///; 2453/// \param[in] bPassed flag whether the current event passed the selection; 2454/// - true: both histograms are filled; 2455/// - false: only the total histogram is filled; 2456/// \param[in] x x-value; 2457/// \param[in] y y-value (use default=0 for 1-D efficiencies); 2458/// \param[in] z z-value (use default=0 for 2-D or 1-D efficiencies); 2459 ; 2460void TEfficiency::Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z); 2461{; 2462 switch(GetDimension()) {; 2463 case 1:; 2464 fTotalHistogr",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:105144,Deployability,update,update,105144,"// Returns a cloned version of fPassedHistogram; 2598///; 2599/// Notes:; 2600/// - The histogram is filled with unit weights. You might want to scale; 2601/// it with the global weight GetWeight().; 2602/// - The returned object is owned by the user who has to care about the; 2603/// deletion of the new TH1 object.; 2604/// - This histogram is by default NOT attached to the current directory; 2605/// to avoid duplication of data. If you want to store it automatically; 2606/// during the next TFile::Write() command, you have to attach it to; 2607/// the corresponding directory.; 2608///; 2609/// ~~~~~~~{.cpp}; 2610/// TFile* pFile = new TFile(""passed.root"",""update"");; 2611/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2612/// TH1* copy = pEff->GetCopyPassedHisto();; 2613/// copy->SetDirectory(gDirectory);; 2614/// pFile->Write();; 2615/// ~~~~~~~; 2616 ; 2617TH1* TEfficiency::GetCopyPassedHisto() const; 2618{; 2619 // do not add cloned histogram to gDirectory; 2620 TDirectory::TContext ctx(nullptr);; 2621 TH1* tmp = (TH1*)(fPassedHistogram->Clone());; 2622 ; 2623 return tmp;; 2624}; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// Returns a cloned version of fTotalHistogram; 2628///; 2629/// Notes:; 2630/// - The histogram is filled with unit weights. You might want to scale; 2631/// it with the global weight GetWeight().; 2632/// - The returned object is owned by the user who has to care about the; 2633/// deletion of the new TH1 object.; 2634/// - This histogram is by default NOT attached to the current directory; 2635/// to avoid duplication of data. If you want to store it automatically; 2636/// during the next TFile::Write() command, you have to attach it to; 2637/// the corresponding directory.; 2638///; 2639/// ~~~~~~~{.cpp}; 2640/// TFile* pFile = new TFile(""total.root"",""update"");; 2641/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2642/// TH1* copy = pEff->GetCopyTotalH",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:106359,Deployability,update,update,106359," automatically; 2636/// during the next TFile::Write() command, you have to attach it to; 2637/// the corresponding directory.; 2638///; 2639/// ~~~~~~~{.cpp}; 2640/// TFile* pFile = new TFile(""total.root"",""update"");; 2641/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2642/// TH1* copy = pEff->GetCopyTotalHisto();; 2643/// copy->SetDirectory(gDirectory);; 2644/// pFile->Write();; 2645/// ~~~~~~~; 2646 ; 2647TH1* TEfficiency::GetCopyTotalHisto() const; 2648{; 2649 // do not add cloned histogram to gDirectory; 2650 TDirectory::TContext ctx(nullptr);; 2651 TH1* tmp = (TH1*)(fTotalHistogram->Clone());; 2652 ; 2653 return tmp;; 2654}; 2655 ; 2656////////////////////////////////////////////////////////////////////////////////; 2657///returns the dimension of the current TEfficiency object; 2658 ; 2659Int_t TEfficiency::GetDimension() const; 2660{; 2661 return fTotalHistogram->GetDimension();; 2662}; 2663 ; 2664////////////////////////////////////////////////////////////////////////////////; 2665/// Returns the efficiency in the given global bin; 2666///; 2667/// Note:; 2668/// - The estimated efficiency depends on the chosen statistic option:; 2669/// for frequentist ones:; 2670/// \f$ \hat{\varepsilon} = \frac{passed}{total} \f$; 2671/// for bayesian ones the expectation value of the resulting posterior; 2672/// distribution is returned:; 2673/// \f$ \hat{\varepsilon} = \frac{passed + \alpha}{total + \alpha + \beta} \f$; 2674/// If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; 2675/// mode (most probable value) of the posterior is returned:; 2676/// \f$ \hat{\varepsilon} = \frac{passed + \alpha -1}{total + \alpha + \beta -2} \f$; 2677/// - If the denominator is equal to 0, an efficiency of 0 is returned.; 2678/// - When \f$ passed + \alpha < 1 \f$ or \f$ total - passed + \beta < 1 \f$ the above; 2679/// formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.; 2680",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:122383,Deployability,update,updated,122383,"copy style; 3055 rhs.TAttLine::Copy(*this);; 3056 rhs.TAttFill::Copy(*this);; 3057 rhs.TAttMarker::Copy(*this);; 3058 }; 3059 ; 3060 return *this;; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Paints this TEfficiency object; 3065///; 3066/// For details on the possible option see Draw(Option_t*); 3067///; 3068/// Note for 1D classes; 3069/// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; 3070/// The TGraph is created only the first time Paint is used. The user can manipulate the; 3071/// TGraph via the method TEfficiency::GetPaintedGraph(); 3072/// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; 3073/// If the axis needs to be updated because in the meantime the class changed use this trick; 3074/// which will trigger a re-calculation of the axis of the graph; 3075/// TEfficiency::GetPaintedGraph()->Set(0); 3076///; 3077/// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; 3078/// gPad->Update();; 3079///; 3080 ; 3081void TEfficiency::Paint(const Option_t* opt); 3082{; 3083 ; 3084 ; 3085 if(!gPad); 3086 return;; 3087 ; 3088 TString option(opt);; 3089 option.ToUpper();; 3090 ; 3091 ; 3092 //use TGraphAsymmErrors for painting; 3093 if(GetDimension() == 1) {; 3094 if(!fPaintGraph) {; 3095 fPaintGraph = CreateGraph(opt);; 3096 }; 3097 else; 3098 // update existing graph already created; 3099 FillGraph(fPaintGraph, opt);; 3100 ; 3101 //paint graph; 3102 fPaintGraph->Paint(opt);; 3103 // paint all associated functions; 3104 if (fFunctions) {; 3105 // paint box with fit parameters; 3106 // the fit statistics will be painted if gStyle->SetOptFit(1) has been; 3107 // called by the user; 3108 TIter next(fFunctions);; 3109 TObject *obj = nullptr;; 3110 while ((obj = next())) {; 3111 if (obj->InheritsFrom(TF1::Class())) {; 3112 fPaintGraph->PaintStats((TF1 *)obj);; 3113 ((TF1 *)obj)->Paint",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:123073,Deployability,update,update,123073," 3073/// If the axis needs to be updated because in the meantime the class changed use this trick; 3074/// which will trigger a re-calculation of the axis of the graph; 3075/// TEfficiency::GetPaintedGraph()->Set(0); 3076///; 3077/// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; 3078/// gPad->Update();; 3079///; 3080 ; 3081void TEfficiency::Paint(const Option_t* opt); 3082{; 3083 ; 3084 ; 3085 if(!gPad); 3086 return;; 3087 ; 3088 TString option(opt);; 3089 option.ToUpper();; 3090 ; 3091 ; 3092 //use TGraphAsymmErrors for painting; 3093 if(GetDimension() == 1) {; 3094 if(!fPaintGraph) {; 3095 fPaintGraph = CreateGraph(opt);; 3096 }; 3097 else; 3098 // update existing graph already created; 3099 FillGraph(fPaintGraph, opt);; 3100 ; 3101 //paint graph; 3102 fPaintGraph->Paint(opt);; 3103 // paint all associated functions; 3104 if (fFunctions) {; 3105 // paint box with fit parameters; 3106 // the fit statistics will be painted if gStyle->SetOptFit(1) has been; 3107 // called by the user; 3108 TIter next(fFunctions);; 3109 TObject *obj = nullptr;; 3110 while ((obj = next())) {; 3111 if (obj->InheritsFrom(TF1::Class())) {; 3112 fPaintGraph->PaintStats((TF1 *)obj);; 3113 ((TF1 *)obj)->Paint(""sameC"");; 3114 }; 3115 }; 3116 }; 3117 return;; 3118 }; 3119 //use TH2 or optionally a TGraph2DAsymmErrors for painting; 3120 if(GetDimension() == 2) {; 3121 bool drawGraph2D = false;; 3122 if (option.Contains(""GRAPH"")) {; 3123 option.ReplaceAll(""GRAPH"","""");; 3124 drawGraph2D = true;; 3125 }; 3126 if (drawGraph2D) {; 3127 //paint a TGraph2DAsymmErrors; 3128 if(!fPaintGraph2D); 3129 fPaintGraph2D = CreateGraph2D(option);; 3130 else; 3131 FillGraph2D(fPaintGraph2D, option);; 3132 // set some sensible marker size and type; 3133 fPaintGraph2D->SetMarkerStyle(20);; 3134 fPaintGraph2D->SetMarkerSize(0.6);; 3135 // use PCOL Z as default option; 3136 if (option.IsNull()) option += ""ERR PCOL Z"";; 3137 fPaintGraph2D->Paint(option);; ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:141047,Deployability,update,updated,141047,"; 3530void TEfficiency::SetDirectory(TDirectory* dir); 3531{; 3532 if(fDirectory == dir); 3533 return;; 3534 if(fDirectory); 3535 fDirectory->Remove(this);; 3536 fDirectory = dir;; 3537 if(fDirectory); 3538 fDirectory->Append(this);; 3539}; 3540 ; 3541////////////////////////////////////////////////////////////////////////////////; 3542/// Sets the name; 3543///; 3544/// Note: The names of the internal histograms are set to ""name + _total"" and; 3545/// ""name + _passed"" respectively.; 3546 ; 3547void TEfficiency::SetName(const char* name); 3548{; 3549 TNamed::SetName(name);; 3550 ; 3551 //setting the names (appending the correct ending); 3552 TString name_total = name + TString(""_total"");; 3553 TString name_passed = name + TString(""_passed"");; 3554 fTotalHistogram->SetName(name_total);; 3555 fPassedHistogram->SetName(name_passed);; 3556}; 3557 ; 3558////////////////////////////////////////////////////////////////////////////////; 3559/// Sets the number of passed events in the given global bin; 3560///; 3561/// returns ""true"" if the number of passed events has been updated; 3562/// otherwise ""false"" ist returned; 3563///; 3564/// Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin); 3565 ; 3566Bool_t TEfficiency::SetPassedEvents(Int_t bin,Int_t events); 3567{; 3568 if(events <= fTotalHistogram->GetBinContent(bin)) {; 3569 fPassedHistogram->SetBinContent(bin,events);; 3570 return true;; 3571 }; 3572 else {; 3573 Error(""SetPassedEvents(Int_t,Int_t)"",""total number of events (%.1lf) in bin %i is less than given number of passed events %i"",fTotalHistogram->GetBinContent(bin),bin,events);; 3574 return false;; 3575 }; 3576}; 3577 ; 3578////////////////////////////////////////////////////////////////////////////////; 3579/// Sets the histogram containing the passed events; 3580///; 3581/// The given histogram is cloned and stored internally as histogram containing; 3582/// the passed events. The given histogram has to be consistent with the current; 3583/// fT",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:147690,Deployability,update,updated,147690,"he tokens there); 3730 TString title_passed = title;; 3731 TString title_total = title;; 3732 Ssiz_t pos = title_passed.First("";"");; 3733 if (pos != kNPOS) {; 3734 title_passed.Insert(pos,"" (passed)"");; 3735 title_total.Insert(pos,"" (total)"");; 3736 }; 3737 else {; 3738 title_passed.Append("" (passed)"");; 3739 title_total.Append("" (total)"");; 3740 }; 3741 fPassedHistogram->SetTitle(title_passed);; 3742 fTotalHistogram->SetTitle(title_total);; 3743 ; 3744 // strip (total) for the TEfficiency title; 3745 // HIstogram SetTitle has already stripped the axis; 3746 TString teffTitle = fTotalHistogram->GetTitle();; 3747 teffTitle.ReplaceAll("" (total)"","""");; 3748 TNamed::SetTitle(teffTitle);; 3749 ; 3750}; 3751 ; 3752////////////////////////////////////////////////////////////////////////////////; 3753/// Sets the number of total events in the given global bin; 3754///; 3755/// returns ""true"" if the number of total events has been updated; 3756/// otherwise ""false"" ist returned; 3757///; 3758/// Note: - requires: fPassedHistogram->GetBinContent(bin) <= events; 3759 ; 3760Bool_t TEfficiency::SetTotalEvents(Int_t bin, Double_t events); 3761{; 3762 if(events >= fPassedHistogram->GetBinContent(bin)) {; 3763 fTotalHistogram->SetBinContent(bin,events);; 3764 return true;; 3765 }; 3766 else {; 3767 Error(""SetTotalEvents(Int_t,Double_t)"",""passed number of events (%.1lf) in bin %i is bigger than given number of total events %.1lf"",fPassedHistogram->GetBinContent(bin),bin,events);; 3768 return false;; 3769 }; 3770}; 3771 ; 3772////////////////////////////////////////////////////////////////////////////////; 3773/// Sets the histogram containing all events; 3774///; 3775/// The given histogram is cloned and stored internally as histogram containing; 3776/// all events. The given histogram has to be consistent with the current; 3777/// fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3778/// The method returns whether the fTotalHistogram has been replaced (true) or; 3779/",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:160872,Energy Efficiency,allocate,allocated,160872,"st char * GetBinLabel(Int_t bin) constReturn label for bin.Definition TAxis.cxx:440; TAxis::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn low edge of bin.Definition TAxis.cxx:518; TAxis::FindFixBinvirtual Int_t FindFixBin(Double_t x) constFind bin number corresponding to abscissa x.Definition TAxis.cxx:419; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width.Definition TAxis.cxx:540; TAxis::GetLabelsTHashList * GetLabels() constDefinition TAxis.h:121; TBinomialEfficiencyFitterBinomial fitter for the division of two histograms.Definition TBinomialEfficiencyFitter.h:42; TBinomialEfficiencyFitter::FitTFitResultPtr Fit(TF1 *f1, Option_t *option="""")Carry out the fit of the given function to the given histograms.Definition TBinomialEfficiencyFitter.cxx:195; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TDirectory::TContextTDirectory::TContext keeps track and restore the current directory.Definition TDirectory.h:89; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEfficiencyClass to handle efficiency histograms.Definition TEfficiency.h:29; TEfficiency::FillGraph2Dvoid FillGraph2D(TGraph2DAsymmErrors *graph, Option_t *opt) constFill the graph to be painted with information from TEfficiency Internal method called by TEfficiency:...Definition TEfficien",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:2880,Integrability,depend,dependency,2880,"Efficiency objects](\ref EFF05); 60 - [Example](\ref EFF05a); 61 - [V.1 When should I use merging?](\ref EFF051); 62 - [Example](\ref EFF05b); 63 - [V.2 When should I use combining?](\ref EFF052); 64 - [Example](\ref EFF05c); 65- [VI. Further operations](\ref EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\a",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:8502,Integrability,depend,depends,8502,"tted.; 168 ; 169Begin_Macro(source); 170{; 171 //canvas only needed for this documentation; 172 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 173 c1->SetFillStyle(1001);; 174 c1->SetFillColor(kWhite);; 175 ; 176 //create one-dimensional TEfficiency object with fixed bin size; 177 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 178 TRandom3 rand3;; 179 ; 180 bool bPassed;; 181 double x;; 182 for(int i=0; i<10000; ++i); 183 {; 184 //simulate events with variable under investigation; 185 x = rand3.Uniform(10);; 186 //check selection: bPassed = DoesEventPassSelection(x); 187 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 188 pEff->Fill(bPassed,x);; 189 }; 190 ; 191 pEff->Draw(""AP"");; 192}; 193End_Macro; 194 ; 195You can also set the number of passed or total events for a bin directly by; 196using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents method.; 197 ; 198\anchor EFF04; 199## IV. Statistic options; 200The calculation of the estimated efficiency depends on the chosen statistic; 201option. Let k denotes the number of passed events and N the number of total; 202events.; 203 ; 204\anchor EFF04a; 205### Frequentist methods; 206The expectation value of the number of passed events is given by the true; 207efficiency times the total number of events. One can estimate the efficiency; 208by replacing the expected number of passed events by the observed number of; 209passed events.; 210 ; 211\f[; 212 k = \epsilon \times N \Rightarrow \hat{\varepsilon} = \frac{k}{N}; 213\f]; 214 ; 215\anchor EFF04b; 216### Bayesian methods; 217In Bayesian statistics a likelihood-function (how probable is it to get the; 218observed data assuming a true efficiency) and a prior probability (what is the; 219probability that a certain true efficiency is actually realised) are used to; 220determine a posterior probability by using Bayes theorem. At the moment, only; 221beta distributions (have 2 free parameters) are supported as prior; 222probabili",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:19509,Integrability,integrat,integrated,19509,"This procedure has the advantage that you can change the weight of one; 428subsample easily without rerunning the whole analysis. On the other hand, more; 429effort is needed to handle several TEfficiency objects instead of one; 430histogram. In the case of many different or even continuously distributed; 431weights, this approach becomes cumbersome. One possibility to overcome this; 432problem is the usage of binned weights.; 433 ; 434\anchor EFF05a; 435### Example; 436In particle physics weights arises from the fact that you want to; 437normalise your results to a certain reference value. A very common formula for; 438calculating weights is; 439 ; 440\f{eqnarray*}{; 441 w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; 442 &-& \sigma ...\ cross\ section \\; 443 &-& L ...\ luminosity \\; 444 &-& N_{gen}\ ... number\ of\ generated\ events \\; 445 &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; 446\f}; 447 ; 448The reason for different weights can therefore be:; 449- different processes; 450- other integrated luminosity; 451- varying trigger efficiency; 452- different sample sizes; 453- ...; 454- or even combination of them; 455 ; 456Depending on the actual meaning of different weights in your case, you; 457should either merge or combine them to get the overall efficiency.; 458 ; 459\anchor EFF051; 460### V.1 When should I use merging?; 461If the weights are artificial and do not represent real alternative hypotheses,; 462you should merge the different TEfficiency objects. That means especially for; 463the Bayesian case that the prior probability should be the same for all merged; 464TEfficiency objects. The merging can be done by invoking one of the following; 465operations:; 466- eff1.Add(eff2); 467- eff1 += eff2; 468- eff1 = eff1 + eff2; 469 ; 470The result of the merging is stored in the TEfficiency object which is marked; 471bold above. The contents of the internal histograms of both TEfficiency; 472objects are added and a new weight is assigned. The",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:20785,Integrability,integrat,integrated,20785," either merge or combine them to get the overall efficiency.; 458 ; 459\anchor EFF051; 460### V.1 When should I use merging?; 461If the weights are artificial and do not represent real alternative hypotheses,; 462you should merge the different TEfficiency objects. That means especially for; 463the Bayesian case that the prior probability should be the same for all merged; 464TEfficiency objects. The merging can be done by invoking one of the following; 465operations:; 466- eff1.Add(eff2); 467- eff1 += eff2; 468- eff1 = eff1 + eff2; 469 ; 470The result of the merging is stored in the TEfficiency object which is marked; 471bold above. The contents of the internal histograms of both TEfficiency; 472objects are added and a new weight is assigned. The statistic options are not; 473changed.; 474 ; 475\f[; 476 \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; 477\f]; 478 ; 479\anchor EFF05b; 480### Example:; 481If you use two samples with different numbers of generated events for the same; 482process and you want to normalise both to the same integrated luminosity and; 483trigger efficiency, the different weights then arise just from the fact that; 484you have different numbers of events. The TEfficiency objects should be merged; 485because the samples do not represent true alternatives. You expect the same; 486result as if you would have a big sample with all events in it.; 487 ; 488\f[; 489 w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}; 490\f]; 491 ; 492\anchor EFF052; 493### V.2 When should I use combining?; 494You should combine TEfficiency objects whenever the weights represent; 495alternatives processes for the efficiency. As the combination of two TEfficiency; 496objects is not always consistent with the representation by two internal; 497histograms, the result is not stored in a TEfficiency object but a TGraphAsymmErr",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:31151,Integrability,depend,depends,31151,"675 pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; 676 pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; 677 pEff->GetPaintedGraph()->GetYaxis()->SetTitleSize(0.05);; 678 pEff->GetPaintedGraph()->GetYaxis()->SetLabelFont(42);; 679 pEff->GetPaintedGraph()->GetYaxis()->SetLabelSize(0.05);; 680 pEff->GetPaintedGraph()->GetXaxis()->SetRangeUser(3,7);; 681}; 682End_Macro; 683 ; 684*/; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Default constructor; 688///; 689/// Should not be used explicitly; 690 ; 691TEfficiency::TEfficiency():; 692fBeta_alpha(kDefBetaAlpha),; 693fBeta_beta(kDefBetaBeta),; 694fBoundary(nullptr),; 695fConfLevel(kDefConfLevel),; 696fDirectory(nullptr),; 697fFunctions(nullptr),; 698fPaintGraph(nullptr),; 699fPaintHisto(nullptr),; 700fPassedHistogram(nullptr),; 701fTotalHistogram(nullptr),; 702fWeight(kDefWeight); 703{; 704 SetStatisticOption(kDefStatOpt);; 705 ; 706 // create 2 dummy histograms; 707 fPassedHistogram = new TH1F(""h_passed"",""passed"",10,0,10);; 708 fTotalHistogram = new TH1F(""h_total"",""total"",10,0,10);; 709}; 710 ; 711////////////////////////////////////////////////////////////////////////////////; 712/// Constructor using two existing histograms as input; 713///; 714///Input: passed - contains the events fulfilling some criteria; 715/// total - contains all investigated events; 716///; 717///Notes: - both histograms have to fulfill the conditions of CheckConsistency; 718/// - dimension of the resulting efficiency object depends; 719/// on the dimension of the given histograms; 720/// - Clones of both histograms are stored internally; 721/// - The function SetName(total.GetName() + ""_clone"") is called to set; 722/// the names of the new object and the internal histograms..; 723/// - The created TEfficiency object is NOT appended to a directory. It; 724/// will not be written to disk during the next TFile::Write() command; 725/// in order to prevent duplication of data.",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:52786,Integrability,depend,depending,52786,"::abs(pmax - pmin) > tol) {; 1253 p = (pmin + pmax)/2;; 1254 //double v = 0.5 * ROOT::Math::binomial_pdf(int(passed), p, int(total));; 1255 // make it work for non integer using the binomial - beta relationship; 1256 double v = 0.5 * ROOT::Math::beta_pdf(p, passed+1., total-passed+1)/(total+1);; 1257 //if (passed > 0) v += ROOT::Math::binomial_cdf(int(passed - 1), p, int(total));; 1258 // compute the binomial cdf at passed -1; 1259 if ( (passed-1) >= 0) v += ROOT::Math::beta_cdf_c(p, passed, total-passed+1);; 1260 ; 1261 double vmin = (bUpper) ? alpha_min : 1.- alpha_min;; 1262 if (v > vmin); 1263 pmin = p;; 1264 else; 1265 pmax = p;; 1266 }; 1267 ; 1268 return p;; 1269}; 1270 ; 1271 ; 1272////////////////////////////////////////////////////////////////////////////////; 1273/**; 1274Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending on the option); 1275 ; 1276\param[in] total number of total events; 1277\param[in] passed 0 <= number of passed events <= total; 1278\param[in] level confidence level; 1279\param[in] alpha shape parameter > 0 for the prior distribution (fBeta_alpha); 1280\param[in] beta shape parameter > 0 for the prior distribution (fBeta_beta); 1281\param[in] bUpper; 1282 - true - upper boundary is returned; 1283 - false - lower boundary is returned; 1284\param[in] bShortest ??; 1285 ; 1286Note: In the case central confidence interval is calculated.; 1287 when passed = 0 (or passed = total) the lower (or upper); 1288 interval values will be larger than 0 (or smaller than 1).; 1289 ; 1290Calculation:; 1291 ; 1292The posterior probability in bayesian statistics is given by:; 1293\f[; 1294 P(\varepsilon |k,N) \propto L(\varepsilon|k,N) \times Prior(\varepsilon); 1295\f]; 1296As an efficiency can be interpreted as probability of a positive outcome of; 1297a Bernoullli trial the likelihood function is given by the binomial; 1298distribution:; 1299\f[; 1300 L(\varepsilon|k,N) = Binomial(N,k) \varepsilon ^{k} (",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:107286,Integrability,depend,depends,107286," automatically; 2636/// during the next TFile::Write() command, you have to attach it to; 2637/// the corresponding directory.; 2638///; 2639/// ~~~~~~~{.cpp}; 2640/// TFile* pFile = new TFile(""total.root"",""update"");; 2641/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2642/// TH1* copy = pEff->GetCopyTotalHisto();; 2643/// copy->SetDirectory(gDirectory);; 2644/// pFile->Write();; 2645/// ~~~~~~~; 2646 ; 2647TH1* TEfficiency::GetCopyTotalHisto() const; 2648{; 2649 // do not add cloned histogram to gDirectory; 2650 TDirectory::TContext ctx(nullptr);; 2651 TH1* tmp = (TH1*)(fTotalHistogram->Clone());; 2652 ; 2653 return tmp;; 2654}; 2655 ; 2656////////////////////////////////////////////////////////////////////////////////; 2657///returns the dimension of the current TEfficiency object; 2658 ; 2659Int_t TEfficiency::GetDimension() const; 2660{; 2661 return fTotalHistogram->GetDimension();; 2662}; 2663 ; 2664////////////////////////////////////////////////////////////////////////////////; 2665/// Returns the efficiency in the given global bin; 2666///; 2667/// Note:; 2668/// - The estimated efficiency depends on the chosen statistic option:; 2669/// for frequentist ones:; 2670/// \f$ \hat{\varepsilon} = \frac{passed}{total} \f$; 2671/// for bayesian ones the expectation value of the resulting posterior; 2672/// distribution is returned:; 2673/// \f$ \hat{\varepsilon} = \frac{passed + \alpha}{total + \alpha + \beta} \f$; 2674/// If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; 2675/// mode (most probable value) of the posterior is returned:; 2676/// \f$ \hat{\varepsilon} = \frac{passed + \alpha -1}{total + \alpha + \beta -2} \f$; 2677/// - If the denominator is equal to 0, an efficiency of 0 is returned.; 2678/// - When \f$ passed + \alpha < 1 \f$ or \f$ total - passed + \beta < 1 \f$ the above; 2679/// formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.; 2680",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:109522,Integrability,depend,depends,109522,"f the denominator is equal to 0, an efficiency of 0 is returned.; 2678/// - When \f$ passed + \alpha < 1 \f$ or \f$ total - passed + \beta < 1 \f$ the above; 2679/// formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.; 2680 ; 2681Double_t TEfficiency::GetEfficiency(Int_t bin) const; 2682{; 2683 Double_t total = fTotalHistogram->GetBinContent(bin);; 2684 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2685 ; 2686 if(TestBit(kIsBayesian)) {; 2687 ; 2688 // parameters for the beta prior distribution; 2689 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2690 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2691 ; 2692 Double_t aa,bb;; 2693 if(TestBit(kUseWeights)); 2694 {; 2695 Double_t tw = fTotalHistogram->GetBinContent(bin);; 2696 Double_t tw2 = fTotalHistogram->GetSumw2()->At(bin);; 2697 Double_t pw = fPassedHistogram->GetBinContent(bin);; 2698 ; 2699 if (tw2 <= 0 ) return pw/tw;; 2700 ; 2701 // tw/tw2 renormalize the weights; 2702 double norm = tw/tw2;; 2703 aa = pw * norm + alpha;; 2704 bb = (tw - pw) * norm + beta;; 2705 }; 2706 else; 2707 {; 2708 aa = passed + alpha;; 2709 bb = total - passed + beta;; 2710 }; 2711 ; 2712 if (!TestBit(kPosteriorMode) ); 2713 return BetaMean(aa,bb);; 2714 else; 2715 return BetaMode(aa,bb);; 2716 ; 2717 }; 2718 else; 2719 return (total)? ((Double_t)passed)/total : 0;; 2720}; 2721 ; 2722////////////////////////////////////////////////////////////////////////////////; 2723/// Returns the lower error on the efficiency in the given global bin; 2724///; 2725/// The result depends on the current confidence level fConfLevel and the; 2726/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2727/// more details.; 2728///; 2729/// Note: If the histograms are filled with weights, only bayesian methods and the; 2730/// normal approximation are supported.; 2731 ; 2732Double_t TEfficiency::GetEfficiencyErrorLow(In",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:112503,Integrability,depend,depends,112503,"; 2770 {; 2771 if(fStatisticOption != kFNormal); 2772 {; 2773 Warning(""GetEfficiencyErrorLow"",""frequentist confidence intervals for weights are only supported by the normal approximation"");; 2774 Info(""GetEfficiencyErrorLow"",""setting statistic option to kFNormal"");; 2775 const_cast<TEfficiency*>(this)->SetStatisticOption(kFNormal);; 2776 }; 2777 ; 2778 Double_t variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 2779 Double_t sigma = sqrt(variance);; 2780 ; 2781 Double_t prob = 0.5 * (1.- fConfLevel);; 2782 Double_t delta = ROOT::Math::normal_quantile_c(prob, sigma);; 2783 ; 2784 // avoid to return errors which makes eff-err < 0; 2785 return (eff - delta < 0) ? eff : delta;; 2786 }; 2787 }; 2788 else; 2789 {; 2790 if(TestBit(kIsBayesian)); 2791 {; 2792 // parameters for the beta prior distribution; 2793 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2794 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2795 return (eff - Bayesian(total,passed,fConfLevel,alpha,beta,false,TestBit(kShortestInterval)));; 2796 }; 2797 else; 2798 return (eff - fBoundary(total,passed,fConfLevel,false));; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Returns the upper error on the efficiency in the given global bin; 2804///; 2805/// The result depends on the current confidence level fConfLevel and the; 2806/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2807/// more details.; 2808///; 2809/// Note: If the histograms are filled with weights, only bayesian methods and the; 2810/// normal approximation are supported.; 2811 ; 2812Double_t TEfficiency::GetEfficiencyErrorUp(Int_t bin) const; 2813{; 2814 Double_t total = fTotalHistogram->GetBinContent(bin);; 2815 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2816 ; 2817 Double_t eff = GetEfficiency(bin);; 2818 ; 2819 // check whether weights have been used; 2820 i",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:157389,Integrability,wrap,wrap,157389,"ion.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; TArrayD::AtDouble_t At(Int_t i) constDefinition TArrayD.h:79; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::GetArrayconst Double_t * GetArray() constDefinition TArrayD.h:43; TArray::fNInt_t fNDefinition TArray.h:38; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::Copyvoid Copy(TAttFill &attfill) constCopy this fill attributes to a new TAttFill.Definition TAttFill.cxx:207; TAttFill::SaveFillAttributesvirtual void SaveFillAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001)Save fill attributes as C++ statement(s) on output stream out.Definition TAttFill.cxx:239; TAttLineLine Attributes class.Definition TAttLine.h:18; TAttLine::Copyvoid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *nam",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:164349,Integrability,depend,depending,164349,"_t CheckWeights(const TH1 &pass, const TH1 &total)Check if both histogram are weighted.Definition TEfficiency.cxx:1638; TEfficiency::BetaMeanstatic Double_t BetaMean(Double_t alpha, Double_t beta)Compute the mean (average) of the beta distribution.Definition TEfficiency.cxx:1458; TEfficiency::TEfficiencyTEfficiency()Default constructor.Definition TEfficiency.cxx:691; TEfficiency::GetBetaAlphaDouble_t GetBetaAlpha(Int_t bin=-1) constDefinition TEfficiency.h:110; TEfficiency::FillWeightedvoid FillWeighted(Bool_t bPassed, Double_t weight, Double_t x, Double_t y=0, Double_t z=0)This function is used for filling the two histograms with a weight.Definition TEfficiency.cxx:2494; TEfficiency::~TEfficiency~TEfficiency() overridedefault destructorDefinition TEfficiency.cxx:1099; TEfficiency::GetListOfFunctionsTList * GetListOfFunctions()Definition TEfficiency.cxx:2897; TEfficiency::Bayesianstatic Double_t Bayesian(Double_t total, Double_t passed, Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper, Bool_t bShortest=false)Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending ...Definition TEfficiency.cxx:1324; TEfficiency::AgrestiCoullstatic Double_t AgrestiCoull(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Agresti-Coull interval.Definition TEfficiency.cxx:1149; TEfficiency::MergeLong64_t Merge(TCollection *list)Merges the TEfficiency objects in the given list to the given TEfficiency object using the operator+=...Definition TEfficiency.cxx:2915; TEfficiency::fBeta_bin_paramsstd::vector< std::pair< Double_t, Double_t > > fBeta_bin_paramsParameter for prior beta distribution different bin by bin (default vector is empty)Definition TEfficiency.h:49; TEfficiency::FeldmanCousinsstatic Double_t FeldmanCousins(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Feldman-Cousins interval.Definition TEfficiency.",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:180278,Integrability,rout,routine,180278,"1; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::GetBinLowEdgevirtual Double_t GetBinLowEdge(Int_t bin) constReturn bin lower edge for 1D histogram.Definition TH1.cxx:9152; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TH1.cxx:3240; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumw2Nvirtual Int_t GetSumw2N() constDefinition TH1.h:315; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:183503,Integrability,message,message,183503,"xx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInval",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184227,Integrability,message,message,184227,"estBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184363,Integrability,message,message,184363,"h the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184675,Integrability,message,message,184675,"ect::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) constFind first occurrence of a character c.Definition TString.cxx:538; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; bool; double; int; uns",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:2930,Modifiability,variab,variables,2930,"Efficiency objects](\ref EFF05); 60 - [Example](\ref EFF05a); 61 - [V.1 When should I use merging?](\ref EFF051); 62 - [Example](\ref EFF05b); 63 - [V.2 When should I use combining?](\ref EFF052); 64 - [Example](\ref EFF05c); 65- [VI. Further operations](\ref EFF06); 66 - [VI.1 Information about the internal histograms](\ref EFF061); 67 - [VI.2 Fitting](\ref EFF062); 68 - [VI.3 Draw a TEfficiency object](\ref EFF063); 69 - [VI.4 TEfficiency object's axis customisation](\ref EFF064); 70 ; 71\anchor EFF01; 72## I. Overview; 73This class handles the calculation of efficiencies and their uncertainties. It; 74provides several statistical methods for calculating frequentist and Bayesian; 75confidence intervals as well as a function for combining several efficiencies.; 76 ; 77Efficiencies have a lot of applications and meanings but in principle, they can; 78be described by the fraction of good/passed events k out of sample containing; 79N events. One is usually interested in the dependency of the efficiency on other; 80(binned) variables. The number of passed and total events is therefore stored; 81internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; 82Then the efficiency, as well as its upper and lower error, can be calculated for each bin; 83individually.; 84 ; 85As the efficiency can be regarded as a parameter of a binomial distribution, the; 86number of passed and total events must always be integer numbers. Therefore a; 87filling with weights is not possible. However, you can assign a global weight to each; 88TEfficiency object (TEfficiency::SetWeight).; 89It is necessary to create one TEfficiency object; 90for each weight if you investigate a process involving different weights. This; 91procedure needs more effort but enables you to re-use the filled object in cases; 92where you want to change one or more weights. This would not be possible if all; 93events with different weights were filled in the same histogram.; 94 ; 95\a",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:7386,Modifiability,variab,variables,7386," and h_total are valid and consistent histograms; 148if(TEfficiency::CheckConsistency(h_pass,h_total)); 149{; 150 pEff = new TEfficiency(h_pass,h_total);; 151 //this will attach the TEfficiency object to the current directory; 152 pEff->SetDirectory(gDirectory);; 153 //now all objects in gDirectory will be written to ""myfile.root""; 154 pFile->Write();; 155}; 156~~~~~~~~~~~~~~~; 157 ; 158In case you already have two filled histograms and you only want to; 159plot them as a graph, you should rather use TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt); 160to create a graph object.; 161 ; 162\anchor EFF03; 163## III. Filling with events; 164You can fill the TEfficiency object by calling the TEfficiency::Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; 165The ""bPassed"" boolean flag indicates whether the current event is good; 166(both histograms are filled) or not (only TEfficiency::fTotalHistogram is filled).; 167The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted.; 168 ; 169Begin_Macro(source); 170{; 171 //canvas only needed for this documentation; 172 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 173 c1->SetFillStyle(1001);; 174 c1->SetFillColor(kWhite);; 175 ; 176 //create one-dimensional TEfficiency object with fixed bin size; 177 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 178 TRandom3 rand3;; 179 ; 180 bool bPassed;; 181 double x;; 182 for(int i=0; i<10000; ++i); 183 {; 184 //simulate events with variable under investigation; 185 x = rand3.Uniform(10);; 186 //check selection: bPassed = DoesEventPassSelection(x); 187 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 188 pEff->Fill(bPassed,x);; 189 }; 190 ; 191 pEff->Draw(""AP"");; 192}; 193End_Macro; 194 ; 195You can also set the number of passed or total events for a bin directly by; 196using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents metho",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:7982,Modifiability,variab,variable,7982,"56~~~~~~~~~~~~~~~; 157 ; 158In case you already have two filled histograms and you only want to; 159plot them as a graph, you should rather use TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt); 160to create a graph object.; 161 ; 162\anchor EFF03; 163## III. Filling with events; 164You can fill the TEfficiency object by calling the TEfficiency::Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; 165The ""bPassed"" boolean flag indicates whether the current event is good; 166(both histograms are filled) or not (only TEfficiency::fTotalHistogram is filled).; 167The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted.; 168 ; 169Begin_Macro(source); 170{; 171 //canvas only needed for this documentation; 172 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 173 c1->SetFillStyle(1001);; 174 c1->SetFillColor(kWhite);; 175 ; 176 //create one-dimensional TEfficiency object with fixed bin size; 177 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 178 TRandom3 rand3;; 179 ; 180 bool bPassed;; 181 double x;; 182 for(int i=0; i<10000; ++i); 183 {; 184 //simulate events with variable under investigation; 185 x = rand3.Uniform(10);; 186 //check selection: bPassed = DoesEventPassSelection(x); 187 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 188 pEff->Fill(bPassed,x);; 189 }; 190 ; 191 pEff->Draw(""AP"");; 192}; 193End_Macro; 194 ; 195You can also set the number of passed or total events for a bin directly by; 196using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents method.; 197 ; 198\anchor EFF04; 199## IV. Statistic options; 200The calculation of the estimated efficiency depends on the chosen statistic; 201option. Let k denotes the number of passed events and N the number of total; 202events.; 203 ; 204\anchor EFF04a; 205### Frequentist methods; 206The expectation value of the number of passed events is given by the true; 207",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:14148,Modifiability,variab,variable,14148,"anCousins | false | total events, passed events, confidence level |; 269| Mid-P Lancaster | kMidP | TEfficiency::MidPInterval | false | total events, passed events, confidence level |; 270| Jeffrey | kBJeffrey | TEfficiency::Bayesian | true | total events, passed events, confidence level, fBeta_alpha = 0.5, fBeta_beta = 0.5 |; 271| Uniform prior | kBUniform |TEfficiency::Bayesian | true |total events, passed events, confidence level, fBeta_alpha = 1, fBeta_beta = 1 |; 272| custom prior | kBBayesian |TEfficiency::Bayesian | true |total events, passed events, confidence level, fBeta_alpha, fBeta_beta |; 273 ; 274The following example demonstrates the effect of different statistic options and; 275confidence levels.; 276 ; 277Begin_Macro(source); 278{; 279 //canvas only needed for the documentation; 280 TCanvas* c1 = new TCanvas(""c1"","""",600,400);; 281 c1->Divide(2);; 282 c1->SetFillStyle(1001);; 283 c1->SetFillColor(kWhite);; 284 ; 285 //create one-dimensional TEfficiency object with fixed bin size; 286 TEfficiency* pEff = new TEfficiency(""eff"",""different confidence levels;x;#epsilon"",20,0,10);; 287 TRandom3 rand3;; 288 ; 289 bool bPassed;; 290 double x;; 291 for(int i=0; i<1000; ++i); 292 {; 293 //simulate events with variable under investigation; 294 x = rand3.Uniform(10);; 295 //check selection: bPassed = DoesEventPassSelection(x); 296 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 297 pEff->Fill(bPassed,x);; 298 }; 299 ; 300 //set style attributes; 301 pEff->SetFillStyle(3004);; 302 pEff->SetFillColor(kRed);; 303 ; 304 //copy current TEfficiency object and set new confidence level; 305 TEfficiency* pCopy = new TEfficiency(*pEff);; 306 pCopy->SetConfidenceLevel(0.90);; 307 ; 308 //set style attributes; 309 pCopy->SetFillStyle(3005);; 310 pCopy->SetFillColor(kBlue);; 311 ; 312 c1->cd(1);; 313 ; 314 //add legend; 315 TLegend* leg1 = new TLegend(0.3,0.1,0.7,0.5);; 316 leg1->AddEntry(pEff,""68.3%"",""F"");; 317 leg1->AddEntry(pCopy,""90%"",""F"");; 318 ; 319 pEff->Draw(""A4"");; 32",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:27146,Modifiability,variab,variable,27146,"ser has to ensure that the; 579other internal histogram is replaced as well and that the TEfficiency object is; 580in a valid state.; 581 ; 582\anchor EFF062; 583### VI.2 Fitting; 584The efficiency can be fitted using the TEfficiency::Fit function which internally uses; 585the TBinomialEfficiencyFitter::Fit method.; 586As this method is using a maximum-likelihood-fit, it is necessary to initialise; 587the given fit function with reasonable start values.; 588The resulting fit function is attached to the list of associated functions and; 589will be drawn automatically during the next TEfficiency::Draw command.; 590The list of associated function can be modified by using the pointer returned; 591by TEfficiency::GetListOfFunctions.; 592 ; 593Begin_Macro(source); 594{; 595 //canvas only needed for this documentation; 596 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 597 c1->SetFillStyle(1001);; 598 c1->SetFillColor(kWhite);; 599 ; 600 //create one-dimensional TEfficiency object with fixed bin size; 601 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 602 TRandom3 rand3;; 603 ; 604 bool bPassed;; 605 double x;; 606 for (int i=0; i<10000; ++i) {; 607 //simulate events with variable under investigation; 608 x = rand3.Uniform(10);; 609 //check selection: bPassed = DoesEventPassSelection(x); 610 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 611 pEff->Fill(bPassed,x);; 612 }; 613 ; 614 //create a function for fitting and do the fit; 615 TF1* f1 = new TF1(""f1"",""gaus"",0,10);; 616 f1->SetParameters(1,5,2);; 617 pEff->Fit(f1);; 618 ; 619 //create a threshold function; 620 TF1* f2 = new TF1(""thres"",""0.8"",0,10);; 621 f2->SetLineColor(kRed);; 622 //add it to the list of functions; 623 //use add first because the parameters of the last function will be displayed; 624 pEff->GetListOfFunctions()->AddFirst(f2);; 625 ; 626 pEff->Draw(""AP"");; 627}; 628End_Macro; 629 ; 630\anchor EFF063; 631### VI.3 Draw a TEfficiency object; 632A TEfficiency object can be ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:29183,Modifiability,variab,variable,29183,"ual TEfficiency::Draw method.; 633At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; 634In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; 635method. For 2-dimensional TEfficiency objects, you can pass the same options as; 636for a TH2::Draw object.; 637 ; 638\anchor EFF064; 639### VI.4 TEfficiency object's axis customisation; 640The axes of a TEfficiency object can be accessed and customised by calling the; 641GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; 642methods.; 643Note that in order to access the painted graph via GetPaintedGraph(), one should either; 644call Paint or, better, gPad->Update().; 645 ; 646Begin_Macro(source); 647{; 648 //canvas only needed for this documentation; 649 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 650 c1->SetFillStyle(1001);; 651 c1->SetFillColor(kWhite);; 652 c1->Divide(2,1);; 653 ; 654 //create one-dimensional TEfficiency object with fixed bin size; 655 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 656 TRandom3 rand3;; 657 ; 658 bool bPassed;; 659 double x;; 660 for(int i=0; i<10000; ++i); 661 {; 662 //simulate events with variable under investigation; 663 x = rand3.Uniform(10);; 664 //check selection: bPassed = DoesEventPassSelection(x); 665 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 666 pEff->Fill(bPassed,x);; 667 }; 668 c1->cd(1);; 669 pEff->Draw(""AP"");; 670 c1->cd(2);; 671 pEff->Draw(""AP"");; 672 gPad->Update();; 673 pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; 674 pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; 675 pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; 676 pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; 677 pEff->GetPaintedGraph()->GetYaxis()->SetTitleSize(0.05);; 678 pEff->GetPaintedGraph()->GetYaxis()->SetLabelFont(42);; 679 pEff->GetPaintedGraph()->GetYaxis()->SetLabelSize(0.05);; 680 pEff->GetPaintedGraph()->GetXa",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:33454,Modifiability,variab,variable,33454," 733fConfLevel(kDefConfLevel),; 734fDirectory(nullptr),; 735fFunctions(nullptr),; 736fPaintGraph(nullptr),; 737fPaintHisto(nullptr),; 738fWeight(kDefWeight); 739{; 740 //check consistency of histograms; 741 if(CheckConsistency(passed,total)) {; 742 // do not add cloned histograms to gDirectory; 743 {; 744 TDirectory::TContext ctx(nullptr);; 745 fTotalHistogram = (TH1*)total.Clone();; 746 fPassedHistogram = (TH1*)passed.Clone();; 747 }; 748 ; 749 TString newName = total.GetName();; 750 newName += TString(""_clone"");; 751 SetName(newName);; 752 ; 753 // are the histograms filled with weights?; 754 if(CheckWeights(passed,total)); 755 {; 756 Info(""TEfficiency"",""given histograms are filled with weights"");; 757 SetUseWeightedEvents();; 758 }; 759 }; 760 else {; 761 Error(""TEfficiency(const TH1&,const TH1&)"",""histograms are not consistent -> results are useless"");; 762 Warning(""TEfficiency(const TH1&,const TH1&)"",""using two empty TH1D('h1','h1',10,0,10)"");; 763 ; 764 // do not add new created histograms to gDirectory; 765 TDirectory::TContext ctx(nullptr);; 766 fTotalHistogram = new TH1D(""h1_total"",""h1 (total)"",10,0,10);; 767 fPassedHistogram = new TH1D(""h1_passed"",""h1 (passed)"",10,0,10);; 768 }; 769 ; 770 SetBit(kPosteriorMode,false);; 771 SetBit(kShortestInterval,false);; 772 ; 773 SetStatisticOption(kDefStatOpt);; 774 SetDirectory(nullptr);; 775}; 776 ; 777////////////////////////////////////////////////////////////////////////////////; 778/// Create 1-dimensional TEfficiency object with variable bin size.; 779///; 780/// Constructor creates two new and empty histograms with a given binning; 781///; 782/// Input:; 783///; 784/// - `name`: the common part of the name for both histograms (no blanks); 785/// fTotalHistogram has name: name + ""_total""; 786/// fPassedHistogram has name: name + ""_passed""; 787/// - `title`: the common part of the title for both histogram; 788/// fTotalHistogram has title: title + "" (total)""; 789/// fPassedHistogram has title: title + "" (passed)""",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:38263,Modifiability,variab,variable,38263,"e for both histograms(no blanks); 865/// fTotalHistogram has name: name + ""_total""; 866/// fPassedHistogram has name: name + ""_passed""; 867/// - `title`: the common part of the title for both histogram; 868/// fTotalHistogram has title: title + "" (total)""; 869/// fPassedHistogram has title: title + "" (passed)""; 870/// It is possible to label the axis by passing a title with; 871/// the following format: ""title;xlabel;ylabel;zlabel"".; 872/// - `nbinsx`: number of bins on the x-axis; 873/// - `xlow`: lower edge of first x-bin; 874/// - `xup`: upper edge of last x-bin; 875/// - `nbinsy`: number of bins on the y-axis; 876/// - `ylow`: lower edge of first y-bin; 877/// - `yup`: upper edge of last y-bin; 878 ; 879TEfficiency::TEfficiency(const char* name,const char* title,Int_t nbinsx,; 880 Double_t xlow,Double_t xup,Int_t nbinsy,; 881 Double_t ylow,Double_t yup):; 882fBeta_alpha(kDefBetaAlpha),; 883fBeta_beta(kDefBetaBeta),; 884fConfLevel(kDefConfLevel),; 885fDirectory(nullptr),; 886fFunctions(nullptr),; 887fPaintGraph(nullptr),; 888fPaintHisto(nullptr),; 889fWeight(kDefWeight); 890{; 891 // do not add new created histograms to gDirectory; 892 {; 893 TDirectory::TContext ctx(nullptr);; 894 fTotalHistogram = new TH2D(""total"",""total"",nbinsx,xlow,xup,nbinsy,ylow,yup);; 895 fPassedHistogram = new TH2D(""passed"",""passed"",nbinsx,xlow,xup,nbinsy,ylow,yup);; 896 }; 897 Build(name,title);; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// Create 2-dimensional TEfficiency object with variable bin size.; 902///; 903/// Constructor creates two new and empty histograms with a given binning.; 904///; 905/// Input:; 906///; 907/// - `name`: the common part of the name for both histograms(no blanks); 908/// fTotalHistogram has name: name + ""_total""; 909/// fPassedHistogram has name: name + ""_passed""; 910/// - `title`: the common part of the title for both histogram; 911/// fTotalHistogram has title: title + "" (total)""; 912/// fPassedHi",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:41997,Modifiability,variab,variable,41997," has name: name + ""_passed""; 953/// - `title`: the common part of the title for both histogram; 954/// fTotalHistogram has title: title + "" (total)""; 955/// fPassedHistogram has title: title + "" (passed)""; 956/// It is possible to label the axis by passing a title with; 957/// the following format: ""title;xlabel;ylabel;zlabel"".; 958/// - `nbinsx`: number of bins on the x-axis; 959/// - `xlow`: lower edge of first x-bin; 960/// - `xup`: upper edge of last x-bin; 961/// - `nbinsy`: number of bins on the y-axis; 962/// - `ylow`: lower edge of first y-bin; 963/// - `yup`: upper edge of last y-bin; 964/// - `nbinsz`: number of bins on the z-axis; 965/// - `zlow`: lower edge of first z-bin; 966/// - `zup`: upper edge of last z-bin; 967 ; 968TEfficiency::TEfficiency(const char* name,const char* title,Int_t nbinsx,; 969 Double_t xlow,Double_t xup,Int_t nbinsy,; 970 Double_t ylow,Double_t yup,Int_t nbinsz,; 971 Double_t zlow,Double_t zup):; 972fBeta_alpha(kDefBetaAlpha),; 973fBeta_beta(kDefBetaBeta),; 974fConfLevel(kDefConfLevel),; 975fDirectory(nullptr),; 976fFunctions(nullptr),; 977fPaintGraph(nullptr),; 978fPaintHisto(nullptr),; 979fWeight(kDefWeight); 980{; 981 // do not add new created histograms to gDirectory; 982 {; 983 TDirectory::TContext ctx(nullptr);; 984 fTotalHistogram = new TH3D(""total"",""total"",nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup);; 985 fPassedHistogram = new TH3D(""passed"",""passed"",nbinsx,xlow,xup,nbinsy,ylow,yup,nbinsz,zlow,zup);; 986 }; 987 Build(name,title);; 988}; 989 ; 990////////////////////////////////////////////////////////////////////////////////; 991/// Create 3-dimensional TEfficiency object with variable bin size.; 992///; 993/// Constructor creates two new and empty histograms with a given binning.; 994///; 995/// Input:; 996///; 997/// - `name`: the common part of the name for both histograms(no blanks); 998/// fTotalHistogram has name: name + ""_total""; 999/// fPassedHistogram has name: name + ""_passed""; 1000/// - `title`: the common ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:125774,Modifiability,variab,variable,125774,"53/// Have histograms fixed bins along each axis?; 3154 ; 3155void TEfficiency::SavePrimitive(std::ostream& out,Option_t* opt); 3156{; 3157 Bool_t equi_bins = true;; 3158 ; 3159 //indentation; 3160 TString indent = "" "";; 3161 //names for arrays containing the bin edges; 3162 //static counter needed if more objects are saved; 3163 static Int_t naxis = 0;; 3164 TString sxaxis=""xAxis"",syaxis=""yAxis"",szaxis=""zAxis"";; 3165 ; 3166 //note the missing break statements!; 3167 switch(GetDimension()) {; 3168 case 3:; 3169 equi_bins = equi_bins && !fTotalHistogram->GetZaxis()->GetXbins()->fArray; 3170 && !fTotalHistogram->GetZaxis()->GetXbins()->fN;; 3171 case 2:; 3172 equi_bins = equi_bins && !fTotalHistogram->GetYaxis()->GetXbins()->fArray; 3173 && !fTotalHistogram->GetYaxis()->GetXbins()->fN;; 3174 case 1:; 3175 equi_bins = equi_bins && !fTotalHistogram->GetXaxis()->GetXbins()->fArray; 3176 && !fTotalHistogram->GetXaxis()->GetXbins()->fN;; 3177 }; 3178 ; 3179 //create arrays containing the variable binning; 3180 if(!equi_bins) {; 3181 Int_t i;; 3182 ++naxis;; 3183 sxaxis += naxis;; 3184 syaxis += naxis;; 3185 szaxis += naxis;; 3186 //x axis; 3187 out << indent << ""Double_t "" << sxaxis << ""[""; 3188 << fTotalHistogram->GetXaxis()->GetXbins()->fN << ""] = {"";; 3189 for (i = 0; i < fTotalHistogram->GetXaxis()->GetXbins()->fN; ++i) {; 3190 if (i != 0) out << "", "";; 3191 out << fTotalHistogram->GetXaxis()->GetXbins()->fArray[i];; 3192 }; 3193 out << ""}; "" << std::endl;; 3194 //y axis; 3195 if(GetDimension() > 1) {; 3196 out << indent << ""Double_t "" << syaxis << ""[""; 3197 << fTotalHistogram->GetYaxis()->GetXbins()->fN << ""] = {"";; 3198 for (i = 0; i < fTotalHistogram->GetYaxis()->GetXbins()->fN; ++i) {; 3199 if (i != 0) out << "", "";; 3200 out << fTotalHistogram->GetYaxis()->GetXbins()->fArray[i];; 3201 }; 3202 out << ""}; "" << std::endl;; 3203 }; 3204 //z axis; 3205 if(GetDimension() > 2) {; 3206 out << indent << ""Double_t "" << szaxis << ""[""; 3207 << fTotalHistogram->GetZaxis()->GetXb",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:127038,Modifiability,variab,variable,127038,"68 case 3:; 3169 equi_bins = equi_bins && !fTotalHistogram->GetZaxis()->GetXbins()->fArray; 3170 && !fTotalHistogram->GetZaxis()->GetXbins()->fN;; 3171 case 2:; 3172 equi_bins = equi_bins && !fTotalHistogram->GetYaxis()->GetXbins()->fArray; 3173 && !fTotalHistogram->GetYaxis()->GetXbins()->fN;; 3174 case 1:; 3175 equi_bins = equi_bins && !fTotalHistogram->GetXaxis()->GetXbins()->fArray; 3176 && !fTotalHistogram->GetXaxis()->GetXbins()->fN;; 3177 }; 3178 ; 3179 //create arrays containing the variable binning; 3180 if(!equi_bins) {; 3181 Int_t i;; 3182 ++naxis;; 3183 sxaxis += naxis;; 3184 syaxis += naxis;; 3185 szaxis += naxis;; 3186 //x axis; 3187 out << indent << ""Double_t "" << sxaxis << ""[""; 3188 << fTotalHistogram->GetXaxis()->GetXbins()->fN << ""] = {"";; 3189 for (i = 0; i < fTotalHistogram->GetXaxis()->GetXbins()->fN; ++i) {; 3190 if (i != 0) out << "", "";; 3191 out << fTotalHistogram->GetXaxis()->GetXbins()->fArray[i];; 3192 }; 3193 out << ""}; "" << std::endl;; 3194 //y axis; 3195 if(GetDimension() > 1) {; 3196 out << indent << ""Double_t "" << syaxis << ""[""; 3197 << fTotalHistogram->GetYaxis()->GetXbins()->fN << ""] = {"";; 3198 for (i = 0; i < fTotalHistogram->GetYaxis()->GetXbins()->fN; ++i) {; 3199 if (i != 0) out << "", "";; 3200 out << fTotalHistogram->GetYaxis()->GetXbins()->fArray[i];; 3201 }; 3202 out << ""}; "" << std::endl;; 3203 }; 3204 //z axis; 3205 if(GetDimension() > 2) {; 3206 out << indent << ""Double_t "" << szaxis << ""[""; 3207 << fTotalHistogram->GetZaxis()->GetXbins()->fN << ""] = {"";; 3208 for (i = 0; i < fTotalHistogram->GetZaxis()->GetXbins()->fN; ++i) {; 3209 if (i != 0) out << "", "";; 3210 out << fTotalHistogram->GetZaxis()->GetXbins()->fArray[i];; 3211 }; 3212 out << ""}; "" << std::endl;; 3213 }; 3214 }//creating variable binning; 3215 ; 3216 //TEfficiency pointer has efficiency name + counter; 3217 static Int_t eff_count = 0;; 3218 ++eff_count;; 3219 TString eff_name = GetName();; 3220 eff_name += eff_count;; 3221 ; 3222 const char* name = eff_name.",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:128245,Modifiability,variab,variable,128245,,MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:184073,Modifiability,inherit,inherits,184073," all ROOT objects.Definition TObject.h:41; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::FirstSsiz_t First(char c) con",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:59559,Performance,perform,perform,59559,"wer, Double_t & upper); 1405{; 1406 if (a <= 0 || b <= 0) {; 1407 lower = 0; upper = 1;; 1408 gROOT->Error(""TEfficiency::BayesianShortest"",""Invalid input parameters - return [0,1]"");; 1409 return kFALSE;; 1410 }; 1411 ; 1412 // treat here special cases when mode == 0 or 1; 1413 double mode = BetaMode(a,b);; 1414 if (mode == 0.0) {; 1415 lower = 0;; 1416 upper = ROOT::Math::beta_quantile(level, a, b);; 1417 return kTRUE;; 1418 }; 1419 if (mode == 1.0) {; 1420 lower = ROOT::Math::beta_quantile_c(level, a, b);; 1421 upper = 1.0;; 1422 return kTRUE;; 1423 }; 1424 // special case when the shortest interval is undefined return the central interval; 1425 // can happen for a posterior when passed=total=0; 1426 //; 1427 if ( a==b && a<=1.0) {; 1428 lower = BetaCentralInterval(level,a,b,kFALSE);; 1429 upper = BetaCentralInterval(level,a,b,kTRUE);; 1430 return kTRUE;; 1431 }; 1432 ; 1433 // for the other case perform a minimization; 1434 // make a function of the length of the posterior interval as a function of lower bound; 1435 Beta_interval_length intervalLength(level,a,b);; 1436 // minimize the interval length; 1437 ROOT::Math::WrappedFunction<const Beta_interval_length &> func(intervalLength);; 1438 ROOT::Math::BrentMinimizer1D minim;; 1439 minim.SetFunction(func, 0, intervalLength.LowerMax() );; 1440 minim.SetNpx(2); // no need to bracket with many iterations. Just do few times to estimate some better points; 1441 bool ret = minim.Minimize(100, 1.E-10,1.E-10);; 1442 if (!ret) {; 1443 gROOT->Error(""TEfficiency::BayesianShortes"",""Error finding the shortest interval"");; 1444 return kFALSE;; 1445 }; 1446 lower = minim.XMinimum();; 1447 upper = lower + minim.FValMinimum();; 1448 return kTRUE;; 1449}; 1450 ; 1451////////////////////////////////////////////////////////////////////////////////; 1452/// Compute the mean (average) of the beta distribution; 1453///; 1454/// \param[in] a parameter > 0 for the beta distribution (for a posterior is passed + prior_alpha; 1455/// \param",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:156361,Performance,perform,performing,156361,"ption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TGraph2DAsymmErrors.h; TGraphAsymmErrors.h; TH1.h; TH2.h; TH3.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TList.h; TMath.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; WrappedFunction.h; BinomialNeymanInterval::Lowerdouble Lower() constDefinition TEfficiencyHelper.h:163; BinomialNeymanInterval::Upperdouble Upper() constDefinition TEfficiencyHelper.h:164; BinomialNeymanInterval::Initvoid Init(double alpha)Definition TEfficiencyHelper.h:79; BinomialNeymanInterval::Calculatevoid Calculate(const double X, const double n)Definition TEfficiencyHelper.h:128; FeldmanCousinsBinomialIntervalDefinition TEfficiencyHelper.h:187; ROOT::Math::BrentMinimizer1DUser class for performing function minimization.Definition BrentMinimizer1D.h:62; ROOT::Math::BrentMinimizer1D::SetFunctionvoid SetFunction(const ROOT::Math::IGenFunction &f, double xlow, double xup)Sets function to be minimized.Definition BrentMinimizer1D.cxx:48; ROOT::Math::BrentMinimizer1D::Minimizebool Minimize(int maxIter, double absTol=1.E-8, double relTol=1.E-10) overrideFind minimum position iterating until convergence specified by the absolute and relative tolerance or...Definition BrentMinimizer1D.cxx:76; ROOT::Math::BrentMinimizer1D::SetNpxvoid SetNpx(int npx)Set the number of point used to bracket root using a grid.Definition BrentMinimizer1D.h:116; ROOT::Math::BrentMinimizer1D::XMinimumdouble XMinimum() const overrideReturn current estimate of the position of the minimum.Definition BrentMinimizer1D.h:75; ROOT::Math::BrentMinimizer1D::FValMinimumdouble FValMinimum() const overrideReturn function value at current estimate of the minimum.Definition BrentMinimizer1D.cxx:67; ROOT::Mat",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:5400,Safety,avoid,avoid,5400,"reate a two-dimensional TEfficiency object with; 104- name = ""eff""; 105- title = ""my efficiency""; 106- axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; 107- 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; 108 from the first bin) up to 10 (upper edge of last bin); 109- 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; 110 edge from the first bin) up to 5 (upper edge of last bin); 111 ; 112 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);; 113 ; 114If you already have two histograms filled with the number of passed and total; 115events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); 116to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; 117to fulfill the conditions mentioned in TEfficiency::CheckConsistency, otherwise the construction will fail.; 118As the histograms already exist, the new TEfficiency is by default **not** attached; 119to the current directory to avoid duplication of data. If you want to store the; 120new object anyway, you can either write it directly by calling TObject::Write or attach it to a directory using TEfficiency::SetDirectory.; 121This also applies to TEfficiency objects created by the copy constructor TEfficiency::TEfficiency(const TEfficiency& rEff).; 122 ; 123\anchor EFF02a; 124### Example 1; 125 ; 126~~~~~~~~~~~~~~~{.cpp}; 127TEfficiency* pEff = 0;; 128TFile* pFile = new TFile(""myfile.root"",""recreate"");; 129 ; 130//h_pass and h_total are valid and consistent histograms; 131if(TEfficiency::CheckConsistency(h_pass,h_total)); 132{; 133 pEff = new TEfficiency(h_pass,h_total);; 134 // this will write the TEfficiency object to ""myfile.root""; 135 // AND pEff will be attached to the current directory; 136 pEff->Write();; 137}; 138~~~~~~~~~~~~~~~; 139 ; 140\anchor EFF02b; 141### Example 2; 142 ; 143~~~~~~~~~~~~~~~{.cpp}; 144TEfficiency* pEff = 0;; 145TFile* pFile = new TFile(",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:104886,Safety,avoid,avoid,104886,"tains(""N"")) { // option ""N"" is not store fit function; 2573 TF1* pFunc = (TF1*)f1->IsA()->New();; 2574 f1->Copy(*pFunc);; 2575 ; 2576 if(bDeleteOld) {; 2577 TIter next(fFunctions);; 2578 TObject* obj = nullptr;; 2579 while((obj = next())) {; 2580 if(obj->InheritsFrom(TF1::Class())) {; 2581 fFunctions->Remove(obj);; 2582 delete obj;; 2583 }; 2584 }; 2585 }; 2586 // create list if necessary; 2587 if(!fFunctions); 2588 fFunctions = new TList();; 2589 ; 2590 fFunctions->Add(pFunc);; 2591 }; 2592 ; 2593 return result;; 2594}; 2595 ; 2596////////////////////////////////////////////////////////////////////////////////; 2597/// Returns a cloned version of fPassedHistogram; 2598///; 2599/// Notes:; 2600/// - The histogram is filled with unit weights. You might want to scale; 2601/// it with the global weight GetWeight().; 2602/// - The returned object is owned by the user who has to care about the; 2603/// deletion of the new TH1 object.; 2604/// - This histogram is by default NOT attached to the current directory; 2605/// to avoid duplication of data. If you want to store it automatically; 2606/// during the next TFile::Write() command, you have to attach it to; 2607/// the corresponding directory.; 2608///; 2609/// ~~~~~~~{.cpp}; 2610/// TFile* pFile = new TFile(""passed.root"",""update"");; 2611/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2612/// TH1* copy = pEff->GetCopyPassedHisto();; 2613/// copy->SetDirectory(gDirectory);; 2614/// pFile->Write();; 2615/// ~~~~~~~; 2616 ; 2617TH1* TEfficiency::GetCopyPassedHisto() const; 2618{; 2619 // do not add cloned histogram to gDirectory; 2620 TDirectory::TContext ctx(nullptr);; 2621 TH1* tmp = (TH1*)(fPassedHistogram->Clone());; 2622 ; 2623 return tmp;; 2624}; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// Returns a cloned version of fTotalHistogram; 2628///; 2629/// Notes:; 2630/// - The histogram is filled with unit weights. You might want to scale; 2631/// ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:106102,Safety,avoid,avoid,106102,"//; 2609/// ~~~~~~~{.cpp}; 2610/// TFile* pFile = new TFile(""passed.root"",""update"");; 2611/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2612/// TH1* copy = pEff->GetCopyPassedHisto();; 2613/// copy->SetDirectory(gDirectory);; 2614/// pFile->Write();; 2615/// ~~~~~~~; 2616 ; 2617TH1* TEfficiency::GetCopyPassedHisto() const; 2618{; 2619 // do not add cloned histogram to gDirectory; 2620 TDirectory::TContext ctx(nullptr);; 2621 TH1* tmp = (TH1*)(fPassedHistogram->Clone());; 2622 ; 2623 return tmp;; 2624}; 2625 ; 2626////////////////////////////////////////////////////////////////////////////////; 2627/// Returns a cloned version of fTotalHistogram; 2628///; 2629/// Notes:; 2630/// - The histogram is filled with unit weights. You might want to scale; 2631/// it with the global weight GetWeight().; 2632/// - The returned object is owned by the user who has to care about the; 2633/// deletion of the new TH1 object.; 2634/// - This histogram is by default NOT attached to the current directory; 2635/// to avoid duplication of data. If you want to store it automatically; 2636/// during the next TFile::Write() command, you have to attach it to; 2637/// the corresponding directory.; 2638///; 2639/// ~~~~~~~{.cpp}; 2640/// TFile* pFile = new TFile(""total.root"",""update"");; 2641/// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; 2642/// TH1* copy = pEff->GetCopyTotalHisto();; 2643/// copy->SetDirectory(gDirectory);; 2644/// pFile->Write();; 2645/// ~~~~~~~; 2646 ; 2647TH1* TEfficiency::GetCopyTotalHisto() const; 2648{; 2649 // do not add cloned histogram to gDirectory; 2650 TDirectory::TContext ctx(nullptr);; 2651 TH1* tmp = (TH1*)(fTotalHistogram->Clone());; 2652 ; 2653 return tmp;; 2654}; 2655 ; 2656////////////////////////////////////////////////////////////////////////////////; 2657///returns the dimension of the current TEfficiency object; 2658 ; 2659Int_t TEfficiency::GetDimension() const; 2660{; 2661 return fTotalHistogram->GetDimension();;",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:111727,Safety,avoid,avoid,111727,"; 2770 {; 2771 if(fStatisticOption != kFNormal); 2772 {; 2773 Warning(""GetEfficiencyErrorLow"",""frequentist confidence intervals for weights are only supported by the normal approximation"");; 2774 Info(""GetEfficiencyErrorLow"",""setting statistic option to kFNormal"");; 2775 const_cast<TEfficiency*>(this)->SetStatisticOption(kFNormal);; 2776 }; 2777 ; 2778 Double_t variance = ( pw2 * (1. - 2 * eff) + tw2 * eff *eff ) / ( tw * tw) ;; 2779 Double_t sigma = sqrt(variance);; 2780 ; 2781 Double_t prob = 0.5 * (1.- fConfLevel);; 2782 Double_t delta = ROOT::Math::normal_quantile_c(prob, sigma);; 2783 ; 2784 // avoid to return errors which makes eff-err < 0; 2785 return (eff - delta < 0) ? eff : delta;; 2786 }; 2787 }; 2788 else; 2789 {; 2790 if(TestBit(kIsBayesian)); 2791 {; 2792 // parameters for the beta prior distribution; 2793 Double_t alpha = TestBit(kUseBinPrior) ? GetBetaAlpha(bin) : GetBetaAlpha();; 2794 Double_t beta = TestBit(kUseBinPrior) ? GetBetaBeta(bin) : GetBetaBeta();; 2795 return (eff - Bayesian(total,passed,fConfLevel,alpha,beta,false,TestBit(kShortestInterval)));; 2796 }; 2797 else; 2798 return (eff - fBoundary(total,passed,fConfLevel,false));; 2799 }; 2800}; 2801 ; 2802////////////////////////////////////////////////////////////////////////////////; 2803/// Returns the upper error on the efficiency in the given global bin; 2804///; 2805/// The result depends on the current confidence level fConfLevel and the; 2806/// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; 2807/// more details.; 2808///; 2809/// Note: If the histograms are filled with weights, only bayesian methods and the; 2810/// normal approximation are supported.; 2811 ; 2812Double_t TEfficiency::GetEfficiencyErrorUp(Int_t bin) const; 2813{; 2814 Double_t total = fTotalHistogram->GetBinContent(bin);; 2815 Double_t passed = fPassedHistogram->GetBinContent(bin);; 2816 ; 2817 Double_t eff = GetEfficiency(bin);; 2818 ; 2819 // check whether weights have been used; 2820 i",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:28399,Security,access,accessed,28399,"F1(""f1"",""gaus"",0,10);; 616 f1->SetParameters(1,5,2);; 617 pEff->Fit(f1);; 618 ; 619 //create a threshold function; 620 TF1* f2 = new TF1(""thres"",""0.8"",0,10);; 621 f2->SetLineColor(kRed);; 622 //add it to the list of functions; 623 //use add first because the parameters of the last function will be displayed; 624 pEff->GetListOfFunctions()->AddFirst(f2);; 625 ; 626 pEff->Draw(""AP"");; 627}; 628End_Macro; 629 ; 630\anchor EFF063; 631### VI.3 Draw a TEfficiency object; 632A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; 633At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; 634In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; 635method. For 2-dimensional TEfficiency objects, you can pass the same options as; 636for a TH2::Draw object.; 637 ; 638\anchor EFF064; 639### VI.4 TEfficiency object's axis customisation; 640The axes of a TEfficiency object can be accessed and customised by calling the; 641GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; 642methods.; 643Note that in order to access the painted graph via GetPaintedGraph(), one should either; 644call Paint or, better, gPad->Update().; 645 ; 646Begin_Macro(source); 647{; 648 //canvas only needed for this documentation; 649 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 650 c1->SetFillStyle(1001);; 651 c1->SetFillColor(kWhite);; 652 c1->Divide(2,1);; 653 ; 654 //create one-dimensional TEfficiency object with fixed bin size; 655 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 656 TRandom3 rand3;; 657 ; 658 bool bPassed;; 659 double x;; 660 for(int i=0; i<10000; ++i); 661 {; 662 //simulate events with variable under investigation; 663 x = rand3.Uniform(10);; 664 //check selection: bPassed = DoesEventPassSelection(x); 665 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 666 pEff->Fill(bPassed,x);; 667 }; 668 c1->cd(1);; 669 pEff->Draw(""AP"");; 6",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:28566,Security,access,access,28566,"kRed);; 622 //add it to the list of functions; 623 //use add first because the parameters of the last function will be displayed; 624 pEff->GetListOfFunctions()->AddFirst(f2);; 625 ; 626 pEff->Draw(""AP"");; 627}; 628End_Macro; 629 ; 630\anchor EFF063; 631### VI.3 Draw a TEfficiency object; 632A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; 633At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; 634In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; 635method. For 2-dimensional TEfficiency objects, you can pass the same options as; 636for a TH2::Draw object.; 637 ; 638\anchor EFF064; 639### VI.4 TEfficiency object's axis customisation; 640The axes of a TEfficiency object can be accessed and customised by calling the; 641GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; 642methods.; 643Note that in order to access the painted graph via GetPaintedGraph(), one should either; 644call Paint or, better, gPad->Update().; 645 ; 646Begin_Macro(source); 647{; 648 //canvas only needed for this documentation; 649 TCanvas* c1 = new TCanvas(""example"","""",600,400);; 650 c1->SetFillStyle(1001);; 651 c1->SetFillColor(kWhite);; 652 c1->Divide(2,1);; 653 ; 654 //create one-dimensional TEfficiency object with fixed bin size; 655 TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; 656 TRandom3 rand3;; 657 ; 658 bool bPassed;; 659 double x;; 660 for(int i=0; i<10000; ++i); 661 {; 662 //simulate events with variable under investigation; 663 x = rand3.Uniform(10);; 664 //check selection: bPassed = DoesEventPassSelection(x); 665 bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; 666 pEff->Fill(bPassed,x);; 667 }; 668 c1->cd(1);; 669 pEff->Draw(""AP"");; 670 c1->cd(2);; 671 pEff->Draw(""AP"");; 672 gPad->Update();; 673 pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; 674 pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; ",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:122606,Security,access,access,122606,"copy style; 3055 rhs.TAttLine::Copy(*this);; 3056 rhs.TAttFill::Copy(*this);; 3057 rhs.TAttMarker::Copy(*this);; 3058 }; 3059 ; 3060 return *this;; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Paints this TEfficiency object; 3065///; 3066/// For details on the possible option see Draw(Option_t*); 3067///; 3068/// Note for 1D classes; 3069/// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; 3070/// The TGraph is created only the first time Paint is used. The user can manipulate the; 3071/// TGraph via the method TEfficiency::GetPaintedGraph(); 3072/// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; 3073/// If the axis needs to be updated because in the meantime the class changed use this trick; 3074/// which will trigger a re-calculation of the axis of the graph; 3075/// TEfficiency::GetPaintedGraph()->Set(0); 3076///; 3077/// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; 3078/// gPad->Update();; 3079///; 3080 ; 3081void TEfficiency::Paint(const Option_t* opt); 3082{; 3083 ; 3084 ; 3085 if(!gPad); 3086 return;; 3087 ; 3088 TString option(opt);; 3089 option.ToUpper();; 3090 ; 3091 ; 3092 //use TGraphAsymmErrors for painting; 3093 if(GetDimension() == 1) {; 3094 if(!fPaintGraph) {; 3095 fPaintGraph = CreateGraph(opt);; 3096 }; 3097 else; 3098 // update existing graph already created; 3099 FillGraph(fPaintGraph, opt);; 3100 ; 3101 //paint graph; 3102 fPaintGraph->Paint(opt);; 3103 // paint all associated functions; 3104 if (fFunctions) {; 3105 // paint box with fit parameters; 3106 // the fit statistics will be painted if gStyle->SetOptFit(1) has been; 3107 // called by the user; 3108 TIter next(fFunctions);; 3109 TObject *obj = nullptr;; 3110 while ((obj = next())) {; 3111 if (obj->InheritsFrom(TF1::Class())) {; 3112 fPaintGraph->PaintStats((TF1 *)obj);; 3113 ((TF1 *)obj)->Paint",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:46153,Testability,log,logic,46153,"fLevel),; 1063 fDirectory(nullptr),; 1064 fFunctions(nullptr),; 1065 fPaintGraph(nullptr),; 1066 fPaintHisto(nullptr),; 1067 fWeight(rEff.fWeight); 1068{; 1069 // copy TObject bits; 1070 rEff.TObject::Copy(*this);; 1071 ; 1072 // do not add cloned histograms to gDirectory; 1073 {; 1074 TDirectory::TContext ctx(nullptr);; 1075 fTotalHistogram = (TH1*)((rEff.fTotalHistogram)->Clone());; 1076 fPassedHistogram = (TH1*)((rEff.fPassedHistogram)->Clone());; 1077 }; 1078 ; 1079 TString name = rEff.GetName();; 1080 name += ""_copy"";; 1081 SetName(name);; 1082 TString title = ""[copy] "";; 1083 title += rEff.GetTitle();; 1084 SetTitle(title);; 1085 ; 1086 SetStatisticOption(rEff.GetStatisticOption());; 1087 ; 1088 SetDirectory(nullptr);; 1089 ; 1090 //copy style; 1091 rEff.TAttLine::Copy(*this);; 1092 rEff.TAttFill::Copy(*this);; 1093 rEff.TAttMarker::Copy(*this);; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097///default destructor; 1098 ; 1099TEfficiency::~TEfficiency(); 1100{; 1101 //delete all function in fFunctions; 1102 // use same logic as in TH1 destructor; 1103 // (see TH1::~TH1 code in TH1.cxx); 1104 if(fFunctions) {; 1105 fFunctions->SetBit(kInvalidObject);; 1106 TObject* obj = nullptr;; 1107 while ((obj = fFunctions->First())) {; 1108 while(fFunctions->Remove(obj)) { }; 1109 if (ROOT::Detail::HasBeenDeleted(obj)) {; 1110 break;; 1111 }; 1112 delete obj;; 1113 obj = nullptr;; 1114 }; 1115 delete fFunctions;; 1116 fFunctions = nullptr;; 1117 }; 1118 ; 1119 if(fDirectory); 1120 fDirectory->Remove(this);; 1121 ; 1122 delete fTotalHistogram;; 1123 delete fPassedHistogram;; 1124 delete fPaintGraph;; 1125 delete fPaintHisto;; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/**; 1130 Calculates the boundaries for the frequentist Agresti-Coull interval; 1131 ; 1132 \param total number of total events; 1133 \param passed 0 <= number of passed events <= total; 1134 \",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:80821,Testability,test,test,80821,"()->SetBinLabel(ibiny, fTotalHistogram->GetYaxis()->GetBinLabel(ibiny));; 1961 }; 1962 ; 1963 //copying style information; 1964 TAttLine::Copy(*hist);; 1965 TAttFill::Copy(*hist);; 1966 TAttMarker::Copy(*hist);; 1967 hist->SetStats(false);; 1968 ; 1969 return;; 1970 ; 1971}; 1972////////////////////////////////////////////////////////////////////////////////; 1973/**; 1974Calculates the boundaries for the frequentist Clopper-Pearson interval; 1975 ; 1976This interval is recommended by the PDG.; 1977 ; 1978\param[in] total number of total events; 1979\param[in] passed 0 <= number of passed events <= total; 1980\param[in] level confidence level; 1981\param[in] bUpper true - upper boundary is returned; 1982 ;false - lower boundary is returned; 1983 ; 1984Calculation:; 1985 ; 1986The lower boundary of the Clopper-Pearson interval is the ""exact"" inversion; 1987of the test:; 1988 \f{eqnarray*}{; 1989 P(x \geq passed; total) &=& \frac{1 - level}{2}\\; 1990 P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\; 1991 &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\; 1992 &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\; 1993 &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\; 1994 &=& I_{\varepsilon}(passed,total - passed + 1); 1995 \f}; 1996The lower boundary is therefore given by the \f$ \frac{1 - level}{2}\f$ quantile; 1997of the beta distribution.; 1998 ; 1999The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion; 2000of the test:; 2001 \f{eqnarray*}{; 2002 P(x \leq passed; total) &=& \frac{1 - level}{2}\\; 2003 P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\; 2004 &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\; 2005 &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:81549,Testability,test,test,81549," passed; total) &=& \frac{1 - level}{2}\\; 1990 P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\; 1991 &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\; 1992 &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\; 1993 &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\; 1994 &=& I_{\varepsilon}(passed,total - passed + 1); 1995 \f}; 1996The lower boundary is therefore given by the \f$ \frac{1 - level}{2}\f$ quantile; 1997of the beta distribution.; 1998 ; 1999The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion; 2000of the test:; 2001 \f{eqnarray*}{; 2002 P(x \leq passed; total) &=& \frac{1 - level}{2}\\; 2003 P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\; 2004 &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\; 2005 &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt\\; 2006 \Rightarrow 1 - \frac{1 - level}{2} &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed -1} dt\\; 2007 \frac{1 + level}{2} &=& I_{\varepsilon}(passed + 1,total - passed); 2008 \f}; 2009The upper boundary is therefore given by the \f$\frac{1 + level}{2}\f$ quantile; 2010of the beta distribution.; 2011 ; 2012Note: The connection between the binomial distribution and the regularized; 2013 incomplete beta function \f$ I_{\varepsilon}(\alpha,\beta)\f$ has been used.; 2014*/; 2015 ; 2016Double_t TEfficiency::ClopperPearson(Double_t total,Double_t passed,Double_t level,Bool_t bUpper); 2017{; 2018 Double_t alpha = (1.0 - level) / 2;; 2019 if(bUpper); 2020 return ((passed == total) ? 1.0 : ROOT::Math::beta_quantile(1 - alpha,passed + 1,total-passed));; 2021 else; 2022 return ((passed == 0) ? 0.0 : ROOT::Math::beta_quantile(alpha,passed,total-passed+1.0));; 2023}; 2024//////////",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:142206,Usability,clear,cleared,142206,"nt(bin); 3565 ; 3566Bool_t TEfficiency::SetPassedEvents(Int_t bin,Int_t events); 3567{; 3568 if(events <= fTotalHistogram->GetBinContent(bin)) {; 3569 fPassedHistogram->SetBinContent(bin,events);; 3570 return true;; 3571 }; 3572 else {; 3573 Error(""SetPassedEvents(Int_t,Int_t)"",""total number of events (%.1lf) in bin %i is less than given number of passed events %i"",fTotalHistogram->GetBinContent(bin),bin,events);; 3574 return false;; 3575 }; 3576}; 3577 ; 3578////////////////////////////////////////////////////////////////////////////////; 3579/// Sets the histogram containing the passed events; 3580///; 3581/// The given histogram is cloned and stored internally as histogram containing; 3582/// the passed events. The given histogram has to be consistent with the current; 3583/// fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3584/// The method returns whether the fPassedHistogram has been replaced (true) or; 3585/// not (false).; 3586///; 3587/// Note: The list of associated functions fFunctions is cleared.; 3588///; 3589/// Option:; 3590/// - ""f"": force the replacement without checking the consistency; 3591/// This can lead to inconsistent histograms and useless results; 3592/// or unexpected behaviour. But sometimes it might be the only; 3593/// way to change the histograms. If you use this option, you; 3594/// should ensure that the fTotalHistogram is replaced by a; 3595/// consistent one (with respect to rPassed) as well.; 3596 ; 3597Bool_t TEfficiency::SetPassedHistogram(const TH1& rPassed,Option_t* opt); 3598{; 3599 TString option = opt;; 3600 option.ToLower();; 3601 ; 3602 Bool_t bReplace = option.Contains(""f"");; 3603 ; 3604 if(!bReplace); 3605 bReplace = CheckConsistency(rPassed,*fTotalHistogram);; 3606 ; 3607 if(bReplace) {; 3608 delete fPassedHistogram;; 3609 // do not add cloned histogram to gDirectory; 3610 {; 3611 TDirectory::TContext ctx(nullptr);; 3612 fPassedHistogram = (TH1*)(rPassed.Clone());; 3613 fPassedHistogram->SetNormFactor(",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8cxx_source.html:148842,Usability,clear,cleared,148842," <= events; 3759 ; 3760Bool_t TEfficiency::SetTotalEvents(Int_t bin, Double_t events); 3761{; 3762 if(events >= fPassedHistogram->GetBinContent(bin)) {; 3763 fTotalHistogram->SetBinContent(bin,events);; 3764 return true;; 3765 }; 3766 else {; 3767 Error(""SetTotalEvents(Int_t,Double_t)"",""passed number of events (%.1lf) in bin %i is bigger than given number of total events %.1lf"",fPassedHistogram->GetBinContent(bin),bin,events);; 3768 return false;; 3769 }; 3770}; 3771 ; 3772////////////////////////////////////////////////////////////////////////////////; 3773/// Sets the histogram containing all events; 3774///; 3775/// The given histogram is cloned and stored internally as histogram containing; 3776/// all events. The given histogram has to be consistent with the current; 3777/// fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; 3778/// The method returns whether the fTotalHistogram has been replaced (true) or; 3779/// not (false).; 3780///; 3781/// Note: The list of associated functions fFunctions is cleared.; 3782///; 3783/// Option:; 3784/// - ""f"": force the replacement without checking the consistency; 3785/// This can lead to inconsistent histograms and useless results; 3786/// or unexpected behaviour. But sometimes it might be the only; 3787/// way to change the histograms. If you use this option, you; 3788/// should ensure that the fPassedHistogram is replaced by a; 3789/// consistent one (with respect to rTotal) as well.; 3790 ; 3791Bool_t TEfficiency::SetTotalHistogram(const TH1& rTotal,Option_t* opt); 3792{; 3793 TString option = opt;; 3794 option.ToLower();; 3795 ; 3796 Bool_t bReplace = option.Contains(""f"");; 3797 ; 3798 if(!bReplace); 3799 bReplace = CheckConsistency(*fPassedHistogram,rTotal);; 3800 ; 3801 if(bReplace) {; 3802 delete fTotalHistogram;; 3803 // do not add cloned histogram to gDirectory; 3804 {; 3805 TDirectory::TContext ctx(nullptr);; 3806 fTotalHistogram = (TH1*)(rTotal.Clone());; 3807 }; 3808 fTotalHistogram->SetNormFacto",MatchSource.WIKI,doc/master/TEfficiency_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html
https://root.cern/doc/master/TEfficiency_8h_source.html:18298,Availability,error,error,18298,"cy::GetDimensionInt_t GetDimension() constreturns the dimension of the current TEfficiency objectDefinition TEfficiency.cxx:2659; TEfficiency::fPaintGraph2DTGraph2DAsymmErrors * fPaintGraph2D! Temporary graph for paintingDefinition TEfficiency.h:56; TEfficiency::operator+=TEfficiency & operator+=(const TEfficiency &rhs)Adds the histograms of another TEfficiency object to current histograms.Definition TEfficiency.cxx:2979; TEfficiency::SetBinsBool_t SetBins(Int_t nx, Double_t xmin, Double_t xmax)Set the bins for the underlined passed and total histograms If the class have been already filled the...Definition TEfficiency.cxx:3389; TEfficiency::Buildvoid Build(const char *name, const char *title)Building standard data structure of a TEfficiency object.Definition TEfficiency.cxx:1505; TEfficiency::GetCopyPassedHistoTH1 * GetCopyPassedHisto() constReturns a cloned version of fPassedHistogram.Definition TEfficiency.cxx:2617; TEfficiency::GetEfficiencyErrorUpDouble_t GetEfficiencyErrorUp(Int_t bin) constReturns the upper error on the efficiency in the given global bin.Definition TEfficiency.cxx:2812; TEfficiency::fBeta_alphaDouble_t fBeta_alphaGlobal parameter for prior beta distribution (default = 1)Definition TEfficiency.h:47; TEfficiency::UsesBayesianStatBool_t UsesBayesianStat() constDefinition TEfficiency.h:161; TEfficiency::GetPassedHistogramconst TH1 * GetPassedHistogram() constDefinition TEfficiency.h:125; TEfficiency::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *opt="""") overrideHave histograms fixed bins along each axis?Definition TEfficiency.cxx:3155; TEfficiency::SetBetaBetavoid SetBetaBeta(Double_t beta)Sets the shape parameter β.Definition TEfficiency.cxx:3347; TEfficiency::GetConfidenceLevelDouble_t GetConfidenceLevel() constDefinition TEfficiency.h:112; TEfficiency::CheckBinningstatic Bool_t CheckBinning(const TH1 &pass, const TH1 &total)Checks binning for each axis.Definition TEfficiency.cxx:1527; TEfficiency::SetNamevoid SetName(const char *",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
https://root.cern/doc/master/TEfficiency_8h_source.html:27134,Availability,error,error,27134," bin.Definition TEfficiency.cxx:3368; TEfficiency::CheckConsistencystatic Bool_t CheckConsistency(const TH1 &pass, const TH1 &total, Option_t *opt="""")Checks the consistence of the given histograms.Definition TEfficiency.cxx:1576; TEfficiency::GetWeightDouble_t GetWeight() constDefinition TEfficiency.h:128; TEfficiency::Addvoid Add(const TEfficiency &rEff)Definition TEfficiency.h:97; TEfficiency::GetCopyTotalHistoTH1 * GetCopyTotalHisto() constReturns a cloned version of fTotalHistogram.Definition TEfficiency.cxx:2647; TEfficiency::ClopperPearsonstatic Double_t ClopperPearson(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TEfficiency::SetConfidenceLevelvoid SetConfidenceLevel(Double_t level)Sets the confidence level (0 < level < 1) The default value is 1-sigma :~ 0.683.Definition TEfficiency.cxx:3511; TEfficiency::GetEfficiencyErrorLowDouble_t GetEfficiencyErrorLow(Int_t bin) constReturns the lower error on the efficiency in the given global bin.Definition TEfficiency.cxx:2732; TEfficiency::UsesShortestIntervalBool_t UsesShortestInterval() constDefinition TEfficiency.h:163; TEfficiency::EStatOptionEStatOptionEnumeration type for different statistic options for calculating confidence intervals kF* ....Definition TEfficiency.h:33; TEfficiency::kBJeffrey@ kBJeffreyJeffrey interval (Prior ~ Beta(0.5,0.5)Definition TEfficiency.h:39; TEfficiency::kFWilson@ kFWilsonWilson interval.Definition TEfficiency.h:36; TEfficiency::kFAC@ kFACAgresti-Coull interval.Definition TEfficiency.h:37; TEfficiency::kMidP@ kMidPMid-P Lancaster interval.Definition TEfficiency.h:42; TEfficiency::kBUniform@ kBUniformPrior ~ Uniform = Beta(1,1)Definition TEfficiency.h:40; TEfficiency::kFFC@ kFFCFeldman-Cousins interval.Definition TEfficiency.h:38; TEfficiency::kBBayesian@ kBBayesianUser specified Prior ~ Beta(fBeta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
https://root.cern/doc/master/TEfficiency_8h_source.html:28862,Availability,error,errors,28862,"Uniform = Beta(1,1)Definition TEfficiency.h:40; TEfficiency::kFFC@ kFFCFeldman-Cousins interval.Definition TEfficiency.h:38; TEfficiency::kBBayesian@ kBBayesianUser specified Prior ~ Beta(fBeta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal@ kFNormalNormal approximation.Definition TEfficiency.h:35; TEfficiency::kFCP@ kFCPClopper-Pearson interval (recommended by PDG)Definition TEfficiency.h:34; TEfficiency::SetTitlevoid SetTitle(const char *title) overrideSets the title.Definition TEfficiency.cxx:3726; TEfficiency::FitTFitResultPtr Fit(TF1 *f1, Option_t *opt="""")Fits the efficiency using the TBinomialEfficiencyFitter class.Definition TEfficiency.cxx:2555; TEfficiency::fPaintHistoTH2 * fPaintHisto! Temporary histogram for paintingDefinition TEfficiency.h:57; TF11-Dim function classDefinition TF1.h:233; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TGraph2DAsymmErrorsGraph 2D class with errors.Definition TGraph2DAsymmErrors.h:26; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; graphDefinition graph.py:1; Drawth1 Draw(). histhistincTEfficiency.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
https://root.cern/doc/master/TEfficiency_8h_source.html:28946,Availability,error,error,28946," Beta(1,1)Definition TEfficiency.h:40; TEfficiency::kFFC@ kFFCFeldman-Cousins interval.Definition TEfficiency.h:38; TEfficiency::kBBayesian@ kBBayesianUser specified Prior ~ Beta(fBeta_alpha,fBeta_beta)Definition TEfficiency.h:41; TEfficiency::kFNormal@ kFNormalNormal approximation.Definition TEfficiency.h:35; TEfficiency::kFCP@ kFCPClopper-Pearson interval (recommended by PDG)Definition TEfficiency.h:34; TEfficiency::SetTitlevoid SetTitle(const char *title) overrideSets the title.Definition TEfficiency.cxx:3726; TEfficiency::FitTFitResultPtr Fit(TF1 *f1, Option_t *opt="""")Fits the efficiency using the TBinomialEfficiencyFitter class.Definition TEfficiency.cxx:2555; TEfficiency::fPaintHistoTH2 * fPaintHisto! Temporary histogram for paintingDefinition TEfficiency.h:57; TF11-Dim function classDefinition TF1.h:233; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TGraph2DAsymmErrorsGraph 2D class with errors.Definition TGraph2DAsymmErrors.h:26; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; graphDefinition graph.py:1; Drawth1 Draw(). histhistincTEfficiency.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
https://root.cern/doc/master/TEfficiency_8h_source.html:15573,Integrability,depend,depending,15573,"m() constDefinition TEfficiency.h:123; TEfficiency::TEfficiencyTEfficiency()Default constructor.Definition TEfficiency.cxx:691; TEfficiency::GetBetaAlphaDouble_t GetBetaAlpha(Int_t bin=-1) constDefinition TEfficiency.h:110; TEfficiency::SetPosteriorAveragevoid SetPosteriorAverage(Bool_t on=true)Definition TEfficiency.h:143; TEfficiency::FillWeightedvoid FillWeighted(Bool_t bPassed, Double_t weight, Double_t x, Double_t y=0, Double_t z=0)This function is used for filling the two histograms with a weight.Definition TEfficiency.cxx:2494; TEfficiency::Browsevoid Browse(TBrowser *) overrideBrowse object. May be overridden for another default action.Definition TEfficiency.h:98; TEfficiency::~TEfficiency~TEfficiency() overridedefault destructorDefinition TEfficiency.cxx:1099; TEfficiency::GetListOfFunctionsTList * GetListOfFunctions()Definition TEfficiency.cxx:2897; TEfficiency::Bayesianstatic Double_t Bayesian(Double_t total, Double_t passed, Double_t level, Double_t alpha, Double_t beta, Bool_t bUpper, Bool_t bShortest=false)Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending ...Definition TEfficiency.cxx:1324; TEfficiency::AgrestiCoullstatic Double_t AgrestiCoull(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Agresti-Coull interval.Definition TEfficiency.cxx:1149; TEfficiency::MergeLong64_t Merge(TCollection *list)Merges the TEfficiency objects in the given list to the given TEfficiency object using the operator+=...Definition TEfficiency.cxx:2915; TEfficiency::fBeta_bin_paramsstd::vector< std::pair< Double_t, Double_t > > fBeta_bin_paramsParameter for prior beta distribution different bin by bin (default vector is empty)Definition TEfficiency.h:49; TEfficiency::FeldmanCousinsstatic Double_t FeldmanCousins(Double_t total, Double_t passed, Double_t level, Bool_t bUpper)Calculates the boundaries for the frequentist Feldman-Cousins interval.Definition TEfficiency.",MatchSource.WIKI,doc/master/TEfficiency_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEfficiency_8h_source.html
https://root.cern/doc/master/TEllipse_8cxx_source.html:6372,Deployability,release,released,6372," 167/// Draw this ellipse with its current attributes.; 168 ; 169void TEllipse::Draw(Option_t *option); 170{; 171 AppendPad(option);; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Draw this ellipse with new coordinates.; 176 ; 177TEllipse *TEllipse::DrawEllipse(Double_t x1, Double_t y1,Double_t r1,Double_t r2,Double_t phimin,Double_t phimax,Double_t theta,Option_t *option); 178{; 179 TEllipse *newellipse = new TEllipse(x1, y1, r1, r2, phimin, phimax,theta);; 180 TAttLine::Copy(*newellipse);; 181 TAttFill::Copy(*newellipse);; 182 newellipse->SetBit(kCanDelete);; 183 newellipse->AppendPad(option);; 184 if (TestBit(kNoEdges)) newellipse->SetBit(kNoEdges);; 185 return newellipse;; 186}; 187 ; 188////////////////////////////////////////////////////////////////////////////////; 189/// Execute action corresponding to one event.; 190///; 191/// This member function is called when a line is clicked with the locator; 192///; 193/// If Left button clicked on one of the line end points, this point; 194/// follows the cursor until button is released.; 195///; 196/// if Middle button clicked, the line is moved parallel to itself; 197/// until the button is released.; 198///; 199/// NOTE that support for log scale is not implemented; 200 ; 201void TEllipse::ExecuteEvent(Int_t event, Int_t px, Int_t py); 202{; 203 if (!gPad) return;; 204 ; 205 Int_t kMaxDiff = 10;; 206 ; 207 Int_t i, dpx, dpy;; 208 Double_t angle,dx,dy,dphi,ct,st,fTy,fBy,fLx,fRx;; 209 static Int_t px1,py1,npe,r1,r2,sav1,sav2;; 210 const Int_t kMinSize = 25;; 211 const Int_t np = 40;; 212 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 213 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 214 static Int_t x[np+2], y[np+2];; 215 static Int_t pxold, pyold;; 216 static Int_t sig,impair;; 217 static Double_t sdx, sdy;; 218 static Double_t oldX1, oldY1, oldR1, oldR2;; 219 ; 220 Bool_t opaque = gPad->OpaqueMoving();; 221 ; 222 if (!gPad->IsEditable()) return;; 223 ; 224 sw",MatchSource.WIKI,doc/master/TEllipse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEllipse_8cxx_source.html
https://root.cern/doc/master/TEllipse_8cxx_source.html:6489,Deployability,release,released,6489,"////////////////////////////////////////////////////////////; 175/// Draw this ellipse with new coordinates.; 176 ; 177TEllipse *TEllipse::DrawEllipse(Double_t x1, Double_t y1,Double_t r1,Double_t r2,Double_t phimin,Double_t phimax,Double_t theta,Option_t *option); 178{; 179 TEllipse *newellipse = new TEllipse(x1, y1, r1, r2, phimin, phimax,theta);; 180 TAttLine::Copy(*newellipse);; 181 TAttFill::Copy(*newellipse);; 182 newellipse->SetBit(kCanDelete);; 183 newellipse->AppendPad(option);; 184 if (TestBit(kNoEdges)) newellipse->SetBit(kNoEdges);; 185 return newellipse;; 186}; 187 ; 188////////////////////////////////////////////////////////////////////////////////; 189/// Execute action corresponding to one event.; 190///; 191/// This member function is called when a line is clicked with the locator; 192///; 193/// If Left button clicked on one of the line end points, this point; 194/// follows the cursor until button is released.; 195///; 196/// if Middle button clicked, the line is moved parallel to itself; 197/// until the button is released.; 198///; 199/// NOTE that support for log scale is not implemented; 200 ; 201void TEllipse::ExecuteEvent(Int_t event, Int_t px, Int_t py); 202{; 203 if (!gPad) return;; 204 ; 205 Int_t kMaxDiff = 10;; 206 ; 207 Int_t i, dpx, dpy;; 208 Double_t angle,dx,dy,dphi,ct,st,fTy,fBy,fLx,fRx;; 209 static Int_t px1,py1,npe,r1,r2,sav1,sav2;; 210 const Int_t kMinSize = 25;; 211 const Int_t np = 40;; 212 static Bool_t pTop, pL, pR, pBot, pINSIDE;; 213 static Int_t pTx,pTy,pLx,pLy,pRx,pRy,pBx,pBy;; 214 static Int_t x[np+2], y[np+2];; 215 static Int_t pxold, pyold;; 216 static Int_t sig,impair;; 217 static Double_t sdx, sdy;; 218 static Double_t oldX1, oldY1, oldR1, oldR2;; 219 ; 220 Bool_t opaque = gPad->OpaqueMoving();; 221 ; 222 if (!gPad->IsEditable()) return;; 223 ; 224 switch (event) {; 225 ; 226 case kArrowKeyPress:; 227 case kButton1Down:; 228 oldX1 = fX1;; 229 oldY1 = fY1;; 230 oldR1 = fR1;; 231 oldR2 = fR2;; 232 dphi = (fPhimax-fPhim",MatchSource.WIKI,doc/master/TEllipse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEllipse_8cxx_source.html
https://root.cern/doc/master/TEllipse_8cxx_source.html:6537,Testability,log,log,6537,,MatchSource.WIKI,doc/master/TEllipse_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEllipse_8cxx_source.html
https://root.cern/doc/master/temperature_8C.html:595,Deployability,update,update,595,". ROOT: tutorials/tree/temperature.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. temperature.C File ReferenceTutorials » Tree tutorials. Detailed Description; This tutorial illustrates how to use the highlight mode with trees. ; It first creates a TTree from a temperature data set in Prague between 1775 and 2004. Then it defines three pads representing the temperature per year, month and day. Thanks to the highlight mechanism it is possible to explore the data set only by moving the mouse on the plots. Movements on the years' plot will update the months' and days' plot. Movements on the months plot will update the days plot. Movements on the days' plot will display the exact temperature for a given day.; ; Int_t year, month, day;; TTree *tree = nullptr;; TProfile *hYear = nullptr, *hMonth = nullptr, *hDay = nullptr;; TCanvas *Canvas = nullptr;; Int_t customhb = -2;; TLatex *info = nullptr;; ; // Ranges for year, month, day and temperature; Int_t rYear[3]; // from tree/data; Int_t rMonth[3] = { 12, 1, 13 };; Int_t rDay[3] = { 31, 1, 32 };; Double_t rTemp[3] = { 55.0, -20.0, 35.0 };; ; void HighlightDay(Int_t xhb); {; if (!info) {; info = new TLatex();; info->SetTextSizePixels(25);; Canvas->cd(3);; info->Draw();; gPad->Update();; }; ; if (xhb != customhb) day = xhb;; TString temp = TString::Format("" %5.1f #circC"", hDay->GetBinContent(day));; if (hDay->GetBinEntries(day) == 0) temp = "" "";; TString m = "" "";; if (month>0) m = TString::Format(""-%02d"",month);; TString d = "" "";; if (day>0) d = TString::Format(""-%02d"",day);; info->SetText(2.0, hDay->GetMinimum()*0.8, TString::Format(""%4d%s%s%s"", year, m.Data(), d.Data(), temp.Data()));; Canvas->GetPad(3)->Modified();; }; ; void HighlightMonth(Int_t xhb); {; if (!hDay) {; hDay = new TProfile(""hDay"", ""; day; temp, #circC"", rDay[0], rDay[1], rDay[2]);; hDay->SetMinimum(rTemp[1]);; hDay->SetMaximum(rTemp[2]);; hDay->GetYaxis()->SetNdivisions(410);; hDay->SetFillColor(kGray);; h",MatchSource.WIKI,doc/master/temperature_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/temperature_8C.html
https://root.cern/doc/master/temperature_8C.html:664,Deployability,update,update,664,". ROOT: tutorials/tree/temperature.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. temperature.C File ReferenceTutorials » Tree tutorials. Detailed Description; This tutorial illustrates how to use the highlight mode with trees. ; It first creates a TTree from a temperature data set in Prague between 1775 and 2004. Then it defines three pads representing the temperature per year, month and day. Thanks to the highlight mechanism it is possible to explore the data set only by moving the mouse on the plots. Movements on the years' plot will update the months' and days' plot. Movements on the months plot will update the days plot. Movements on the days' plot will display the exact temperature for a given day.; ; Int_t year, month, day;; TTree *tree = nullptr;; TProfile *hYear = nullptr, *hMonth = nullptr, *hDay = nullptr;; TCanvas *Canvas = nullptr;; Int_t customhb = -2;; TLatex *info = nullptr;; ; // Ranges for year, month, day and temperature; Int_t rYear[3]; // from tree/data; Int_t rMonth[3] = { 12, 1, 13 };; Int_t rDay[3] = { 31, 1, 32 };; Double_t rTemp[3] = { 55.0, -20.0, 35.0 };; ; void HighlightDay(Int_t xhb); {; if (!info) {; info = new TLatex();; info->SetTextSizePixels(25);; Canvas->cd(3);; info->Draw();; gPad->Update();; }; ; if (xhb != customhb) day = xhb;; TString temp = TString::Format("" %5.1f #circC"", hDay->GetBinContent(day));; if (hDay->GetBinEntries(day) == 0) temp = "" "";; TString m = "" "";; if (month>0) m = TString::Format(""-%02d"",month);; TString d = "" "";; if (day>0) d = TString::Format(""-%02d"",day);; info->SetText(2.0, hDay->GetMinimum()*0.8, TString::Format(""%4d%s%s%s"", year, m.Data(), d.Data(), temp.Data()));; Canvas->GetPad(3)->Modified();; }; ; void HighlightMonth(Int_t xhb); {; if (!hDay) {; hDay = new TProfile(""hDay"", ""; day; temp, #circC"", rDay[0], rDay[1], rDay[2]);; hDay->SetMinimum(rTemp[1]);; hDay->SetMaximum(rTemp[2]);; hDay->GetYaxis()->SetNdivisions(410);; hDay->SetFillColor(kGray);; h",MatchSource.WIKI,doc/master/temperature_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/temperature_8C.html
https://root.cern/doc/master/temperature_8C.html:6225,Usability,simpl,simplification,6225," gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TAttText::SetTextSizePixelsvirtual void SetTextSizePixels(Int_t npixels)Set the text size in pixel.Definition TAttText.cxx:423; TCanvasThe Canvas class.Definition TCanvas.h:23; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TCanvas::Updatevoid Update() overrideUpdate canvas pad buffers.Definition TCanvas.cxx:2489; TH1::GetMeanvirtual Double_t GetMean(Int_t axis=1) constFor axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis.Definition TH1.cxx:7535; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::SetHighlightvirtual void SetHighlight(Bool_t set=kTRUE)Set highlight (enable/disable) mode for the histogram by default highlight mode ",MatchSource.WIKI,doc/master/temperature_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/temperature_8C.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:383,Deployability,integrat,integrated,383,". ROOT: tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TensorDataLoader.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TTensorDataLoader *; 8 * *; 9 * *; 10 * Description: *; 11 * Tensor Data Loader Class *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 ",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:383,Integrability,integrat,integrated,383,". ROOT: tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TensorDataLoader.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TTensorDataLoader *; 8 * *; 9 * *; 10 * Description: *; 11 * Tensor Data Loader Class *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 ",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:8133,Integrability,rout,routine,8133,"&&) = default;; 168 ; 169 /** Copy input tensor into the given host buffer. Function to be specialized by; 170 * the architecture-specific backend. */; 171 void CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin);; 172 /** Copy output matrix into the given host buffer. Function to be specialized; 173 * by the architecture-specific backend. */; 174 void CopyTensorOutput(HostBuffer_t &buffer, IndexIterator_t begin);; 175 /** Copy weight matrix into the given host buffer. Function to be specialized; 176 * by the architecture-specific backend. */; 177 void CopyTensorWeights(HostBuffer_t &buffer, IndexIterator_t begin);; 178 ; 179 BatchIterator_t begin() { return TTensorBatchIterator<Data_t, Architecture_t>(*this); }; 180 BatchIterator_t end() { return TTensorBatchIterator<Data_t, Architecture_t>(*this, fNSamples / fBatchSize); }; 181 ; 182 /** Shuffle the order of the samples in the batch. The shuffling is indirect,; 183 * i.e. only the indices are shuffled. No input data is moved by this; 184 * routine. */; 185 template<typename RNG>; 186 void Shuffle(RNG & rng);; 187 ; 188 /** Return the next batch from the training set. The TTensorDataLoader object; 189 * keeps an internal counter that cycles over the batches in the training; 190 * set. */; 191 TTensorBatch<Architecture_t> GetTensorBatch();; 192};; 193 ; 194//; 195// TTensorBatch Class.; 196//______________________________________________________________________________; 197template <typename Architecture_t>; 198TTensorBatch<Architecture_t>::TTensorBatch(Tensor_t &inputTensor, Matrix_t &outputMatrix,; 199 Matrix_t &weightMatrix); 200 : fInputTensor(inputTensor), fOutputMatrix(outputMatrix), fWeightMatrix(weightMatrix); 201{; 202 // Nothing to do here.; 203}; 204 ; 205//; 206// TTensorDataLoader Class.; 207//______________________________________________________________________________; 208template <typename Data_t, typename Architecture_t>; 209TTensorDataLoader<Data_t, Architecture_t>::TTensorDataLoader(const",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:12273,Modifiability,layers,layers,12273,"eBuffer = deviceBuffer.GetSubBuffer(inputTensorSize, outputMatrixSize);; 251 DeviceBuffer_t weightDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 252 ; 253 // here sample index has batch size as offset , while in; 254 // copy tensor input has batch depth.; 255 // We support then now two cases: batchdepth = 1 batchHeight = batch size; 256 // or batch depth = batch; 257 size_t sampleIndex = fBatchIndex * fBatchSize;; 258 IndexIterator_t sampleIndexIterator = fSampleIndices.begin() + sampleIndex;; 259 ; 260 CopyTensorInput(inputHostBuffer, sampleIndexIterator);; 261 CopyTensorOutput(outputHostBuffer, sampleIndexIterator);; 262 CopyTensorWeights(weightHostBuffer, sampleIndexIterator);; 263 ; 264 deviceBuffer.CopyFrom(hostBuffer);; 265 ; 266 assert(fInputLayout.size() == 3);; 267 Tensor_t inputTensor = Architecture_t::CreateTensor( inputDeviceBuffer, fBatchSize, fInputLayout[0], fInputLayout[1], fInputLayout[2] );; 268 // in case of dense layers; 269 if (fBatchDepth == 1 && fBatchHeight == fBatchSize && fInputLayout[0] == 1 && fInputLayout[1] == 1){; 270 inputTensor = Tensor_t( inputDeviceBuffer, {fBatchSize, fInputLayout.back() }, Tensor_t::MemoryLayout::ColumnMajor );; 271 }; 272 ; 273 Matrix_t outputMatrix(outputDeviceBuffer, fBatchSize, fNOutputFeatures);; 274 Matrix_t weightMatrix(weightDeviceBuffer, fBatchSize, 1);; 275 ; 276 fBatchIndex++;; 277 ; 278 ; 279 return TTensorBatch<Architecture_t>(inputTensor, outputMatrix, weightMatrix);; 280}; 281 ; 282//______________________________________________________________________________; 283template <typename Data_t, typename Architecture_t>; 284template <typename RNG>; 285void TTensorDataLoader<Data_t, Architecture_t>::Shuffle(RNG & rng); 286{; 287 std::shuffle(fSampleIndices.begin(), fSampleIndices.end(), rng);; 288}; 289 ; 290} // namespace DNN; 291} // namespace TMVA; 292 ; 293#endif; Event.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle G",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:20858,Modifiability,variab,variable,20858,"en host buffer.; TMVA::DNN::TTensorDataLoader::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition TensorDataLoader.h:137; TMVA::DNN::TTensorDataLoader::HostBuffer_ttypename Architecture_t::HostBuffer_t HostBuffer_tDefinition TensorDataLoader.h:135; TMVA::DNN::TTensorDataLoader::fBatchDepthsize_t fBatchDepthThe number of matrices in the tensor.Definition TensorDataLoader.h:146; TMVA::DNN::TTensorDataLoader::fNStreamssize_t fNStreamsNumber of buffer pairs.Definition TensorDataLoader.h:153; TMVA::DNN::TTensorDataLoader::fDataconst Data_t & fDataThe data that should be loaded in the batches.Definition TensorDataLoader.h:142; TMVA::DNN::TTensorDataLoader::operator=TTensorDataLoader & operator=(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition TensorDataLoader.h:138; TMVA::DNN::TTensorDataLoader::endBatchIterator_t end()Definition TensorDataLoader.h:180; TMVA::DNN::TTensorDataLoader::fNSamplessize_t fNSamplesThe total number of samples in the dataset.Definition TensorDataLoader.h:143; TMVA::DNN::TTensorDataLoader::CopyTensorInputvoid CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin)Copy input tensor into the given host buffer.; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMatrixTTMatrixT.Definition TMatrixT.h:40; TMVA::DNN::TensorInputstd::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & > TensorInputDefinition TensorDataLoader.h:44; TMVA::DNN::IndexIterator_ttypename std::vector< size_t >::iterator IndexIterator_tDefinition DataLoader.h:42; TMVA::DNN::TMVAInput_tstd::tuple< const std::vector< Event * > &, const DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22. tmvatmvaincTMVADNNTensorDataLoader.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:5634,Performance,load,loaded,5634,"ning data from the input data; 120 * type to the accelerator device or the CPU. A TTensorDataLoader object manages; 121 * a number of host and device buffer pairs that are used in a round-robin manner; 122 * for the transfer of batches to the device.; 123 *; 124 * Each TTensorDataLoader object has an associated batch size and a number of total; 125 * samples in the dataset. One epoch is the number of buffers required to transfer; 126 * the complete training set. Using the begin() and end() member functions allows; 127 * the user to iterate over the batches in one epoch.; 128 *; 129 * \tparam Data_t The input data type.; 130 * \tparam Architecture_t The architecture class of the underlying architecture.; 131 */; 132template <typename Data_t, typename Architecture_t>; 133class TTensorDataLoader {; 134private:; 135 using HostBuffer_t = typename Architecture_t::HostBuffer_t;; 136 using DeviceBuffer_t = typename Architecture_t::DeviceBuffer_t;; 137 using Matrix_t = typename Architecture_t::Matrix_t;; 138 using Tensor_t = typename Architecture_t::Tensor_t;; 139 using Shape_t = typename Architecture_t::Tensor_t::Shape_t;; 140 using BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>;; 141 ; 142 const Data_t &fData; ///< The data that should be loaded in the batches.; 143 size_t fNSamples; ///< The total number of samples in the dataset.; 144 size_t fBatchSize; ///< The size of a batch.; 145 Shape_t fInputLayout; ///< The input data layout (does not include batch size); 146 size_t fBatchDepth; ///< The number of matrices in the tensor.; 147 size_t fBatchHeight; ///< The number od rows in each matrix.; 148 size_t fBatchWidth; ///< The number of columns in each matrix.; 149 size_t fNOutputFeatures; ///< The number of outputs from the classifier/regressor.; 150 size_t fBatchIndex; ///< The index of the batch when there are multiple batches in parallel; 151 ; 152 ; 153 size_t fNStreams; ///< Number of buffer pairs.; 154 std::vector<DeviceBuffer_t> fDeviceBuffers; ///<",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:6510,Performance,load,load,6510,"ape_t;; 140 using BatchIterator_t = TTensorBatchIterator<Data_t, Architecture_t>;; 141 ; 142 const Data_t &fData; ///< The data that should be loaded in the batches.; 143 size_t fNSamples; ///< The total number of samples in the dataset.; 144 size_t fBatchSize; ///< The size of a batch.; 145 Shape_t fInputLayout; ///< The input data layout (does not include batch size); 146 size_t fBatchDepth; ///< The number of matrices in the tensor.; 147 size_t fBatchHeight; ///< The number od rows in each matrix.; 148 size_t fBatchWidth; ///< The number of columns in each matrix.; 149 size_t fNOutputFeatures; ///< The number of outputs from the classifier/regressor.; 150 size_t fBatchIndex; ///< The index of the batch when there are multiple batches in parallel; 151 ; 152 ; 153 size_t fNStreams; ///< Number of buffer pairs.; 154 std::vector<DeviceBuffer_t> fDeviceBuffers; ///< The device buffers used to keep the input, output and weight data.; 155 std::vector<HostBuffer_t> fHostBuffers; ///< The host buffers used to load the input, output and weight data.; 156 ; 157 std::vector<size_t> fSampleIndices; ///< Ordering of the samples in the epoch.; 158 ; 159public:; 160 /*! Constructor. */; 161 TTensorDataLoader(const Data_t &data, size_t nSamples, size_t batchSize, const Shape_t & inputLayout,; 162 const Shape_t & batchLayout, size_t nOutputFeatures, size_t nStreams = 1);; 163 ; 164 TTensorDataLoader(const TTensorDataLoader &) = default;; 165 TTensorDataLoader(TTensorDataLoader &&) = default;; 166 TTensorDataLoader &operator=(const TTensorDataLoader &) = default;; 167 TTensorDataLoader &operator=(TTensorDataLoader &&) = default;; 168 ; 169 /** Copy input tensor into the given host buffer. Function to be specialized by; 170 * the architecture-specific backend. */; 171 void CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin);; 172 /** Copy output matrix into the given host buffer. Function to be specialized; 173 * by the architecture-specific backend. */; 174 void CopyTensorO",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:18125,Performance,load,load,18125,"rchitecture_t > GetTensorBatch()Return the next batch from the training set.Definition TensorDataLoader.h:233; TMVA::DNN::TTensorDataLoader::operator=TTensorDataLoader & operator=(const TTensorDataLoader &)=default; TMVA::DNN::TTensorDataLoader::DeviceBuffer_ttypename Architecture_t::DeviceBuffer_t DeviceBuffer_tDefinition TensorDataLoader.h:136; TMVA::DNN::TTensorDataLoader::fBatchWidthsize_t fBatchWidthThe number of columns in each matrix.Definition TensorDataLoader.h:148; TMVA::DNN::TTensorDataLoader::CopyTensorOutputvoid CopyTensorOutput(HostBuffer_t &buffer, IndexIterator_t begin)Copy output matrix into the given host buffer.; TMVA::DNN::TTensorDataLoader::fBatchIndexsize_t fBatchIndexThe index of the batch when there are multiple batches in parallel.Definition TensorDataLoader.h:150; TMVA::DNN::TTensorDataLoader::fBatchHeightsize_t fBatchHeightThe number od rows in each matrix.Definition TensorDataLoader.h:147; TMVA::DNN::TTensorDataLoader::fHostBuffersstd::vector< HostBuffer_t > fHostBuffersThe host buffers used to load the input, output and weight data.Definition TensorDataLoader.h:155; TMVA::DNN::TTensorDataLoader::TTensorDataLoaderTTensorDataLoader(const Data_t &data, size_t nSamples, size_t batchSize, const Shape_t &inputLayout, const Shape_t &batchLayout, size_t nOutputFeatures, size_t nStreams=1)Constructor.Definition TensorDataLoader.h:209; TMVA::DNN::TTensorDataLoader::beginBatchIterator_t begin()Definition TensorDataLoader.h:179; TMVA::DNN::TTensorDataLoader::TTensorDataLoaderTTensorDataLoader(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::fBatchSizesize_t fBatchSizeThe size of a batch.Definition TensorDataLoader.h:144; TMVA::DNN::TTensorDataLoader::fInputLayoutShape_t fInputLayoutThe input data layout (does not include batch size)Definition TensorDataLoader.h:145; TMVA::DNN::TTensorDataLoader::CopyTensorWeightsvoid CopyTensorWeights(HostBuffer_t &buffer, IndexIterator_t begin)Copy weight matrix into the given host buffer.; TMVA::DNN::TT",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:19640,Performance,load,loaded,19640,"sorDataLoader(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::fBatchSizesize_t fBatchSizeThe size of a batch.Definition TensorDataLoader.h:144; TMVA::DNN::TTensorDataLoader::fInputLayoutShape_t fInputLayoutThe input data layout (does not include batch size)Definition TensorDataLoader.h:145; TMVA::DNN::TTensorDataLoader::CopyTensorWeightsvoid CopyTensorWeights(HostBuffer_t &buffer, IndexIterator_t begin)Copy weight matrix into the given host buffer.; TMVA::DNN::TTensorDataLoader::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition TensorDataLoader.h:137; TMVA::DNN::TTensorDataLoader::HostBuffer_ttypename Architecture_t::HostBuffer_t HostBuffer_tDefinition TensorDataLoader.h:135; TMVA::DNN::TTensorDataLoader::fBatchDepthsize_t fBatchDepthThe number of matrices in the tensor.Definition TensorDataLoader.h:146; TMVA::DNN::TTensorDataLoader::fNStreamssize_t fNStreamsNumber of buffer pairs.Definition TensorDataLoader.h:153; TMVA::DNN::TTensorDataLoader::fDataconst Data_t & fDataThe data that should be loaded in the batches.Definition TensorDataLoader.h:142; TMVA::DNN::TTensorDataLoader::operator=TTensorDataLoader & operator=(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition TensorDataLoader.h:138; TMVA::DNN::TTensorDataLoader::endBatchIterator_t end()Definition TensorDataLoader.h:180; TMVA::DNN::TTensorDataLoader::fNSamplessize_t fNSamplesThe total number of samples in the dataset.Definition TensorDataLoader.h:143; TMVA::DNN::TTensorDataLoader::CopyTensorInputvoid CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin)Copy input tensor into the given host buffer.; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMatrixTTMatrixT.Definition TMatrixT.h:40; TMVA::DNN::TensorInputstd::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & > TensorInputDefinition TensorDataLoader.h:44",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:1982,Security,access,accessed,1982,"see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_TENSORDATALOADER; 28#define TMVA_DNN_TENSORDATALOADER; 29 ; 30#include ""TMatrix.h""; 31#include ""TMVA/Event.h""; 32#include <algorithm>; 33#include <vector>; 34#include <utility>; 35 ; 36namespace TMVA {; 37 class DataSetInfo;; 38namespace DNN {; 39 ; 40//; 41// Input Data Types; 42//______________________________________________________________________________; 43using TensorInput =; 44 std::tuple<const std::vector<TMatrixT<Double_t>> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 45 ; 46using TMVAInput_t = std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 47using IndexIterator_t = typename std::vector<size_t>::iterator;; 48 ; 49/** TTensorBatch; 50 *; 51 * Class representing training batches consisting of a vector of matrices as input data; 52 * and a matrix of output data. The input and output data can be accessed using; 53 * the GetInput() and GetOutput() member functions.; 54 *; 55 * \tparam Architecture_t The underlying architecture.; 56 */; 57 ; 58template <typename Architecture_t>; 59class TTensorBatch {; 60public:; 61 using Matrix_t = typename Architecture_t::Matrix_t;; 62 using Tensor_t = typename Architecture_t::Tensor_t;; 63 ; 64private:; 65 Tensor_t fInputTensor; ///< The input tensor batch, one matrix one input.; 66 Matrix_t fOutputMatrix; ///< The output matrix representing the ground truth.; 67 Matrix_t fWeightMatrix; ///< The event/example weights; 68 ; 69public:; 70 TTensorBatch(Tensor_t &, Matrix_t &, Matrix_t &);; 71 TTensorBatch(const TTensorBatch &) = default;; 72 TTensorBatch(TTensorBatch &&) = default;; 73 TTensorBatch &operator=(const TTensorBatch &) = default;; 74 TTensorBatch &operator=(TTensorBatch &&) = default;; 75 ; 76 /** Return the tensor representing the input data */; 77 Tensor_t &GetInput() { return fInputTensor; }; 78 /** Return the matrix representing the output data. *",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TensorDataLoader_8h_source.html:12072,Testability,assert,assert,12072,"uffer = hostBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 248 ; 249 DeviceBuffer_t inputDeviceBuffer = deviceBuffer.GetSubBuffer(0, inputTensorSize);; 250 DeviceBuffer_t outputDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize, outputMatrixSize);; 251 DeviceBuffer_t weightDeviceBuffer = deviceBuffer.GetSubBuffer(inputTensorSize + outputMatrixSize, weightMatrixSize);; 252 ; 253 // here sample index has batch size as offset , while in; 254 // copy tensor input has batch depth.; 255 // We support then now two cases: batchdepth = 1 batchHeight = batch size; 256 // or batch depth = batch; 257 size_t sampleIndex = fBatchIndex * fBatchSize;; 258 IndexIterator_t sampleIndexIterator = fSampleIndices.begin() + sampleIndex;; 259 ; 260 CopyTensorInput(inputHostBuffer, sampleIndexIterator);; 261 CopyTensorOutput(outputHostBuffer, sampleIndexIterator);; 262 CopyTensorWeights(weightHostBuffer, sampleIndexIterator);; 263 ; 264 deviceBuffer.CopyFrom(hostBuffer);; 265 ; 266 assert(fInputLayout.size() == 3);; 267 Tensor_t inputTensor = Architecture_t::CreateTensor( inputDeviceBuffer, fBatchSize, fInputLayout[0], fInputLayout[1], fInputLayout[2] );; 268 // in case of dense layers; 269 if (fBatchDepth == 1 && fBatchHeight == fBatchSize && fInputLayout[0] == 1 && fInputLayout[1] == 1){; 270 inputTensor = Tensor_t( inputDeviceBuffer, {fBatchSize, fInputLayout.back() }, Tensor_t::MemoryLayout::ColumnMajor );; 271 }; 272 ; 273 Matrix_t outputMatrix(outputDeviceBuffer, fBatchSize, fNOutputFeatures);; 274 Matrix_t weightMatrix(weightDeviceBuffer, fBatchSize, 1);; 275 ; 276 fBatchIndex++;; 277 ; 278 ; 279 return TTensorBatch<Architecture_t>(inputTensor, outputMatrix, weightMatrix);; 280}; 281 ; 282//______________________________________________________________________________; 283template <typename Data_t, typename Architecture_t>; 284template <typename RNG>; 285void TTensorDataLoader<Data_t, Architecture_t>::Shuffle(RNG & rng); 286{; 287 std::shuffle(fSampl",MatchSource.WIKI,doc/master/TensorDataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:2806,Availability,redundant,redundant,2806,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:56339,Availability,error,error,56339,"lete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListBlock.h; GetCommonStringstatic Int_t GetCommonString(TString a, TString b, TString &c)Get in 'c' the string in common at the beginning of 'a' and 'b'.Definition TEntryList.cxx:1516; operator||TEntryList operator||(TEntryList &elist1, TEntryList &elist2)Definition TEntryList.cxx:1385; TEntryList.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TFile.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:71229,Availability,error,error,71229," *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTS",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:18526,Deployability,configurat,configuration,18526,"t){; 522 if (fCurrent->fBlocks){; 523 Int_t currentblock = (fCurrent->fLastIndexReturned)/kBlockSize;; 524 TEntryListBlock *block = (TEntryListBlock*)fCurrent->fBlocks->UncheckedAt(currentblock);; 525 block->ResetIndices();; 526 fCurrent->fLastIndexReturned = 0;; 527 fCurrent->fLastIndexQueried = -1;; 528 }; 529 }; 530 fCurrent = nullptr;; 531 }; 532 ; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// \brief Add a sub entry list to the current list.; 537/// \param[in] elist an entry list that should be added as a sub list of this list.; 538///; 539/// This function is specifically targeted at situations where there is a global; 540/// TEntryList that should hold one or more sub TEntryList objects. For example,; 541/// if one wants to create a one to one mapping between the sub entry lists and; 542/// the trees in the files that make a TChain. Note that in such cases this; 543/// configuration of the entry list should be used in pair with the option \p ""sync""; 544/// of the function TChain::SetEntryList; 545///; 546/// ~~~{.cpp}; 547/// // Create a TChain with two files. Each contains a tree with 20 entries; 548/// TChain chain{""entries""};; 549/// chain.Add(""file_20entries_1.root"");; 550/// chain.Add(""file_20entries_2.root"");; 551///; 552/// // Create a global, empty TEntryList.; 553/// TEntryList elists;; 554/// // Create two entry lists. Each one will be referring to a different tree in the chain; 555/// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; 556/// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; 557///; 558/// // Select the first ten entries from the first tree and all entries from the second; 559/// for(auto entry = 0; entry < 10; entry++){; 560/// elist1.Enter(entry);; 561/// }; 562/// for(auto entry = 0; entry < 20; entry++){; 563/// elist2.Enter(entry);; 564/// }; 565///; 566/// // Add sub entry lists to the global list; 567/// elists.AddSubList(&elist1);; 568/// elists.Add",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:2873,Integrability,interface,interface,2873,"st"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntry);; 88 }; 89~~~; 90## TSelectors; 91 ; 92To fill an TEntryList from a TSelector correctly, one must add the TEntryList object; 93to the output list of the",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:29108,Integrability,protocol,protocol,29108,"responding tree in the chain, this list is not; 841//taken into account, and entry from the next list with a tree is returned.; 842//Example:; 843//First sublist - 20 entries, second sublist - 5 entries, third sublist - 10 entries; 844//Second sublist doesn't correspond to any trees of the chain; 845//Then, when GetEntryAndTree(21, treenum, true) is called, first entry of the; 846//third sublist will be returned; 847 ; 848 Long64_t result = GetEntry(index);; 849 if (result < 0) {; 850 treenum = -1;; 851 return result;; 852 }; 853 R__ASSERT(fLists == nullptr || (fLists != nullptr && fCurrent != nullptr));; 854 if (fCurrent); 855 treenum = fCurrent->fTreeNumber;; 856 else; 857 treenum = fTreeNumber;; 858 if (treenum < 0); 859 return -1;; 860 ; 861 return result;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// To be able to re-localize the entry-list we identify the file by just the; 866/// name and the anchor, i.e. we drop protocol, host, options, ...; 867/// The result in the form 'file#anchor' (or 'file', if no anchor is present); 868/// is saved in 'fn'.; 869/// The function optionally (is 'local' is defined) checks file locality (i.e.; 870/// protocol 'file://') returning the result in '*local' .; 871 ; 872void TEntryList::GetFileName(const char *filename, TString &fn, bool *local); 873{; 874 TUrl u(filename, true);; 875 if (local) *local = (!strcmp(u.GetProtocol(), ""file"")) ? true : false;; 876 if (strlen(u.GetAnchor()) > 0) {; 877 fn.Form(""%s#%s"", u.GetFile(), u.GetAnchor());; 878 } else {; 879 fn = u.GetFile();; 880 }; 881 // Done; 882 return;; 883}; 884 ; 885////////////////////////////////////////////////////////////////////////////////; 886/// Return the entry list, corresponding to treename and filename; 887/// By default, the filename is first tried as is, and then, if the corresponding list; 888/// is not found, the filename is expanded to the absolute path, and compared again.; 889/// To avoid it, u",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:29336,Integrability,protocol,protocol,29336,"d sublist doesn't correspond to any trees of the chain; 845//Then, when GetEntryAndTree(21, treenum, true) is called, first entry of the; 846//third sublist will be returned; 847 ; 848 Long64_t result = GetEntry(index);; 849 if (result < 0) {; 850 treenum = -1;; 851 return result;; 852 }; 853 R__ASSERT(fLists == nullptr || (fLists != nullptr && fCurrent != nullptr));; 854 if (fCurrent); 855 treenum = fCurrent->fTreeNumber;; 856 else; 857 treenum = fTreeNumber;; 858 if (treenum < 0); 859 return -1;; 860 ; 861 return result;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// To be able to re-localize the entry-list we identify the file by just the; 866/// name and the anchor, i.e. we drop protocol, host, options, ...; 867/// The result in the form 'file#anchor' (or 'file', if no anchor is present); 868/// is saved in 'fn'.; 869/// The function optionally (is 'local' is defined) checks file locality (i.e.; 870/// protocol 'file://') returning the result in '*local' .; 871 ; 872void TEntryList::GetFileName(const char *filename, TString &fn, bool *local); 873{; 874 TUrl u(filename, true);; 875 if (local) *local = (!strcmp(u.GetProtocol(), ""file"")) ? true : false;; 876 if (strlen(u.GetAnchor()) > 0) {; 877 fn.Form(""%s#%s"", u.GetFile(), u.GetAnchor());; 878 } else {; 879 fn = u.GetFile();; 880 }; 881 // Done; 882 return;; 883}; 884 ; 885////////////////////////////////////////////////////////////////////////////////; 886/// Return the entry list, corresponding to treename and filename; 887/// By default, the filename is first tried as is, and then, if the corresponding list; 888/// is not found, the filename is expanded to the absolute path, and compared again.; 889/// To avoid it, use option ""ne""; 890 ; 891TEntryList *TEntryList::GetEntryList(const char *treename, const char *filename, Option_t *opt); 892{; 893 if (gDebug > 1); 894 Info(""GetEntryList"",""tree: %s, file: %s"",; 895 (treename ? treename : ""-""), (filename ? f",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:55064,Integrability,protocol,protocol,55064,"= nullptr;; 1623 while ((key = (TKey *) nxk())) {; 1624 if (!strcmp(key->GetClassName(), ""TEntryList"")) {; 1625 TEntryList *enl = dynamic_cast<TEntryList *>(fl->Get(key->GetName()));; 1626 if (enl) {; 1627 nrs += enl->ScanPaths(roots);; 1628 } else {; 1629 ::Error(""TEntryList::Scan"", ""object entry-list '%s' not found or not loadable!"", key->GetName());; 1630 }; 1631 }; 1632 }; 1633 // Close the file; 1634 fl->Close();; 1635 delete fl;; 1636 ; 1637 // Done; 1638 return nrs;; 1639}; 1640 ; 1641////////////////////////////////////////////////////////////////////////////////; 1642/// Custom streamer for class TEntryList to handle the different interpretation; 1643/// of fFileName between version 1 and >1 .; 1644 ; 1645void TEntryList::Streamer(TBuffer &b); 1646{; 1647 if (b.IsReading()) {; 1648 UInt_t R__s, R__c;; 1649 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 1650 b.ReadClassBuffer(TEntryList::Class(), this, R__v, R__s, R__c);; 1651 if (R__v <= 1) {; 1652 // The filename contained also the protocol and host: this was dropped; 1653 // in version > 1 to allow re-localization; 1654 GetFileName(fFileName.Data(), fFileName);; 1655 }; 1656 } else {; 1657 b.WriteClassBuffer(TEntryList::Class(), this);; 1658 }; 1659}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEntryListBlock.h; GetCommonStringstatic Int_t GetCommonString(TString a, TString b, TString &c)Get in 'c'",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:70698,Integrability,message,message,70698,"bjects.Definition TObjArray.h:31; TObjArray::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the array AND delete all heap based objects.Definition TObjArray.cxx:356; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::GetStringconst TString & GetString() constDefinition TObjString.h:46; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TStri",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:71235,Integrability,message,message,71235," *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTS",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:71362,Integrability,message,message,71362,"ring.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method ",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:18526,Modifiability,config,configuration,18526,"t){; 522 if (fCurrent->fBlocks){; 523 Int_t currentblock = (fCurrent->fLastIndexReturned)/kBlockSize;; 524 TEntryListBlock *block = (TEntryListBlock*)fCurrent->fBlocks->UncheckedAt(currentblock);; 525 block->ResetIndices();; 526 fCurrent->fLastIndexReturned = 0;; 527 fCurrent->fLastIndexQueried = -1;; 528 }; 529 }; 530 fCurrent = nullptr;; 531 }; 532 ; 533}; 534 ; 535////////////////////////////////////////////////////////////////////////////////; 536/// \brief Add a sub entry list to the current list.; 537/// \param[in] elist an entry list that should be added as a sub list of this list.; 538///; 539/// This function is specifically targeted at situations where there is a global; 540/// TEntryList that should hold one or more sub TEntryList objects. For example,; 541/// if one wants to create a one to one mapping between the sub entry lists and; 542/// the trees in the files that make a TChain. Note that in such cases this; 543/// configuration of the entry list should be used in pair with the option \p ""sync""; 544/// of the function TChain::SetEntryList; 545///; 546/// ~~~{.cpp}; 547/// // Create a TChain with two files. Each contains a tree with 20 entries; 548/// TChain chain{""entries""};; 549/// chain.Add(""file_20entries_1.root"");; 550/// chain.Add(""file_20entries_2.root"");; 551///; 552/// // Create a global, empty TEntryList.; 553/// TEntryList elists;; 554/// // Create two entry lists. Each one will be referring to a different tree in the chain; 555/// TEntryList elist1{"""","""",""entries"",""file_20entries_1.root""};; 556/// TEntryList elist2{"""","""",""entries"",""file_20entries_2.root""};; 557///; 558/// // Select the first ten entries from the first tree and all entries from the second; 559/// for(auto entry = 0; entry < 10; entry++){; 560/// elist1.Enter(entry);; 561/// }; 562/// for(auto entry = 0; entry < 20; entry++){; 563/// elist2.Enter(entry);; 564/// }; 565///; 566/// // Add sub entry lists to the global list; 567/// elists.AddSubList(&elist1);; 568/// elists.Add",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:71081,Modifiability,inherit,inherits,71081,"StringCollectable string class.Definition TObjString.h:28; TObjString::GetStringconst TString & GetString() constDefinition TObjString.h:46; TObjString::SetStringvoid SetString(const char *s)Definition TObjString.h:45; TObjString::GetNameconst char * GetName() const overrideReturns name of object.Definition TObjString.h:38; TObject::kOverwrite@ kOverwriteoverwrite existing object with same nameDefinition TObject.h:92; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:54383,Performance,load,loadable,54383,"*"");; 1594 }; 1595 ; 1596 if (xrl != roots) {; 1597 xrl->SetOwner(true);; 1598 SafeDelete(xrl);; 1599 }; 1600 ; 1601 // Done; 1602 return nrl;; 1603}; 1604 ; 1605////////////////////////////////////////////////////////////////////////////////; 1606/// Scan TEntryList in 'fn' to find the common parts of paths.; 1607/// If 'roots' is defined, add the found roots to the list as TObjStrings.; 1608/// Return the number of common root paths found.; 1609 ; 1610Int_t TEntryList::Scan(const char *fn, TList *roots); 1611{; 1612 // Open the file for updating; 1613 TFile *fl = TFile::Open(fn);; 1614 if (!fl || (fl&& fl->IsZombie())) {; 1615 ::Error(""TEntryList::Relocate"", ""file '%s' cannot be open for reading"", fn);; 1616 return -1;; 1617 }; 1618 ; 1619 Int_t nrs = 0;; 1620 // Read the lists; 1621 TIter nxk(fl->GetListOfKeys());; 1622 TKey *key = nullptr;; 1623 while ((key = (TKey *) nxk())) {; 1624 if (!strcmp(key->GetClassName(), ""TEntryList"")) {; 1625 TEntryList *enl = dynamic_cast<TEntryList *>(fl->Get(key->GetName()));; 1626 if (enl) {; 1627 nrs += enl->ScanPaths(roots);; 1628 } else {; 1629 ::Error(""TEntryList::Scan"", ""object entry-list '%s' not found or not loadable!"", key->GetName());; 1630 }; 1631 }; 1632 }; 1633 // Close the file; 1634 fl->Close();; 1635 delete fl;; 1636 ; 1637 // Done; 1638 return nrs;; 1639}; 1640 ; 1641////////////////////////////////////////////////////////////////////////////////; 1642/// Custom streamer for class TEntryList to handle the different interpretation; 1643/// of fFileName between version 1 and >1 .; 1644 ; 1645void TEntryList::Streamer(TBuffer &b); 1646{; 1647 if (b.IsReading()) {; 1648 UInt_t R__s, R__c;; 1649 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 1650 b.ReadClassBuffer(TEntryList::Class(), this, R__v, R__s, R__c);; 1651 if (R__v <= 1) {; 1652 // The filename contained also the protocol and host: this was dropped; 1653 // in version > 1 to allow re-localization; 1654 GetFileName(fFileName.Data(), fFileName);; 1655 }; 1656 } ",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:60262,Performance,optimiz,optimized,60262,"eturn the capacity of the collection, i.e.Definition TCollection.h:184; TDirectoryFile::GetListOfKeysTList * GetListOfKeys() const overrideDefinition TDirectoryFile.h:94; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEntryListBlockUsed by TEntryList to store the entry numbers.Definition TEntryListBlock.h:44; TEntryListBlock::OptimizeStoragevoid OptimizeStorage()If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation.Definition TEntryListBlock.cxx:546; TEntryListBlock::Removebool Remove(Int_t entry)Remove entry #entry If the block has already been optimized and the entries are stored as a list and ...Definition TEntryListBlock.cxx:165; TEntryListBlock::NextInt_t Next()Return the next non-zero entry Faster than GetEntry() function.Definition TEntryListBlock.cxx:446; TEntryListBlock::Enterbool Enter(Int_t entry)If the block has already been optimized and the entries are stored as a list and not as bits,...Definition TEntryListBlock.cxx:127; TEntryListBlock::GetNPassedInt_t GetNPassed()Returns the number of entries, passing the selection.Definition TEntryListBlock.cxx:369; TEntryListBlock::PrintWithShiftvoid PrintWithShift(Int_t shift) constPrint the indices of this block + shift (used from TEntryList::Print()) to print the current values.Definition TEntryListBlock.cxx:503; TEntryListBlock::ContainsInt_t Contains(Int_t entry)True if the block contains entry #entry.Definition TEntryListBlock.cxx:193; TEntryListBlock::GetEntryInt_t GetEntry(Int_t entry)Return entry #entry.Definition TEntryListBlock.cxx:381;",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:60559,Performance,optimiz,optimized,60559,"937; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::Appendvirtual void Append(TObject *obj, Bool_t replace=kFALSE)Append object to this directory.Definition TDirectory.cxx:199; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TEntryListBlockUsed by TEntryList to store the entry numbers.Definition TEntryListBlock.h:44; TEntryListBlock::OptimizeStoragevoid OptimizeStorage()If there are < kBlockSize or >kBlockSize*15 entries, change to an array representation.Definition TEntryListBlock.cxx:546; TEntryListBlock::Removebool Remove(Int_t entry)Remove entry #entry If the block has already been optimized and the entries are stored as a list and ...Definition TEntryListBlock.cxx:165; TEntryListBlock::NextInt_t Next()Return the next non-zero entry Faster than GetEntry() function.Definition TEntryListBlock.cxx:446; TEntryListBlock::Enterbool Enter(Int_t entry)If the block has already been optimized and the entries are stored as a list and not as bits,...Definition TEntryListBlock.cxx:127; TEntryListBlock::GetNPassedInt_t GetNPassed()Returns the number of entries, passing the selection.Definition TEntryListBlock.cxx:369; TEntryListBlock::PrintWithShiftvoid PrintWithShift(Int_t shift) constPrint the indices of this block + shift (used from TEntryList::Print()) to print the current values.Definition TEntryListBlock.cxx:503; TEntryListBlock::ContainsInt_t Contains(Int_t entry)True if the block contains entry #entry.Definition TEntryListBlock.cxx:193; TEntryListBlock::GetEntryInt_t GetEntry(Int_t entry)Return entry #entry.Definition TEntryListBlock.cxx:381; TEntryListBlock::ResetIndicesvoid ResetIndices()Definition TEntryListBlock.h:74; TEntryListBlock::MergeInt_t Merge(TEntryListBlock *block)Merge with the other block Returns the resulting number of entries in the block.Definition TEntryListBlock.cxx:242; TEntryListA List of entry numbers in a TTree or TChain.Defi",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:61884,Performance,optimiz,optimize,61884,"es of this block + shift (used from TEntryList::Print()) to print the current values.Definition TEntryListBlock.cxx:503; TEntryListBlock::ContainsInt_t Contains(Int_t entry)True if the block contains entry #entry.Definition TEntryListBlock.cxx:193; TEntryListBlock::GetEntryInt_t GetEntry(Int_t entry)Return entry #entry.Definition TEntryListBlock.cxx:381; TEntryListBlock::ResetIndicesvoid ResetIndices()Definition TEntryListBlock.h:74; TEntryListBlock::MergeInt_t Merge(TEntryListBlock *block)Merge with the other block Returns the resulting number of entries in the block.Definition TEntryListBlock.cxx:242; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEntryList::Entervirtual bool Enter(Long64_t entry, TTree *tree=nullptr)Add entry #entry to the list.Definition TEntryList.cxx:631; TEntryList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEntryList.h:49; TEntryList::fLastIndexQueriedLong64_t fLastIndexQueried! used to optimize GetEntry() function from a loopDefinition TEntryList.h:44; TEntryList::GetEntryListvirtual TEntryList * GetEntryList(const char *treename, const char *filename, Option_t *opt="""")Return the entry list, corresponding to treename and filename By default, the filename is first tried...Definition TEntryList.cxx:889; TEntryList::fEntriesToProcessLong64_t fEntriesToProcessused on proof to set the number of entries to process in a packetDefinition TEntryList.h:37; TEntryList::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TEntryList.h:81; TEntryList::Classstatic TClass * Class(); TEntryList::fFileNameTString fFileNamename of the file, where the tree isDefinition TEntryList.h:39; TEntryList::OptimizeStoragevirtual void OptimizeStorage()Checks if the array representation is more economical and if so, switches to it.Definition TEntryList.cxx:1085; TEntryList::GetListsvirtual TList * GetLists() constDefinition TEntryList.h:76; TEntryList::Containsvirtual Int_t Contains(Lon",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:64796,Performance,optimiz,optimize,64796,".h:77; TEntryList::fBlocksTObjArray * fBlocksblocks with indices of passing events (TEntryListBlocks)Definition TEntryList.h:35; TEntryList::GetEntryAndTreevirtual Long64_t GetEntryAndTree(Long64_t index, Int_t &treenum)Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding t...Definition TEntryList.cxx:835; TEntryList::GetFileNamevirtual const char * GetFileName() constDefinition TEntryList.h:80; TEntryList::Scanstatic Int_t Scan(const char *fn, TList *roots)Scan TEntryList in 'fn' to find the common parts of paths.Definition TEntryList.cxx:1608; TEntryList::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and others to automatically add us to a directory when we are read from a file.Definition TEntryList.cxx:619; TEntryList::kBlockSize@ kBlockSizeDefinition TEntryList.h:54; TEntryList::fNLong64_t fNnumber of entries in the listDefinition TEntryList.h:36; TEntryList::fLastIndexReturnedLong64_t fLastIndexReturned! used to optimize GetEntry() function from a loopDefinition TEntryList.h:45; TEntryList::Nextvirtual Long64_t Next()Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetE...Definition TEntryList.cxx:998; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::EnterRangevoid EnterRange(Long64_t start, Long64_t end, TTree *tree=nullptr, UInt_t step=1U)Enter all entries in a range in the TEntryList.Definition TEntryList.cxx:703; TEntryList::Resetvirtual void Reset()Reset this list.Definition TEntryList.cxx:1138; TEntryList::fNBlocksInt_t fNBlocksnumber of TEntryListBlocksDefinition TEntryList.h:34; TEntryList::GetEntryvirtual Long64_t GetEntry(Long64_t index)Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next().Definition TEntryList.cxx:759; TEntryList::Streamervoid Streamer(TBuffer &) overrideCustom streame",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:2806,Safety,redund,redundant,2806,"); 36 ; 37Use option __entrylist__ to write the results of TTree::Draw and TChain::Draw into; 38an entry list. Example:; 39~~~ {.cpp}; 40 tree->Draw("">>elist"", ""x<0 && y>0"", ""entrylist"");; 41 TEntryList *elist = (TEntryList*)gDirectory->Get(""elist"");; 42~~~; 43## Example of Loop on TEntryList with a TChain; 44~~~ {.cpp}; 45 void loopChain() {; 46 TFile *fe = TFile::Open(""myelist.root"");; 47 TEntryList *myelist = (TEntryList*)fe->Get(""myelist"");; 48 TChain *chain = new TChain(""ntuple"");; 49 chain->Add(""hsimple.root"");; 50 chain->Add(""hsimple2.root"");; 51 Long64_t listEntries = myelist->GetN();; 52 Long64_t chainEntries = chain->GetEntries();; 53 Int_t treenum = 0;; 54 chain->SetEntryList(myelist);; 55 ; 56 for (entry=start;entry < end;entry++) {; 57 entryNumber = chain->GetEntryNumber(entry);; 58 if (entryNumber < 0) break;; 59 localEntry = chain->LoadTree(entryNumber);; 60 if (localEntry < 0) break;; 61 ....; 62 then either call; 63 branch->GetEntry(localEntry);; 64 or; 65 chain->GetEntry(entryNumber);; 66 In the later case the LoadTree is then somewhat redundant.; 67 ...; 68 }; 69 }; 70~~~; 71When using the TEntryList interface directly, you can get the 'tree number' and entry in; 72the current tree (i.e. value similar to the return value of LoadTree) from calling; 73TEntryList::GetEntryAndTree:; 74~~~ {.cpp}; 75 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 76~~~; 77to obtain the entry number within the chain you need to add to it the value of; 78`treeEntry+ch->GetTreeOffset()[treenum]`; 79such that the loop in the previous example can also be written as:; 80~~~ {.cpp}; 81 for (Long64_t el = 0; el < listEntries; el++) {; 82 Long64_t treeEntry = myelist->GetEntryAndTree(el,treenum);; 83 Long64_t chainEntry = treeEntry+ch->GetTreeOffset()[treenum];; 84 printf(""el=%lld, treeEntry=%lld, chainEntry=%lld, treenum=%d\n"", el, treeEntry, chainEntry, treenum);; 85 ; 86 ch->LoadTree(chainEntry); // this also returns treeEntry; 87 needed_branch->GetEntry(treeEntr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:23815,Safety,avoid,avoid,23815,"t){; 670 if (fCurrent->Enter(localentry)) {; 671 if (fLists); 672 fN++;; 673 return true;; 674 }; 675 }; 676 }; 677 return false;; 678 ; 679}; 680 ; 681bool TEntryList::Enter(Long64_t localentry, const char *treename, const char *filename); 682{; 683 SetTree(treename, filename);; 684 if (fCurrent) {; 685 if (fCurrent->Enter(localentry)) {; 686 if (fLists); 687 fN++;; 688 return true;; 689 }; 690 }; 691 return false;; 692}; 693 ; 694/////////////////////////////////////////////////////////////////////////////; 695/// \brief Enter all entries in a range in the TEntryList.; 696/// \param[in] start starting entry to enter.; 697/// \param[in] end ending entry to enter.; 698/// \param[in] tree passed as is to TEntryList::Enter.; 699/// \param[in] step step increase of the loop entering the entries.; 700///; 701/// This is a helper function that enters all entries between \p start; 702/// (inclusive) and \p end (exclusive) to the TEntryList in a loop. It; 703/// is useful also in PyROOT to avoid having to do the same in a Python loop.; 704 ; 705void TEntryList::EnterRange(Long64_t start, Long64_t end, TTree *tree, UInt_t step); 706{; 707 for (auto entry = start; entry < end; entry += step) {; 708 this->Enter(entry, tree);; 709 }; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Remove entry \#entry from the list; 714/// - When tree = 0, removes from the current list; 715/// - When tree != 0, finds the list, corresponding to this tree; 716/// - When tree is a chain, the entry is assumed to be global index and the local; 717/// entry is recomputed from the treeoffset information of the chain; 718 ; 719bool TEntryList::Remove(Long64_t entry, TTree *tree); 720{; 721 if (entry < 0); 722 return false;; 723 if (!tree) {; 724 if (!fLists) {; 725 if (!fBlocks) return false;; 726 TEntryListBlock *block = nullptr;; 727 Long64_t nblock = entry/kBlockSize;; 728 block = (TEntryListBlock*)fBlocks->UncheckedAt(nblock);; 729 if (!block)",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:30106,Safety,avoid,avoid,30106,"local' is defined) checks file locality (i.e.; 870/// protocol 'file://') returning the result in '*local' .; 871 ; 872void TEntryList::GetFileName(const char *filename, TString &fn, bool *local); 873{; 874 TUrl u(filename, true);; 875 if (local) *local = (!strcmp(u.GetProtocol(), ""file"")) ? true : false;; 876 if (strlen(u.GetAnchor()) > 0) {; 877 fn.Form(""%s#%s"", u.GetFile(), u.GetAnchor());; 878 } else {; 879 fn = u.GetFile();; 880 }; 881 // Done; 882 return;; 883}; 884 ; 885////////////////////////////////////////////////////////////////////////////////; 886/// Return the entry list, corresponding to treename and filename; 887/// By default, the filename is first tried as is, and then, if the corresponding list; 888/// is not found, the filename is expanded to the absolute path, and compared again.; 889/// To avoid it, use option ""ne""; 890 ; 891TEntryList *TEntryList::GetEntryList(const char *treename, const char *filename, Option_t *opt); 892{; 893 if (gDebug > 1); 894 Info(""GetEntryList"",""tree: %s, file: %s"",; 895 (treename ? treename : ""-""), (filename ? filename : ""-""));; 896 ; 897 if (!treename || !filename) return nullptr;; 898 TString option = opt;; 899 option.ToUpper();; 900 bool nexp = option.Contains(""NE"");; 901 ; 902 TString fn;; 903 bool local;; 904 GetFileName(filename, fn, &local);; 905 if (nexp) local = false;; 906 ; 907 if (gDebug > 1); 908 Info(""GetEntryList"", ""file: %s, local? %d"", filename, local);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:31736,Security,hash,hash,31736,"cal);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923 }; 924 return nullptr;; 925 }; 926 }; 927 ; 928 TString stotal = treename;; 929 stotal.Append(fn);; 930 ULong_t newhash = stotal.Hash();; 931 ; 932 TIter next(fLists);; 933 TEntryList *templist;; 934 while ((templist = (TEntryList*)next())){; 935 if (templist->fStringHash==0){; 936 stotal = templist->fTreeName + templist->fFileName;; 937 templist->fStringHash = stotal.Hash();; 938 }; 939 if (gDebug > 1); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, elem",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:31755,Security,hash,hash,31755,"cal);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923 }; 924 return nullptr;; 925 }; 926 }; 927 ; 928 TString stotal = treename;; 929 stotal.Append(fn);; 930 ULong_t newhash = stotal.Hash();; 931 ; 932 TIter next(fLists);; 933 TEntryList *templist;; 934 while ((templist = (TEntryList*)next())){; 935 if (templist->fStringHash==0){; 936 stotal = templist->fTreeName + templist->fFileName;; 937 templist->fStringHash = stotal.Hash();; 938 }; 939 if (gDebug > 1); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, elem",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:32705,Security,hash,hash,32705,"); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, element hash: %lu"",; 967 filename, longname.Data(), newhash, templist->fStringHash);; 968 if (newhash == templist->fStringHash){; 969 if (templist->fTreeName == treename && templist->fFileName == longname){; 970 return templist;; 971 }; 972 }; 973 }; 974 }; 975 return nullptr;; 976}; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Merge this list with the lists from the collection; 980 ; 981Int_t TEntryList::Merge(TCollection *list); 982{; 983 if (!list) return -1;; 984 TIter next(list);; 985 TEntryList *elist = nullptr;; 986 while ((elist = (TEntryList*)next())) {; 987 if (!elist->InheritsFrom(TEntryList::Class())) {; 988 Error(""Add"",""Attempt to add object of class: %s to a %s"",elist->ClassName(),this->ClassName());; 989 return -1;; 990 }; 991 Add(elist);; 992 }; 993 return 0;; 994}; 995 ; 996////////////////////////////////////////////////////////////////////////////////; 997/// Return the next non-zero entr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:32724,Security,hash,hash,32724,"); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, element hash: %lu"",; 967 filename, longname.Data(), newhash, templist->fStringHash);; 968 if (newhash == templist->fStringHash){; 969 if (templist->fTreeName == treename && templist->fFileName == longname){; 970 return templist;; 971 }; 972 }; 973 }; 974 }; 975 return nullptr;; 976}; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Merge this list with the lists from the collection; 980 ; 981Int_t TEntryList::Merge(TCollection *list); 982{; 983 if (!list) return -1;; 984 TIter next(list);; 985 TEntryList *elist = nullptr;; 986 while ((elist = (TEntryList*)next())) {; 987 if (!elist->InheritsFrom(TEntryList::Class())) {; 988 Error(""Add"",""Attempt to add object of class: %s to a %s"",elist->ClassName(),this->ClassName());; 989 return -1;; 990 }; 991 Add(elist);; 992 }; 993 return 0;; 994}; 995 ; 996////////////////////////////////////////////////////////////////////////////////; 997/// Return the next non-zero entr",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:72174,Security,hash,hash,72174,"ect::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directo",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:12603,Testability,test,testing,12603,"332{; 333 if (fBlocks){; 334 fBlocks->Delete();; 335 delete fBlocks;; 336 }; 337 fBlocks = nullptr;; 338 if (fLists){; 339 fLists->Delete();; 340 delete fLists;; 341 }; 342 ; 343 fLists = nullptr;; 344 ; 345 if (fDirectory) fDirectory->Remove(this);; 346 fDirectory = nullptr;; 347 ; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// \brief Add 2 entry lists.; 352///; 353/// \param[in] elist The list that should be added to the current one.; 354///; 355/// \note If you are creating a TEntryList for a TChain and you would like to; 356/// have a one to one mapping between the sub lists of the TEntryList and; 357/// the sub trees in the TChain, please do not call this function but use; 358/// TEntryList::AddSubList instead and pair it with a call to; 359/// TChain::SetEntryList with option ""sync"". See the AddSubList function; 360/// documentation for an example usage. This helps for example in a; 361/// testing or benchmark scenario where a TChain holds multiple times the; 362/// same tree in the same file. In that case, this function would not be; 363/// be able to distinguish different sub entry lists that refer to the; 364/// same treename and filename. Instead it would create a union of all the; 365/// sub entry lists into one list.; 366 ; 367void TEntryList::Add(const TEntryList *elist); 368{; 369 if (fN==0){; 370 if (!fLists && fTreeName=="""" && fFileName==""""){; 371 //this list is empty. copy the other list completely; 372 fNBlocks = elist->fNBlocks;; 373 fTreeName = elist->fTreeName;; 374 fFileName = elist->fFileName;; 375 fStringHash = elist->fStringHash;; 376 fTreeNumber = elist->fTreeNumber;; 377 fLastIndexQueried = -1;; 378 fLastIndexReturned = 0;; 379 fN = elist->fN;; 380 if (elist->fLists){; 381 fLists = new TList();; 382 TEntryList *el1 = nullptr;; 383 TEntryList *el2 = nullptr;; 384 TIter next(elist->fLists);; 385 while((el1 = (TEntryList*)next())){; 386 el2 = new TEntryList(*el1);; 387 if (el1==elist->f",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8cxx_source.html:12614,Testability,benchmark,benchmark,12614,"332{; 333 if (fBlocks){; 334 fBlocks->Delete();; 335 delete fBlocks;; 336 }; 337 fBlocks = nullptr;; 338 if (fLists){; 339 fLists->Delete();; 340 delete fLists;; 341 }; 342 ; 343 fLists = nullptr;; 344 ; 345 if (fDirectory) fDirectory->Remove(this);; 346 fDirectory = nullptr;; 347 ; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// \brief Add 2 entry lists.; 352///; 353/// \param[in] elist The list that should be added to the current one.; 354///; 355/// \note If you are creating a TEntryList for a TChain and you would like to; 356/// have a one to one mapping between the sub lists of the TEntryList and; 357/// the sub trees in the TChain, please do not call this function but use; 358/// TEntryList::AddSubList instead and pair it with a call to; 359/// TChain::SetEntryList with option ""sync"". See the AddSubList function; 360/// documentation for an example usage. This helps for example in a; 361/// testing or benchmark scenario where a TChain holds multiple times the; 362/// same tree in the same file. In that case, this function would not be; 363/// be able to distinguish different sub entry lists that refer to the; 364/// same treename and filename. Instead it would create a union of all the; 365/// sub entry lists into one list.; 366 ; 367void TEntryList::Add(const TEntryList *elist); 368{; 369 if (fN==0){; 370 if (!fLists && fTreeName=="""" && fFileName==""""){; 371 //this list is empty. copy the other list completely; 372 fNBlocks = elist->fNBlocks;; 373 fTreeName = elist->fTreeName;; 374 fFileName = elist->fFileName;; 375 fStringHash = elist->fStringHash;; 376 fTreeNumber = elist->fTreeNumber;; 377 fLastIndexQueried = -1;; 378 fLastIndexReturned = 0;; 379 fN = elist->fN;; 380 if (elist->fLists){; 381 fLists = new TList();; 382 TEntryList *el1 = nullptr;; 383 TEntryList *el2 = nullptr;; 384 TIter next(elist->fLists);; 385 while((el1 = (TEntryList*)next())){; 386 el2 = new TEntryList(*el1);; 387 if (el1==elist->f",MatchSource.WIKI,doc/master/TEntryList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html
https://root.cern/doc/master/TEntryList_8h_source.html:1789,Performance,optimiz,optimize,1789,"************************************************************************/; 11 ; 12#ifndef ROOT_TEntryList; 13#define ROOT_TEntryList; 14 ; 15#include ""TNamed.h""; 16 ; 17class TTree;; 18class TDirectory;; 19class TObjArray;; 20class TString;; 21 ; 22class TList;; 23class TCollection;; 24 ; 25class TEntryList: public TNamed; 26{; 27 private:; 28 TEntryList& operator=(const TEntryList&); // Not implemented; 29 ; 30 protected:; 31 TList *fLists; ///< a list of underlying entry lists for each tree of a chain; 32 TEntryList *fCurrent; ///<! currently filled entry list; 33 ; 34 Int_t fNBlocks; ///< number of TEntryListBlocks; 35 TObjArray *fBlocks; ///< blocks with indices of passing events (TEntryListBlocks); 36 Long64_t fN; ///< number of entries in the list; 37 Long64_t fEntriesToProcess; ///< used on proof to set the number of entries to process in a packet; 38 TString fTreeName; ///< name of the tree; 39 TString fFileName; ///< name of the file, where the tree is; 40 ULong_t fStringHash; ///<! Hash value of a string of treename and filename; 41 Int_t fTreeNumber; ///<! the index of the tree in the chain (used when the entry; 42 ///< list is used as input (TTree::SetEntryList()); 43 ; 44 Long64_t fLastIndexQueried; ///<! used to optimize GetEntry() function from a loop; 45 Long64_t fLastIndexReturned; ///<! used to optimize GetEntry() function from a loop; 46 bool fShift; ///<! true when some sub-lists don't correspond to trees; 47 ///< (when the entry list is used as input in TChain); 48 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 49 bool fReapply; ///< If true, TTree::Draw will 'reapply' the original cut; 50 ; 51 void GetFileName(const char *filename, TString &fn, bool * = nullptr);; 52 ; 53 public:; 54 enum {kBlockSize = 64000}; //number of entries in each block (not the physical size).; 55 ; 56 TEntryList();; 57 TEntryList(const char *name, const char *title);; 58 TEntryList(const char *name, const char *title, const TTree *tree);; 59 TEntr",MatchSource.WIKI,doc/master/TEntryList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html
https://root.cern/doc/master/TEntryList_8h_source.html:1877,Performance,optimiz,optimize,1877,"************************************************************************/; 11 ; 12#ifndef ROOT_TEntryList; 13#define ROOT_TEntryList; 14 ; 15#include ""TNamed.h""; 16 ; 17class TTree;; 18class TDirectory;; 19class TObjArray;; 20class TString;; 21 ; 22class TList;; 23class TCollection;; 24 ; 25class TEntryList: public TNamed; 26{; 27 private:; 28 TEntryList& operator=(const TEntryList&); // Not implemented; 29 ; 30 protected:; 31 TList *fLists; ///< a list of underlying entry lists for each tree of a chain; 32 TEntryList *fCurrent; ///<! currently filled entry list; 33 ; 34 Int_t fNBlocks; ///< number of TEntryListBlocks; 35 TObjArray *fBlocks; ///< blocks with indices of passing events (TEntryListBlocks); 36 Long64_t fN; ///< number of entries in the list; 37 Long64_t fEntriesToProcess; ///< used on proof to set the number of entries to process in a packet; 38 TString fTreeName; ///< name of the tree; 39 TString fFileName; ///< name of the file, where the tree is; 40 ULong_t fStringHash; ///<! Hash value of a string of treename and filename; 41 Int_t fTreeNumber; ///<! the index of the tree in the chain (used when the entry; 42 ///< list is used as input (TTree::SetEntryList()); 43 ; 44 Long64_t fLastIndexQueried; ///<! used to optimize GetEntry() function from a loop; 45 Long64_t fLastIndexReturned; ///<! used to optimize GetEntry() function from a loop; 46 bool fShift; ///<! true when some sub-lists don't correspond to trees; 47 ///< (when the entry list is used as input in TChain); 48 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 49 bool fReapply; ///< If true, TTree::Draw will 'reapply' the original cut; 50 ; 51 void GetFileName(const char *filename, TString &fn, bool * = nullptr);; 52 ; 53 public:; 54 enum {kBlockSize = 64000}; //number of entries in each block (not the physical size).; 55 ; 56 TEntryList();; 57 TEntryList(const char *name, const char *title);; 58 TEntryList(const char *name, const char *title, const TTree *tree);; 59 TEntr",MatchSource.WIKI,doc/master/TEntryList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html
https://root.cern/doc/master/TEntryList_8h_source.html:7891,Performance,optimiz,optimize,7891,"t_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEntryList::Entervirtual bool Enter(Long64_t entry, TTree *tree=nullptr)Add entry #entry to the list.Definition TEntryList.cxx:631; TEntryList::fReapplybool fReapplyIf true, TTree::Draw will 'reapply' the original cut.Definition TEntryList.h:49; TEntryList::fLastIndexQueriedLong64_t fLastIndexQueried! used to optimize GetEntry() function from a loopDefinition TEntryList.h:44; TEntryList::GetEntryListvirtual TEntryList * GetEntryList(const char *treename, const char *filename, Option_t *opt="""")Return the entry list, corresponding to treename and filename By default, the filename is first tried...Definition TEntryList.cxx:889; TEntryList::fEntriesToProcessLong64_t fEntriesToProcessused on proof to set the number of entries to process in a packetDefinition TEntryList.h:37; TEntryList::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TEntryList.h:81; TEntryList::fFileNameTString fFileNamename of the file, where the tree isDefinition TEntryList.h:39; TEntryList::OptimizeStoragevirtual void OptimizeStorage()Checks if the array representation is more economical and if so, switches to it.Definition TEntryList.cxx:1085; TEntryList::GetListsvirtual TList * GetLists() constDefinition TEntryList.h:76; TEntryList::Containsvirtual Int_t Contains(Long64_t entry, TTree *tree=nullptr)Definitio",MatchSource.WIKI,doc/master/TEntryList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html
https://root.cern/doc/master/TEntryList_8h_source.html:11308,Performance,optimiz,optimize,11308,"ng64_t index, Int_t &treenum)Return the index of ""index""-th non-zero entry in the TTree or TChain and the # of the corresponding t...Definition TEntryList.cxx:835; TEntryList::GetFileNamevirtual const char * GetFileName() constDefinition TEntryList.h:80; TEntryList::Scanstatic Int_t Scan(const char *fn, TList *roots)Scan TEntryList in 'fn' to find the common parts of paths.Definition TEntryList.cxx:1608; TEntryList::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and others to automatically add us to a directory when we are read from a file.Definition TEntryList.cxx:619; TEntryList::kBlockSize@ kBlockSizeDefinition TEntryList.h:54; TEntryList::fNLong64_t fNnumber of entries in the listDefinition TEntryList.h:36; TEntryList::SetReapplyCutvirtual void SetReapplyCut(bool apply=false)Definition TEntryList.h:108; TEntryList::SetTreeNumbervirtual void SetTreeNumber(Int_t index)Definition TEntryList.h:107; TEntryList::fLastIndexReturnedLong64_t fLastIndexReturned! used to optimize GetEntry() function from a loopDefinition TEntryList.h:45; TEntryList::Nextvirtual Long64_t Next()Return the next non-zero entry index (next after fLastIndexQueried) this function is faster than GetE...Definition TEntryList.cxx:998; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::EnterRangevoid EnterRange(Long64_t start, Long64_t end, TTree *tree=nullptr, UInt_t step=1U)Enter all entries in a range in the TEntryList.Definition TEntryList.cxx:703; TEntryList::GetCurrentListvirtual TEntryList * GetCurrentList() constDefinition TEntryList.h:71; TEntryList::SetTreeNamevirtual void SetTreeName(const char *treename)Definition TEntryList.h:105; TEntryList::Resetvirtual void Reset()Reset this list.Definition TEntryList.cxx:1138; TEntryList::IsValidbool IsValid() constDefinition TEntryList.h:84; TEntryList::fNBlocksInt_t fNBlocksnumber of TEntryListBlocksDefinition TEntryLis",MatchSource.WIKI,doc/master/TEntryList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEntryList_8h_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:16567,Availability,error,error,16567,"nv();; 560 return;; 561 }; 562 ; 563 if (!strcmp(opt, ""global"")); 564 PrintEnv(kEnvGlobal);; 565 if (!strcmp(opt, ""user"")); 566 PrintEnv(kEnvUser);; 567 if (!strcmp(opt, ""local"")); 568 PrintEnv(kEnvLocal);; 569}; 570 ; 571////////////////////////////////////////////////////////////////////////////////; 572/// Print all resources for a certain level (global, user, local, changed).; 573 ; 574void TEnv::PrintEnv(EEnvLevel level) const; 575{; 576 if (!fTable) return;; 577 ; 578 TIter next(fTable);; 579 TEnvRec *er;; 580 static const char *lc[] = { ""Global"", ""User"", ""Local"", ""Changed"", ""All"" };; 581 ; 582 while ((er = (TEnvRec*) next())); 583 if (er->fLevel == level || level == kEnvAll); 584 Printf(""%-25s %-30s [%s]"", TString::Format(""%s:"", er->fName.Data()).Data(),; 585 er->fValue.Data(), lc[er->fLevel]);; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Read and parse the resource file for a certain level.; 590/// Returns -1 on case of error, 0 in case of success.; 591 ; 592Int_t TEnv::ReadFile(const char *fname, EEnvLevel level); 593{; 594 if (!fname || !fname[0]) {; 595 Error(""ReadFile"", ""no file name specified"");; 596 return -1;; 597 }; 598 ; 599 FILE *ifp;; 600 if ((ifp = fopen(fname, ""r""))) {; 601 TReadEnvParser rp(this, ifp, level);; 602 rp.Parse();; 603 fclose(ifp);; 604 return 0;; 605 }; 606 ; 607 // no Error() here since we are allowed to try to read from a non-existing; 608 // file (like ./.rootrc, $HOME/.rootrc, etc.); 609 return -1;; 610}; 611 ; 612////////////////////////////////////////////////////////////////////////////////; 613/// Write resource records to file fname for a certain level. Use; 614/// level kEnvAll to write all resources. Returns -1 on case of error,; 615/// 0 in case of success.; 616 ; 617Int_t TEnv::WriteFile(const char *fname, EEnvLevel level); 618{; 619 if (!fname || !fname[0]) {; 620 Error(""WriteFile"", ""no file name specified"");; 621 return -1;; 622 }; 623 ; 624 if (!fTable) {; 6",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:17321,Availability,error,error,17321,").Data(),; 585 er->fValue.Data(), lc[er->fLevel]);; 586}; 587 ; 588////////////////////////////////////////////////////////////////////////////////; 589/// Read and parse the resource file for a certain level.; 590/// Returns -1 on case of error, 0 in case of success.; 591 ; 592Int_t TEnv::ReadFile(const char *fname, EEnvLevel level); 593{; 594 if (!fname || !fname[0]) {; 595 Error(""ReadFile"", ""no file name specified"");; 596 return -1;; 597 }; 598 ; 599 FILE *ifp;; 600 if ((ifp = fopen(fname, ""r""))) {; 601 TReadEnvParser rp(this, ifp, level);; 602 rp.Parse();; 603 fclose(ifp);; 604 return 0;; 605 }; 606 ; 607 // no Error() here since we are allowed to try to read from a non-existing; 608 // file (like ./.rootrc, $HOME/.rootrc, etc.); 609 return -1;; 610}; 611 ; 612////////////////////////////////////////////////////////////////////////////////; 613/// Write resource records to file fname for a certain level. Use; 614/// level kEnvAll to write all resources. Returns -1 on case of error,; 615/// 0 in case of success.; 616 ; 617Int_t TEnv::WriteFile(const char *fname, EEnvLevel level); 618{; 619 if (!fname || !fname[0]) {; 620 Error(""WriteFile"", ""no file name specified"");; 621 return -1;; 622 }; 623 ; 624 if (!fTable) {; 625 Error(""WriteFile"", ""TEnv table is empty"");; 626 return -1;; 627 }; 628 ; 629 FILE *ofp;; 630 if ((ofp = fopen(fname, ""w""))) {; 631 TIter next(fTable);; 632 TEnvRec *er;; 633 while ((er = (TEnvRec*) next())); 634 if (er->fLevel == level || level == kEnvAll); 635 fprintf(ofp, ""%-40s %s\n"", TString::Format(""%s:"", er->fName.Data()).Data(),; 636 er->fValue.Data());; 637 fclose(ofp);; 638 return 0;; 639 }; 640 ; 641 Error(""WriteFile"", ""cannot open %s for writing"", fname);; 642 return -1;; 643}; 644 ; 645////////////////////////////////////////////////////////////////////////////////; 646/// Write the resource files for each level. The new files have the same; 647/// name as the original files. The old files are renamed to *.bak.; 648 ; 649void TEnv::Save(",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:30273,Availability,error,error,30273,"Env()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Defi",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:30400,Deployability,install,installation,30400,"elete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECase",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:30149,Integrability,message,message,30149,"elvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TStri",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:30279,Integrability,message,message,30279,"Env()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Defi",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:723,Modifiability,config,config,723,". ROOT: core/base/src/TEnv.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same res",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:783,Modifiability,config,config,783,". ROOT: core/base/src/TEnv.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same res",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:1010,Modifiability,variab,variable,1010," ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 U",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:2334,Modifiability,variab,variables,2334," 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<SystemName>` and `<ProgName>` or `<RootName>` may be the wildcard ""*"".; 46A # in the first column starts comment line.; 47 ; 48Note that the environment variables (like $ROOTSYS) need to be; 49surrounded in parentheses in order to be expanded.; 50 ; 51For the currently defined resources (and their default values) see; 52`$ROOTSYS/etc/system.rootrc`.; 53 ; 54Note that the .rootrc config files contain the config for all ROOT; 55based applications.; 56 ; 57To add new entries to a TEnv:; 58~~~ {.cpp}; 59TEnv env("".myfile"");; 60env.SetValue(""myname"",""value"");; 61env.SaveLevel(kEnvLocal);; 62~~~; 63All new entries will be saved in the file corresponding to the; 64first SaveLevel() command. If Save() is used, new entries go; 65into the local file by default.; 66*/; 67 ; 68#include ""RConfigure.h""; 69 ; 70#include <cstring>; 71#include <cstdio>; 72#include <cstdlib>; 73#include <cctype>; 74 ; 75#include ""strlcpy.h""; 76#include ""TEnv.h""; 77#include ""TROOT.h""; 78#include ""TSystem.h""; 79#include ""THashList.h""; 80#include ""TError.h""; 81 ; 82 ; 83TEnv *gEnv; // main environment created in TROOT; 84 ; 85 ; 86static struct BoolNameTable_t {; 87 const char *fName;; 88 Int_t fValu",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:2563,Modifiability,config,config,2563,"lication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<SystemName>` and `<ProgName>` or `<RootName>` may be the wildcard ""*"".; 46A # in the first column starts comment line.; 47 ; 48Note that the environment variables (like $ROOTSYS) need to be; 49surrounded in parentheses in order to be expanded.; 50 ; 51For the currently defined resources (and their default values) see; 52`$ROOTSYS/etc/system.rootrc`.; 53 ; 54Note that the .rootrc config files contain the config for all ROOT; 55based applications.; 56 ; 57To add new entries to a TEnv:; 58~~~ {.cpp}; 59TEnv env("".myfile"");; 60env.SetValue(""myname"",""value"");; 61env.SaveLevel(kEnvLocal);; 62~~~; 63All new entries will be saved in the file corresponding to the; 64first SaveLevel() command. If Save() is used, new entries go; 65into the local file by default.; 66*/; 67 ; 68#include ""RConfigure.h""; 69 ; 70#include <cstring>; 71#include <cstdio>; 72#include <cstdlib>; 73#include <cctype>; 74 ; 75#include ""strlcpy.h""; 76#include ""TEnv.h""; 77#include ""TROOT.h""; 78#include ""TSystem.h""; 79#include ""THashList.h""; 80#include ""TError.h""; 81 ; 82 ; 83TEnv *gEnv; // main environment created in TROOT; 84 ; 85 ; 86static struct BoolNameTable_t {; 87 const char *fName;; 88 Int_t fValue;; 89} gBoolNames[]= {; 90 { ""TRUE"", 1 },; 91 { ""FALSE"", 0 },; 92 { ""ON"", 1 },; 93 { ""OFF"", 0 },; 94 { ""YES"", 1 },; 95 { ""NO"", 0 },; 96 { ""OK"", 1 },; 97 { ""NOT"", 0 },; 98 { nullptr, 0 }; 99};; 100 ; 101 ; 102/** \class TEnvParser;",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:2588,Modifiability,config,config,2588,"lication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<SystemName>` and `<ProgName>` or `<RootName>` may be the wildcard ""*"".; 46A # in the first column starts comment line.; 47 ; 48Note that the environment variables (like $ROOTSYS) need to be; 49surrounded in parentheses in order to be expanded.; 50 ; 51For the currently defined resources (and their default values) see; 52`$ROOTSYS/etc/system.rootrc`.; 53 ; 54Note that the .rootrc config files contain the config for all ROOT; 55based applications.; 56 ; 57To add new entries to a TEnv:; 58~~~ {.cpp}; 59TEnv env("".myfile"");; 60env.SetValue(""myname"",""value"");; 61env.SaveLevel(kEnvLocal);; 62~~~; 63All new entries will be saved in the file corresponding to the; 64first SaveLevel() command. If Save() is used, new entries go; 65into the local file by default.; 66*/; 67 ; 68#include ""RConfigure.h""; 69 ; 70#include <cstring>; 71#include <cstdio>; 72#include <cstdlib>; 73#include <cctype>; 74 ; 75#include ""strlcpy.h""; 76#include ""TEnv.h""; 77#include ""TROOT.h""; 78#include ""TSystem.h""; 79#include ""THashList.h""; 80#include ""TError.h""; 81 ; 82 ; 83TEnv *gEnv; // main environment created in TROOT; 84 ; 85 ; 86static struct BoolNameTable_t {; 87 const char *fName;; 88 Int_t fValue;; 89} gBoolNames[]= {; 90 { ""TRUE"", 1 },; 91 { ""FALSE"", 0 },; 92 { ""ON"", 1 },; 93 { ""OFF"", 0 },; 94 { ""YES"", 1 },; 95 { ""NO"", 0 },; 96 { ""OK"", 1 },; 97 { ""NOT"", 0 },; 98 { nullptr, 0 }; 99};; 100 ; 101 ; 102/** \class TEnvParser;",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:10595,Modifiability,variab,variable,10595," + len;; 363 char *nv = new char[nch];; 364 *nv = 0;; 365 ; 366 while ((s1 = (char*)strstr(v, ""$(""))) {; 367 *s1 = 0;; 368 strlcat(nv, v,nch);; 369 *s1 = '$';; 370 s1 += 2;; 371 s2 = (char*)strchr(s1, ')');; 372 *s2 = 0;; 373 vv = gSystem->Getenv(s1);; 374 if (vv) strlcat(nv, vv,nch);; 375 *s2 = ')';; 376 v = s2 + 1;; 377 }; 378 ; 379 if (*v) strlcat(nv, v,nch);; 380 ; 381 TString val = nv;; 382 delete [] nv;; 383 delete [] vorg;; 384 ; 385 return val;; 386}; 387 ; 388ClassImp(TEnv);; 389 ; 390////////////////////////////////////////////////////////////////////////////////; 391/// Create a resource table and read the (possibly) three resource files,; 392/// i.e.\ `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`),; 393/// `$HOME/<name>` and `$PWD/<name>`.; 394/// ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; 395/// read additional user defined resource files by creating additional TEnv; 396/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 397/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 398/// case the home directory resides on an auto-mounted remote file system; 399/// and one wants to avoid the file system from being mounted.; 400 ; 401TEnv::TEnv(const char *name); 402{; 403 fIgnoreDup = kFALSE;; 404 ; 405 if (!name || !name[0] || !gSystem); 406 fTable = nullptr;; 407 else {; 408 fTable = new THashList(1000);; 409 fRcName = name;; 410 ; 411 TString sname = ""system"";; 412 sname += name;; 413 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 414 ReadFile(s, kEnvGlobal);; 415 delete [] s;; 416 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 417 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 418 ReadFile(s, kEnvUser);; 419 delete [] s;; 420 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())); 421 ReadFile(name, kEnvLocal);; 422 } else; 423 ReadFile(name, kEnvLocal);; 424 }; 425}; 426 ; 427///////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:27422,Modifiability,config,config,27422,"virtual void KeyValue(const TString &, const TString &, const TString &)Definition TEnv.cxx:117; TEnvParser::fIfpFILE * fIfpDefinition TEnv.cxx:109; TEnvRecDefinition TEnv.h:86; TEnvRec::fValueTString fValueDefinition TEnv.h:96; TEnvRec::ChangeValuevoid ChangeValue(const char *v, const char *t, EEnvLevel l, Bool_t append=kFALSE, Bool_t ignoredup=kFALSE)Change the value of a resource.Definition TEnv.cxx:293; TEnvRec::fLevelEEnvLevel fLevelDefinition TEnv.h:97; TEnvRec::TEnvRecTEnvRec()Definition TEnv.h:107; TEnvRec::ExpandValueTString ExpandValue(const char *v)Replace all strings by the value defined in the shell (obtained via TSystem::Getenv()).Definition TEnv.cxx:334; TEnvRec::fNameTString fNameDefinition TEnv.h:94; TEnvRec::fModifiedBool_t fModifiedDefinition TEnv.h:98; TEnvRec::~TEnvRec~TEnvRec()TNamed destructor.Definition TEnv.cxx:284; TEnvRec::CompareInt_t Compare(const TObject *obj) const overrideComparison function for resources.Definition TEnv.cxx:325; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::fTableTHashList * fTableDefinition TEnv.h:127; TEnv::Printvoid Print(Option_t *option="""") const overridePrint all resources or the global, user or local resources separately.Definition TEnv.cxx:556; TEnv::PrintEnvvirtual void PrintEnv(EEnvLevel level=kEnvAll) constPrint all resources for a certain level (global, user, local, changed).Definition TEnv.cxx:574; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::fRcNameTString fRcNameDefinition TEnv.h:128; TEnv::WriteFilevirtual Int_t WriteFile(const char *fname, EEnvLevel level=kEnvAll)Write resource records to file fname for a certain level.Definition TEnv.cxx:617; TEnv::IgnoreDuplicatesBool_t IgnoreDuplicates(Bool_t ignore)If set to true, no warnings in case of duplicates are issued.Definition TEnv.cxx:793; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:31486,Modifiability,variab,variable,31486,"TROOT.cxx:3056; TReadEnvParserDefinition TEnv.cxx:228; TReadEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideDefinition TEnv.cxx:235; TReadEnvParser::TReadEnvParserTReadEnvParser(TEnv *e, FILE *f, EEnvLevel l)Definition TEnv.cxx:234; TReadEnvParser::fLevelEEnvLevel fLevelDefinition TEnv.cxx:231; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::CompareToint CompareTo(const char *cs, ECaseCompare cmp=kExact) constCompare a string to char *cs2.Definition TString.cxx:457; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::HomeDirectoryvirtual const char * HomeDirectory(const char *userName=nullptr)Return the user's home directory.Definition TSystem.cxx:887; TWriteEnvParserDefinition TEnv.cxx:242; TWriteEnvParser::KeyValuevoid KeyValue(const TString &name, const TString &value, const TString &type) overrideWrite resources out to a new file.Definition TEnv.cxx:256; TWriteEnvParser::Charvoid Char(Int_t c) overrideDefinition TEnv.cxx:250; TWriteEnvParser::TWriteEnvParserTWriteEnvParser(TEnv *e, FILE *f, FILE *of)Defi",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:1224,Safety,avoid,avoid,1224,"base:$Id: 0daf41ec24086ee7af29fdc2f9f2f848b150dcc8 $; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TEnv; 13\ingroup Base; 14 ; 15The TEnv class reads config files, by default named `.rootrc`.; 16Three types of config files are read: global, user and local files. The; 17global file is `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`); 18the user file is `$HOME/<name>` and the local file is `./<name>`.; 19By setting the shell variable `ROOTENV_NO_HOME=1` the reading of; 20the `$HOME/<name>` resource file will be skipped. This might be useful; 21in case the home directory resides on an auto-mounted remote file; 22system and one wants to avoid this file system from being mounted.; 23 ; 24The format of the `.rootrc` file is similar to the `.Xdefaults` format:; 25~~~ {.cpp}; 26 [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value>; 27~~~; 28Where `<SystemName>` is either Unix, WinNT, MacOS or Vms,; 29`<RootName>` the name as given in the TApplication ctor (or ""RootApp""; 30in case no explicit TApplication derived object was created),; 31`<ProgName>` the current program name and `<name>` the resource name,; 32with optionally a type specification. `<value>` can be either a; 33string, an integer, a float/double or a boolean with the values; 34TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as; 35an integer 0 or 1. The options [+] allows the concatenation of; 36values to the same resource name.; 37 ; 38E.g.:; 39~~~ {.cpp}; 40 Unix.Rint.Root.DynamicPath: .:$(ROOTSYS)/lib:~/lib; 41 myapp.Root.Debug: FALSE; 42 TH.Root.Debug: YES; 43 *.Root.ObjStat: 1; 44~~~; 45`<Syste",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:10822,Safety,avoid,avoid,10822,"69 *s1 = '$';; 370 s1 += 2;; 371 s2 = (char*)strchr(s1, ')');; 372 *s2 = 0;; 373 vv = gSystem->Getenv(s1);; 374 if (vv) strlcat(nv, vv,nch);; 375 *s2 = ')';; 376 v = s2 + 1;; 377 }; 378 ; 379 if (*v) strlcat(nv, v,nch);; 380 ; 381 TString val = nv;; 382 delete [] nv;; 383 delete [] vorg;; 384 ; 385 return val;; 386}; 387 ; 388ClassImp(TEnv);; 389 ; 390////////////////////////////////////////////////////////////////////////////////; 391/// Create a resource table and read the (possibly) three resource files,; 392/// i.e.\ `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`),; 393/// `$HOME/<name>` and `$PWD/<name>`.; 394/// ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; 395/// read additional user defined resource files by creating additional TEnv; 396/// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; 397/// the `$HOME/<name>` resource file will be skipped. This might be useful in; 398/// case the home directory resides on an auto-mounted remote file system; 399/// and one wants to avoid the file system from being mounted.; 400 ; 401TEnv::TEnv(const char *name); 402{; 403 fIgnoreDup = kFALSE;; 404 ; 405 if (!name || !name[0] || !gSystem); 406 fTable = nullptr;; 407 else {; 408 fTable = new THashList(1000);; 409 fRcName = name;; 410 ; 411 TString sname = ""system"";; 412 sname += name;; 413 char *s = gSystem->ConcatFileName(TROOT::GetEtcDir(), sname);; 414 ReadFile(s, kEnvGlobal);; 415 delete [] s;; 416 if (!gSystem->Getenv(""ROOTENV_NO_HOME"")) {; 417 s = gSystem->ConcatFileName(gSystem->HomeDirectory(), name);; 418 ReadFile(s, kEnvUser);; 419 delete [] s;; 420 if (strcmp(gSystem->HomeDirectory(), gSystem->WorkingDirectory())); 421 ReadFile(name, kEnvLocal);; 422 } else; 423 ReadFile(name, kEnvLocal);; 424 }; 425}; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Delete the resource table.; 429 ; 430TEnv::~TEnv(); 431{; 432 if (fTable) {; 433 fTable->Delete();; 434 SafeDelete(",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8cxx_source.html:29438,Security,hash,hash,29438,"*fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TEnv::Savevirtual void Save()Write the resource files for each level.Definition TEnv.cxx:649; TEnv::fIgnoreDupBool_t fIgnoreDupDefinition TEnv.h:129; TEnv::Getvalueconst char * Getvalue(const char *name) constReturns the character value for a named resource.Definition TEnv.cxx:441; TEnv::SaveLevelvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition THashList.cxx:207; THashList::FindObjectTObject * FindObject(const char *name) const overrideFind object using its name.Definition THashList.cxx:262; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the",MatchSource.WIKI,doc/master/TEnv_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8cxx_source.html
https://root.cern/doc/master/TEnv_8h.html:240,Integrability,depend,dependency,240,". ROOT: core/base/inc/TEnv.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations |; Variables ; TEnv.h File Reference. #include ""TObject.h""; #include ""TString.h"". Include dependency graph for TEnv.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TEnvRec;  . Enumerations; enum  EEnvLevel { ;   kEnvGlobal; , kEnvUser; , kEnvLocal; , kEnvChange; , ;   kEnvAll. };  . Variables; R__EXTERN TEnv * gEnv;  . Enumeration Type Documentation. ◆ EEnvLevel. enum EEnvLevel. EnumeratorkEnvGlobal ; kEnvUser ; kEnvLocal ; kEnvChange ; kEnvAll . Definition at line 69 of file TEnv.h. Variable Documentation. ◆ gEnv. R__EXTERN TEnv* gEnv. Definition at line 170 of file TEnv.h. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h.html
https://root.cern/doc/master/TEnv_8h.html:556,Modifiability,config,config,556,". ROOT: core/base/inc/TEnv.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations |; Variables ; TEnv.h File Reference. #include ""TObject.h""; #include ""TString.h"". Include dependency graph for TEnv.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TEnvRec;  . Enumerations; enum  EEnvLevel { ;   kEnvGlobal; , kEnvUser; , kEnvLocal; , kEnvChange; , ;   kEnvAll. };  . Variables; R__EXTERN TEnv * gEnv;  . Enumeration Type Documentation. ◆ EEnvLevel. enum EEnvLevel. EnumeratorkEnvGlobal ; kEnvUser ; kEnvLocal ; kEnvChange ; kEnvAll . Definition at line 69 of file TEnv.h. Variable Documentation. ◆ gEnv. R__EXTERN TEnv* gEnv. Definition at line 170 of file TEnv.h. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:12 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h.html
https://root.cern/doc/master/TEnv_8h_source.html:6400,Deployability,configurat,configuration,6400,"9// //; 120// TEnv //; 121// //; 122//////////////////////////////////////////////////////////////////////////; 123 ; 124class TEnv : public TObject {; 125 ; 126private:; 127 THashList *fTable; // hash table containing env records; 128 TString fRcName; // resource file base name; 129 Bool_t fIgnoreDup; // ignore duplicates, don't issue warning; 130 ; 131 TEnv(const TEnv&) = delete;; 132 TEnv& operator=(const TEnv&) = delete;; 133 ; 134 const char *Getvalue(const char *name) const;; 135 ; 136public:; 137 TEnv(const char *name="""");; 138 virtual ~TEnv();; 139 ; 140 THashList *GetTable() const { return fTable; }; 141 Bool_t Defined(const char *name) const; 142 { return Getvalue(name) != nullptr; }; 143 ; 144 virtual const char *GetRcName() const { return fRcName; }; 145 virtual void SetRcName(const char *name) { fRcName = name; }; 146 ; 147 virtual Int_t GetValue(const char *name, Int_t dflt) const;; 148 virtual Double_t GetValue(const char *name, Double_t dflt) const;; 149 virtual const char *GetValue(const char *name, const char *dflt) const;; 150 ; 151 virtual void SetValue(const char *name, const char *value,; 152 EEnvLevel level = kEnvChange,; 153 const char *type = nullptr);; 154 virtual void SetValue(const char *name, EEnvLevel level = kEnvChange);; 155 virtual void SetValue(const char *name, Int_t value);; 156 virtual void SetValue(const char *name, Double_t value);; 157 ; 158 virtual TEnvRec *Lookup(const char *n) const;; 159 virtual Int_t ReadFile(const char *fname, EEnvLevel level);; 160 virtual Int_t WriteFile(const char *fname, EEnvLevel level = kEnvAll);; 161 virtual void Save();; 162 virtual void SaveLevel(EEnvLevel level);; 163 void Print(Option_t *option="""") const override;; 164 virtual void PrintEnv(EEnvLevel level = kEnvAll) const;; 165 Bool_t IgnoreDuplicates(Bool_t ignore);; 166 ; 167 ClassDefOverride(TEnv,2) // Handle ROOT configuration resources; 168};; 169 ; 170R__EXTERN TEnv *gEnv;; 171 ; 172#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:800,Modifiability,config,config,800,". ROOT: core/base/inc/TEnv.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:864,Modifiability,config,config,864,". ROOT: core/base/inc/TEnv.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TEnv.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:1100,Modifiability,variab,variable,1100," to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 22/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:2620,Modifiability,config,config,2620,"TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug: FALSE //; 47// TH.Root.Debug: YES //; 48// //; 49// <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"". //; 50// A # in the first column starts comment line. //; 51// //; 52// For the currently defined resources (and their default values) see //; 53// $ROOTSYS/etc/system.rootrc. //; 54// //; 55// Note that the .rootrc config files contain the config for all ROOT //; 56// based applications. //; 57// //; 58//////////////////////////////////////////////////////////////////////////; 59 ; 60#include ""TObject.h""; 61#include ""TString.h""; 62 ; 63class THashList;; 64class TEnv;; 65class TEnvParser;; 66class TReadEnvParser;; 67class TWriteEnvParser;; 68 ; 69enum EEnvLevel {; 70 kEnvGlobal,; 71 kEnvUser,; 72 kEnvLocal,; 73 kEnvChange,; 74 kEnvAll; 75};; 76 ; 77 ; 78//////////////////////////////////////////////////////////////////////////; 79// //; 80// TEnvRec //; 81// //; 82// Individual TEnv records. //; 83// //; 84//////////////////////////////////////////////////////////////////////////; 85 ; 86class TEnvRec : public TObject {; 87 ; 88friend class TEnv;; 89friend class TEnvParser;; 90friend class TReadEnvParser;; 91friend class TWriteEnvParser;; 92 ; 93private:; 94 TString fName; // env rec key name; 95 TString fType; // env rec type; 96 TString fValue; // env rec value; 97 EEnvLevel fLevel; // env rec level; 98 Bool_t fModified; // if ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:2645,Modifiability,config,config,2645,"TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug: FALSE //; 47// TH.Root.Debug: YES //; 48// //; 49// <SystemName> and <ProgName> or <RootName> may be the wildcard ""*"". //; 50// A # in the first column starts comment line. //; 51// //; 52// For the currently defined resources (and their default values) see //; 53// $ROOTSYS/etc/system.rootrc. //; 54// //; 55// Note that the .rootrc config files contain the config for all ROOT //; 56// based applications. //; 57// //; 58//////////////////////////////////////////////////////////////////////////; 59 ; 60#include ""TObject.h""; 61#include ""TString.h""; 62 ; 63class THashList;; 64class TEnv;; 65class TEnvParser;; 66class TReadEnvParser;; 67class TWriteEnvParser;; 68 ; 69enum EEnvLevel {; 70 kEnvGlobal,; 71 kEnvUser,; 72 kEnvLocal,; 73 kEnvChange,; 74 kEnvAll; 75};; 76 ; 77 ; 78//////////////////////////////////////////////////////////////////////////; 79// //; 80// TEnvRec //; 81// //; 82// Individual TEnv records. //; 83// //; 84//////////////////////////////////////////////////////////////////////////; 85 ; 86class TEnvRec : public TObject {; 87 ; 88friend class TEnv;; 89friend class TEnvParser;; 90friend class TReadEnvParser;; 91friend class TWriteEnvParser;; 92 ; 93private:; 94 TString fName; // env rec key name; 95 TString fType; // env rec type; 96 TString fValue; // env rec value; 97 EEnvLevel fLevel; // env rec level; 98 Bool_t fModified; // if ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:6400,Modifiability,config,configuration,6400,"9// //; 120// TEnv //; 121// //; 122//////////////////////////////////////////////////////////////////////////; 123 ; 124class TEnv : public TObject {; 125 ; 126private:; 127 THashList *fTable; // hash table containing env records; 128 TString fRcName; // resource file base name; 129 Bool_t fIgnoreDup; // ignore duplicates, don't issue warning; 130 ; 131 TEnv(const TEnv&) = delete;; 132 TEnv& operator=(const TEnv&) = delete;; 133 ; 134 const char *Getvalue(const char *name) const;; 135 ; 136public:; 137 TEnv(const char *name="""");; 138 virtual ~TEnv();; 139 ; 140 THashList *GetTable() const { return fTable; }; 141 Bool_t Defined(const char *name) const; 142 { return Getvalue(name) != nullptr; }; 143 ; 144 virtual const char *GetRcName() const { return fRcName; }; 145 virtual void SetRcName(const char *name) { fRcName = name; }; 146 ; 147 virtual Int_t GetValue(const char *name, Int_t dflt) const;; 148 virtual Double_t GetValue(const char *name, Double_t dflt) const;; 149 virtual const char *GetValue(const char *name, const char *dflt) const;; 150 ; 151 virtual void SetValue(const char *name, const char *value,; 152 EEnvLevel level = kEnvChange,; 153 const char *type = nullptr);; 154 virtual void SetValue(const char *name, EEnvLevel level = kEnvChange);; 155 virtual void SetValue(const char *name, Int_t value);; 156 virtual void SetValue(const char *name, Double_t value);; 157 ; 158 virtual TEnvRec *Lookup(const char *n) const;; 159 virtual Int_t ReadFile(const char *fname, EEnvLevel level);; 160 virtual Int_t WriteFile(const char *fname, EEnvLevel level = kEnvAll);; 161 virtual void Save();; 162 virtual void SaveLevel(EEnvLevel level);; 163 void Print(Option_t *option="""") const override;; 164 virtual void PrintEnv(EEnvLevel level = kEnvAll) const;; 165 Bool_t IgnoreDuplicates(Bool_t ignore);; 166 ; 167 ClassDefOverride(TEnv,2) // Handle ROOT configuration resources; 168};; 169 ; 170R__EXTERN TEnv *gEnv;; 171 ; 172#endif; R__EXTERN#define R__EXTERNDefinition DllImport.",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:9787,Modifiability,config,config,9787," constDefinition TEnv.h:111; TEnvRec::fLevelEEnvLevel fLevelDefinition TEnv.h:97; TEnvRec::GetLevelEEnvLevel GetLevel() constDefinition TEnv.h:112; TEnvRec::TEnvRecTEnvRec()Definition TEnv.h:107; TEnvRec::GetValueconst char * GetValue() constDefinition TEnv.h:110; TEnvRec::ExpandValueTString ExpandValue(const char *v)Replace all strings by the value defined in the shell (obtained via TSystem::Getenv()).Definition TEnv.cxx:334; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TEnvRec::fNameTString fNameDefinition TEnv.h:94; TEnvRec::fTypeTString fTypeDefinition TEnv.h:95; TEnvRec::fModifiedBool_t fModifiedDefinition TEnv.h:98; TEnvRec::GetNameconst char * GetName() const overrideReturns name of object.Definition TEnv.h:109; TEnvRec::~TEnvRec~TEnvRec()TNamed destructor.Definition TEnv.cxx:284; TEnvRec::CompareInt_t Compare(const TObject *obj) const overrideComparison function for resources.Definition TEnv.cxx:325; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::fTableTHashList * fTableDefinition TEnv.h:127; TEnv::Printvoid Print(Option_t *option="""") const overridePrint all resources or the global, user or local resources separately.Definition TEnv.cxx:556; TEnv::PrintEnvvirtual void PrintEnv(EEnvLevel level=kEnvAll) constPrint all resources for a certain level (global, user, local, changed).Definition TEnv.cxx:574; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEnv::GetTableTHashList * GetTable() constDefinition TEnv.h:140; TEnv::fRcNameTString fRcNameDefinition TEnv.h:128; TEnv::WriteFilevirtual Int_t WriteFile(const char *fname, EEnvLevel level=kEnvAll)Write resource records to file fname for a certain level.Definition TEnv.cxx:617; TEnv::IgnoreDuplicatesBool_t IgnoreDuplicates(Bool_t ignore)If set to true, no warnings in case of duplicates are issued.Definition TEnv.cxx:793; TEnv::",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:1327,Safety,avoid,avoid,1327,"***************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TEnv; 13#define ROOT_TEnv; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TEnv //; 19// //; 20// The TEnv class reads config files, by default named .rootrc. Three //; 21// types of config files are read: global, user and local files. The //; 22// global file is $ROOTSYS/etc/system<name> (or ROOTETCDIR/system<name>)//; 23// the user file is $HOME/<name> and the local file is ./<name>. //; 24// By setting the shell variable ROOTENV_NO_HOME=1 the reading of //; 25// the $HOME/<name> resource file will be skipped. This might be useful //; 26// in case the home directory resides on an automounted remote file //; 27// system and one wants to avoid this file system from being mounted. //; 28// //; 29// The format of the .rootrc file is similar to the .Xdefaults format: //; 30// //; 31// [+]<SystemName>.<RootName|ProgName>.<name>[(type)]: <value> //; 32// //; 33// Where <SystemName> is either Unix, WinNT, MacOS or Vms, //; 34// <RootName> the name as given in the TApplication ctor (or ""RootApp"" //; 35// in case no explicit TApplication derived object was created), //; 36// <ProgName> the current program name and <name> the resource name, //; 37// with optionally a type specification. <value> can be either a //; 38// string, an integer, a float/double or a boolean with the values //; 39// TRUE, FALSE, ON, OFF, YES, NO, OK, NOT. Booleans will be returned as //; 40// an integer 0 or 1. The options [+] allows the concatenation of //; 41// values to the same resouce name. //; 42// //; 43// E.g.: //; 44// //; 45// Unix.Rint.Root.DynamicPath: .:$ROOTSYS/lib:~/lib //; 46// myapp.Root.Debug:",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:4724,Security,hash,hash,4724,,MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:9266,Security,hash,hash,9266,"om_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; TObject.h; TString.h; TEnvParserTEnv Parser.Definition TEnv.cxx:106; TEnvRecDefinition TEnv.h:86; TEnvRec::fValueTString fValueDefinition TEnv.h:96; TEnvRec::ChangeValuevoid ChangeValue(const char *v, const char *t, EEnvLevel l, Bool_t append=kFALSE, Bool_t ignoredup=kFALSE)Change the value of a resource.Definition TEnv.cxx:293; TEnvRec::GetTypeconst char * GetType() constDefinition TEnv.h:111; TEnvRec::fLevelEEnvLevel fLevelDefinition TEnv.h:97; TEnvRec::GetLevelEEnvLevel GetLevel() constDefinition TEnv.h:112; TEnvRec::TEnvRecTEnvRec()Definition TEnv.h:107; TEnvRec::GetValueconst char * GetValue() constDefinition TEnv.h:110; TEnvRec::ExpandValueTString ExpandValue(const char *v)Replace all strings by the value defined in the shell (obtained via TSystem::Getenv()).Definition TEnv.cxx:334; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TEnvRec::fNameTString fNameDefinition TEnv.h:94; TEnvRec::fTypeTString fTypeDefinition TEnv.h:95; TEnvRec::fModifiedBool_t fModifiedDefinition TEnv.h:98; TEnvRec::GetNameconst char * GetName() const overrideReturns name of object.Definition TEnv.h:109; TEnvRec::~TEnvRec~TEnvRec()TNamed destructor.Definition TEnv.cxx:284; TEnvRec::CompareInt_t Compare(const TObject *obj) const overrideComparison function for resources.Definition TEnv.cxx:325; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TEnv::fTableTHashList * fTableDefinition TEnv.h:127; TEnv::Printvoid Print(Option_t *option="""") const overridePrint all resources or the global, user or local resources separately.Definition TEnv.cxx:556; TEnv::PrintEnvvirtual void PrintEnv(EEnvLevel level=kEnvAll) constPrint all resources for a certain level (global, user, local, changed).Definition TEnv.cxx:574; TEnv::GetValuevirtual Int_t GetValu",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:12150,Security,hash,hash,12150,"efinition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TEnv::Savevirtual void Save()Write the resource files for each level.Definition TEnv.cxx:649; TEnv::DefinedBool_t Defined(const char *name) constDefinition TEnv.h:141; TEnv::fIgnoreDupBool_t fIgnoreDupDefinition TEnv.h:129; TEnv::GetRcNamevirtual const char * GetRcName() constDefinition TEnv.h:144; TEnv::Getvalueconst char * Getvalue(const char *name) constReturns the character value for a named resource.Definition TEnv.cxx:441; TEnv::operator=TEnv & operator=(const TEnv &)=delete; TEnv::SaveLevelvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TReadEnvParserDefinition TEnv.cxx:228; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TWriteEnvParserDefinition TEnv.cxx:242; bool; int; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TEnv_8h_source.html:12430,Security,hash,hash,12430,"efinition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TEnv::Savevirtual void Save()Write the resource files for each level.Definition TEnv.cxx:649; TEnv::DefinedBool_t Defined(const char *name) constDefinition TEnv.h:141; TEnv::fIgnoreDupBool_t fIgnoreDupDefinition TEnv.h:129; TEnv::GetRcNamevirtual const char * GetRcName() constDefinition TEnv.h:144; TEnv::Getvalueconst char * Getvalue(const char *name) constReturns the character value for a named resource.Definition TEnv.cxx:441; TEnv::operator=TEnv & operator=(const TEnv &)=delete; TEnv::SaveLevelvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TReadEnvParserDefinition TEnv.cxx:228; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TWriteEnvParserDefinition TEnv.cxx:242; bool; int; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TEnv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html
https://root.cern/doc/master/TError_8cxx_source.html:705,Availability,error,error,705,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:823,Availability,error,error,823,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2133,Availability,error,error,2133,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2193,Availability,error,error,2193,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2227,Availability,error,error,2227,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:3032,Availability,error,errorhandler,3032,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:3386,Availability,error,error,3386,"not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 de",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:3608,Availability,error,error,3608," const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 delete[] buf;; 130 buf_storage = buf = new char[buf_size];; 131 ; 132 // Try again with a sufficiently large buffer; 133 va_copy(ap_copy, ap);; 134 vsnprintf(buf, buf_size, fmt, ap_copy);; 135 }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:3654,Availability,error,error,3654,"reak *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 delete[] buf;; 130 buf_storage = buf = new char[buf_size];; 131 ; 132 // Try again with a sufficiently large buffer; 133 va_copy(ap_copy, ap);; 134 vsnprintf(buf, buf_size, fmt, ap_copy);; 135 }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError && level < kFatal) {; 140 bp.push_back(' ');; 141 if (GetErrorSystemMsgHandlerRef()); 142 bp += GetErrorSystemMsgHandlerRef()();; ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:4041,Availability,error,error,4041,"etErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 delete[] buf;; 130 buf_storage = buf = new char[buf_size];; 131 ; 132 // Try again with a sufficiently large buffer; 133 va_copy(ap_copy, ap);; 134 vsnprintf(buf, buf_size, fmt, ap_copy);; 135 }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError && level < kFatal) {; 140 bp.push_back(' ');; 141 if (GetErrorSystemMsgHandlerRef()); 142 bp += GetErrorSystemMsgHandlerRef()();; 143 else; 144 bp += std::string(""(errno: "") + std::to_string(errno) + "")"";; 145 }; 146 ; 147 if (level != kFatal); 148 gErrorHandler(level, level >= gErrorAbortLevel, location, bp.c_str());; 149 else; 150 gErrorHandler(level, kTRUE, location, bp.c_str());; 151}; 152 ; 153////////////////////////////////////////////////////////////////////////////////; 154/// This function can be used in abstract base classes in case one does; 155/// not want to make the c",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:6312,Availability,error,error,6312,"; 156/// function is called it will warn the user that the function should; 157/// have been overridden.; 158 ; 159void AbstractMethod(const char *method); 160{; 161 Warning(method, ""this method must be overridden!"");; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// This function can be used in classes that should override a certain; 166/// function, but in the inherited class the function makes no sense.; 167 ; 168void MayNotUse(const char *method); 169{; 170 Warning(method, ""may not use this method"");; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Use this function to declare a function obsolete. Specify as of which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start(ap, fmt);; 189 ErrorHandler(kError, location, fmt, ap);; 190 va_end(ap);; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Use this function in case a system (OS or GUI) related error occurred.; 195 ; 196void SysError(const char *location, const char *fmt, ...); 197{; 198 std::va_list ap;; 199 va_start(ap, fmt);; 200 ErrorHandler(kSysError, location, fmt, ap);; 201 va_end(ap);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHand",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:6668,Availability,error,error,6668,"ain; 166/// function, but in the inherited class the function makes no sense.; 167 ; 168void MayNotUse(const char *method); 169{; 170 Warning(method, ""may not use this method"");; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Use this function to declare a function obsolete. Specify as of which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start(ap, fmt);; 189 ErrorHandler(kError, location, fmt, ap);; 190 va_end(ap);; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Use this function in case a system (OS or GUI) related error occurred.; 195 ; 196void SysError(const char *location, const char *fmt, ...); 197{; 198 std::va_list ap;; 199 va_start(ap, fmt);; 200 ErrorHandler(kSysError, location, fmt, ap);; 201 va_end(ap);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 2",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:7004,Availability,error,error,7004,"which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start(ap, fmt);; 189 ErrorHandler(kError, location, fmt, ap);; 190 va_end(ap);; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Use this function in case a system (OS or GUI) related error occurred.; 195 ; 196void SysError(const char *location, const char *fmt, ...); 197{; 198 std::va_list ap;; 199 va_start(ap, fmt);; 200 ErrorHandler(kSysError, location, fmt, ap);; 201 va_end(ap);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237//////////",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:8001,Availability,error,error,8001,"2}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function i",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:8884,Availability,error,error,8884,"///////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoi",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:9013,Availability,error,error,9013,"r. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the u",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:9126,Availability,error,error,9126," `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, c",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:9501,Availability,error,error,9501,"tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the pro",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:9968,Availability,error,error,9968,"85; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an error",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10014,Availability,error,error,10014," an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandle",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10453,Availability,error,error,10453,"*fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10917,Availability,error,errorhandler,10917,"rrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the e",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:11879,Availability,error,error,11879,"rErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; .",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:11924,Availability,error,error,11924,"rErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; .",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12091,Availability,error,error,12091,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12151,Availability,error,error,12151,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12342,Availability,error,error,12342,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:650,Integrability,rout,routines,650,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:720,Integrability,rout,routines,720,". ROOT: core/foundation/src/TError.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TError.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/**; 13Error handling routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHa",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:4047,Integrability,message,message,4047,"etErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function. It calls the user set error handler.; 108 ; 109void ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap); 110{; 111 thread_local Int_t buf_size(256);; 112 thread_local char *buf_storage(nullptr);; 113 ; 114 char small_buf[256];; 115 char *buf = buf_storage ? buf_storage : small_buf;; 116 ; 117 std::va_list ap_copy;; 118 va_copy(ap_copy, ap);; 119 ; 120 if (!fmt); 121 fmt = ""no error message provided"";; 122 ; 123 Int_t n = vsnprintf(buf, buf_size, fmt, ap_copy);; 124 if (n >= buf_size) {; 125 va_end(ap_copy);; 126 ; 127 buf_size = n + 1;; 128 if (buf != &(small_buf[0])); 129 delete[] buf;; 130 buf_storage = buf = new char[buf_size];; 131 ; 132 // Try again with a sufficiently large buffer; 133 va_copy(ap_copy, ap);; 134 vsnprintf(buf, buf_size, fmt, ap_copy);; 135 }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError && level < kFatal) {; 140 bp.push_back(' ');; 141 if (GetErrorSystemMsgHandlerRef()); 142 bp += GetErrorSystemMsgHandlerRef()();; 143 else; 144 bp += std::string(""(errno: "") + std::to_string(errno) + "")"";; 145 }; 146 ; 147 if (level != kFatal); 148 gErrorHandler(level, level >= gErrorAbortLevel, location, bp.c_str());; 149 else; 150 gErrorHandler(level, kTRUE, location, bp.c_str());; 151}; 152 ; 153////////////////////////////////////////////////////////////////////////////////; 154/// This function can be used in abstract base classes in case one does; 155/// not want to make the c",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:7341,Integrability,message,messages,7341,"//////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start(ap, fmt);; 189 ErrorHandler(kError, location, fmt, ap);; 190 va_end(ap);; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Use this function in case a system (OS or GUI) related error occurred.; 195 ; 196void SysError(const char *location, const char *fmt, ...); 197{; 198 std::va_list ap;; 199 va_start(ap, fmt);; 200 ErrorHandler(kSysError, location, fmt, ap);; 201 va_end(ap);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable w",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:9268,Integrability,message,messages,9268,"244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used i",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10568,Integrability,rout,routines,10568,"6; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definiti",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:11524,Integrability,rout,routines,11524,"Error.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TEr",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12348,Integrability,message,message,12348,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:5570,Modifiability,inherit,inherited,5570," }; 136 va_end(ap_copy);; 137 ; 138 std::string bp = buf;; 139 if (level >= kSysError && level < kFatal) {; 140 bp.push_back(' ');; 141 if (GetErrorSystemMsgHandlerRef()); 142 bp += GetErrorSystemMsgHandlerRef()();; 143 else; 144 bp += std::string(""(errno: "") + std::to_string(errno) + "")"";; 145 }; 146 ; 147 if (level != kFatal); 148 gErrorHandler(level, level >= gErrorAbortLevel, location, bp.c_str());; 149 else; 150 gErrorHandler(level, kTRUE, location, bp.c_str());; 151}; 152 ; 153////////////////////////////////////////////////////////////////////////////////; 154/// This function can be used in abstract base classes in case one does; 155/// not want to make the class a ""real"" (in C++ sense) ABC. If this; 156/// function is called it will warn the user that the function should; 157/// have been overridden.; 158 ; 159void AbstractMethod(const char *method); 160{; 161 Warning(method, ""this method must be overridden!"");; 162}; 163 ; 164////////////////////////////////////////////////////////////////////////////////; 165/// This function can be used in classes that should override a certain; 166/// function, but in the inherited class the function makes no sense.; 167 ; 168void MayNotUse(const char *method); 169{; 170 Warning(method, ""may not use this method"");; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Use this function to declare a function obsolete. Specify as of which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10316,Modifiability,inherit,inherited,10316,"r informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2293,Performance,multi-thread,multi-threaded,2293,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2356,Safety,abort,abort,2356,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2811,Safety,abort,aborting,2811,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2849,Safety,abort,abort,2849,"lerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** Break *** "");; 74 fprintf(stderr, ""<%s>: %s\n"", location ? location : ""unspecified location"", msg);; 75 fflush(stderr);; 76 if (abort_bool) {; 77 fprintf(stderr, ""aborting\n"");; 78 fflush(stderr);; 79 abort();; 80 }; 81}; 82 ; 83} // namespace Internal; 84} // namespace ROOT; 85 ; 86 ; 87////////////////////////////////////////////////////////////////////////////////; 88/// Set an errorhandler function. Returns the old handler.; 89 ; 90ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler); 91{; 92 ErrorHandlerFunc_t oldhandler = gErrorHandler;; 93 gErrorHandler = newhandler;; 94 return oldhandler;; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Returns the current error handler function.; 99 ; 100ErrorHandlerFunc_t GetErrorHandler(); 101{; 102 return gErrorHandler;; 103}; 104 ; 105 ; 106////////////////////////////////////////////////////////////////////////////////; 107/// General error handler function.",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:8016,Safety,abort,abort,8016," 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error oc",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:8077,Safety,abort,abort,8077,"ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Retu",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:8179,Safety,abort,abort,8179,"ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Retu",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:10468,Safety,abort,abort,10468,"a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoid ErrorHandler(Int_t level, const char *location, const char *fmt, std::va_list ap)General error handler function. It calls the user set error handler.Definition TError.cxx:109; Warningvoid Warning(const char *location, const char *fmt,...)Use this function in warning situations.Definition TError.cxx:229; MayNotUsevoid MayNotUse(const char *method)This function can be used in classes that should override a certain function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErr",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:11298,Safety,abort,abort,11298,"function, but in the inherited cl...Definition TError.cxx:168; Fatalvoid Fatal(const char *location, const char *fmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36; Obsoletevoid Obsolete(const char *function, const char *asOfVers, const char *removedFromVers)Use this function to declare a function obsolete.Definition TError.cxx:177; SetErrorHandlerErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystem",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12032,Safety,abort,abort,12032,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:2126,Usability,simpl,simple,2126,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8cxx_source.html:12084,Usability,simpl,simple,12084,"ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler)Set an errorhandler function. Returns the old handler.Definition TError.cxx:90; gPrintViaErrorHandlerBool_t gPrintViaErrorHandlerDefinition TError.cxx:33; TError.h; kErrorconstexpr Int_t kErrorDefinition TError.h:47; kFatalconstexpr Int_t kFatalDefinition TError.h:50; kWarningconstexpr Int_t kWarningDefinition TError.h:46; ErrorHandlerFunc_tvoid(* ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location, const char *msg)Definition TError.h:71; kBreakconstexpr Int_t kBreakDefinition TError.h:48; kInfoconstexpr Int_t kInfoDefinition TError.h:45; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; kSysErrorconstexpr Int_t kSysErrorDefinition TError.h:49; kUnsetconstexpr Int_t kUnsetDefinition TError.h:43; va_copy#define va_copy(x, y)Definition civetweb.c:1000; nconst Int_t nDefinition legend1.C:16; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::GetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler()Definition TError.cxx:51; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. corefoundationsrcTError.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TError_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html
https://root.cern/doc/master/TError_8h.html:758,Availability,error,error,758,". ROOT: core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t Get",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1088,Availability,error,error,1088,": core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorH",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1133,Availability,error,error,1133,": core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorH",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1417,Availability,error,error,1417," show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the functio",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1542,Availability,error,error,1542,"b::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1660,Availability,error,error,1660,"7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsole",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1777,Availability,error,error,1777," and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1823,Availability,error,error,1823,"tion e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1940,Availability,error,error,1940,"nt level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSyst",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2039,Availability,error,error,2039,"ystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  R",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2560,Availability,error,error,2560," The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMs",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2620,Availability,error,error,2620," The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMs",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2861,Availability,error,errorhandler,2861,"ndler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__AS",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:3045,Availability,error,error,3045,"dlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:3191,Availability,error,error,3191,"cation, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4224,Availability,error,error,4224,"id Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5597,Availability,error,error,5597,"))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error hand",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5816,Availability,error,error,5816," stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will ",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5942,Availability,error,error,5942,"mentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 2",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6337,Availability,error,error,6337,"ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ;",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6534,Availability,error,error,6534," * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Ob",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6580,Availability,error,error,6580,"s function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const ",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6765,Availability,error,error,6765,", . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the metho",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:7050,Availability,error,error,7050,"ring the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ S",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:7956,Availability,error,errorhandler,7956,"x. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is suppo",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8200,Availability,error,error,8200,"ar * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8680,Availability,error,error,8680,"ction obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg. const char* kAssertMsg. extern . Definition at line 35 of file TError.cxx. ◆ kBreak. constexpr Int_t kBreak = 4000. constexpr . Definition at line 48 of file TError.h. ◆ kCheckMsg. const char* kCheckMsg. extern . Definition at line 36 of file TError.cxx. ◆ kError. constexpr Int_t kError = 3000. constexpr . Definition at line 47 of file TError.h. ◆ kFatal. constexpr Int_t kFatal = 6000. constexpr . Definition at line 50 of file TError.h. ◆ kInfo. constexpr Int_t kInfo = 1000. constexpr . Definition at line 4",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8792,Availability,error,error,8792,"emoved. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg. const char* kAssertMsg. extern . Definition at line 35 of file TError.cxx. ◆ kBreak. constexpr Int_t kBreak = 4000. constexpr . Definition at line 48 of file TError.h. ◆ kCheckMsg. const char* kCheckMsg. extern . Definition at line 36 of file TError.cxx. ◆ kError. constexpr Int_t kError = 3000. constexpr . Definition at line 47 of file TError.h. ◆ kFatal. constexpr Int_t kFatal = 6000. constexpr . Definition at line 50 of file TError.h. ◆ kInfo. constexpr Int_t kInfo = 1000. constexpr . Definition at line 45 of file TError.h. ◆ kPrint. constexpr Int_t kPrint = 0. constexpr . Definition at line 44 of file TError.h",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8891,Availability,error,errorhandler,8891,"lerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg. const char* kAssertMsg. extern . Definition at line 35 of file TError.cxx. ◆ kBreak. constexpr Int_t kBreak = 4000. constexpr . Definition at line 48 of file TError.h. ◆ kCheckMsg. const char* kCheckMsg. extern . Definition at line 36 of file TError.cxx. ◆ kError. constexpr Int_t kError = 3000. constexpr . Definition at line 47 of file TError.h. ◆ kFatal. constexpr Int_t kFatal = 6000. constexpr . Definition at line 50 of file TError.h. ◆ kInfo. constexpr Int_t kInfo = 1000. constexpr . Definition at line 45 of file TError.h. ◆ kPrint. constexpr Int_t kPrint = 0. constexpr . Definition at line 44 of file TError.h. ◆ kSysError. constexpr Int_t kSysError = 5000. constexpr . Definition at line 49",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4286,Deployability,release,release,4286," in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to ma",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4834,Deployability,release,release,4834," ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ;",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:349,Integrability,depend,dependency,349,". ROOT: core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t Get",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:847,Integrability,message,message,847,". ROOT: core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t Get",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2239,Integrability,message,messages,2239,"d in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:3051,Integrability,message,message,3051,"dlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:3399,Integrability,rout,routines,3399,"ction, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t gErrorAbortLevel;  ; Int_t gErrorIgnoreLevel;  Error handling routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer ",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4385,Integrability,depend,depending,4385,"g routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the func",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4772,Integrability,message,message,4772,"= 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const cha",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5856,Integrability,message,message,5856,"t paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but fo",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:7244,Integrability,message,messages,7244,"id Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition a",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8631,Integrability,rout,routines,8631,"st char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg. const char* kAssertMsg. extern . Definition at line 35 of file TError.cxx. ◆ kBreak. constexpr Int_t kBreak = 4000. constexpr . Definition at line 48 of file TError.h. ◆ kCheckMsg. const char* kCheckMsg. extern . Definition at line 36 of file TError.cxx. ◆ kError. constexpr Int_t kError = 3000. constexpr . Definition at line 47 of file TError.h. ◆ kFatal. constexpr Int_t kFatal = 6000. constexpr . Definition at line 50 of file TError.h. ◆ kIn",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:8695,Integrability,rout,routines,8695,"ction obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg. const char* kAssertMsg. extern . Definition at line 35 of file TError.cxx. ◆ kBreak. constexpr Int_t kBreak = 4000. constexpr . Definition at line 48 of file TError.h. ◆ kCheckMsg. const char* kCheckMsg. extern . Definition at line 36 of file TError.cxx. ◆ kError. constexpr Int_t kError = 3000. constexpr . Definition at line 47 of file TError.h. ◆ kFatal. constexpr Int_t kFatal = 6000. constexpr . Definition at line 50 of file TError.h. ◆ kInfo. constexpr Int_t kInfo = 1000. constexpr . Definition at line 4",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:2381,Modifiability,inherit,inherited,2381,"ak (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::SetErrorSystemMsgHandler (ErrorSystemMsgHandlerFunc_t h);  Returns the previous system error message handler. ;  ; void SysError (const char *location, const char *msgfmt,...);  Use this function in case a system (OS or GUI) related error occurred. ;  ; void Warning (const char *location, const char *msgfmt,...);  Use this function in warning situations. ;  . Variables; Int_t ",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:7447,Modifiability,inherit,inherited,7447,"orHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:939,Safety,abort,abort,939,": core/foundation/inc/TError.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Macros |; Typedefs |; Functions |; Variables ; TError.h File Reference. #include <DllImport.h>; #include ""RtypesCore.h""; #include <ROOT/RConfig.hxx>; #include <cstdarg>; #include <functional>. Include dependency graph for TError.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorH",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1482,Safety,abort,abort,1482,"b::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Internal;  . Macros; #define R__ASSERT(e);  Checks condition e and reports a fatal error if it's false. ;  ; #define R__CHECK(e);  Checks condition e and reports a warning message if it's false. ;  . Typedefs; typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:1955,Safety,abort,abort,1955,"ocation, const char *msg);  ; using ROOT::Internal::ErrorSystemMsgHandlerFunc_t = std::function< const char *()>;  Retrieves the error string associated with the last system error. ;  . Functions; void AbstractMethod (const char *method);  This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ;  ; void Break (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void DefaultErrorHandler (int level, Bool_t abort, const char *location, const char *msg);  The default error handler function. ;  ; void Error (const char *location, const char *msgfmt,...);  Use this function in case an error occurred. ;  ; void ErrorHandler (int level, const char *location, const char *fmt, std::va_list va);  General error handler function. It calls the user set error handler. ;  ; void Fatal (const char *location, const char *msgfmt,...);  Use this function in case of a fatal error. It will abort the program. ;  ; ErrorHandlerFunc_t GetErrorHandler ();  Returns the current error handler function. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::GetErrorSystemMsgHandler ();  ; void Info (const char *location, const char *msgfmt,...);  Use this function for informational messages. ;  ; void MayNotUse (const char *method);  This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ;  ; void ROOT::Internal::MinimalErrorHandler (Int_t level, Bool_t abort_bool, const char *location, const char *msg);  A very simple error handler that is usually replaced by the TROOT default error handler. ;  ; void Obsolete (const char *function, const char *asOfVers, const char *removedFromVers);  Use this function to declare a function obsolete. ;  ; ErrorHandlerFunc_t SetErrorHandler (ErrorHandlerFunc_t newhandler);  Set an errorhandler function. Returns the old handler. ;  ; ErrorSystemMsgHandlerFunc_t ROOT::Internal::Se",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5030,Safety,abort,abort,5030,"nlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handle",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5881,Safety,abort,abort,5881,"t paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but fo",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:5897,Safety,abort,aborts,5897,"t paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the function should have been overridden. ; Definition at line 159 of file TError.cxx. ◆ Break(). void Break ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 207 of file TError.cxx. ◆ DefaultErrorHandler(). void DefaultErrorHandler ; (; Int_t ; level, . Bool_t ; abort_bool, . const char * ; location, . const char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but fo",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6780,Safety,abort,abort,6780,"t char * ; msg . ). The default error handler function. ; It prints the message on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which vers",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6825,Safety,abort,abort,6825,"sage on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ Set",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:6914,Safety,abort,abort,6914,"sage on stderr and if abort is set it aborts the application. Replaces the minimal error handler of TError.h as part of the gROOT construction. TError's minimal handler is put back in place during the gROOT destruction. Noteabort() is only called if abort_bool is true and level < gErrorIgnoreLevel ; Definition at line 102 of file TErrorDefaultHandler.cxx. ◆ Error(). void Error ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case an error occurred. ; Definition at line 185 of file TError.cxx. ◆ ErrorHandler(). void ErrorHandler ; (; int ; level, . const char * ; location, . const char * ; fmt, . std::va_list ; va . ). General error handler function. It calls the user set error handler. ; Definition at line 109 of file TError.cxx. ◆ Fatal(). void Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ). Use this function in case of a fatal error. It will abort the program. ; WarningFatal() will not abort the program if gErrorIgnoreLevel > kFatal; but for all reasonable settings it will abort. . Definition at line 244 of file TError.cxx. ◆ GetErrorHandler(). ErrorHandlerFunc_t GetErrorHandler ; (; ). Returns the current error handler function. ; Definition at line 100 of file TError.cxx. ◆ Info(). void Info ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ Set",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
https://root.cern/doc/master/TError_8h.html:4374,Testability,assert,assert,4374,"g routines. ;  ; Bool_t gPrintViaErrorHandler;  ; const char * kAssertMsg;  ; constexpr Int_t kBreak = 4000;  ; const char * kCheckMsg;  ; constexpr Int_t kError = 3000;  ; constexpr Int_t kFatal = 6000;  ; constexpr Int_t kInfo = 1000;  ; constexpr Int_t kPrint = 0;  ; constexpr Int_t kSysError = 5000;  ; constexpr Int_t kUnset = -1;  ; constexpr Int_t kWarning = 2000;  . Macro Definition Documentation. ◆ R__ASSERT. #define R__ASSERT; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Fatal("""", kAssertMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); _QUOTE_#define _QUOTE_(name)Definition RConfig.hxx:446; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; e#define e(i)Definition RSha256.hxx:103; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35. Checks condition e and reports a fatal error if it's false. ; Warning; this check is NOT stripped in release mode, so it should not be used for hot paths. For those cases, prefer a regular assert();; depending on gErrorIgnoreLevel, this might not terminate the program, . See alsoFatal. ; Definition at line 125 of file TError.h. ◆ R__CHECK. #define R__CHECK; (;  ; e). Value: do { \; if (R__unlikely(!(e))) \; ::Warning("""", kCheckMsg, _QUOTE_(e), __LINE__, __FILE__); \; } while (false); kCheckMsgconst char * kCheckMsgDefinition TError.cxx:36. Checks condition e and reports a warning message if it's false. ; Warningthis check is NOT stripped in release mode, so it should not be used for hot paths. ; Definition at line 134 of file TError.h. Typedef Documentation. ◆ ErrorHandlerFunc_t. typedef void(* ErrorHandlerFunc_t) (int level, Bool_t abort, const char *location, const char *msg). Definition at line 71 of file TError.h. Function Documentation. ◆ AbstractMethod(). void AbstractMethod ; (; const char * ; method). This function can be used in abstract base classes in case one does not want to make the class a ""real"" (in C++ sense) ABC. ; If this function is called it will warn the user that the func",MatchSource.WIKI,doc/master/TError_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TError_8h.html
